{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma action_loc_aux_compP [simp]: \"action_loc_aux (compP f P) = action_loc_aux P\"", "lemma action_loc_compP: \"action_loc (compP f P) = action_loc P\"", "lemma is_volatile_compP [simp]: \"is_volatile (compP f P) = is_volatile P\"", "lemma saction_compP [simp]: \"saction (compP f P) = saction P\"", "lemma sactions_compP [simp]: \"sactions (compP f P) = sactions P\"", "lemma addr_locs_compP [simp]: \"addr_locs (compP f P) = addr_locs P\"", "lemma syncronizes_with_compP [simp]: \"synchronizes_with (compP f P) = synchronizes_with P\"", "lemma sync_order_compP [simp]: \"sync_order (compP f P) = sync_order P\"", "lemma sync_with_compP [simp]: \"sync_with (compP f P) = sync_with P\"", "lemma po_sw_compP [simp]: \"po_sw (compP f P) = po_sw P\"", "lemma happens_before_compP: \"happens_before (compP f P) = happens_before P\"", "lemma addr_loc_default_compP [simp]: \"addr_loc_default (compP f P) = addr_loc_default P\"", "lemma value_written_aux_compP [simp]: \"value_written_aux (compP f P) = value_written_aux P\"", "lemma value_written_compP [simp]: \"value_written (compP f P) = value_written P\"", "lemma is_write_seen_compP [simp]: \"is_write_seen (compP f P) = is_write_seen P\"", "lemma justification_well_formed_compP [simp]:\n  \"justification_well_formed (compP f P) = justification_well_formed P\"", "lemma happens_before_committed_compP [simp]:\n  \"happens_before_committed (compP f P) = happens_before_committed P\"", "lemma happens_before_committed_weak_compP [simp]:\n  \"happens_before_committed_weak (compP f P) = happens_before_committed_weak P\"", "lemma sync_order_committed_compP [simp]:\n  \"sync_order_committed (compP f P) = sync_order_committed P\"", "lemma value_written_committed_compP [simp]:\n  \"value_written_committed (compP f P) = value_written_committed P\"", "lemma uncommitted_reads_see_hb_compP [simp]:\n  \"uncommitted_reads_see_hb (compP f P) = uncommitted_reads_see_hb P\"", "lemma external_actions_committed_compP [simp]:\n  \"external_actions_committed (compP f P) = external_actions_committed P\"", "lemma is_justified_by_compP [simp]: \"is_justified_by (compP f P) = is_justified_by P\"", "lemma is_weakly_justified_by_compP [simp]: \"is_weakly_justified_by (compP f P) = is_weakly_justified_by P\"", "lemma legal_execution_compP: \"legal_execution (compP f P) = legal_execution P\"", "lemma weakly_legal_execution_compP: \"weakly_legal_execution (compP f P) = weakly_legal_execution P\"", "lemma most_recent_write_for_compP [simp]: \n  \"most_recent_write_for (compP f P) = most_recent_write_for P\"", "lemma sequentially_consistent_compP [simp]:\n  \"sequentially_consistent (compP f P) = sequentially_consistent P\"", "lemma conflict_compP [simp]: \"non_volatile_conflict (compP f P) = non_volatile_conflict P\"", "lemma correctly_synchronized_compP [simp]: \n  \"correctly_synchronized (compP f P) = correctly_synchronized P\"", "lemma (in heap_base) heap_read_typed_compP [simp]:\n  \"heap_read_typed (compP f P) = heap_read_typed P\"", "theorem if_bisimJ2JVM_weak_bisim:\n  assumes wf: \"wf_J_prog P\"\n  shows \"delay_bisimulation_diverge_final\n    (red_mthr.mthr.if.redT P) (execd_mthr.mthr.if.redT (J2JVM P)) if_bisimJ2JVM if_tlsimJ2JVM \n    red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal\"", "lemma if_bisimJ2JVM_start:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"if_bisimJ2JVM (init_fin_lift_state Running (J_start_state P C M vs))\n                       (init_fin_lift_state Running (JVM_start_state (J2JVM P) C M vs))\"", "lemma red_Runs_eq_mexecd_Runs:\n  fixes C M vs\n  defines s: \"s \\<equiv> init_fin_lift_state Running (J_start_state P C M vs)\"\n  and comps: \"cs \\<equiv> init_fin_lift_state Running (JVM_start_state (J2JVM P) C M vs)\"\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs\"", "lemma red_\\<E>_eq_mexecd_\\<E>:\n  \"\\<lbrakk> wf_J_prog P; wf_start_state P C M vs \\<rbrakk>\n  \\<Longrightarrow> J_\\<E> P C M vs Running = JVMd_\\<E> (J2JVM P) C M vs Running\"", "theorem J2JVM_jmm_correct:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"legal_execution P (J_\\<E> P C M vs Running) (E, ws) \\<longleftrightarrow> \n         legal_execution (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) (E, ws)\"", "theorem J2JVM_jmm_correct_weak:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"weakly_legal_execution P (J_\\<E> P C M vs Running) (E, ws) \\<longleftrightarrow> \n         weakly_legal_execution (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) (E, ws)\"", "theorem J2JVM_jmm_correctly_synchronized:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"correctly_synchronized (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) \\<longleftrightarrow> \n         correctly_synchronized P (J_\\<E> P C M vs Running)\""], "translations": [["", "lemma action_loc_aux_compP [simp]: \"action_loc_aux (compP f P) = action_loc_aux P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action_loc_aux (compP f P) = action_loc_aux P", "by(auto 4 4 elim!: action_loc_aux_cases)"], ["", "lemma action_loc_compP: \"action_loc (compP f P) = action_loc P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action_loc (compP f P) = action_loc P", "by simp"], ["", "lemma is_volatile_compP [simp]: \"is_volatile (compP f P) = is_volatile P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_volatile (compP f P) = is_volatile P", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_volatile (compP f P) x = is_volatile P x", "fix hT"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_volatile (compP f P) x = is_volatile P x", "show \"is_volatile (compP f P) hT = is_volatile P hT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_volatile (compP f P) hT = is_volatile P hT", "by(cases hT) simp_all"], ["proof (state)\nthis:\n  is_volatile (compP f P) hT = is_volatile P hT\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma saction_compP [simp]: \"saction (compP f P) = saction P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saction (compP f P) = saction P", "by(simp add: saction.simps fun_eq_iff)"], ["", "lemma sactions_compP [simp]: \"sactions (compP f P) = sactions P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sactions (compP f P) = sactions P", "by(rule ext)(simp only: sactions_def, simp)"], ["", "lemma addr_locs_compP [simp]: \"addr_locs (compP f P) = addr_locs P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_locs (compP f P) = addr_locs P", "by(rule ext)(case_tac x, simp_all)"], ["", "lemma syncronizes_with_compP [simp]: \"synchronizes_with (compP f P) = synchronizes_with P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synchronizes_with (compP f P) = synchronizes_with P", "by(simp add: synchronizes_with.simps fun_eq_iff)"], ["", "lemma sync_order_compP [simp]: \"sync_order (compP f P) = sync_order P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_order (compP f P) = sync_order P", "by(simp add: sync_order_def fun_eq_iff)"], ["", "lemma sync_with_compP [simp]: \"sync_with (compP f P) = sync_with P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_with (compP f P) = sync_with P", "by(simp add: sync_with_def fun_eq_iff)"], ["", "lemma po_sw_compP [simp]: \"po_sw (compP f P) = po_sw P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. po_sw (compP f P) = po_sw P", "by(simp add: po_sw_def fun_eq_iff)"], ["", "lemma happens_before_compP: \"happens_before (compP f P) = happens_before P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happens_before (compP f P) = happens_before P", "by simp"], ["", "lemma addr_loc_default_compP [simp]: \"addr_loc_default (compP f P) = addr_loc_default P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_loc_default (compP f P) = addr_loc_default P", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. addr_loc_default (compP f P) x xa = addr_loc_default P x xa", "fix hT al"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. addr_loc_default (compP f P) x xa = addr_loc_default P x xa", "show \"addr_loc_default (compP f P) hT al = addr_loc_default P hT al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_loc_default (compP f P) hT al = addr_loc_default P hT al", "by(cases \"(P, hT, al)\" rule: addr_loc_default.cases) simp_all"], ["proof (state)\nthis:\n  addr_loc_default (compP f P) hT al = addr_loc_default P hT al\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_written_aux_compP [simp]: \"value_written_aux (compP f P) = value_written_aux P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_written_aux (compP f P) = value_written_aux P", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       value_written_aux (compP f P) x xa = value_written_aux P x xa", "fix a al"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       value_written_aux (compP f P) x xa = value_written_aux P x xa", "show \"value_written_aux (compP f P) a al = value_written_aux P a al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_written_aux (compP f P) a al = value_written_aux P a al", "by(cases \"(P, a, al)\" rule: value_written_aux.cases)(simp_all add: value_written_aux.simps)"], ["proof (state)\nthis:\n  value_written_aux (compP f P) a al = value_written_aux P a al\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_written_compP [simp]: \"value_written (compP f P) = value_written P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_written (compP f P) = value_written P", "by(simp add: fun_eq_iff value_written.simps)"], ["", "lemma is_write_seen_compP [simp]: \"is_write_seen (compP f P) = is_write_seen P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_write_seen (compP f P) = is_write_seen P", "by(simp add: fun_eq_iff is_write_seen_def)"], ["", "lemma justification_well_formed_compP [simp]:\n  \"justification_well_formed (compP f P) = justification_well_formed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. justification_well_formed (compP f P) = justification_well_formed P", "by(simp add: fun_eq_iff justification_well_formed_def)"], ["", "lemma happens_before_committed_compP [simp]:\n  \"happens_before_committed (compP f P) = happens_before_committed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happens_before_committed (compP f P) = happens_before_committed P", "by(simp add: fun_eq_iff happens_before_committed_def)"], ["", "lemma happens_before_committed_weak_compP [simp]:\n  \"happens_before_committed_weak (compP f P) = happens_before_committed_weak P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happens_before_committed_weak (compP f P) =\n    happens_before_committed_weak P", "by(simp add: fun_eq_iff happens_before_committed_weak_def)"], ["", "lemma sync_order_committed_compP [simp]:\n  \"sync_order_committed (compP f P) = sync_order_committed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_order_committed (compP f P) = sync_order_committed P", "by(simp add: fun_eq_iff sync_order_committed_def)"], ["", "lemma value_written_committed_compP [simp]:\n  \"value_written_committed (compP f P) = value_written_committed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_written_committed (compP f P) = value_written_committed P", "by(simp add: fun_eq_iff value_written_committed_def)"], ["", "lemma uncommitted_reads_see_hb_compP [simp]:\n  \"uncommitted_reads_see_hb (compP f P) = uncommitted_reads_see_hb P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncommitted_reads_see_hb (compP f P) = uncommitted_reads_see_hb P", "by(simp add: fun_eq_iff uncommitted_reads_see_hb_def)"], ["", "lemma external_actions_committed_compP [simp]:\n  \"external_actions_committed (compP f P) = external_actions_committed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. external_actions_committed (compP f P) = external_actions_committed P", "by(simp add: fun_eq_iff external_actions_committed_def)"], ["", "lemma is_justified_by_compP [simp]: \"is_justified_by (compP f P) = is_justified_by P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_justified_by (compP f P) = is_justified_by P", "by(simp add: fun_eq_iff is_justified_by.simps)"], ["", "lemma is_weakly_justified_by_compP [simp]: \"is_weakly_justified_by (compP f P) = is_weakly_justified_by P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weakly_justified_by (compP f P) = is_weakly_justified_by P", "by(simp add: fun_eq_iff is_weakly_justified_by.simps)"], ["", "lemma legal_execution_compP: \"legal_execution (compP f P) = legal_execution P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_execution (compP f P) = legal_execution P", "by(simp add: fun_eq_iff gen_legal_execution.simps)"], ["", "lemma weakly_legal_execution_compP: \"weakly_legal_execution (compP f P) = weakly_legal_execution P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_legal_execution (compP f P) = weakly_legal_execution P", "by(simp add: fun_eq_iff gen_legal_execution.simps)"], ["", "lemma most_recent_write_for_compP [simp]: \n  \"most_recent_write_for (compP f P) = most_recent_write_for P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. most_recent_write_for (compP f P) = most_recent_write_for P", "by(simp add: fun_eq_iff most_recent_write_for.simps)"], ["", "lemma sequentially_consistent_compP [simp]:\n  \"sequentially_consistent (compP f P) = sequentially_consistent P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequentially_consistent (compP f P) = sequentially_consistent P", "by(simp add: sequentially_consistent_def split_beta)"], ["", "lemma conflict_compP [simp]: \"non_volatile_conflict (compP f P) = non_volatile_conflict P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_volatile_conflict (compP f P) = non_volatile_conflict P", "by(simp add: fun_eq_iff non_volatile_conflict_def)"], ["", "lemma correctly_synchronized_compP [simp]: \n  \"correctly_synchronized (compP f P) = correctly_synchronized P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correctly_synchronized (compP f P) = correctly_synchronized P", "by(simp add: fun_eq_iff correctly_synchronized_def)"], ["", "lemma (in heap_base) heap_read_typed_compP [simp]:\n  \"heap_read_typed (compP f P) = heap_read_typed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_read_typed (compP f P) = heap_read_typed P", "by(intro ext)(simp add: heap_read_typed_def)"], ["", "context J_JVM_heap_conf_base begin"], ["", "definition if_bisimJ2JVM :: \n  \"(('addr,'thread_id,status \\<times> 'addr expr\\<times>'addr locals,'heap,'addr) state, \n    ('addr,'thread_id,status \\<times> 'addr option \\<times> 'addr frame list,'heap,'addr) state) bisim\"\nwhere \n  \"if_bisimJ2JVM = \n   FWbisimulation_base.mbisim red_red0.init_fin_bisim red_red0.init_fin_bisim_wait \\<circ>\\<^sub>B\n   FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n   if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B \n   FWbisimulation_base.mbisim Red1_execd.init_fin_bisim Red1_execd.init_fin_bisim_wait\""], ["", "definition if_tlsimJ2JVM ::\n  \"('thread_id \\<times> ('addr, 'thread_id, status \\<times> 'addr expr \\<times> 'addr locals,\n                  'heap, 'addr, ('addr, 'thread_id) obs_event action) thread_action,\n    'thread_id \\<times> ('addr, 'thread_id, status \\<times> 'addr jvm_thread_state,\n                  'heap, 'addr, ('addr, 'thread_id) obs_event action) thread_action) bisim\"\nwhere\n  \"if_tlsimJ2JVM = \n   FWbisimulation_base.mta_bisim red_red0.init_fin_bisim \\<circ>\\<^sub>B \n   FWbisimulation_base.mta_bisim red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B (=) \\<circ>\\<^sub>B \n   FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim\""], ["", "end"], ["", "sublocale J_JVM_conf_read < red_mthr: if_\\<tau>multithreaded_wf final_expr \"mred P\" convert_RA \"\\<tau>MOVE P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_\\<tau>multithreaded_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>((e, x), h) ta s'.\n         \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)", "by(unfold_locales)"], ["", "sublocale J_JVM_conf_read < execd_mthr: \n  if_\\<tau>multithreaded_wf\n    JVM_final\n    \"mexecd (compP2 (compP1 P))\"\n    convert_RA \n    \"\\<tau>MOVE2 (compP2 (compP1 P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_\\<tau>multithreaded_wf JVM_final (mexecd (compP2 (compP1 P)))\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 (compP1 P)) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "by(unfold_locales)"], ["", "context J_JVM_conf_read begin"], ["", "theorem if_bisimJ2JVM_weak_bisim:\n  assumes wf: \"wf_J_prog P\"\n  shows \"delay_bisimulation_diverge_final\n    (red_mthr.mthr.if.redT P) (execd_mthr.mthr.if.redT (J2JVM P)) if_bisimJ2JVM if_tlsimJ2JVM \n    red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (red_mthr.mthr.if.redT P)\n     (execd_mthr.mthr.if.redT (J2JVM P)) if_bisimJ2JVM if_tlsimJ2JVM\n     red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move\n     red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal", "apply (simp only: if_bisimJ2JVM_def if_tlsimJ2JVM_def J2JVM_def o_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (red_mthr.mthr.if.redT P)\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim red_red0.init_fin_bisim\n       red_red0.init_fin_bisim_wait \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n      if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim red_red0.init_fin_bisim \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim\n       red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B\n      (=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move\n     red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal", "apply(rule delay_bisimulation_diverge_final_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge_final (red_mthr.mthr.if.redT P) ?trsys2.1\n     (FWbisimulation_base.mbisim red_red0.init_fin_bisim\n       red_red0.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim red_red0.init_fin_bisim)\n     red_mthr.if.m\\<tau>move ?\\<tau>move2.1 red_mthr.mthr.if.mfinal\n     ?final2.1\n 2. delay_bisimulation_diverge_final ?trsys2.1\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n      if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim\n       red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B\n      (=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     ?\\<tau>move2.1 execd_mthr.if.m\\<tau>move ?final2.1\n     execd_mthr.mthr.if.mfinal", "apply(rule FWdelay_bisimulation_diverge.mthr_delay_bisimulation_diverge_final)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWdelay_bisimulation_diverge red_mthr.init_fin_final\n     (red_mthr.init_fin P) ?final2.4 ?r2.4 red_red0.init_fin_bisim\n     red_red0.init_fin_bisim_wait (red_mthr.init_fin_\\<tau>move P)\n     ?\\<tau>move2.4\n 2. delay_bisimulation_diverge_final\n     (multithreaded_base.redT ?final2.4 ?r2.4\n       (map NormalAction \\<circ> convert_RA))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n      if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim\n       red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B\n      (=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move ?\\<tau>move2.4)\n     execd_mthr.if.m\\<tau>move (final_thread.mfinal ?final2.4)\n     execd_mthr.mthr.if.mfinal", "apply(rule FWdelay_bisimulation_diverge.init_fin_FWdelay_bisimulation_diverge)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWdelay_bisimulation_diverge final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     final_expr0 ?r2.6 (\\<lambda>t. bisim_red_red0)\n     (\\<lambda>exs (e0, es0). \\<not> final e0)\n     (\\<lambda>((e, x), h) ta s'.\n         \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n     ?\\<tau>move2.6\n 2. delay_bisimulation_diverge_final\n     (multithreaded_base.redT red0_mthr.init_fin_final\n       (multithreaded_base.init_fin final_expr0 ?r2.6)\n       (map NormalAction \\<circ> convert_RA))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n      if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim\n       red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B\n      (=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move\n       (\\<tau>multithreaded.init_fin_\\<tau>move ?\\<tau>move2.6))\n     execd_mthr.if.m\\<tau>move\n     (final_thread.mfinal red0_mthr.init_fin_final)\n     execd_mthr.mthr.if.mfinal", "apply(rule red_red0_FWbisim[OF wf_prog_wwf_prog[OF wf]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final\n     (multithreaded_base.redT red0_mthr.init_fin_final\n       (red0_mthr.init_fin P) (map NormalAction \\<circ> convert_RA))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n      if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim\n       red0_Red1'.init_fin_bisim \\<circ>\\<^sub>B\n      (=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move (red0_mthr.init_fin_\\<tau>move P))\n     execd_mthr.if.m\\<tau>move\n     (final_thread.mfinal red0_mthr.init_fin_final)\n     execd_mthr.mthr.if.mfinal", "apply(rule delay_bisimulation_diverge_final_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge_final\n     (multithreaded_base.redT red0_mthr.init_fin_final\n       (red0_mthr.init_fin P) (map NormalAction \\<circ> convert_RA))\n     ?trsys2.10\n     (FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n       red0_Red1'.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim red0_Red1'.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move (red0_mthr.init_fin_\\<tau>move P))\n     ?\\<tau>move2.10 (final_thread.mfinal red0_mthr.init_fin_final)\n     ?final2.10\n 2. delay_bisimulation_diverge_final ?trsys2.10\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     ((=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     ?\\<tau>move2.10 execd_mthr.if.m\\<tau>move ?final2.10\n     execd_mthr.mthr.if.mfinal", "apply(rule FWdelay_bisimulation_diverge.mthr_delay_bisimulation_diverge_final)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWdelay_bisimulation_diverge red0_mthr.init_fin_final\n     (red0_mthr.init_fin P) ?final2.13 ?r2.13 red0_Red1'.init_fin_bisim\n     red0_Red1'.init_fin_bisim_wait (red0_mthr.init_fin_\\<tau>move P)\n     ?\\<tau>move2.13\n 2. delay_bisimulation_diverge_final\n     (multithreaded_base.redT ?final2.13 ?r2.13\n       (map NormalAction \\<circ> convert_RA))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     ((=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move ?\\<tau>move2.13)\n     execd_mthr.if.m\\<tau>move (final_thread.mfinal ?final2.13)\n     execd_mthr.mthr.if.mfinal", "apply(rule FWdelay_bisimulation_diverge.init_fin_FWdelay_bisimulation_diverge)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWdelay_bisimulation_diverge final_expr0 (mred0 P) final_expr1 ?r2.15\n     (\\<lambda>t. bisim_red0_Red1) bisim_wait01\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n     ?\\<tau>move2.15\n 2. delay_bisimulation_diverge_final\n     (multithreaded_base.redT Red1_mthr.init_fin_final\n       (multithreaded_base.init_fin final_expr1 ?r2.15)\n       (map NormalAction \\<circ> convert_RA))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     ((=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (\\<tau>multithreaded.m\\<tau>move\n       (\\<tau>multithreaded.init_fin_\\<tau>move ?\\<tau>move2.15))\n     execd_mthr.if.m\\<tau>move Red1_mthr.if.mfinal execd_mthr.mthr.if.mfinal", "apply(rule red0_Red1'_FWweak_bisim[OF wf])"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (Red1_mthr.if.redT False (compP1 P))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n      FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     ((=) \\<circ>\\<^sub>B\n      FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) execd_mthr.if.m\\<tau>move\n     Red1_mthr.if.mfinal execd_mthr.mthr.if.mfinal", "apply(rule delay_bisimulation_diverge_final_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge_final (Red1_mthr.if.redT False (compP1 P))\n     ?trsys2.18 if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) ?\\<tau>move2.18\n     Red1_mthr.if.mfinal ?final2.18\n 2. delay_bisimulation_diverge_final ?trsys2.18\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     ?\\<tau>move2.18 execd_mthr.if.m\\<tau>move ?final2.18\n     execd_mthr.mthr.if.mfinal", "apply(rule delay_bisimulation_diverge_final.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. delay_bisimulation_diverge (Red1_mthr.if.redT False (compP1 P))\n     ?trsys2.18 if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) ?\\<tau>move2.18\n 2. delay_bisimulation_final_base (Red1_mthr.if.redT False (compP1 P))\n     ?trsys2.18 if_mbisim_Red1'_Red1 (Red1_mthr.if.m\\<tau>move (compP1 P))\n     ?\\<tau>move2.18 Red1_mthr.if.mfinal ?final2.18\n 3. delay_bisimulation_diverge_final ?trsys2.18\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     ?\\<tau>move2.18 execd_mthr.if.m\\<tau>move ?final2.18\n     execd_mthr.mthr.if.mfinal", "apply(rule bisimulation_into_delay.delay_bisimulation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bisimulation_into_delay (Red1_mthr.if.redT False (compP1 P)) ?trsys2.18\n     if_mbisim_Red1'_Red1 (=) (Red1_mthr.if.m\\<tau>move (compP1 P))\n     ?\\<tau>move2.18\n 2. delay_bisimulation_final_base (Red1_mthr.if.redT False (compP1 P))\n     ?trsys2.18 if_mbisim_Red1'_Red1 (Red1_mthr.if.m\\<tau>move (compP1 P))\n     ?\\<tau>move2.18 Red1_mthr.if.mfinal ?final2.18\n 3. delay_bisimulation_diverge_final ?trsys2.18\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     ?\\<tau>move2.18 execd_mthr.if.m\\<tau>move ?final2.18\n     execd_mthr.mthr.if.mfinal", "apply(rule if_Red1'_Red1_bisim_into_weak[OF compP1_pres_wf[OF wf]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_final_base (Red1_mthr.if.redT False (compP1 P))\n     (Red1_mthr.if.redT True (compP1 P)) if_mbisim_Red1'_Red1\n     (Red1_mthr.if.m\\<tau>move (compP1 P))\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) Red1_mthr.if.mfinal ?final2.18\n 2. delay_bisimulation_diverge_final (Red1_mthr.if.redT True (compP1 P))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) execd_mthr.if.m\\<tau>move\n     ?final2.18 execd_mthr.mthr.if.mfinal", "apply(rule bisimulation_final.delay_bisimulation_final_base)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bisimulation_final (Red1_mthr.if.redT False (compP1 P))\n     (Red1_mthr.if.redT True (compP1 P)) if_mbisim_Red1'_Red1 ?tlsim28\n     Red1_mthr.if.mfinal ?final2.18\n 2. delay_bisimulation_diverge_final (Red1_mthr.if.redT True (compP1 P))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) execd_mthr.if.m\\<tau>move\n     ?final2.18 execd_mthr.mthr.if.mfinal", "apply(rule if_Red1'_Red1_bisimulation_final[OF compP1_pres_wf[OF wf]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (Red1_mthr.if.redT True (compP1 P))\n     (execd_mthr.mthr.if.redT (compP2 (compP1 P)))\n     (FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n       Red1_execd.init_fin_bisim_wait)\n     (FWbisimulation_base.mta_bisim Red1_execd.init_fin_bisim)\n     (Red1_mthr.if.m\\<tau>move (compP1 P)) execd_mthr.if.m\\<tau>move\n     Red1_mthr.if.mfinal execd_mthr.mthr.if.mfinal", "apply(rule FWdelay_bisimulation_diverge.mthr_delay_bisimulation_diverge_final)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge Red1_mthr.init_fin_final\n     (Red1_mthr.init_fin True (compP1 P)) exec_mthr.init_fin_final\n     (execd_mthr.init_fin (compP2 (compP1 P))) Red1_execd.init_fin_bisim\n     Red1_execd.init_fin_bisim_wait\n     (Red1_mthr.init_fin_\\<tau>move (compP1 P))\n     (execd_mthr.init_fin_\\<tau>move (compP2 (compP1 P)))", "apply(rule FWdelay_bisimulation_diverge.init_fin_FWdelay_bisimulation_diverge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 (compP1 P)) JVM_final\n     (mexecd (compP2 (compP1 P))) wbisim1\n     (bisim_wait1JVM (compP2 (compP1 P)))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 (compP1 P) h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 (compP1 P)) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "apply(rule Red1_exec1_FWwbisim[OF compP1_pres_wf[OF wf]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_bisimJ2JVM_start:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"if_bisimJ2JVM (init_fin_lift_state Running (J_start_state P C M vs))\n                       (init_fin_lift_state Running (JVM_start_state (J2JVM P) C M vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_bisimJ2JVM\n     (init_fin_lift_state Running (start_state J_local_start P C M vs))\n     (init_fin_lift_state Running\n       (start_state JVM_local_start (J2JVM P) C M vs))", "using assms"], ["proof (prove)\nusing this:\n  wf_J_prog P\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. if_bisimJ2JVM\n     (init_fin_lift_state Running (start_state J_local_start P C M vs))\n     (init_fin_lift_state Running\n       (start_state JVM_local_start (J2JVM P) C M vs))", "unfolding if_bisimJ2JVM_def J2JVM_def o_apply"], ["proof (prove)\nusing this:\n  wf_J_prog P\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. (FWbisimulation_base.mbisim red_red0.init_fin_bisim\n      red_red0.init_fin_bisim_wait \\<circ>\\<^sub>B\n     FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n      red0_Red1'.init_fin_bisim_wait \\<circ>\\<^sub>B\n     if_mbisim_Red1'_Red1 \\<circ>\\<^sub>B\n     FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n      Red1_execd.init_fin_bisim_wait)\n     (init_fin_lift_state Running (start_state J_local_start P C M vs))\n     (init_fin_lift_state Running\n       (start_state JVM_local_start (compP2 (compP1 P)) C M vs))", "apply(intro bisim_composeI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim red_red0.init_fin_bisim\n                       red_red0.init_fin_bisim_wait\n                       (init_fin_lift_state Running\n                         (start_state J_local_start P C M vs))\n                       ?s2.2\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n                       red0_Red1'.init_fin_bisim_wait ?s2.2 ?s2.3\n 3. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> if_mbisim_Red1'_Red1 ?s2.3 ?s2.4\n 4. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait ?s2.4\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(rule FWbisimulation_base.init_fin_lift_state_mbisimI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> red_red0.mbisim (start_state J_local_start P C M vs)\n                       ?s'5\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n                       red0_Red1'.init_fin_bisim_wait\n                       (init_fin_lift_state Running ?s'5) ?s2.3\n 3. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> if_mbisim_Red1'_Red1 ?s2.3 ?s2.4\n 4. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait ?s2.4\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(erule (1) bisim_J_J0_start[OF wf_prog_wwf_prog])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim red0_Red1'.init_fin_bisim\n                       red0_Red1'.init_fin_bisim_wait\n                       (init_fin_lift_state Running\n                         (J0_start_state P C M vs))\n                       ?s2.3\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> if_mbisim_Red1'_Red1 ?s2.3 ?s2.4\n 3. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait ?s2.4\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(rule FWbisimulation_base.init_fin_lift_state_mbisimI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> red0_Red1'.mbisim (J0_start_state P C M vs) ?s'10\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> if_mbisim_Red1'_Red1\n                       (init_fin_lift_state Running ?s'10) ?s2.4\n 3. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait ?s2.4\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(erule (1) bisim_J0_J1_start)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> if_mbisim_Red1'_Red1\n                       (init_fin_lift_state Running\n                         (J1_start_state (compP1 P) C M vs))\n                       ?s2.4\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait ?s2.4\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(erule if_bisim_J1_J1_start[OF compP1_pres_wf])"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_start_state P C M vs \\<Longrightarrow>\n    wf_start_state (compP1 P) C M vs\n 2. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait\n                       (init_fin_lift_state Running\n                         (J1_start_state (compP1 P) C M vs))\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> FWbisimulation_base.mbisim Red1_execd.init_fin_bisim\n                       Red1_execd.init_fin_bisim_wait\n                       (init_fin_lift_state Running\n                         (J1_start_state (compP1 P) C M vs))\n                       (init_fin_lift_state Running\n                         (start_state JVM_local_start (compP2 (compP1 P)) C\n                           M vs))", "apply(rule FWbisimulation_base.init_fin_lift_state_mbisimI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> Red1_execd.mbisim (J1_start_state (compP1 P) C M vs)\n                       (start_state JVM_local_start (compP2 (compP1 P)) C M\n                         vs)", "apply(erule bisim_J1_JVM_start[OF compP1_pres_wf])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_start_state P C M vs \\<Longrightarrow>\n    wf_start_state (compP1 P) C M vs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_Runs_eq_mexecd_Runs:\n  fixes C M vs\n  defines s: \"s \\<equiv> init_fin_lift_state Running (J_start_state P C M vs)\"\n  and comps: \"cs \\<equiv> init_fin_lift_state Running (JVM_start_state (J2JVM P) C M vs)\"\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "from wf wf_start"], ["proof (chain)\npicking this:\n  wf_J_prog P\n  wf_start_state P C M vs", "have bisim: \"if_bisimJ2JVM s cs\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. if_bisimJ2JVM s cs", "unfolding s comps"], ["proof (prove)\nusing this:\n  wf_J_prog P\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. if_bisimJ2JVM\n     (init_fin_lift_state Running (start_state J_local_start P C M vs))\n     (init_fin_lift_state Running\n       (start_state JVM_local_start (J2JVM P) C M vs))", "by(rule if_bisimJ2JVM_start)"], ["proof (state)\nthis:\n  if_bisimJ2JVM s cs\n\ngoal (1 subgoal):\n 1. red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "interpret divfin: delay_bisimulation_diverge_final \n    \"red_mthr.mthr.if.redT P\" \n    \"execd_mthr.mthr.if.redT (J2JVM P)\"\n    \"if_bisimJ2JVM\"\n    \"if_tlsimJ2JVM\"\n    \"red_mthr.if.m\\<tau>move\"\n    \"execd_mthr.if.m\\<tau>move\"\n    \"red_mthr.mthr.if.mfinal\"\n    \"execd_mthr.mthr.if.mfinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (red_mthr.mthr.if.redT P)\n     (execd_mthr.mthr.if.redT (J2JVM P)) if_bisimJ2JVM if_tlsimJ2JVM\n     red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move\n     red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal", "using wf"], ["proof (prove)\nusing this:\n  wf_J_prog P\n\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final (red_mthr.mthr.if.redT P)\n     (execd_mthr.mthr.if.redT (J2JVM P)) if_bisimJ2JVM if_tlsimJ2JVM\n     red_mthr.if.m\\<tau>move execd_mthr.if.m\\<tau>move\n     red_mthr.mthr.if.mfinal execd_mthr.mthr.if.mfinal", "by(rule if_bisimJ2JVM_weak_bisim)"], ["proof (state)\ngoal (1 subgoal):\n 1. red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "show ?thesis (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "proof(intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "fix E"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "assume \"E \\<in> ?lhs\""], ["proof (state)\nthis:\n  E \\<in> red_mthr.mthr.if.\\<E> P s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "then"], ["proof (chain)\npicking this:\n  E \\<in> red_mthr.mthr.if.\\<E> P s", "obtain E' where E: \"E = lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E'))\"\n      and E': \"red_mthr.if.mthr.\\<tau>Runs s E'\""], ["proof (prove)\nusing this:\n  E \\<in> red_mthr.mthr.if.\\<E> P s\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (llist_of_tllist E'));\n         red_mthr.if.mthr.\\<tau>Runs s E'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding red_mthr.if.\\<E>_conv_Runs"], ["proof (prove)\nusing this:\n  E \\<in> lconcat `\n          lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) `\n          llist_of_tllist ` Collect (red_mthr.if.mthr.\\<tau>Runs s)\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (llist_of_tllist E'));\n         red_mthr.if.mthr.\\<tau>Runs s E'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E =\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n  red_mthr.if.mthr.\\<tau>Runs s E'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from divfin.simulation_\\<tau>Runs1[OF bisim E']"], ["proof (chain)\npicking this:\n  \\<exists>tls2.\n     divfin.\\<tau>Runs cs tls2 \\<and>\n     tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' tls2", "obtain E'' where E'': \"execd_mthr.if.mthr.\\<tau>Runs cs E''\"\n      and tlsim: \"tllist_all2 if_tlsimJ2JVM (option.rel_option if_bisimJ2JVM) E' E''\""], ["proof (prove)\nusing this:\n  \\<exists>tls2.\n     divfin.\\<tau>Runs cs tls2 \\<and>\n     tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' tls2\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        \\<lbrakk>execd_mthr.if.mthr.\\<tau>Runs cs E'';\n         tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E'\n          E''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding J2JVM_def o_apply"], ["proof (prove)\nusing this:\n  \\<exists>tls2.\n     \\<tau>trsys.\\<tau>Runs\n      (multithreaded_base.redT exec_mthr.init_fin_final\n        (execd_mthr.init_fin (compP2 (compP1 P)))\n        (\\<lambda>x. map NormalAction (convert_RA x)))\n      execd_mthr.if.m\\<tau>move cs tls2 \\<and>\n     tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' tls2\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        \\<lbrakk>\\<tau>trsys.\\<tau>Runs\n                  (multithreaded_base.redT exec_mthr.init_fin_final\n                    (execd_mthr.init_fin (compP2 (compP1 P)))\n                    (\\<lambda>x. map NormalAction (convert_RA x)))\n                  execd_mthr.if.m\\<tau>move cs E'';\n         tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E'\n          E''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execd_mthr.if.mthr.\\<tau>Runs cs E''\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' E''\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "let ?E = \"lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E''))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from tlsim"], ["proof (chain)\npicking this:\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' E''", "have \"llist_all2 if_tlsimJ2JVM (llist_of_tllist E') (llist_of_tllist E'')\""], ["proof (prove)\nusing this:\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E' E''\n\ngoal (1 subgoal):\n 1. divfin.Tlsiml (llist_of_tllist E') (llist_of_tllist E'')", "by(rule tllist_all2D_llist_all2_llist_of_tllist)"], ["proof (state)\nthis:\n  divfin.Tlsiml (llist_of_tllist E') (llist_of_tllist E'')\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "hence \"llist_all2 (=) (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E'))\n                             (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E''))\""], ["proof (prove)\nusing this:\n  divfin.Tlsiml (llist_of_tllist E') (llist_of_tllist E'')\n\ngoal (1 subgoal):\n 1. llist_all2 (=)\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'))\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))", "unfolding llist_all2_lmap1 llist_all2_lmap2"], ["proof (prove)\nusing this:\n  divfin.Tlsiml (llist_of_tllist E') (llist_of_tllist E'')\n\ngoal (1 subgoal):\n 1. llist_all2\n     (\\<lambda>x y.\n         (case x of\n          (t, ta) \\<Rightarrow>\n            llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) =\n         (case y of\n          (t, ta) \\<Rightarrow>\n            llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (llist_of_tllist E') (llist_of_tllist E'')", "by(rule llist_all2_mono)(auto simp add: if_tlsimJ2JVM_def FWbisimulation_base.mta_bisim_def ta_bisim_def)"], ["proof (state)\nthis:\n  llist_all2 (=)\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "hence \"?E = E\""], ["proof (prove)\nusing this:\n  llist_all2 (=)\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'')) =\n    E", "unfolding llist.rel_eq E"], ["proof (prove)\nusing this:\n  lmap\n   (\\<lambda>(t, ta).\n       llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n   (llist_of_tllist E') =\n  lmap\n   (\\<lambda>(t, ta).\n       llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n   (llist_of_tllist E'')\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'')) =\n    lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'))", "by simp"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'')) =\n  E\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "also"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'')) =\n  E\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from E''"], ["proof (chain)\npicking this:\n  execd_mthr.if.mthr.\\<tau>Runs cs E''", "have \"?E \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  execd_mthr.if.mthr.\\<tau>Runs cs E''\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))\n    \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "unfolding J2JVM_def o_apply execd_mthr.if.\\<E>_conv_Runs"], ["proof (prove)\nusing this:\n  \\<tau>trsys.\\<tau>Runs\n   (multithreaded_base.redT exec_mthr.init_fin_final\n     (execd_mthr.init_fin (compP2 (compP1 P)))\n     (\\<lambda>x. map NormalAction (convert_RA x)))\n   execd_mthr.if.m\\<tau>move cs E''\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))\n    \\<in> lconcat `\n          lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) `\n          llist_of_tllist `\n          Collect\n           (\\<tau>trsys.\\<tau>Runs\n             (multithreaded_base.redT exec_mthr.init_fin_final\n               (execd_mthr.init_fin (compP2 (compP1 P)))\n               (\\<lambda>x. map NormalAction (convert_RA x)))\n             execd_mthr.if.m\\<tau>move cs)", "by blast"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n  \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> red_mthr.mthr.if.\\<E> P s \\<Longrightarrow>\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n 2. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "finally (subst)"], ["proof (chain)\npicking this:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "show \"E \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal (1 subgoal):\n 1. E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "."], ["proof (state)\nthis:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "fix E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "assume \"E \\<in> ?rhs\""], ["proof (state)\nthis:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "then"], ["proof (chain)\npicking this:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs", "obtain E' where E: \"E = lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E'))\"\n      and E': \"execd_mthr.if.mthr.\\<tau>Runs cs E'\""], ["proof (prove)\nusing this:\n  E \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (llist_of_tllist E'));\n         execd_mthr.if.mthr.\\<tau>Runs cs E'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding execd_mthr.if.\\<E>_conv_Runs J2JVM_def o_apply"], ["proof (prove)\nusing this:\n  E \\<in> lconcat `\n          lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) `\n          llist_of_tllist `\n          Collect\n           (\\<tau>trsys.\\<tau>Runs\n             (multithreaded_base.redT exec_mthr.init_fin_final\n               (execd_mthr.init_fin (compP2 (compP1 P)))\n               (\\<lambda>x. map NormalAction (convert_RA x)))\n             execd_mthr.if.m\\<tau>move cs)\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (llist_of_tllist E'));\n         \\<tau>trsys.\\<tau>Runs\n          (multithreaded_base.redT exec_mthr.init_fin_final\n            (execd_mthr.init_fin (compP2 (compP1 P)))\n            (\\<lambda>x. map NormalAction (convert_RA x)))\n          execd_mthr.if.m\\<tau>move cs E'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E =\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n  execd_mthr.if.mthr.\\<tau>Runs cs E'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from divfin.simulation_\\<tau>Runs2[OF bisim, simplified J2JVM_def o_apply, OF E']"], ["proof (chain)\npicking this:\n  \\<exists>tls1.\n     red_mthr.if.mthr.\\<tau>Runs s tls1 \\<and>\n     tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) tls1 E'", "obtain E'' where E'': \"red_mthr.if.mthr.\\<tau>Runs s E''\"\n      and tlsim: \"tllist_all2 if_tlsimJ2JVM (option.rel_option if_bisimJ2JVM) E'' E'\""], ["proof (prove)\nusing this:\n  \\<exists>tls1.\n     red_mthr.if.mthr.\\<tau>Runs s tls1 \\<and>\n     tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) tls1 E'\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        \\<lbrakk>red_mthr.if.mthr.\\<tau>Runs s E'';\n         tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E''\n          E'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  red_mthr.if.mthr.\\<tau>Runs s E''\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E'' E'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "let ?E = \"lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E''))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from tlsim"], ["proof (chain)\npicking this:\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E'' E'", "have \"llist_all2 if_tlsimJ2JVM (llist_of_tllist E'') (llist_of_tllist E')\""], ["proof (prove)\nusing this:\n  tllist_all2 if_tlsimJ2JVM (rel_option if_bisimJ2JVM) E'' E'\n\ngoal (1 subgoal):\n 1. divfin.Tlsiml (llist_of_tllist E'') (llist_of_tllist E')", "by(rule tllist_all2D_llist_all2_llist_of_tllist)"], ["proof (state)\nthis:\n  divfin.Tlsiml (llist_of_tllist E'') (llist_of_tllist E')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "hence \"llist_all2 (=) (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E''))\n                             (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (llist_of_tllist E'))\""], ["proof (prove)\nusing this:\n  divfin.Tlsiml (llist_of_tllist E'') (llist_of_tllist E')\n\ngoal (1 subgoal):\n 1. llist_all2 (=)\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'))", "unfolding llist_all2_lmap1 llist_all2_lmap2"], ["proof (prove)\nusing this:\n  divfin.Tlsiml (llist_of_tllist E'') (llist_of_tllist E')\n\ngoal (1 subgoal):\n 1. llist_all2\n     (\\<lambda>x y.\n         (case x of\n          (t, ta) \\<Rightarrow>\n            llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) =\n         (case y of\n          (t, ta) \\<Rightarrow>\n            llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (llist_of_tllist E'') (llist_of_tllist E')", "by(rule llist_all2_mono)(auto simp add: if_tlsimJ2JVM_def FWbisimulation_base.mta_bisim_def ta_bisim_def)"], ["proof (state)\nthis:\n  llist_all2 (=)\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "hence \"?E = E\""], ["proof (prove)\nusing this:\n  llist_all2 (=)\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'))\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'')) =\n    E", "unfolding llist.rel_eq E"], ["proof (prove)\nusing this:\n  lmap\n   (\\<lambda>(t, ta).\n       llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n   (llist_of_tllist E'') =\n  lmap\n   (\\<lambda>(t, ta).\n       llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n   (llist_of_tllist E')\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'')) =\n    lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E'))", "by simp"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'')) =\n  E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "also"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E'')) =\n  E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "from E''"], ["proof (chain)\npicking this:\n  red_mthr.if.mthr.\\<tau>Runs s E''", "have \"?E \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  red_mthr.if.mthr.\\<tau>Runs s E''\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))\n    \\<in> red_mthr.mthr.if.\\<E> P s", "unfolding red_mthr.if.\\<E>_conv_Runs"], ["proof (prove)\nusing this:\n  red_mthr.if.mthr.\\<tau>Runs s E''\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta).\n           llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (llist_of_tllist E''))\n    \\<in> lconcat `\n          lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) `\n          llist_of_tllist ` Collect (red_mthr.if.mthr.\\<tau>Runs s)", "by blast"], ["proof (state)\nthis:\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (llist_of_tllist E''))\n  \\<in> red_mthr.mthr.if.\\<E> P s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> execd_mthr.mthr.if.\\<E> (J2JVM P) cs \\<Longrightarrow>\n       x \\<in> red_mthr.mthr.if.\\<E> P s", "finally (subst)"], ["proof (chain)\npicking this:\n  E \\<in> red_mthr.mthr.if.\\<E> P s", "show \"E \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  E \\<in> red_mthr.mthr.if.\\<E> P s\n\ngoal (1 subgoal):\n 1. E \\<in> red_mthr.mthr.if.\\<E> P s", "."], ["proof (state)\nthis:\n  E \\<in> red_mthr.mthr.if.\\<E> P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red_mthr.mthr.if.\\<E> P s = execd_mthr.mthr.if.\\<E> (J2JVM P) cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_\\<E>_eq_mexecd_\\<E>:\n  \"\\<lbrakk> wf_J_prog P; wf_start_state P C M vs \\<rbrakk>\n  \\<Longrightarrow> J_\\<E> P C M vs Running = JVMd_\\<E> (J2JVM P) C M vs Running\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> red_mthr.\\<E>_start P J_local_start P C M vs Running =\n                      execd_mthr.\\<E>_start (J2JVM P) JVM_local_start\n                       (J2JVM P) C M vs Running", "by(simp only: red_Runs_eq_mexecd_Runs)"], ["", "theorem J2JVM_jmm_correct:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"legal_execution P (J_\\<E> P C M vs Running) (E, ws) \\<longleftrightarrow> \n         legal_execution (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) (E, ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_execution P (red_mthr.\\<E>_start P J_local_start P C M vs Running)\n     (E, ws) =\n    legal_execution (J2JVM P)\n     (execd_mthr.\\<E>_start (J2JVM P) JVM_local_start (J2JVM P) C M vs\n       Running)\n     (E, ws)", "by(simp only: red_\\<E>_eq_mexecd_\\<E>[OF assms] J2JVM_def o_apply compP1_def compP2_def legal_execution_compP)"], ["", "theorem J2JVM_jmm_correct_weak:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"weakly_legal_execution P (J_\\<E> P C M vs Running) (E, ws) \\<longleftrightarrow> \n         weakly_legal_execution (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) (E, ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_legal_execution P\n     (red_mthr.\\<E>_start P J_local_start P C M vs Running) (E, ws) =\n    weakly_legal_execution (J2JVM P)\n     (execd_mthr.\\<E>_start (J2JVM P) JVM_local_start (J2JVM P) C M vs\n       Running)\n     (E, ws)", "by(simp only: red_\\<E>_eq_mexecd_\\<E>[OF assms] J2JVM_def o_apply compP1_def compP2_def weakly_legal_execution_compP)"], ["", "theorem J2JVM_jmm_correctly_synchronized:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"correctly_synchronized (J2JVM P) (JVMd_\\<E> (J2JVM P) C M vs Running) \\<longleftrightarrow> \n         correctly_synchronized P (J_\\<E> P C M vs Running)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correctly_synchronized (J2JVM P)\n     (execd_mthr.\\<E>_start (J2JVM P) JVM_local_start (J2JVM P) C M vs\n       Running) =\n    correctly_synchronized P\n     (red_mthr.\\<E>_start P J_local_start P C M vs Running)", "by(simp only: red_\\<E>_eq_mexecd_\\<E>[OF assms] J2JVM_def o_apply compP1_def compP2_def correctly_synchronized_compP)"], ["", "end"], ["", "end"]]}