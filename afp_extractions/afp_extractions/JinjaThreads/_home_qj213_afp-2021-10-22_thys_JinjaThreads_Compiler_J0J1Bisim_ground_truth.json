{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/J0J1Bisim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma unmods_map_Val [simp]: \"unmods (map Val vs) V\"", "lemma fixes e :: \"'addr expr\" and es :: \"'addr expr list\"\n  shows hidden_unmod: \"hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i\"\n  and hidden_unmods: \"hidden Vs i \\<Longrightarrow> unmods (compEs1 Vs es) i\"", "lemma unmod_extRet2J [simp]: \"unmod e i \\<Longrightarrow> unmod (extRet2J e va) i\"", "lemma max_dest: \"(n :: nat) + max a b \\<le> c \\<Longrightarrow> n + a \\<le> c \\<and> n + b \\<le> c\"", "lemma fixes e :: \"'addr expr\" and es :: \"'addr expr list\"\n  shows fv_unmod_compE1: \"\\<lbrakk> i < length Vs; Vs ! i \\<notin> fv e \\<rbrakk> \\<Longrightarrow> unmod (compE1 Vs e) i\"\n  and fvs_unmods_compEs1: \"\\<lbrakk> i < length Vs; Vs ! i \\<notin> fvs es \\<rbrakk> \\<Longrightarrow> unmods (compEs1 Vs es) i\"", "lemma hidden_lengthD: \"hidden Vs i \\<Longrightarrow> i < length Vs\"", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows fv_B_unmod: \"\\<lbrakk> V \\<notin> fv e; \\<B> e n; V < n \\<rbrakk> \\<Longrightarrow> unmod e V\"\n  and fvs_Bs_unmods: \"\\<lbrakk> V \\<notin> fvs es; \\<B>s es n; V < n \\<rbrakk> \\<Longrightarrow> unmods es V\"", "lemma assumes fin: \"final e'\"\n  shows unmod_inline_call: \"unmod (inline_call e' e) V \\<longleftrightarrow> unmod e V\"\n  and unmods_inline_calls: \"unmods (inline_calls e' es) V \\<longleftrightarrow> unmods es V\"", "lemma bisim_list1I[intro?]:\n  \"\\<lbrakk> bisim_list es exs1; bisim [] e e1 xs1; fv e = {};\n     \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e1 \\<le> length xs1 \\<rbrakk>\n  \\<Longrightarrow> bisim_list1 (e, es) ((e1, xs1), exs1)\"", "lemma bisim_list1E[elim?]:\n  assumes \"bisim_list1 (e, es) ((e1, xs1), exs1)\"\n  obtains \"bisim_list es exs1\" \"bisim [] e e1 xs1\" \"fv e = {}\" \"\\<D> e \\<lfloor>{}\\<rfloor>\" \"max_vars e1 \\<le> length xs1\"", "lemma bisim_list1_elim:\n  assumes \"bisim_list1 es' exs\"\n  obtains e es e1 xs1 exs1\n  where \"es' = (e, es)\" \"exs = ((e1, xs1), exs1)\"\n  and \"bisim_list es exs1\" \"bisim [] e e1 xs1\" \"fv e = {}\" \"\\<D> e \\<lfloor>{}\\<rfloor>\" \"max_vars e1 \\<le> length xs1\"", "lemma bisims_map_Val_conv [simp]: \"bisims Vs (map Val vs) es xs = (es = map Val vs)\"", "lemma bisim_contains_insync: \"bisim Vs e e' xs \\<Longrightarrow> contains_insync e = contains_insync e'\"\n  and bisims_contains_insyncs: \"bisims Vs es es' xs \\<Longrightarrow> contains_insyncs es = contains_insyncs es'\"", "lemma bisims_map_Val_Throw: \n  \"bisims Vs (map Val vs @ Throw a # es) es' xs \\<longleftrightarrow> es' = map Val vs @ Throw a # compEs1 Vs es \\<and> \\<not> contains_insyncs es\"", "lemma compE1_bisim [intro]: \"\\<lbrakk> fv e \\<subseteq> set Vs; \\<not> contains_insync e \\<rbrakk> \\<Longrightarrow> bisim Vs e (compE1 Vs e) xs\"\n  and compEs1_bisims [intro]: \"\\<lbrakk> fvs es \\<subseteq> set Vs; \\<not> contains_insyncs es \\<rbrakk> \\<Longrightarrow> bisims Vs es (compEs1 Vs es) xs\"", "lemma bisim_hidden_unmod: \"\\<lbrakk> bisim Vs e e' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and bisims_hidden_unmods: \"\\<lbrakk> bisims Vs es es' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmods es' i\"", "lemma bisim_fv_unmod: \"\\<lbrakk> bisim Vs e e' xs; i < length Vs; Vs ! i \\<notin> fv e \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and bisims_fvs_unmods: \"\\<lbrakk> bisims Vs es es' xs; i < length Vs; Vs ! i \\<notin> fvs es \\<rbrakk> \\<Longrightarrow> unmods es' i\"", "lemma bisim_extRet2J [intro!]: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (extRet2J e va) (extRet2J1 e' va) xs\"", "lemma bisims_map_Val_conv2 [simp]: \"bisims Vs es (map Val vs) xs = (es = map Val vs)\"", "lemma bisims_map_Val_Throw2: \n  \"bisims Vs es' (map Val vs @ Throw a # es) xs \\<longleftrightarrow>\n   (\\<exists>es''. es' = map Val vs @ Throw a # es'' \\<and> es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')\"", "lemma hidden_bisim_unmod: \"\\<lbrakk> bisim Vs e e' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and hidden_bisims_unmods: \"\\<lbrakk> bisims Vs es es' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmods es' i\"", "lemma bisim_list_list_all2_conv:\n  \"bisim_list es exs' \\<longleftrightarrow> list_all2 bisim01 es exs'\"", "lemma bisim_list_extTA2J0_extTA2J1:\n  assumes wf: \"wf_J_prog P\"\n  and sees: \"P \\<turnstile> C sees M:[]\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D\"\n  shows \"bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))\"", "lemma bisim_max_vars: \"bisim Vs e e' xs \\<Longrightarrow> max_vars e = max_vars e'\"\n  and bisims_max_varss: \"bisims Vs es es' xs \\<Longrightarrow> max_varss es = max_varss es'\"", "lemma bisim_call: \"bisim Vs e e' xs \\<Longrightarrow> call e = call e'\"\n  and bisims_calls: \"bisims Vs es es' xs \\<Longrightarrow> calls es = calls es'\"", "lemma bisim_call_None_call1: \"\\<lbrakk> bisim Vs e e' xs; call e = None \\<rbrakk> \\<Longrightarrow> call1 e' = None\"\n  and bisims_calls_None_calls1: \"\\<lbrakk> bisims Vs es es' xs; calls es = None \\<rbrakk> \\<Longrightarrow> calls1 es' = None\"", "lemma bisim_call1_Some_call:\n  \"\\<lbrakk> bisim Vs e e' xs; call1 e' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> call e = \\<lfloor>aMvs\\<rfloor>\"\n\n  and bisims_calls1_Some_calls:\n  \"\\<lbrakk> bisims Vs es es' xs; calls1 es' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> calls es = \\<lfloor>aMvs\\<rfloor>\"", "lemma blocks_bisim: \n  assumes bisim: \"bisim (Vs @ pns) e e' xs\"\n  and length: \"length vs = length pns\" \"length Ts = length pns\"\n  and xs: \"\\<forall>i. i < length vs \\<longrightarrow> xs ! (i + length Vs) = vs ! i\"\n  shows \"bisim Vs (blocks pns Ts vs e) (blocks1 (length Vs) Ts e') xs\"", "lemma fixes e :: \"('a,'b,'addr) exp\" and es :: \"('a,'b,'addr) exp list\"\n  shows inline_call_max_vars: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> max_vars (inline_call e' e) \\<le> max_vars e + max_vars e'\"\n  and inline_calls_max_varss: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e'\"", "lemma assumes \"final E\" \"bisim VS E E' xs\"\n  shows inline_call_compE1: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e)\"\n  and inline_calls_compEs1: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\"", "lemma assumes bisim: \"bisim VS E E' XS\"\n  and final: \"final E\"\n  shows bisim_inline_call:\n  \"\\<lbrakk> bisim Vs e e' xs; call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\"\n  \n  and bisims_inline_calls: \n  \"\\<lbrakk> bisims Vs es es' xs; calls es = \\<lfloor>aMvs\\<rfloor>; fvs es \\<subseteq> set Vs \\<rbrakk>\n  \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\"", "lemma sqInt_lem3: \"\\<lbrakk> A \\<sqsubseteq> A'; B \\<sqsubseteq> B' \\<rbrakk> \\<Longrightarrow> A \\<sqinter> B \\<sqsubseteq> A' \\<sqinter> B'\"", "lemma sqUn_lem3: \"\\<lbrakk> A \\<sqsubseteq> A'; B \\<sqsubseteq> B' \\<rbrakk> \\<Longrightarrow> A \\<squnion> B \\<sqsubseteq> A' \\<squnion> B'\"", "lemma A_inline_call: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<A> e \\<sqsubseteq> \\<A> (inline_call e' e)\"\n  and As_inline_calls: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>  \\<A>s es \\<sqsubseteq> \\<A>s (inline_calls e' es)\"", "lemma assumes \"final e'\"\n  shows defass_inline_call: \"\\<lbrakk> call e = \\<lfloor>aMvs\\<rfloor>; \\<D> e A \\<rbrakk> \\<Longrightarrow> \\<D> (inline_call e' e) A\"\n  and defasss_inline_calls: \"\\<lbrakk> calls es = \\<lfloor>aMvs\\<rfloor>; \\<D>s es A \\<rbrakk> \\<Longrightarrow> \\<D>s (inline_calls e' es) A\"", "lemma bisim_B: \"bisim Vs e E xs \\<Longrightarrow> \\<B> E (length Vs)\"\n  and bisims_Bs: \"bisims Vs es Es xs \\<Longrightarrow> \\<B>s Es (length Vs)\"", "lemma bisim_expr_locks_eq: \"bisim Vs e e' xs \\<Longrightarrow> expr_locks e = expr_locks e'\"\n  and bisims_expr_lockss_eq: \"bisims Vs es es' xs \\<Longrightarrow> expr_lockss es = expr_lockss es'\"", "lemma bisim_list_expr_lockss_eq: \"bisim_list es exs' \\<Longrightarrow> expr_lockss es = expr_lockss (map fst exs')\"", "lemma [simp]:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1_compP: \"\\<tau>move1 (compP f P) h e = \\<tau>move1 P h e\"\n  and \\<tau>moves1_compP: \"\\<tau>moves1 (compP f P) h es = \\<tau>moves1 P h es\"", "lemma \\<tau>Move1_compP [simp]: \"\\<tau>Move1 (compP f P) = \\<tau>Move1 P\"", "lemma red1_preserves_unmod:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; unmod e i \\<rbrakk> \\<Longrightarrow> (lcl s') ! i = (lcl s) ! i\"\n  \n  and reds1_preserves_unmod:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; unmods es i \\<rbrakk> \\<Longrightarrow> (lcl s') ! i = (lcl s) ! i\"", "lemma red1_unmod_preserved:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and reds1_unmods_preserved:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; unmods es i \\<rbrakk> \\<Longrightarrow> unmods es' i\"", "lemma \\<tau>red1t_unmod_preserved:\n  \"\\<lbrakk> \\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\"", "lemma \\<tau>red1r_unmod_preserved:\n  \"\\<lbrakk> \\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\"", "lemma \\<tau>red1t_preserves_unmod: \n  \"\\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i; i < length xs \\<rbrakk>\n  \\<Longrightarrow> xs' ! i = xs ! i\"", "lemma \\<tau>red1'r_preserves_unmod: \n  \"\\<lbrakk>\\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i; i < length xs \\<rbrakk>\n  \\<Longrightarrow> xs' ! i = xs ! i\"", "lemma [simp]:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_compP: \"\\<tau>move0 (compP f P) h e = \\<tau>move0 P h e\"\n  and \\<tau>moves0_compP: \"\\<tau>moves0 (compP f P) h es = \\<tau>moves0 P h es\"", "lemma \\<tau>Move0_compP [simp]: \"\\<tau>Move0 (compP f P) = \\<tau>Move0 P\""], "translations": [["", "lemma unmods_map_Val [simp]: \"unmods (map Val vs) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unmods (map Val vs) V", "by(induct vs) simp_all"], ["", "lemma fixes e :: \"'addr expr\" and es :: \"'addr expr list\"\n  shows hidden_unmod: \"hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i\"\n  and hidden_unmods: \"hidden Vs i \\<Longrightarrow> unmods (compEs1 Vs es) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i) &&&\n    (hidden Vs i \\<Longrightarrow> unmods (compEs1 Vs es) i)", "apply(induct Vs e and Vs es rule: compE1_compEs1_induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>Vs C. hidden Vs i \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v. hidden Vs i \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V. hidden Vs i \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n        hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e') i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs a) i;\n        hidden Vs i \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>hidden Vs i \\<Longrightarrow> unmod (compE1 Vs a) i;\n         hidden Vs i \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         hidden Vs i \\<Longrightarrow> unmod (compE1 Vs e) i;\n         hidden Vs i\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "apply (simp_all add:hidden_inacc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Vs V vo e.\n       \\<lbrakk>unmod (compE1 (Vs @ [V]) e) i; hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> i = length Vs \\<longrightarrow> vo = None\n 2. \\<And>Vs o' e.\n       \\<lbrakk>unmod (compE1 Vs o') i;\n        unmod (compE1 (Vs @ [fresh_var Vs]) e) i; hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> length Vs\n 3. \\<And>Vs e1 V e2.\n       \\<lbrakk>unmod (compE1 Vs e1) i; unmod (compE1 (Vs @ [V]) e2) i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> length Vs \\<noteq> i", "apply(auto simp add:hidden_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unmod_extRet2J [simp]: \"unmod e i \\<Longrightarrow> unmod (extRet2J e va) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod e i \\<Longrightarrow> unmod (extRet2J e va) i", "by(cases va) simp_all"], ["", "lemma max_dest: \"(n :: nat) + max a b \\<le> c \\<Longrightarrow> n + a \\<le> c \\<and> n + b \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + max a b \\<le> c \\<Longrightarrow> n + a \\<le> c \\<and> n + b \\<le> c", "apply(auto simp add: max_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare max_dest [dest!]"], ["", "lemma fixes e :: \"'addr expr\" and es :: \"'addr expr list\"\n  shows fv_unmod_compE1: \"\\<lbrakk> i < length Vs; Vs ! i \\<notin> fv e \\<rbrakk> \\<Longrightarrow> unmod (compE1 Vs e) i\"\n  and fvs_unmods_compEs1: \"\\<lbrakk> i < length Vs; Vs ! i \\<notin> fvs es \\<rbrakk> \\<Longrightarrow> unmods (compEs1 Vs es) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n     \\<Longrightarrow> unmod (compE1 Vs e) i) &&&\n    (\\<lbrakk>i < length Vs; Vs ! i \\<notin> fvs es\\<rbrakk>\n     \\<Longrightarrow> unmods (compEs1 Vs es) i)", "proof(induct Vs e and Vs es rule: compE1_compEs1_induct)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "case (Block Vs V ty vo exp)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv exp\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 (Vs @ [V]) exp) i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:ty=vo; exp}\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "note IH = \\<open>\\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv exp \\<rbrakk> \\<Longrightarrow> unmod (compE1 (Vs @ [V]) exp) i\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv exp\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 (Vs @ [V]) exp) i\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "note len = \\<open>i < length Vs\\<close>"], ["proof (state)\nthis:\n  i < length Vs\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "hence i: \"i < length (Vs @ [V])\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. i < length (Vs @ [V])", "by simp"], ["proof (state)\nthis:\n  i < length (Vs @ [V])\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 25 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod (compE1 Vs {V:ty=vo; exp}) i", "proof(cases \"Vs ! i = V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "case True"], ["proof (state)\nthis:\n  Vs ! i = V\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by(rule hidden_snoc_nth)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "with len True"], ["proof (chain)\npicking this:\n  i < length Vs\n  Vs ! i = V\n  hidden (Vs @ [Vs ! i]) i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length Vs\n  Vs ! i = V\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. unmod (compE1 Vs {V:ty=vo; exp}) i", "by(auto intro: hidden_unmod)"], ["proof (state)\nthis:\n  unmod (compE1 Vs {V:ty=vo; exp}) i\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "case False"], ["proof (state)\nthis:\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "with \\<open>Vs ! i \\<notin> fv {V:ty=vo; exp}\\<close> len"], ["proof (chain)\npicking this:\n  Vs ! i \\<notin> fv {V:ty=vo; exp}\n  i < length Vs\n  Vs ! i \\<noteq> V", "have \"(Vs @ [V]) ! i \\<notin> fv exp\""], ["proof (prove)\nusing this:\n  Vs ! i \\<notin> fv {V:ty=vo; exp}\n  i < length Vs\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. (Vs @ [V]) ! i \\<notin> fv exp", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  (Vs @ [V]) ! i \\<notin> fv exp\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 Vs {V:ty=vo; exp}) i", "from IH[OF i this] len"], ["proof (chain)\npicking this:\n  unmod (compE1 (Vs @ [V]) exp) i\n  i < length Vs", "show ?thesis"], ["proof (prove)\nusing this:\n  unmod (compE1 (Vs @ [V]) exp) i\n  i < length Vs\n\ngoal (1 subgoal):\n 1. unmod (compE1 Vs {V:ty=vo; exp}) i", "by(auto)"], ["proof (state)\nthis:\n  unmod (compE1 Vs {V:ty=vo; exp}) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unmod (compE1 Vs {V:ty=vo; exp}) i\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "case (TryCatch Vs e1 C V e2)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e1\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 Vs e1) i\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e2\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\n  i < length Vs\n  Vs ! i \\<notin> fv (try e1 catch(C V) e2)\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "note IH1 = \\<open>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e1 \\<rbrakk> \\<Longrightarrow> unmod (compE1 Vs e1) i\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e1\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 Vs e1) i\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "note IH2 = \\<open>\\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e2 \\<rbrakk> \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e2\\<rbrakk>\n  \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "note len = \\<open>i < length Vs\\<close>"], ["proof (state)\nthis:\n  i < length Vs\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "hence i: \"i < length (Vs @ [V])\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. i < length (Vs @ [V])", "by simp"], ["proof (state)\nthis:\n  i < length (Vs @ [V])\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "have \"unmod (compE1 (Vs @ [V]) e2) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod (compE1 (Vs @ [V]) e2) i", "proof(cases \"Vs ! i = V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "case True"], ["proof (state)\nthis:\n  Vs ! i = V\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by(rule hidden_snoc_nth)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "with len True"], ["proof (chain)\npicking this:\n  i < length Vs\n  Vs ! i = V\n  hidden (Vs @ [Vs ! i]) i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length Vs\n  Vs ! i = V\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. unmod (compE1 (Vs @ [V]) e2) i", "by(auto intro: hidden_unmod)"], ["proof (state)\nthis:\n  unmod (compE1 (Vs @ [V]) e2) i\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "case False"], ["proof (state)\nthis:\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "with \\<open>Vs ! i \\<notin> fv (try e1 catch(C V) e2)\\<close> len"], ["proof (chain)\npicking this:\n  Vs ! i \\<notin> fv (try e1 catch(C V) e2)\n  i < length Vs\n  Vs ! i \\<noteq> V", "have \"(Vs @ [V]) ! i \\<notin> fv e2\""], ["proof (prove)\nusing this:\n  Vs ! i \\<notin> fv (try e1 catch(C V) e2)\n  i < length Vs\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. (Vs @ [V]) ! i \\<notin> fv e2", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  (Vs @ [V]) ! i \\<notin> fv e2\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod (compE1 (Vs @ [V]) e2) i", "from IH2[OF i this] len"], ["proof (chain)\npicking this:\n  unmod (compE1 (Vs @ [V]) e2) i\n  i < length Vs", "show ?thesis"], ["proof (prove)\nusing this:\n  unmod (compE1 (Vs @ [V]) e2) i\n  i < length Vs\n\ngoal (1 subgoal):\n 1. unmod (compE1 (Vs @ [V]) e2) i", "by(auto)"], ["proof (state)\nthis:\n  unmod (compE1 (Vs @ [V]) e2) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unmod (compE1 (Vs @ [V]) e2) i\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 24 subgoals...", "with IH1[OF len] \\<open>Vs ! i \\<notin> fv (try e1 catch(C V) e2)\\<close> len"], ["proof (chain)\npicking this:\n  Vs ! i \\<notin> fv e1 \\<Longrightarrow> unmod (compE1 Vs e1) i\n  Vs ! i \\<notin> fv (try e1 catch(C V) e2)\n  i < length Vs\n  unmod (compE1 (Vs @ [V]) e2) i", "show ?case"], ["proof (prove)\nusing this:\n  Vs ! i \\<notin> fv e1 \\<Longrightarrow> unmod (compE1 Vs e1) i\n  Vs ! i \\<notin> fv (try e1 catch(C V) e2)\n  i < length Vs\n  unmod (compE1 (Vs @ [V]) e2) i\n\ngoal (1 subgoal):\n 1. unmod (compE1 Vs (try e1 catch(C V) e2)) i", "by(auto)"], ["proof (state)\nthis:\n  unmod (compE1 Vs (try e1 catch(C V) e2)) i\n\ngoal (23 subgoals):\n 1. \\<And>Vs C.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (new C)) i\n 2. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) i\n 3. \\<And>Vs T e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Cast T e)) i\n 4. \\<And>Vs e T.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (e instanceof T)) i\n 5. \\<And>Vs v.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Val v)) i\n 6. \\<And>Vs V.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (Var V)) i\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e'\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs e') i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          i\n 8. \\<And>Vs V e.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs e) i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (V:=e)) i\n 9. \\<And>Vs a ia.\n       \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                \\<Longrightarrow> unmod (compE1 Vs a) i;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs ia) i;\n        i < length Vs; Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil>)) i\n 10. \\<And>Vs a ia e.\n        \\<lbrakk>\\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n                 \\<Longrightarrow> unmod (compE1 Vs a) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv ia\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs ia) i;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n         \\<Longrightarrow> unmod (compE1 Vs e) i;\n         i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> unmod (compE1 Vs (a\\<lfloor>ia\\<rceil> := e)) i\nA total of 23 subgoals...", "qed(auto dest: index_le_lengthD simp add: nth_append)"], ["", "lemma hidden_lengthD: \"hidden Vs i \\<Longrightarrow> i < length Vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden Vs i \\<Longrightarrow> i < length Vs", "by(simp add: hidden_def)"], ["", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows fv_B_unmod: \"\\<lbrakk> V \\<notin> fv e; \\<B> e n; V < n \\<rbrakk> \\<Longrightarrow> unmod e V\"\n  and fvs_Bs_unmods: \"\\<lbrakk> V \\<notin> fvs es; \\<B>s es n; V < n \\<rbrakk> \\<Longrightarrow> unmods es V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>V \\<notin> fv e; \\<B> e n; V < n\\<rbrakk>\n     \\<Longrightarrow> unmod e V) &&&\n    (\\<lbrakk>V \\<notin> fvs es; \\<B>s es n; V < n\\<rbrakk>\n     \\<Longrightarrow> unmods es V)", "by(induct e and es arbitrary: n and n rule: unmod.induct unmods.induct) auto"], ["", "lemma assumes fin: \"final e'\"\n  shows unmod_inline_call: \"unmod (inline_call e' e) V \\<longleftrightarrow> unmod e V\"\n  and unmods_inline_calls: \"unmods (inline_calls e' es) V \\<longleftrightarrow> unmods es V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod (inline_call e' e) V = unmod e V &&&\n    unmods (inline_calls e' es) V = unmods es V", "apply(induct e and es rule: unmod.induct unmods.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x. unmod (inline_call e' (new x)) V = unmod (new x) V\n 2. \\<And>x1 x2.\n       unmod (inline_call e' x2) V = unmod x2 V \\<Longrightarrow>\n       unmod (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) V =\n       unmod (newA x1\\<lfloor>x2\\<rceil>) V\n 3. \\<And>x1 x2.\n       unmod (inline_call e' x2) V = unmod x2 V \\<Longrightarrow>\n       unmod (inline_call e' (Cast x1 x2)) V = unmod (Cast x1 x2) V\n 4. \\<And>x1 x2.\n       unmod (inline_call e' x1) V = unmod x1 V \\<Longrightarrow>\n       unmod (inline_call e' (x1 instanceof x2)) V =\n       unmod (x1 instanceof x2) V\n 5. \\<And>x. unmod (inline_call e' (Val x)) V = unmod (Val x) V\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n        unmod (inline_call e' x3) V = unmod x3 V\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          V =\n                         unmod (x1 \\<guillemotleft>x2\\<guillemotright> x3) V\n 7. \\<And>x. unmod (inline_call e' (Var x)) V = unmod (Var x) V\n 8. \\<And>x1 x2.\n       unmod (inline_call e' x2) V = unmod x2 V \\<Longrightarrow>\n       unmod (inline_call e' (x1:=x2)) V = unmod (x1:=x2) V\n 9. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n        unmod (inline_call e' x2) V = unmod x2 V\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (x1\\<lfloor>x2\\<rceil>)) V =\n                         unmod (x1\\<lfloor>x2\\<rceil>) V\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n         unmod (inline_call e' x2) V = unmod x2 V;\n         unmod (inline_call e' x3) V = unmod x3 V\\<rbrakk>\n        \\<Longrightarrow> unmod\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\n                           V =\n                          unmod (x1\\<lfloor>x2\\<rceil> := x3) V\nA total of 25 subgoals...", "apply(insert fin)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       final e' \\<Longrightarrow>\n       unmod (inline_call e' (new x)) V = unmod (new x) V\n 2. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x2) V = unmod x2 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          V =\n                         unmod (newA x1\\<lfloor>x2\\<rceil>) V\n 3. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x2) V = unmod x2 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (Cast x1 x2)) V =\n                         unmod (Cast x1 x2) V\n 4. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (x1 instanceof x2)) V =\n                         unmod (x1 instanceof x2) V\n 5. \\<And>x.\n       final e' \\<Longrightarrow>\n       unmod (inline_call e' (Val x)) V = unmod (Val x) V\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n        unmod (inline_call e' x3) V = unmod x3 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          V =\n                         unmod (x1 \\<guillemotleft>x2\\<guillemotright> x3) V\n 7. \\<And>x.\n       final e' \\<Longrightarrow>\n       unmod (inline_call e' (Var x)) V = unmod (Var x) V\n 8. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x2) V = unmod x2 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (x1:=x2)) V =\n                         unmod (x1:=x2) V\n 9. \\<And>x1 x2.\n       \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n        unmod (inline_call e' x2) V = unmod x2 V; final e'\\<rbrakk>\n       \\<Longrightarrow> unmod (inline_call e' (x1\\<lfloor>x2\\<rceil>)) V =\n                         unmod (x1\\<lfloor>x2\\<rceil>) V\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>unmod (inline_call e' x1) V = unmod x1 V;\n         unmod (inline_call e' x2) V = unmod x2 V;\n         unmod (inline_call e' x3) V = unmod x3 V; final e'\\<rbrakk>\n        \\<Longrightarrow> unmod\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\n                           V =\n                          unmod (x1\\<lfloor>x2\\<rceil> := x3) V\nA total of 25 subgoals...", "apply(auto simp add: is_vals_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>The delay bisimulation relation\\<close>"], ["", "text \\<open>Delay bisimulation for expressions\\<close>"], ["", "inductive bisim :: \"vname list \\<Rightarrow> 'addr expr \\<Rightarrow> 'addr expr1 \\<Rightarrow> 'addr val list \\<Rightarrow> bool\"\n  and bisims :: \"vname list \\<Rightarrow> 'addr expr list \\<Rightarrow> 'addr expr1 list \\<Rightarrow> 'addr val list \\<Rightarrow> bool\"\nwhere\n  bisimNew: \"bisim Vs (new C) (new C) xs\"\n| bisimNewArray: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>) (newA T\\<lfloor>e'\\<rceil>) xs\"\n| bisimCast: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (Cast T e) (Cast T e') xs\"\n| bisimInstanceOf: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (e instanceof T) (e' instanceof T) xs\"\n| bisimVal: \"bisim Vs (Val v) (Val v) xs\"\n| bisimBinOp1:\n  \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insync e'' \\<rbrakk> \\<Longrightarrow> bisim Vs (e \\<guillemotleft>bop\\<guillemotright> e'') (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs e'') xs\"\n| bisimBinOp2: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (Val v \\<guillemotleft>bop\\<guillemotright> e) (Val v \\<guillemotleft>bop\\<guillemotright> e') xs\"\n| bisimVar: \"bisim Vs (Var V) (Var (index Vs V)) xs\"\n| bisimLAss: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (V:=e) (index Vs V:=e') xs\"\n| bisimAAcc1: \"\\<lbrakk> bisim Vs a a' xs; \\<not> is_val a; \\<not> contains_insync i \\<rbrakk> \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>) (a'\\<lfloor>compE1 Vs i\\<rceil>) xs\"\n| bisimAAcc2: \"bisim Vs i i' xs \\<Longrightarrow> bisim Vs (Val v\\<lfloor>i\\<rceil>) (Val v\\<lfloor>i'\\<rceil>) xs\"\n| bisimAAss1:\n  \"\\<lbrakk> bisim Vs a a' xs; \\<not> is_val a; \\<not> contains_insync i; \\<not> contains_insync e \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>:=e) (a'\\<lfloor>compE1 Vs i\\<rceil>:=compE1 Vs e) xs\"\n| bisimAAss2: \"\\<lbrakk> bisim Vs i i' xs; \\<not> is_val i; \\<not> contains_insync e \\<rbrakk> \\<Longrightarrow> bisim Vs (Val v\\<lfloor>i\\<rceil>:=e) (Val v\\<lfloor>i'\\<rceil>:=compE1 Vs e) xs\"\n| bisimAAss3: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (Val v\\<lfloor>Val i\\<rceil> := e) (Val v\\<lfloor>Val i\\<rceil> := e') xs\"\n| bisimALength: \"bisim Vs a a' xs \\<Longrightarrow> bisim Vs (a\\<bullet>length) (a'\\<bullet>length) xs\"\n| bisimFAcc: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (e\\<bullet>F{D}) (e'\\<bullet>F{D}) xs\"\n| bisimFAss1: \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insync e'' \\<rbrakk> \\<Longrightarrow> bisim Vs (e\\<bullet>F{D}:=e'') (e'\\<bullet>F{D}:=compE1 Vs e'') xs\"\n| bisimFAss2: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (Val v\\<bullet>F{D} := e) (Val v\\<bullet>F{D} := e') xs\"\n| bisimCAS1: \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3 \\<rbrakk> \n  \\<Longrightarrow> bisim Vs (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs e2, compE1 Vs e3)) xs\"\n| bisimCAS2: \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insync e3 \\<rbrakk> \n  \\<Longrightarrow> bisim Vs (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', compE1 Vs e3)) xs\"\n| bisimCAS3: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e)) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e')) xs\"\n| bisimCallObj: \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insyncs es \\<rbrakk> \\<Longrightarrow> bisim Vs (e\\<bullet>M(es)) (e'\\<bullet>M(compEs1 Vs es)) xs\"\n| bisimCallParams: \"bisims Vs es es' xs \\<Longrightarrow> bisim Vs (Val v\\<bullet>M(es)) (Val v\\<bullet>M(es')) xs\"\n| bisimBlockNone: \"bisim (Vs@[V]) e e' xs \\<Longrightarrow> bisim Vs {V:T=None; e} {(length Vs):T=None; e'} xs\"\n| bisimBlockSome: \"\\<lbrakk> bisim (Vs@[V]) e e' (xs[length Vs := v]) \\<rbrakk> \\<Longrightarrow> bisim Vs {V:T=\\<lfloor>v\\<rfloor>; e} {(length Vs):T=\\<lfloor>v\\<rfloor>; e'} xs\"\n| bisimBlockSomeNone: \"\\<lbrakk> bisim (Vs@[V]) e e' xs; xs ! (length Vs) = v \\<rbrakk> \\<Longrightarrow> bisim Vs {V:T=\\<lfloor>v\\<rfloor>; e} {(length Vs):T=None; e'} xs\"\n| bisimSynchronized:\n  \"\\<lbrakk> bisim Vs o' o'' xs; \\<not> contains_insync e \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (sync(o') e) (sync\\<^bsub>length Vs\\<^esub>(o'') (compE1 (Vs@[fresh_var Vs]) e)) xs\"\n| bisimInSynchronized:\n  \"\\<lbrakk> bisim (Vs@[fresh_var Vs]) e e' xs; xs ! length Vs = Addr a \\<rbrakk> \\<Longrightarrow> bisim Vs (insync(a) e) (insync\\<^bsub>length Vs\\<^esub>(a) e') xs\"\n| bisimSeq: \"\\<lbrakk> bisim Vs e e' xs; \\<not> contains_insync e'' \\<rbrakk> \\<Longrightarrow> bisim Vs (e;;e'') (e';;compE1 Vs e'') xs\"\n| bisimCond:\n  \"\\<lbrakk> bisim Vs e e' xs; \\<not> contains_insync e1; \\<not> contains_insync e2 \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (if (e) e1 else e2) (if (e') (compE1 Vs e1) else (compE1 Vs e2)) xs\"\n| bisimWhile:\n  \"\\<lbrakk> \\<not> contains_insync b; \\<not> contains_insync e \\<rbrakk> \\<Longrightarrow> bisim Vs (while (b) e) (while (compE1 Vs b) (compE1 Vs e)) xs\"\n| bisimThrow: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (throw e) (throw e') xs\"\n| bisimTryCatch:\n  \"\\<lbrakk> bisim Vs e e' xs; \\<not> contains_insync e'' \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (try e catch(C V) e'') (try e' catch(C (length Vs)) compE1 (Vs@[V]) e'') xs\"\n\n| bisimsNil: \"bisims Vs [] [] xs\"\n| bisimsCons1: \"\\<lbrakk> bisim Vs e e' xs; \\<not> is_val e; \\<not> contains_insyncs es \\<rbrakk> \\<Longrightarrow> bisims Vs (e # es) (e' # compEs1 Vs es) xs\"\n| bisimsCons2: \"bisims Vs es es' xs \\<Longrightarrow> bisims Vs (Val v # es) (Val v # es') xs\""], ["", "declare bisimNew [iff]"], ["", "declare bisimVal [iff]"], ["", "declare bisimVar [iff]"], ["", "declare bisimWhile [iff]"], ["", "declare bisimsNil [iff]"], ["", "declare bisim_bisims.intros [intro!]"], ["", "declare bisimsCons1 [rule del, intro] bisimsCons2 [rule del, intro]\n  bisimBinOp1 [rule del, intro] bisimAAcc1 [rule del, intro]\n  bisimAAss1 [rule del, intro] bisimAAss2 [rule del, intro]\n  bisimFAss1 [rule del, intro]\n  bisimCAS1 [rule del, intro] bisimCAS2 [rule del, intro]\n  bisimCallObj [rule del, intro]"], ["", "inductive_cases bisim_safe_cases [elim!]:\n  \"bisim Vs (new C) e' xs\"\n  \"bisim Vs (newA T\\<lfloor>e\\<rceil>) e' xs\"\n  \"bisim Vs (Cast T e) e' xs\"\n  \"bisim Vs (e instanceof T) e' xs\"\n  \"bisim Vs (Val v) e' xs\"\n  \"bisim Vs (Var V) e' xs\"\n  \"bisim Vs (V:=e) e' xs\"\n  \"bisim Vs (Val v\\<lfloor>i\\<rceil>) e' xs\"\n  \"bisim Vs (Val v\\<lfloor>Val v'\\<rceil> := e) e' xs\"\n  \"bisim Vs (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e)) e' xs\"\n  \"bisim Vs (a\\<bullet>length) e' xs\"\n  \"bisim Vs (e\\<bullet>F{D}) e' xs\"\n  \"bisim Vs (sync(o') e) e' xs\"\n  \"bisim Vs (insync(a) e) e' xs\"\n  \"bisim Vs (e;;e') e'' xs\"\n  \"bisim Vs (if (b) e1 else e2) e' xs\"\n  \"bisim Vs (while (b) e) e' xs\"\n  \"bisim Vs (throw e) e' xs\"\n  \"bisim Vs (try e catch(C V) e') e'' xs\"\n  \"bisim Vs e' (new C) xs\"\n  \"bisim Vs e' (newA T\\<lfloor>e\\<rceil>) xs\"\n  \"bisim Vs e' (Cast T e) xs\"\n  \"bisim Vs e' (e instanceof T) xs\"\n  \"bisim Vs e' (Val v) xs\"\n  \"bisim Vs e' (Var V) xs\"\n  \"bisim Vs e' (V:=e) xs\"\n  \"bisim Vs e' (Val v\\<lfloor>i\\<rceil>) xs\"\n  \"bisim Vs e' (Val v\\<lfloor>Val v'\\<rceil> := e) xs\"\n  \"bisim Vs e' (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e)) xs\"\n  \"bisim Vs e' (a\\<bullet>length) xs\"\n  \"bisim Vs e' (e\\<bullet>F{D}) xs\"\n  \"bisim Vs e' (sync\\<^bsub>V\\<^esub> (o') e) xs\"\n  \"bisim Vs e' (insync\\<^bsub>V\\<^esub> (a) e) xs\"\n  \"bisim Vs e'' (e;;e') xs\"\n  \"bisim Vs e' (if (b) e1 else e2) xs\"\n  \"bisim Vs e' (while (b) e) xs\"\n  \"bisim Vs e' (throw e) xs\"\n  \"bisim Vs e'' (try e catch(C V) e') xs\""], ["", "inductive_cases bisim_cases [elim]:\n  \"bisim Vs (e1 \\<guillemotleft>bop\\<guillemotright> e2) e' xs\"\n  \"bisim Vs (a\\<lfloor>i\\<rceil>) e' xs\"\n  \"bisim Vs (a\\<lfloor>i\\<rceil>:=e) e' xs\"\n  \"bisim Vs (e\\<bullet>F{D}:=e') e'' xs\"\n  \"bisim Vs (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) e''' xs\"\n  \"bisim Vs (e\\<bullet>M(es)) e' xs\"\n  \"bisim Vs {V:T=vo; e} e' xs\"\n  \"bisim Vs e' (e1 \\<guillemotleft>bop\\<guillemotright> e2) xs\"\n  \"bisim Vs e' (a\\<lfloor>i\\<rceil>) xs\"\n  \"bisim Vs e' (a\\<lfloor>i\\<rceil>:=e) xs\"\n  \"bisim Vs e'' (e\\<bullet>F{D}:=e') xs\"\n  \"bisim Vs e''' (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) xs\"\n  \"bisim Vs e' (e\\<bullet>M(es)) xs\"\n  \"bisim Vs e' {V:T=vo; e} xs\""], ["", "inductive_cases bisims_safe_cases [elim!]:\n  \"bisims Vs [] es xs\"\n  \"bisims Vs es [] xs\""], ["", "inductive_cases bisims_cases [elim]:\n  \"bisims Vs (e # es) es' xs\"\n  \"bisims Vs es' (e # es) xs\""], ["", "text \\<open>Delay bisimulation for call stacks\\<close>"], ["", "inductive bisim01 :: \"'addr expr \\<Rightarrow> 'addr expr1 \\<times> 'addr locals1 \\<Rightarrow> bool\"\nwhere\n  \"\\<lbrakk> bisim [] e e' xs; fv e = {}; \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e' \\<le> length xs; call e = \\<lfloor>aMvs\\<rfloor>; call1 e' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> bisim01 e (e', xs)\""], ["", "inductive bisim_list :: \"'addr expr list \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> bool\"\nwhere\n  bisim_listNil: \"bisim_list [] []\"\n| bisim_listCons: \n  \"\\<lbrakk> bisim_list es exs'; bisim [] e e' xs; \n     fv e = {}; \\<D> e \\<lfloor>{}\\<rfloor>;\n     max_vars e' \\<le> length xs;\n     call e = \\<lfloor>aMvs\\<rfloor>; call1 e' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> bisim_list (e # es) ((e', xs) # exs')\""], ["", "inductive_cases bisim_list_cases [elim!]:\n \"bisim_list [] exs'\"\n \"bisim_list (ex # exs) exs'\"\n \"bisim_list exs (ex' # exs')\""], ["", "fun bisim_list1 :: \n  \"'addr expr \\<times> 'addr expr list \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> bool\"\nwhere\n  \"bisim_list1 (e, es) ((e1, xs1), exs1) \\<longleftrightarrow> \n   bisim_list es exs1 \\<and> bisim [] e e1 xs1 \\<and> fv e = {} \\<and> \\<D> e \\<lfloor>{}\\<rfloor> \\<and> max_vars e1 \\<le> length xs1\""], ["", "definition bisim_red0_Red1 :: \n  \"(('addr expr \\<times> 'addr expr list) \\<times> 'heap)\n  \\<Rightarrow> ((('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list) \\<times> 'heap) \\<Rightarrow> bool\"\nwhere \"bisim_red0_Red1 \\<equiv> (\\<lambda>(es, h) (exs, h'). bisim_list1 es exs \\<and> h = h')\""], ["", "abbreviation ta_bisim01 ::\n  \"('addr, 'thread_id, 'heap) J0_thread_action \\<Rightarrow> ('addr, 'thread_id, 'heap) J1_thread_action \\<Rightarrow> bool\" \nwhere\n  \"ta_bisim01 \\<equiv> ta_bisim (\\<lambda>t. bisim_red0_Red1)\""], ["", "definition bisim_wait01 ::\n  \"('addr expr \\<times> 'addr expr list) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> bool\"\nwhere \"bisim_wait01 \\<equiv> \\<lambda>(e0, es0) ((e1, xs1), exs1). call e0 \\<noteq> None \\<and> call1 e1 \\<noteq> None\""], ["", "lemma bisim_list1I[intro?]:\n  \"\\<lbrakk> bisim_list es exs1; bisim [] e e1 xs1; fv e = {};\n     \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e1 \\<le> length xs1 \\<rbrakk>\n  \\<Longrightarrow> bisim_list1 (e, es) ((e1, xs1), exs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bisim_list es exs1; bisim [] e e1 xs1; fv e = {};\n     \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e1 \\<le> length xs1\\<rbrakk>\n    \\<Longrightarrow> bisim_list1 (e, es) ((e1, xs1), exs1)", "by simp"], ["", "lemma bisim_list1E[elim?]:\n  assumes \"bisim_list1 (e, es) ((e1, xs1), exs1)\"\n  obtains \"bisim_list es exs1\" \"bisim [] e e1 xs1\" \"fv e = {}\" \"\\<D> e \\<lfloor>{}\\<rfloor>\" \"max_vars e1 \\<le> length xs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim_list es exs1; bisim [] e e1 xs1; fv e = {};\n      \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e1 \\<le> length xs1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  bisim_list1 (e, es) ((e1, xs1), exs1)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim_list es exs1; bisim [] e e1 xs1; fv e = {};\n      \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e1 \\<le> length xs1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma bisim_list1_elim:\n  assumes \"bisim_list1 es' exs\"\n  obtains e es e1 xs1 exs1\n  where \"es' = (e, es)\" \"exs = ((e1, xs1), exs1)\"\n  and \"bisim_list es exs1\" \"bisim [] e e1 xs1\" \"fv e = {}\" \"\\<D> e \\<lfloor>{}\\<rfloor>\" \"max_vars e1 \\<le> length xs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e es e1 xs1 exs1.\n        \\<lbrakk>es' = (e, es); exs = ((e1, xs1), exs1); bisim_list es exs1;\n         bisim [] e e1 xs1; fv e = {}; \\<D> e \\<lfloor>{}\\<rfloor>;\n         max_vars e1 \\<le> length xs1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  bisim_list1 es' exs\n\ngoal (1 subgoal):\n 1. (\\<And>e es e1 xs1 exs1.\n        \\<lbrakk>es' = (e, es); exs = ((e1, xs1), exs1); bisim_list es exs1;\n         bisim [] e e1 xs1; fv e = {}; \\<D> e \\<lfloor>{}\\<rfloor>;\n         max_vars e1 \\<le> length xs1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases es')(cases exs, fastforce)"], ["", "declare bisim_list1.simps [simp del]"], ["", "lemma bisims_map_Val_conv [simp]: \"bisims Vs (map Val vs) es xs = (es = map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisims Vs (map Val vs) es xs = (es = map Val vs)", "apply(induct vs arbitrary: es)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es. bisims Vs (map Val []) es xs = (es = map Val [])\n 2. \\<And>a vs es.\n       (\\<And>es.\n           bisims Vs (map Val vs) es xs =\n           (es = map Val vs)) \\<Longrightarrow>\n       bisims Vs (map Val (a # vs)) es xs = (es = map Val (a # vs))", "apply(fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs es.\n       (\\<And>es.\n           bisims Vs (map Val vs) es xs =\n           (es = map Val vs)) \\<Longrightarrow>\n       bisims Vs (map Val (a # vs)) es xs = (es = map Val (a # vs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs es.\n       (\\<And>es.\n           bisims Vs (map Val vs) es xs =\n           (es = map Val vs)) \\<Longrightarrow>\n       bisims Vs (Val a # map Val vs) es xs = (es = Val a # map Val vs)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a vs es.\n       \\<lbrakk>\\<And>es. bisims Vs (map Val vs) es xs = (es = map Val vs);\n        bisims Vs (Val a # map Val vs) es xs\\<rbrakk>\n       \\<Longrightarrow> es = Val a # map Val vs\n 2. \\<And>a vs es.\n       \\<lbrakk>\\<And>es. bisims Vs (map Val vs) es xs = (es = map Val vs);\n        es = Val a # map Val vs\\<rbrakk>\n       \\<Longrightarrow> bisims Vs (Val a # map Val vs) es xs", "apply(erule bisims_cases, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare compEs1_conv_map [simp del]"], ["", "lemma bisim_contains_insync: \"bisim Vs e e' xs \\<Longrightarrow> contains_insync e = contains_insync e'\"\n  and bisims_contains_insyncs: \"bisims Vs es es' xs \\<Longrightarrow> contains_insyncs es = contains_insyncs es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim Vs e e' xs \\<Longrightarrow>\n     contains_insync e = contains_insync e') &&&\n    (bisims Vs es es' xs \\<Longrightarrow>\n     contains_insyncs es = contains_insyncs es')", "by(induct rule: bisim_bisims.inducts)(auto)"], ["", "lemma bisims_map_Val_Throw: \n  \"bisims Vs (map Val vs @ Throw a # es) es' xs \\<longleftrightarrow> es' = map Val vs @ Throw a # compEs1 Vs es \\<and> \\<not> contains_insyncs es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisims Vs (map Val vs @ Throw a # es) es' xs =\n    (es' = map Val vs @ Throw a # compEs1 Vs es \\<and>\n     \\<not> contains_insyncs es)", "apply(induct vs arbitrary: es')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       bisims Vs (map Val [] @ Throw a # es) es' xs =\n       (es' = map Val [] @ Throw a # compEs1 Vs es \\<and>\n        \\<not> contains_insyncs es)\n 2. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs (map Val vs @ Throw a # es) es' xs =\n           (es' = map Val vs @ Throw a # compEs1 Vs es \\<and>\n            \\<not> contains_insyncs es)) \\<Longrightarrow>\n       bisims Vs (map Val (aa # vs) @ Throw a # es) es' xs =\n       (es' = map Val (aa # vs) @ Throw a # compEs1 Vs es \\<and>\n        \\<not> contains_insyncs es)", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       bisims Vs (Throw a # es) es' xs =\n       (es' = Throw a # compEs1 Vs es \\<and> \\<not> contains_insyncs es)\n 2. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs (map Val vs @ Throw a # es) es' xs =\n           (es' = map Val vs @ Throw a # compEs1 Vs es \\<and>\n            \\<not> contains_insyncs es)) \\<Longrightarrow>\n       bisims Vs (map Val (aa # vs) @ Throw a # es) es' xs =\n       (es' = map Val (aa # vs) @ Throw a # compEs1 Vs es \\<and>\n        \\<not> contains_insyncs es)", "apply(fastforce simp add: compEs1_conv_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs (map Val vs @ Throw a # es) es' xs =\n           (es' = map Val vs @ Throw a # compEs1 Vs es \\<and>\n            \\<not> contains_insyncs es)) \\<Longrightarrow>\n       bisims Vs (map Val (aa # vs) @ Throw a # es) es' xs =\n       (es' = map Val (aa # vs) @ Throw a # compEs1 Vs es \\<and>\n        \\<not> contains_insyncs es)", "apply(fastforce elim!: bisims_cases intro: bisimsCons2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compE1_bisim [intro]: \"\\<lbrakk> fv e \\<subseteq> set Vs; \\<not> contains_insync e \\<rbrakk> \\<Longrightarrow> bisim Vs e (compE1 Vs e) xs\"\n  and compEs1_bisims [intro]: \"\\<lbrakk> fvs es \\<subseteq> set Vs; \\<not> contains_insyncs es \\<rbrakk> \\<Longrightarrow> bisims Vs es (compEs1 Vs es) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>fv e \\<subseteq> set Vs; \\<not> contains_insync e\\<rbrakk>\n     \\<Longrightarrow> bisim Vs e (compE1 Vs e) xs) &&&\n    (\\<lbrakk>fvs es \\<subseteq> set Vs; \\<not> contains_insyncs es\\<rbrakk>\n     \\<Longrightarrow> bisims Vs es (compEs1 Vs es) xs)", "proof(induct Vs e and Vs es arbitrary: xs and xs rule: compE1_compEs1_induct)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs e bop e' x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        \\<And>x.\n           \\<lbrakk>fv e' \\<subseteq> set Vs;\n            \\<not> contains_insync e'\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n        fv (e \\<guillemotleft>bop\\<guillemotright> e') \\<subseteq> set Vs;\n        \\<not> contains_insync\n                (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (e \\<guillemotleft>bop\\<guillemotright> e')\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          x\n 8. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 9. \\<And>Vs a i x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil>)) x\n 10. \\<And>Vs a i e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv a \\<subseteq> set Vs;\n                     \\<not> contains_insync a\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n         \\<And>x.\n            \\<lbrakk>fv i \\<subseteq> set Vs;\n             \\<not> contains_insync i\\<rbrakk>\n            \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set Vs;\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n         \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\nA total of 25 subgoals...", "case (BinOp Vs exp1 bop exp2 x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1 \\<guillemotleft>bop\\<guillemotright> exp2) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)\n\ngoal (25 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs e bop e' x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        \\<And>x.\n           \\<lbrakk>fv e' \\<subseteq> set Vs;\n            \\<not> contains_insync e'\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n        fv (e \\<guillemotleft>bop\\<guillemotright> e') \\<subseteq> set Vs;\n        \\<not> contains_insync\n                (e \\<guillemotleft>bop\\<guillemotright> e')\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (e \\<guillemotleft>bop\\<guillemotright> e')\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n                          x\n 8. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 9. \\<And>Vs a i x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil>)) x\n 10. \\<And>Vs a i e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv a \\<subseteq> set Vs;\n                     \\<not> contains_insync a\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n         \\<And>x.\n            \\<lbrakk>fv i \\<subseteq> set Vs;\n             \\<not> contains_insync i\\<rbrakk>\n            \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set Vs;\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n         \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1 \\<guillemotleft>bop\\<guillemotright> exp2) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)\n\ngoal (1 subgoal):\n 1. bisim Vs (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)\n     (compE1 Vs (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)) x", "by(cases \"is_val exp1\")(auto)"], ["proof (state)\nthis:\n  bisim Vs (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)\n   (compE1 Vs (exp1 \\<guillemotleft>bop\\<guillemotright> exp2)) x\n\ngoal (24 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil>)) x\n 9. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 10. \\<And>Vs a x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv a \\<subseteq> set Vs;\n                     \\<not> contains_insync a\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n         fv (a\\<bullet>length) \\<subseteq> set Vs;\n         \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                           (compE1 Vs (a\\<bullet>length)) x\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil>)) x\n 9. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 10. \\<And>Vs a x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv a \\<subseteq> set Vs;\n                     \\<not> contains_insync a\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n         fv (a\\<bullet>length) \\<subseteq> set Vs;\n         \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                           (compE1 Vs (a\\<bullet>length)) x\nA total of 24 subgoals...", "case (AAcc Vs exp1 exp2 x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1\\<lfloor>exp2\\<rceil>) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<lfloor>exp2\\<rceil>)\n\ngoal (24 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil>)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil>)) x\n 9. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 10. \\<And>Vs a x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv a \\<subseteq> set Vs;\n                     \\<not> contains_insync a\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n         fv (a\\<bullet>length) \\<subseteq> set Vs;\n         \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                           (compE1 Vs (a\\<bullet>length)) x\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1\\<lfloor>exp2\\<rceil>) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<lfloor>exp2\\<rceil>)\n\ngoal (1 subgoal):\n 1. bisim Vs (exp1\\<lfloor>exp2\\<rceil>)\n     (compE1 Vs (exp1\\<lfloor>exp2\\<rceil>)) x", "by(cases \"is_val exp1\")(auto)"], ["proof (state)\nthis:\n  bisim Vs (exp1\\<lfloor>exp2\\<rceil>)\n   (compE1 Vs (exp1\\<lfloor>exp2\\<rceil>)) x\n\ngoal (23 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 9. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 10. \\<And>Vs e F D x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                           (compE1 Vs (e\\<bullet>F{D})) x\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 9. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 10. \\<And>Vs e F D x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                           (compE1 Vs (e\\<bullet>F{D})) x\nA total of 23 subgoals...", "case (AAss Vs exp1 exp2 exp3 x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  \\<lbrakk>fv exp3 \\<subseteq> set Vs; \\<not> contains_insync exp3\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp3 (compE1 Vs exp3) ?x\n  fv (exp1\\<lfloor>exp2\\<rceil> := exp3) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<lfloor>exp2\\<rceil> := exp3)\n\ngoal (23 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a i e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        \\<And>x.\n           \\<lbrakk>fv i \\<subseteq> set Vs;\n            \\<not> contains_insync i\\<rbrakk>\n           \\<Longrightarrow> bisim Vs i (compE1 Vs i) x;\n        \\<And>x.\n           \\<lbrakk>fv e \\<subseteq> set Vs;\n            \\<not> contains_insync e\\<rbrakk>\n           \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<lfloor>i\\<rceil> := e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<lfloor>i\\<rceil> := e)\n                          (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) x\n 9. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 10. \\<And>Vs e F D x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                           (compE1 Vs (e\\<bullet>F{D})) x\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  \\<lbrakk>fv exp3 \\<subseteq> set Vs; \\<not> contains_insync exp3\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp3 (compE1 Vs exp3) ?x\n  fv (exp1\\<lfloor>exp2\\<rceil> := exp3) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<lfloor>exp2\\<rceil> := exp3)\n\ngoal (1 subgoal):\n 1. bisim Vs (exp1\\<lfloor>exp2\\<rceil> := exp3)\n     (compE1 Vs (exp1\\<lfloor>exp2\\<rceil> := exp3)) x", "by(cases \"is_val exp1\", cases \"is_val exp2\", fastforce+)"], ["proof (state)\nthis:\n  bisim Vs (exp1\\<lfloor>exp2\\<rceil> := exp3)\n   (compE1 Vs (exp1\\<lfloor>exp2\\<rceil> := exp3)) x\n\ngoal (22 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e F D e' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         fv (e\\<bullet>F{D} := e') \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D} := e')\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D} := e')\n                           (compE1 Vs (e\\<bullet>F{D} := e')) x\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e F D e' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         fv (e\\<bullet>F{D} := e') \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D} := e')\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D} := e')\n                           (compE1 Vs (e\\<bullet>F{D} := e')) x\nA total of 22 subgoals...", "case (FAss Vs exp1 F D exp2 x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1\\<bullet>F{D} := exp2) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<bullet>F{D} := exp2)\n\ngoal (22 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e F D e' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         fv (e\\<bullet>F{D} := e') \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>F{D} := e')\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>F{D} := e')\n                           (compE1 Vs (e\\<bullet>F{D} := e')) x\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp1 \\<subseteq> set Vs; \\<not> contains_insync exp1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp1 (compE1 Vs exp1) ?x\n  \\<lbrakk>fv exp2 \\<subseteq> set Vs; \\<not> contains_insync exp2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp2 (compE1 Vs exp2) ?x\n  fv (exp1\\<bullet>F{D} := exp2) \\<subseteq> set Vs\n  \\<not> contains_insync (exp1\\<bullet>F{D} := exp2)\n\ngoal (1 subgoal):\n 1. bisim Vs (exp1\\<bullet>F{D} := exp2)\n     (compE1 Vs (exp1\\<bullet>F{D} := exp2)) x", "by(cases \"is_val exp1\", auto)"], ["proof (state)\nthis:\n  bisim Vs (exp1\\<bullet>F{D} := exp2)\n   (compE1 Vs (exp1\\<bullet>F{D} := exp2)) x\n\ngoal (21 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e D F e' e'' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         \\<And>x.\n            \\<lbrakk>fv e'' \\<subseteq> set Vs;\n             \\<not> contains_insync e''\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e'' (compE1 Vs e'') x;\n         fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n         \\<subseteq> set Vs;\n         \\<not> contains_insync\n                 (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n                           (compE1 Vs\n                             (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))\n                           x\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e D F e' e'' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         \\<And>x.\n            \\<lbrakk>fv e'' \\<subseteq> set Vs;\n             \\<not> contains_insync e''\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e'' (compE1 Vs e'') x;\n         fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n         \\<subseteq> set Vs;\n         \\<not> contains_insync\n                 (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n                           (compE1 Vs\n                             (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))\n                           x\nA total of 21 subgoals...", "case (CAS Vs e1 D F e2 e3 x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv e1 \\<subseteq> set Vs; \\<not> contains_insync e1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e1 (compE1 Vs e1) ?x\n  \\<lbrakk>fv e2 \\<subseteq> set Vs; \\<not> contains_insync e2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e2 (compE1 Vs e2) ?x\n  \\<lbrakk>fv e3 \\<subseteq> set Vs; \\<not> contains_insync e3\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e3 (compE1 Vs e3) ?x\n  fv (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs\n  \\<not> contains_insync (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n\ngoal (21 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e D F e' e'' x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fv e' \\<subseteq> set Vs;\n             \\<not> contains_insync e'\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e' (compE1 Vs e') x;\n         \\<And>x.\n            \\<lbrakk>fv e'' \\<subseteq> set Vs;\n             \\<not> contains_insync e''\\<rbrakk>\n            \\<Longrightarrow> bisim Vs e'' (compE1 Vs e'') x;\n         fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n         \\<subseteq> set Vs;\n         \\<not> contains_insync\n                 (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n                           (compE1 Vs\n                             (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))\n                           x\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv e1 \\<subseteq> set Vs; \\<not> contains_insync e1\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e1 (compE1 Vs e1) ?x\n  \\<lbrakk>fv e2 \\<subseteq> set Vs; \\<not> contains_insync e2\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e2 (compE1 Vs e2) ?x\n  \\<lbrakk>fv e3 \\<subseteq> set Vs; \\<not> contains_insync e3\\<rbrakk>\n  \\<Longrightarrow> bisim Vs e3 (compE1 Vs e3) ?x\n  fv (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs\n  \\<not> contains_insync (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n\ngoal (1 subgoal):\n 1. bisim Vs (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n     (compE1 Vs (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))) x", "by(cases \"is_val e1\", cases \"is_val e2\", fastforce+)"], ["proof (state)\nthis:\n  bisim Vs (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n   (compE1 Vs (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))) x\n\ngoal (20 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e M es x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fvs es \\<subseteq> set Vs;\n             \\<not> contains_insyncs es\\<rbrakk>\n            \\<Longrightarrow> bisims Vs es (compEs1 Vs es) x;\n         fv (e\\<bullet>M(es)) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>M(es))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>M(es))\n                           (compE1 Vs (e\\<bullet>M(es))) x\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e M es x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fvs es \\<subseteq> set Vs;\n             \\<not> contains_insyncs es\\<rbrakk>\n            \\<Longrightarrow> bisims Vs es (compEs1 Vs es) x;\n         fv (e\\<bullet>M(es)) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>M(es))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>M(es))\n                           (compE1 Vs (e\\<bullet>M(es))) x\nA total of 20 subgoals...", "case (Call Vs obj M params x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv obj \\<subseteq> set Vs; \\<not> contains_insync obj\\<rbrakk>\n  \\<Longrightarrow> bisim Vs obj (compE1 Vs obj) ?x\n  \\<lbrakk>fvs params \\<subseteq> set Vs;\n   \\<not> contains_insyncs params\\<rbrakk>\n  \\<Longrightarrow> bisims Vs params (compEs1 Vs params) ?x\n  fv (obj\\<bullet>M(params)) \\<subseteq> set Vs\n  \\<not> contains_insync (obj\\<bullet>M(params))\n\ngoal (20 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs e M es x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set Vs;\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n         \\<And>x.\n            \\<lbrakk>fvs es \\<subseteq> set Vs;\n             \\<not> contains_insyncs es\\<rbrakk>\n            \\<Longrightarrow> bisims Vs es (compEs1 Vs es) x;\n         fv (e\\<bullet>M(es)) \\<subseteq> set Vs;\n         \\<not> contains_insync (e\\<bullet>M(es))\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (e\\<bullet>M(es))\n                           (compE1 Vs (e\\<bullet>M(es))) x\nA total of 20 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv obj \\<subseteq> set Vs; \\<not> contains_insync obj\\<rbrakk>\n  \\<Longrightarrow> bisim Vs obj (compE1 Vs obj) ?x\n  \\<lbrakk>fvs params \\<subseteq> set Vs;\n   \\<not> contains_insyncs params\\<rbrakk>\n  \\<Longrightarrow> bisims Vs params (compEs1 Vs params) ?x\n  fv (obj\\<bullet>M(params)) \\<subseteq> set Vs\n  \\<not> contains_insync (obj\\<bullet>M(params))\n\ngoal (1 subgoal):\n 1. bisim Vs (obj\\<bullet>M(params)) (compE1 Vs (obj\\<bullet>M(params))) x", "by(cases \"is_val obj\")(auto)"], ["proof (state)\nthis:\n  bisim Vs (obj\\<bullet>M(params)) (compE1 Vs (obj\\<bullet>M(params))) x\n\ngoal (19 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs V T vo e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set (Vs @ [V]);\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim (Vs @ [V]) e\n (compE1 (Vs @ [V]) e) x;\n         fv {V:T=vo; e} \\<subseteq> set Vs;\n         \\<not> contains_insync {V:T=vo; e}\\<rbrakk>\n        \\<Longrightarrow> bisim Vs {V:T=vo; e} (compE1 Vs {V:T=vo; e}) x\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs V T vo e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set (Vs @ [V]);\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim (Vs @ [V]) e\n (compE1 (Vs @ [V]) e) x;\n         fv {V:T=vo; e} \\<subseteq> set Vs;\n         \\<not> contains_insync {V:T=vo; e}\\<rbrakk>\n        \\<Longrightarrow> bisim Vs {V:T=vo; e} (compE1 Vs {V:T=vo; e}) x\nA total of 19 subgoals...", "case (Block Vs V T vo exp xs)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp \\<subseteq> set (Vs @ [V]);\n   \\<not> contains_insync exp\\<rbrakk>\n  \\<Longrightarrow> bisim (Vs @ [V]) exp (compE1 (Vs @ [V]) exp) ?x\n  fv {V:T=vo; exp} \\<subseteq> set Vs\n  \\<not> contains_insync {V:T=vo; exp}\n\ngoal (19 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs V T vo e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set (Vs @ [V]);\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim (Vs @ [V]) e\n (compE1 (Vs @ [V]) e) x;\n         fv {V:T=vo; e} \\<subseteq> set Vs;\n         \\<not> contains_insync {V:T=vo; e}\\<rbrakk>\n        \\<Longrightarrow> bisim Vs {V:T=vo; e} (compE1 Vs {V:T=vo; e}) x\nA total of 19 subgoals...", "from \\<open>fv {V:T=vo; exp} \\<subseteq> set Vs\\<close>"], ["proof (chain)\npicking this:\n  fv {V:T=vo; exp} \\<subseteq> set Vs", "have \"fv exp \\<subseteq> set (Vs@[V])\""], ["proof (prove)\nusing this:\n  fv {V:T=vo; exp} \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. fv exp \\<subseteq> set (Vs @ [V])", "by(auto)"], ["proof (state)\nthis:\n  fv exp \\<subseteq> set (Vs @ [V])\n\ngoal (19 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs V T vo e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv e \\<subseteq> set (Vs @ [V]);\n                     \\<not> contains_insync e\\<rbrakk>\n                    \\<Longrightarrow> bisim (Vs @ [V]) e\n (compE1 (Vs @ [V]) e) x;\n         fv {V:T=vo; e} \\<subseteq> set Vs;\n         \\<not> contains_insync {V:T=vo; e}\\<rbrakk>\n        \\<Longrightarrow> bisim Vs {V:T=vo; e} (compE1 Vs {V:T=vo; e}) x\nA total of 19 subgoals...", "with Block"], ["proof (chain)\npicking this:\n  \\<lbrakk>fv exp \\<subseteq> set (Vs @ [V]);\n   \\<not> contains_insync exp\\<rbrakk>\n  \\<Longrightarrow> bisim (Vs @ [V]) exp (compE1 (Vs @ [V]) exp) ?x\n  fv {V:T=vo; exp} \\<subseteq> set Vs\n  \\<not> contains_insync {V:T=vo; exp}\n  fv exp \\<subseteq> set (Vs @ [V])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp \\<subseteq> set (Vs @ [V]);\n   \\<not> contains_insync exp\\<rbrakk>\n  \\<Longrightarrow> bisim (Vs @ [V]) exp (compE1 (Vs @ [V]) exp) ?x\n  fv {V:T=vo; exp} \\<subseteq> set Vs\n  \\<not> contains_insync {V:T=vo; exp}\n  fv exp \\<subseteq> set (Vs @ [V])\n\ngoal (1 subgoal):\n 1. bisim Vs {V:T=vo; exp} (compE1 Vs {V:T=vo; exp}) xs", "by(cases vo)(auto)"], ["proof (state)\nthis:\n  bisim Vs {V:T=vo; exp} (compE1 Vs {V:T=vo; exp}) xs\n\ngoal (18 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs U o' e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv o' \\<subseteq> set Vs;\n                     \\<not> contains_insync o'\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs o' (compE1 Vs o') x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set (Vs @ [fresh_var Vs]);\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim (Vs @ [fresh_var Vs]) e\n                               (compE1 (Vs @ [fresh_var Vs]) e) x;\n         fv (sync\\<^bsub>U\\<^esub> (o') e) \\<subseteq> set Vs;\n         \\<not> contains_insync (sync\\<^bsub>U\\<^esub> (o') e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (sync\\<^bsub>U\\<^esub> (o') e)\n                           (compE1 Vs (sync\\<^bsub>U\\<^esub> (o') e)) x\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs U o' e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv o' \\<subseteq> set Vs;\n                     \\<not> contains_insync o'\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs o' (compE1 Vs o') x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set (Vs @ [fresh_var Vs]);\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim (Vs @ [fresh_var Vs]) e\n                               (compE1 (Vs @ [fresh_var Vs]) e) x;\n         fv (sync\\<^bsub>U\\<^esub> (o') e) \\<subseteq> set Vs;\n         \\<not> contains_insync (sync\\<^bsub>U\\<^esub> (o') e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (sync\\<^bsub>U\\<^esub> (o') e)\n                           (compE1 Vs (sync\\<^bsub>U\\<^esub> (o') e)) x\nA total of 18 subgoals...", "case (Cons Vs exp list x)"], ["proof (state)\nthis:\n  \\<lbrakk>fv exp \\<subseteq> set Vs; \\<not> contains_insync exp\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp (compE1 Vs exp) ?x\n  \\<lbrakk>fvs list \\<subseteq> set Vs;\n   \\<not> contains_insyncs list\\<rbrakk>\n  \\<Longrightarrow> bisims Vs list (compEs1 Vs list) ?x\n  fvs (exp # list) \\<subseteq> set Vs\n  \\<not> contains_insyncs (exp # list)\n\ngoal (18 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs U o' e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv o' \\<subseteq> set Vs;\n                     \\<not> contains_insync o'\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs o' (compE1 Vs o') x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set (Vs @ [fresh_var Vs]);\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim (Vs @ [fresh_var Vs]) e\n                               (compE1 (Vs @ [fresh_var Vs]) e) x;\n         fv (sync\\<^bsub>U\\<^esub> (o') e) \\<subseteq> set Vs;\n         \\<not> contains_insync (sync\\<^bsub>U\\<^esub> (o') e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (sync\\<^bsub>U\\<^esub> (o') e)\n                           (compE1 Vs (sync\\<^bsub>U\\<^esub> (o') e)) x\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fv exp \\<subseteq> set Vs; \\<not> contains_insync exp\\<rbrakk>\n  \\<Longrightarrow> bisim Vs exp (compE1 Vs exp) ?x\n  \\<lbrakk>fvs list \\<subseteq> set Vs;\n   \\<not> contains_insyncs list\\<rbrakk>\n  \\<Longrightarrow> bisims Vs list (compEs1 Vs list) ?x\n  fvs (exp # list) \\<subseteq> set Vs\n  \\<not> contains_insyncs (exp # list)\n\ngoal (1 subgoal):\n 1. bisims Vs (exp # list) (compEs1 Vs (exp # list)) x", "by(cases \"is_val exp\")(auto intro!: bisimsCons2)"], ["proof (state)\nthis:\n  bisims Vs (exp # list) (compEs1 Vs (exp # list)) x\n\ngoal (17 subgoals):\n 1. \\<And>Vs C x.\n       \\<lbrakk>fv (new C) \\<subseteq> set Vs;\n        \\<not> contains_insync (new C)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (new C) (compE1 Vs (new C)) x\n 2. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs;\n        \\<not> contains_insync (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (newA T\\<lfloor>e\\<rceil>)\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) x\n 3. \\<And>Vs T e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (Cast T e) \\<subseteq> set Vs;\n        \\<not> contains_insync (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Cast T e) (compE1 Vs (Cast T e)) x\n 4. \\<And>Vs e T x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e instanceof T) \\<subseteq> set Vs;\n        \\<not> contains_insync (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e instanceof T)\n                          (compE1 Vs (e instanceof T)) x\n 5. \\<And>Vs v x.\n       \\<lbrakk>fv (Val v) \\<subseteq> set Vs;\n        \\<not> contains_insync (Val v)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Val v) (compE1 Vs (Val v)) x\n 6. \\<And>Vs V x.\n       \\<lbrakk>fv (Var V) \\<subseteq> set Vs;\n        \\<not> contains_insync (Var V)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (Var V) (compE1 Vs (Var V)) x\n 7. \\<And>Vs V e x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (V:=e) \\<subseteq> set Vs; \\<not> contains_insync (V:=e)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (V:=e) (compE1 Vs (V:=e)) x\n 8. \\<And>Vs a x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv a \\<subseteq> set Vs;\n                    \\<not> contains_insync a\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs a (compE1 Vs a) x;\n        fv (a\\<bullet>length) \\<subseteq> set Vs;\n        \\<not> contains_insync (a\\<bullet>length)\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (a\\<bullet>length)\n                          (compE1 Vs (a\\<bullet>length)) x\n 9. \\<And>Vs e F D x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>fv e \\<subseteq> set Vs;\n                    \\<not> contains_insync e\\<rbrakk>\n                   \\<Longrightarrow> bisim Vs e (compE1 Vs e) x;\n        fv (e\\<bullet>F{D}) \\<subseteq> set Vs;\n        \\<not> contains_insync (e\\<bullet>F{D})\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (e\\<bullet>F{D})\n                          (compE1 Vs (e\\<bullet>F{D})) x\n 10. \\<And>Vs U o' e x.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>fv o' \\<subseteq> set Vs;\n                     \\<not> contains_insync o'\\<rbrakk>\n                    \\<Longrightarrow> bisim Vs o' (compE1 Vs o') x;\n         \\<And>x.\n            \\<lbrakk>fv e \\<subseteq> set (Vs @ [fresh_var Vs]);\n             \\<not> contains_insync e\\<rbrakk>\n            \\<Longrightarrow> bisim (Vs @ [fresh_var Vs]) e\n                               (compE1 (Vs @ [fresh_var Vs]) e) x;\n         fv (sync\\<^bsub>U\\<^esub> (o') e) \\<subseteq> set Vs;\n         \\<not> contains_insync (sync\\<^bsub>U\\<^esub> (o') e)\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (sync\\<^bsub>U\\<^esub> (o') e)\n                           (compE1 Vs (sync\\<^bsub>U\\<^esub> (o') e)) x\nA total of 17 subgoals...", "qed(auto)"], ["", "lemma bisim_hidden_unmod: \"\\<lbrakk> bisim Vs e e' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and bisims_hidden_unmods: \"\\<lbrakk> bisims Vs es es' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmods es' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; hidden Vs i\\<rbrakk>\n     \\<Longrightarrow> unmod e' i) &&&\n    (\\<lbrakk>bisims Vs es es' xs; hidden Vs i\\<rbrakk>\n     \\<Longrightarrow> unmods es' i)", "by(induct rule: bisim_bisims.inducts)(auto intro: hidden_unmod hidden_unmods dest: hidden_inacc hidden_lengthD)"], ["", "lemma bisim_fv_unmod: \"\\<lbrakk> bisim Vs e e' xs; i < length Vs; Vs ! i \\<notin> fv e \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and bisims_fvs_unmods: \"\\<lbrakk> bisims Vs es es' xs; i < length Vs; Vs ! i \\<notin> fvs es \\<rbrakk> \\<Longrightarrow> unmods es' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n     \\<Longrightarrow> unmod e' i) &&&\n    (\\<lbrakk>bisims Vs es es' xs; i < length Vs;\n      Vs ! i \\<notin> fvs es\\<rbrakk>\n     \\<Longrightarrow> unmods es' i)", "proof(induct rule: bisim_bisims.inducts)"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 36 subgoals...", "case (bisimBlockNone Vs V e e' xs T)"], ["proof (state)\nthis:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=None; e}\n\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 36 subgoals...", "note len = \\<open>i < length Vs\\<close>"], ["proof (state)\nthis:\n  i < length Vs\n\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 36 subgoals...", "have \"unmod e' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod e' i", "proof(cases \"Vs ! i = V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod e' i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "case True"], ["proof (state)\nthis:\n  Vs ! i = V\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod e' i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by(rule hidden_snoc_nth)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod e' i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "with len True \\<open>bisim (Vs @ [V]) e e' xs\\<close>"], ["proof (chain)\npicking this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' xs\n  hidden (Vs @ [Vs ! i]) i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' xs\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. unmod e' i", "by(auto intro: bisim_hidden_unmod)"], ["proof (state)\nthis:\n  unmod e' i\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "case False"], ["proof (state)\nthis:\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod e' i", "with bisimBlockNone"], ["proof (chain)\npicking this:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=None; e}\n  Vs ! i \\<noteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=None; e}\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. unmod e' i", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  unmod e' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unmod e' i\n\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 36 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  unmod e' i\n\ngoal (1 subgoal):\n 1. unmod {length Vs:T=None; e'} i", "by simp"], ["proof (state)\nthis:\n  unmod {length Vs:T=None; e'} i\n\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 35 subgoals...", "case (bisimBlockSome Vs V e e' xs v T)"], ["proof (state)\nthis:\n  bisim (Vs @ [V]) e e' (xs[length Vs := v])\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 35 subgoals...", "note len = \\<open>i < length Vs\\<close>"], ["proof (state)\nthis:\n  i < length Vs\n\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 35 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "proof(cases \"Vs ! i = V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "case True"], ["proof (state)\nthis:\n  Vs ! i = V\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by(rule hidden_snoc_nth)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "with len True \\<open>bisim (Vs @ [V]) e e' (xs[length Vs := v])\\<close>"], ["proof (chain)\npicking this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' (xs[length Vs := v])\n  hidden (Vs @ [Vs ! i]) i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' (xs[length Vs := v])\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "by(auto intro: bisim_hidden_unmod)"], ["proof (state)\nthis:\n  unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "case False"], ["proof (state)\nthis:\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow>\n    unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "with bisimBlockSome"], ["proof (chain)\npicking this:\n  bisim (Vs @ [V]) e e' (xs[length Vs := v])\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n  Vs ! i \\<noteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  bisim (Vs @ [V]) e e' (xs[length Vs := v])\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unmod {length Vs:T=\\<lfloor>v\\<rfloor>; e'} i\n\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 34 subgoals...", "case (bisimBlockSomeNone Vs V e e' xs v T)"], ["proof (state)\nthis:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  xs ! length Vs = v\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 34 subgoals...", "note len = \\<open>i < length Vs\\<close>"], ["proof (state)\nthis:\n  i < length Vs\n\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 34 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unmod {length Vs:T=None; e'} i", "proof(cases \"Vs ! i = V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod {length Vs:T=None; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "case True"], ["proof (state)\nthis:\n  Vs ! i = V\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod {length Vs:T=None; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by(rule hidden_snoc_nth)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (2 subgoals):\n 1. Vs ! i = V \\<Longrightarrow> unmod {length Vs:T=None; e'} i\n 2. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "with len True \\<open>bisim (Vs @ [V]) e e' xs\\<close>"], ["proof (chain)\npicking this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' xs\n  hidden (Vs @ [Vs ! i]) i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length Vs\n  Vs ! i = V\n  bisim (Vs @ [V]) e e' xs\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. unmod {length Vs:T=None; e'} i", "by(auto intro: bisim_hidden_unmod)"], ["proof (state)\nthis:\n  unmod {length Vs:T=None; e'} i\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "case False"], ["proof (state)\nthis:\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. Vs ! i \\<noteq> V \\<Longrightarrow> unmod {length Vs:T=None; e'} i", "with bisimBlockSomeNone"], ["proof (chain)\npicking this:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  xs ! length Vs = v\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n  Vs ! i \\<noteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  bisim (Vs @ [V]) e e' xs\n  \\<lbrakk>i < length (Vs @ [V]); (Vs @ [V]) ! i \\<notin> fv e\\<rbrakk>\n  \\<Longrightarrow> unmod e' i\n  xs ! length Vs = v\n  i < length Vs\n  Vs ! i \\<notin> fv {V:T=\\<lfloor>v\\<rfloor>; e}\n  Vs ! i \\<noteq> V\n\ngoal (1 subgoal):\n 1. unmod {length Vs:T=None; e'} i", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  unmod {length Vs:T=None; e'} i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unmod {length Vs:T=None; e'} i\n\ngoal (33 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (new C)\\<rbrakk>\n       \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i \\<notin> fv (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (Cast T e)\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (e instanceof T)\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Val v)\\<rbrakk>\n       \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; i < length Vs;\n        Vs ! i\n        \\<notin> fv (e \\<guillemotleft>bop\\<guillemotright> e'')\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs;\n        Vs ! i\n        \\<notin> fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs.\n       \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv (Var V)\\<rbrakk>\n       \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> unmod e' i;\n        i < length Vs; Vs ! i \\<notin> fv (V:=e)\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>i < length Vs; Vs ! i \\<notin> fv a\\<rbrakk>\n         \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; i < length Vs;\n         Vs ! i \\<notin> fv (a\\<lfloor>ia\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 33 subgoals...", "qed(fastforce dest: fv_unmod_compE1 fvs_unmods_compEs1 index_le_lengthD simp add: nth_append)+"], ["", "lemma bisim_extRet2J [intro!]: \"bisim Vs e e' xs \\<Longrightarrow> bisim Vs (extRet2J e va) (extRet2J1 e' va) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim Vs e e' xs \\<Longrightarrow>\n    bisim Vs (extRet2J e va) (extRet2J e' va) xs", "by(cases va) auto"], ["", "lemma bisims_map_Val_conv2 [simp]: \"bisims Vs es (map Val vs) xs = (es = map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisims Vs es (map Val vs) xs = (es = map Val vs)", "apply(induct vs arbitrary: es)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es. bisims Vs es (map Val []) xs = (es = map Val [])\n 2. \\<And>a vs es.\n       (\\<And>es.\n           bisims Vs es (map Val vs) xs =\n           (es = map Val vs)) \\<Longrightarrow>\n       bisims Vs es (map Val (a # vs)) xs = (es = map Val (a # vs))", "apply(fastforce elim!: bisims_cases)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisims_map_Val_Throw2: \n  \"bisims Vs es' (map Val vs @ Throw a # es) xs \\<longleftrightarrow>\n   (\\<exists>es''. es' = map Val vs @ Throw a # es'' \\<and> es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisims Vs es' (map Val vs @ Throw a # es) xs =\n    (\\<exists>es''.\n        es' = map Val vs @ Throw a # es'' \\<and>\n        es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')", "apply(induct vs arbitrary: es')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       bisims Vs es' (map Val [] @ Throw a # es) xs =\n       (\\<exists>es''.\n           es' = map Val [] @ Throw a # es'' \\<and>\n           es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')\n 2. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs es' (map Val vs @ Throw a # es) xs =\n           (\\<exists>es''.\n               es' = map Val vs @ Throw a # es'' \\<and>\n               es = compEs1 Vs es'' \\<and>\n               \\<not> contains_insyncs es'')) \\<Longrightarrow>\n       bisims Vs es' (map Val (aa # vs) @ Throw a # es) xs =\n       (\\<exists>es''.\n           es' = map Val (aa # vs) @ Throw a # es'' \\<and>\n           es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       bisims Vs es' (Throw a # es) xs =\n       (\\<exists>es''.\n           es' = Throw a # es'' \\<and>\n           es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')\n 2. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs es' (map Val vs @ Throw a # es) xs =\n           (\\<exists>es''.\n               es' = map Val vs @ Throw a # es'' \\<and>\n               es = compEs1 Vs es'' \\<and>\n               \\<not> contains_insyncs es'')) \\<Longrightarrow>\n       bisims Vs es' (map Val (aa # vs) @ Throw a # es) xs =\n       (\\<exists>es''.\n           es' = map Val (aa # vs) @ Throw a # es'' \\<and>\n           es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')", "apply(fastforce simp add: compEs1_conv_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa vs es'.\n       (\\<And>es'.\n           bisims Vs es' (map Val vs @ Throw a # es) xs =\n           (\\<exists>es''.\n               es' = map Val vs @ Throw a # es'' \\<and>\n               es = compEs1 Vs es'' \\<and>\n               \\<not> contains_insyncs es'')) \\<Longrightarrow>\n       bisims Vs es' (map Val (aa # vs) @ Throw a # es) xs =\n       (\\<exists>es''.\n           es' = map Val (aa # vs) @ Throw a # es'' \\<and>\n           es = compEs1 Vs es'' \\<and> \\<not> contains_insyncs es'')", "apply(fastforce elim!: bisims_cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hidden_bisim_unmod: \"\\<lbrakk> bisim Vs e e' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and hidden_bisims_unmods: \"\\<lbrakk> bisims Vs es es' xs; hidden Vs i \\<rbrakk> \\<Longrightarrow> unmods es' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; hidden Vs i\\<rbrakk>\n     \\<Longrightarrow> unmod e' i) &&&\n    (\\<lbrakk>bisims Vs es es' xs; hidden Vs i\\<rbrakk>\n     \\<Longrightarrow> unmods es' i)", "apply(induct rule: bisim_bisims.inducts)"], ["proof (prove)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs. hidden Vs i \\<Longrightarrow> unmod (new C) i\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (newA T\\<lfloor>e'\\<rceil>) i\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (Cast T e') i\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (e' instanceof T) i\n 5. \\<And>Vs v xs. hidden Vs i \\<Longrightarrow> unmod (Val v) i\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        \\<not> is_val e; \\<not> contains_insync e''; hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          i\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e') i\n 8. \\<And>Vs V xs. hidden Vs i \\<Longrightarrow> unmod (Var (index Vs V)) i\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs; hidden Vs i \\<Longrightarrow> unmod e' i;\n        hidden Vs i\\<rbrakk>\n       \\<Longrightarrow> unmod (index Vs V:=e') i\n 10. \\<And>Vs a a' xs ia.\n        \\<lbrakk>bisim Vs a a' xs; hidden Vs i \\<Longrightarrow> unmod a' i;\n         \\<not> is_val a; \\<not> contains_insync ia; hidden Vs i\\<rbrakk>\n        \\<Longrightarrow> unmod (a'\\<lfloor>compE1 Vs ia\\<rceil>) i\nA total of 36 subgoals...", "apply(auto simp add:hidden_inacc intro: hidden_unmod hidden_unmods)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Vs V e e' xs v.\n       \\<lbrakk>bisim (Vs @ [V]) e e' (xs[length Vs := v]);\n        unmod e' (length Vs); hidden Vs (length Vs); i = length Vs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Vs o' o'' xs e.\n       \\<lbrakk>bisim Vs o' o'' xs; unmod o'' (length Vs);\n        \\<not> contains_insync e; hidden Vs (length Vs);\n        i = length Vs\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Vs e e' xs e''.\n       \\<lbrakk>bisim Vs e e' xs; unmod e' (length Vs);\n        \\<not> contains_insync e''; hidden Vs (length Vs);\n        i = length Vs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: hidden_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_list_list_all2_conv:\n  \"bisim_list es exs' \\<longleftrightarrow> list_all2 bisim01 es exs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_list es exs' = list_all2 bisim01 es exs'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bisim_list es exs' \\<Longrightarrow> list_all2 bisim01 es exs'\n 2. list_all2 bisim01 es exs' \\<Longrightarrow> bisim_list es exs'", "assume \"bisim_list es exs'\""], ["proof (state)\nthis:\n  bisim_list es exs'\n\ngoal (2 subgoals):\n 1. bisim_list es exs' \\<Longrightarrow> list_all2 bisim01 es exs'\n 2. list_all2 bisim01 es exs' \\<Longrightarrow> bisim_list es exs'", "thus \"list_all2 bisim01 es exs'\""], ["proof (prove)\nusing this:\n  bisim_list es exs'\n\ngoal (1 subgoal):\n 1. list_all2 bisim01 es exs'", "by induct(auto intro!: bisim01.intros)"], ["proof (state)\nthis:\n  list_all2 bisim01 es exs'\n\ngoal (1 subgoal):\n 1. list_all2 bisim01 es exs' \\<Longrightarrow> bisim_list es exs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 bisim01 es exs' \\<Longrightarrow> bisim_list es exs'", "assume \"list_all2 bisim01 es exs'\""], ["proof (state)\nthis:\n  list_all2 bisim01 es exs'\n\ngoal (1 subgoal):\n 1. list_all2 bisim01 es exs' \\<Longrightarrow> bisim_list es exs'", "thus \"bisim_list es exs'\""], ["proof (prove)\nusing this:\n  list_all2 bisim01 es exs'\n\ngoal (1 subgoal):\n 1. bisim_list es exs'", "by(induct es arbitrary: exs')(auto intro!: bisim_listCons bisim_listNil elim!: bisim01.cases simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  bisim_list es exs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisim_list_extTA2J0_extTA2J1:\n  assumes wf: \"wf_J_prog P\"\n  and sees: \"P \\<turnstile> C sees M:[]\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D\"\n  shows \"bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "obtain pns body where \"meth = (pns, body)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pns body.\n        meth = (pns, body) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases meth)"], ["proof (state)\nthis:\n  meth = (pns, body)\n\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "with sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D\n  meth = (pns, body)", "have sees: \"P \\<turnstile> C sees M:[]\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D\n  meth = (pns, body)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>(pns,\n                    body)\\<rfloor> in D", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "let ?xs = \"Addr a # replicate (max_vars body) undefined_value\""], ["proof (state)\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "let ?e' = \"{0:Class D=None; compE1 (this # pns) body}\""], ["proof (state)\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "have \"bisim_list1 ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}, []) ((?e', ?xs), [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_list1 ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}, [])\n     (({0:Class D=None; compE1 (this # pns) body},\n       Addr a # replicate (max_vars body) undefined_value),\n      [])", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. bisim_list [] []\n 2. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 3. fv {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} = {}\n 4. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 5. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "show \"bisim_list [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_list [] []", ".."], ["proof (state)\nthis:\n  bisim_list [] []\n\ngoal (4 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. fv {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} = {}\n 3. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 4. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "from sees_wf_mdecl[OF wf_prog_wwf_prog[OF wf] sees]"], ["proof (chain)\npicking this:\n  wf_mdecl wwf_J_mdecl P D (M, [], T, \\<lfloor>(pns, body)\\<rfloor>)", "have \"fv body \\<subseteq> set [this]\" \"pns = []\""], ["proof (prove)\nusing this:\n  wf_mdecl wwf_J_mdecl P D (M, [], T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. fv body \\<subseteq> set [this] &&& pns = []", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  fv body \\<subseteq> set [this]\n  pns = []\n\ngoal (4 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. fv {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} = {}\n 3. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 4. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "thus \"fv ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}) = {}\""], ["proof (prove)\nusing this:\n  fv body \\<subseteq> set [this]\n  pns = []\n\ngoal (1 subgoal):\n 1. fv {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} = {}", "by simp"], ["proof (state)\nthis:\n  fv {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} = {}\n\ngoal (3 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 3. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "from sees_wf_mdecl[OF wf sees]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (M, [], T, \\<lfloor>(pns, body)\\<rfloor>)", "obtain T' where \"P,[this \\<mapsto> Class D] \\<turnstile> body :: T'\" \"this \\<notin> set pns\"\n      and \"\\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (M, [], T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>P,[this \\<mapsto> Class D] \\<turnstile> body :: T';\n         this \\<notin> set pns;\n         \\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T'\n  this \\<notin> set pns\n  \\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\n\ngoal (3 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 3. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "hence \"\\<not> contains_insync body\""], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T'\n  this \\<notin> set pns\n  \\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> contains_insync body", "by(auto simp add: contains_insync_conv dest: WT_expr_locks)"], ["proof (state)\nthis:\n  \\<not> contains_insync body\n\ngoal (3 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 3. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "with \\<open>fv body \\<subseteq> set [this]\\<close>"], ["proof (chain)\npicking this:\n  fv body \\<subseteq> set [this]\n  \\<not> contains_insync body", "have \"bisim ([] @ [this]) body (compE1 (this # pns) body) ?xs\""], ["proof (prove)\nusing this:\n  fv body \\<subseteq> set [this]\n  \\<not> contains_insync body\n\ngoal (1 subgoal):\n 1. bisim ([] @ [this]) body (compE1 (this # pns) body)\n     (Addr a # replicate (max_vars body) undefined_value)", "unfolding append.simps \\<open>pns = []\\<close>"], ["proof (prove)\nusing this:\n  fv body \\<subseteq> set [this]\n  \\<not> contains_insync body\n\ngoal (1 subgoal):\n 1. bisim [this] body (compE1 [this] body)\n     (Addr a # replicate (max_vars body) undefined_value)", "by(rule compE1_bisim)"], ["proof (state)\nthis:\n  bisim ([] @ [this]) body (compE1 (this # pns) body)\n   (Addr a # replicate (max_vars body) undefined_value)\n\ngoal (3 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 3. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "hence \"bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} {length ([] :: String.literal list):Class D=None; compE1 (this # pns) body} ?xs\""], ["proof (prove)\nusing this:\n  bisim ([] @ [this]) body (compE1 (this # pns) body)\n   (Addr a # replicate (max_vars body) undefined_value)\n\ngoal (1 subgoal):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {length []:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)", "by(rule bisimBlockSomeNone)(simp)"], ["proof (state)\nthis:\n  bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n   {length []:Class D=None; compE1 (this # pns) body}\n   (Addr a # replicate (max_vars body) undefined_value)\n\ngoal (3 subgoals):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)\n 2. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 3. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "thus \"bisim [] ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}) ?e' ?xs\""], ["proof (prove)\nusing this:\n  bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n   {length []:Class D=None; compE1 (this # pns) body}\n   (Addr a # replicate (max_vars body) undefined_value)\n\ngoal (1 subgoal):\n 1. bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n     {0:Class D=None; compE1 (this # pns) body}\n     (Addr a # replicate (max_vars body) undefined_value)", "by simp"], ["proof (state)\nthis:\n  bisim [] {this:Class D=\\<lfloor>Addr a\\<rfloor>; body}\n   {0:Class D=None; compE1 (this # pns) body}\n   (Addr a # replicate (max_vars body) undefined_value)\n\ngoal (2 subgoals):\n 1. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n 2. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "from \\<open>\\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  \\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>", "show \"\\<D> ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}) \\<lfloor>{}\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<D> body \\<lfloor>dom [this \\<mapsto> Addr a]\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<D> {this:Class D=\\<lfloor>Addr a\\<rfloor>; body} \\<lfloor>{}\\<rfloor>\n\ngoal (1 subgoal):\n 1. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "show \"max_vars ?e' \\<le> length ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_vars {0:Class D=None; compE1 (this # pns) body}\n    \\<le> length (Addr a # replicate (max_vars body) undefined_value)", "by simp"], ["proof (state)\nthis:\n  max_vars {0:Class D=None; compE1 (this # pns) body}\n  \\<le> length (Addr a # replicate (max_vars body) undefined_value)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bisim_list1 ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}, [])\n   (({0:Class D=None; compE1 (this # pns) body},\n     Addr a # replicate (max_vars body) undefined_value),\n    [])\n\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  bisim_list1 ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}, [])\n   (({0:Class D=None; compE1 (this # pns) body},\n     Addr a # replicate (max_vars body) undefined_value),\n    [])", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: []\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  bisim_list1 ({this:Class D=\\<lfloor>Addr a\\<rfloor>; body}, [])\n   (({0:Class D=None; compE1 (this # pns) body},\n     Addr a # replicate (max_vars body) undefined_value),\n    [])\n\ngoal (1 subgoal):\n 1. bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))", "by(simp)"], ["proof (state)\nthis:\n  bisim_list1 (extNTA2J0 P (C, M, a)) (extNTA2J1 (compP1 P) (C, M, a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisim_max_vars: \"bisim Vs e e' xs \\<Longrightarrow> max_vars e = max_vars e'\"\n  and bisims_max_varss: \"bisims Vs es es' xs \\<Longrightarrow> max_varss es = max_varss es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim Vs e e' xs \\<Longrightarrow> max_vars e = max_vars e') &&&\n    (bisims Vs es es' xs \\<Longrightarrow> max_varss es = max_varss es')", "apply(induct rule: bisim_bisims.inducts)"], ["proof (prove)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs. max_vars (new C) = max_vars (new C)\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'\\<rbrakk>\n       \\<Longrightarrow> max_vars (newA T\\<lfloor>e\\<rceil>) =\n                         max_vars (newA T\\<lfloor>e'\\<rceil>)\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'\\<rbrakk>\n       \\<Longrightarrow> max_vars (Cast T e) = max_vars (Cast T e')\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'\\<rbrakk>\n       \\<Longrightarrow> max_vars (e instanceof T) =\n                         max_vars (e' instanceof T)\n 5. \\<And>Vs v xs. max_vars (Val v) = max_vars (Val v)\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'; \\<not> is_val e;\n        \\<not> contains_insync e''\\<rbrakk>\n       \\<Longrightarrow> max_vars\n                          (e \\<guillemotleft>bop\\<guillemotright> e'') =\n                         max_vars\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'\\<rbrakk>\n       \\<Longrightarrow> max_vars\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n                         max_vars\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e')\n 8. \\<And>Vs V xs. max_vars (Var V) = max_vars (Var (index Vs V))\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs; max_vars e = max_vars e'\\<rbrakk>\n       \\<Longrightarrow> max_vars (V:=e) = max_vars (index Vs V:=e')\n 10. \\<And>Vs a a' xs i.\n        \\<lbrakk>bisim Vs a a' xs; max_vars a = max_vars a';\n         \\<not> is_val a; \\<not> contains_insync i\\<rbrakk>\n        \\<Longrightarrow> max_vars (a\\<lfloor>i\\<rceil>) =\n                          max_vars (a'\\<lfloor>compE1 Vs i\\<rceil>)\nA total of 36 subgoals...", "apply(auto simp add: max_vars_compE1 max_varss_compEs1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_call: \"bisim Vs e e' xs \\<Longrightarrow> call e = call e'\"\n  and bisims_calls: \"bisims Vs es es' xs \\<Longrightarrow> calls es = calls es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim Vs e e' xs \\<Longrightarrow> call e = call e') &&&\n    (bisims Vs es es' xs \\<Longrightarrow> calls es = calls es')", "apply(induct rule: bisim_bisims.inducts)"], ["proof (prove)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs. call (new C) = call (new C)\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'\\<rbrakk>\n       \\<Longrightarrow> call (newA T\\<lfloor>e\\<rceil>) =\n                         call (newA T\\<lfloor>e'\\<rceil>)\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'\\<rbrakk>\n       \\<Longrightarrow> call (Cast T e) = call (Cast T e')\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'\\<rbrakk>\n       \\<Longrightarrow> call (e instanceof T) = call (e' instanceof T)\n 5. \\<And>Vs v xs. call (Val v) = call (Val v)\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'; \\<not> is_val e;\n        \\<not> contains_insync e''\\<rbrakk>\n       \\<Longrightarrow> call (e \\<guillemotleft>bop\\<guillemotright> e'') =\n                         call\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'\\<rbrakk>\n       \\<Longrightarrow> call\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n                         call\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e')\n 8. \\<And>Vs V xs. call (Var V) = call (Var (index Vs V))\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs; call e = call e'\\<rbrakk>\n       \\<Longrightarrow> call (V:=e) = call (index Vs V:=e')\n 10. \\<And>Vs a a' xs i.\n        \\<lbrakk>bisim Vs a a' xs; call a = call a'; \\<not> is_val a;\n         \\<not> contains_insync i\\<rbrakk>\n        \\<Longrightarrow> call (a\\<lfloor>i\\<rceil>) =\n                          call (a'\\<lfloor>compE1 Vs i\\<rceil>)\nA total of 36 subgoals...", "apply(auto simp add: is_vals_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_call_None_call1: \"\\<lbrakk> bisim Vs e e' xs; call e = None \\<rbrakk> \\<Longrightarrow> call1 e' = None\"\n  and bisims_calls_None_calls1: \"\\<lbrakk> bisims Vs es es' xs; calls es = None \\<rbrakk> \\<Longrightarrow> calls1 es' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; call e = None\\<rbrakk>\n     \\<Longrightarrow> call1 e' = None) &&&\n    (\\<lbrakk>bisims Vs es es' xs; calls es = None\\<rbrakk>\n     \\<Longrightarrow> calls1 es' = None)", "by(induct rule: bisim_bisims.inducts)(auto simp add: is_vals_conv split: if_split_asm)"], ["", "lemma bisim_call1_Some_call:\n  \"\\<lbrakk> bisim Vs e e' xs; call1 e' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> call e = \\<lfloor>aMvs\\<rfloor>\"\n\n  and bisims_calls1_Some_calls:\n  \"\\<lbrakk> bisims Vs es es' xs; calls1 es' = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> calls es = \\<lfloor>aMvs\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; call1 e' = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> call e = \\<lfloor>aMvs\\<rfloor>) &&&\n    (\\<lbrakk>bisims Vs es es' xs;\n      calls1 es' = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> calls es = \\<lfloor>aMvs\\<rfloor>)", "by(induct rule: bisim_bisims.inducts)(auto simp add: is_vals_conv split: if_split_asm)"], ["", "lemma blocks_bisim: \n  assumes bisim: \"bisim (Vs @ pns) e e' xs\"\n  and length: \"length vs = length pns\" \"length Ts = length pns\"\n  and xs: \"\\<forall>i. i < length vs \\<longrightarrow> xs ! (i + length Vs) = vs ! i\"\n  shows \"bisim Vs (blocks pns Ts vs e) (blocks1 (length Vs) Ts e') xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim Vs (blocks pns Ts vs e) (blocks1 (length Vs) Ts e') xs", "using bisim length xs"], ["proof (prove)\nusing this:\n  bisim (Vs @ pns) e e' xs\n  length vs = length pns\n  length Ts = length pns\n  \\<forall>i<length vs. xs ! (i + length Vs) = vs ! i\n\ngoal (1 subgoal):\n 1. bisim Vs (blocks pns Ts vs e) (blocks1 (length Vs) Ts e') xs", "proof(induct pns Ts vs e arbitrary: e' Vs rule: blocks.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "case (1 V Vs T Ts v vs e e' VS)"], ["proof (state)\nthis:\n  \\<lbrakk>bisim (?Vs @ Vs) e ?e' xs; length vs = length Vs;\n   length Ts = length Vs;\n   \\<forall>i<length vs. xs ! (i + length ?Vs) = vs ! i\\<rbrakk>\n  \\<Longrightarrow> bisim ?Vs (blocks Vs Ts vs e)\n                     (blocks1 (length ?Vs) Ts ?e') xs\n  bisim (VS @ V # Vs) e e' xs\n  length (v # vs) = length (V # Vs)\n  length (T # Ts) = length (V # Vs)\n  \\<forall>i<length (v # vs). xs ! (i + length VS) = (v # vs) ! i\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "note IH = \\<open>\\<And>e' Vsa. \\<lbrakk>bisim (Vsa @ Vs) e e' xs;\n                       length vs = length Vs; length Ts = length Vs; \\<forall>i<length vs. xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n           \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e) (blocks1 (length Vsa) Ts e') xs\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>bisim (?Vsa @ Vs) e ?e' xs; length vs = length Vs;\n   length Ts = length Vs;\n   \\<forall>i<length vs. xs ! (i + length ?Vsa) = vs ! i\\<rbrakk>\n  \\<Longrightarrow> bisim ?Vsa (blocks Vs Ts vs e)\n                     (blocks1 (length ?Vsa) Ts ?e') xs\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "note xs = \\<open>\\<forall>i<length (v # vs). xs ! (i + length VS) = (v # vs) ! i\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<length (v # vs). xs ! (i + length VS) = (v # vs) ! i\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "hence xs': \"\\<forall>i<length vs. xs ! (i + length (VS @ [V])) = vs ! i\" and v: \"xs ! length VS = v\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (v # vs). xs ! (i + length VS) = (v # vs) ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length vs. xs ! (i + length (VS @ [V])) = vs ! i &&&\n    xs ! length VS = v", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>i<length vs. xs ! (i + length (VS @ [V])) = vs ! i\n  xs ! length VS = v\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "from \\<open>bisim (VS @ V # Vs) e e' xs\\<close>"], ["proof (chain)\npicking this:\n  bisim (VS @ V # Vs) e e' xs", "have \"bisim ((VS @ [V]) @ Vs) e e' xs\""], ["proof (prove)\nusing this:\n  bisim (VS @ V # Vs) e e' xs\n\ngoal (1 subgoal):\n 1. bisim ((VS @ [V]) @ Vs) e e' xs", "by simp"], ["proof (state)\nthis:\n  bisim ((VS @ [V]) @ Vs) e e' xs\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "from IH[OF this _ _ xs'] \\<open>length (v # vs) = length (V # Vs)\\<close> \\<open>length (T # Ts) = length (V # Vs)\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n  \\<Longrightarrow> bisim (VS @ [V]) (blocks Vs Ts vs e)\n                     (blocks1 (length (VS @ [V])) Ts e') xs\n  length (v # vs) = length (V # Vs)\n  length (T # Ts) = length (V # Vs)", "have \"bisim (VS @ [V]) (blocks Vs Ts vs e) (blocks1 (length (VS @ [V])) Ts e') xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n  \\<Longrightarrow> bisim (VS @ [V]) (blocks Vs Ts vs e)\n                     (blocks1 (length (VS @ [V])) Ts e') xs\n  length (v # vs) = length (V # Vs)\n  length (T # Ts) = length (V # Vs)\n\ngoal (1 subgoal):\n 1. bisim (VS @ [V]) (blocks Vs Ts vs e) (blocks1 (length (VS @ [V])) Ts e')\n     xs", "by auto"], ["proof (state)\nthis:\n  bisim (VS @ [V]) (blocks Vs Ts vs e) (blocks1 (length (VS @ [V])) Ts e')\n   xs\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "hence \"bisim VS ({V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}) {length VS:T=None; blocks1 (length (VS @ [V])) Ts e'} xs\""], ["proof (prove)\nusing this:\n  bisim (VS @ [V]) (blocks Vs Ts vs e) (blocks1 (length (VS @ [V])) Ts e')\n   xs\n\ngoal (1 subgoal):\n 1. bisim VS {V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}\n     {length VS:T=None; blocks1 (length (VS @ [V])) Ts e'} xs", "using v"], ["proof (prove)\nusing this:\n  bisim (VS @ [V]) (blocks Vs Ts vs e) (blocks1 (length (VS @ [V])) Ts e')\n   xs\n  xs ! length VS = v\n\ngoal (1 subgoal):\n 1. bisim VS {V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}\n     {length VS:T=None; blocks1 (length (VS @ [V])) Ts e'} xs", "by(rule bisimBlockSomeNone)"], ["proof (state)\nthis:\n  bisim VS {V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}\n   {length VS:T=None; blocks1 (length (VS @ [V])) Ts e'} xs\n\ngoal (8 subgoals):\n 1. \\<And>V Vs T Ts v vs e e' Vsa.\n       \\<lbrakk>\\<And>e' Vsa.\n                   \\<lbrakk>bisim (Vsa @ Vs) e e' xs; length vs = length Vs;\n                    length Ts = length Vs;\n                    \\<forall>i<length vs.\n                       xs ! (i + length Vsa) = vs ! i\\<rbrakk>\n                   \\<Longrightarrow> bisim Vsa (blocks Vs Ts vs e)\n(blocks1 (length Vsa) Ts e') xs;\n        bisim (Vsa @ V # Vs) e e' xs; length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs);\n        \\<forall>i<length (v # vs).\n           xs ! (i + length Vsa) = (v # vs) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vsa (blocks (V # Vs) (T # Ts) (v # vs) e)\n                          (blocks1 (length Vsa) (T # Ts) e') xs\n 2. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 3. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 4. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 5. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 7. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 8. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "thus ?case"], ["proof (prove)\nusing this:\n  bisim VS {V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}\n   {length VS:T=None; blocks1 (length (VS @ [V])) Ts e'} xs\n\ngoal (1 subgoal):\n 1. bisim VS (blocks (V # Vs) (T # Ts) (v # vs) e)\n     (blocks1 (length VS) (T # Ts) e') xs", "by simp"], ["proof (state)\nthis:\n  bisim VS (blocks (V # Vs) (T # Ts) (v # vs) e)\n   (blocks1 (length VS) (T # Ts) e') xs\n\ngoal (7 subgoals):\n 1. \\<And>e e' Vs.\n       \\<lbrakk>bisim (Vs @ []) e e' xs; length [] = length [];\n        length [] = length [];\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] [] [] e)\n                          (blocks1 (length Vs) [] e') xs\n 2. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length c = length [];\n        length (v # va) = length [];\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] (v # va) c d)\n                          (blocks1 (length Vs) (v # va) e') xs\n 3. \\<And>b v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ []) d e' xs; length (v # va) = length [];\n        length b = length [];\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks [] b (v # va) d)\n                          (blocks1 (length Vs) b e') xs\n 4. \\<And>v va c d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length c = length (v # va);\n        length [] = length (v # va);\n        \\<forall>i<length c. xs ! (i + length Vs) = c ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) [] c d)\n                          (blocks1 (length Vs) [] e') xs\n 5. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length (v # va) = length a;\n        length [] = length a;\n        \\<forall>i<length (v # va).\n           xs ! (i + length Vs) = (v # va) ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a [] (v # va) d)\n                          (blocks1 (length Vs) [] e') xs\n 6. \\<And>v va b d e' Vs.\n       \\<lbrakk>bisim (Vs @ v # va) d e' xs; length [] = length (v # va);\n        length b = length (v # va);\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks (v # va) b [] d)\n                          (blocks1 (length Vs) b e') xs\n 7. \\<And>a v va d e' Vs.\n       \\<lbrakk>bisim (Vs @ a) d e' xs; length [] = length a;\n        length (v # va) = length a;\n        \\<forall>i<length []. xs ! (i + length Vs) = [] ! i\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (blocks a (v # va) [] d)\n                          (blocks1 (length Vs) (v # va) e') xs", "qed(auto)"], ["", "lemma fixes e :: \"('a,'b,'addr) exp\" and es :: \"('a,'b,'addr) exp list\"\n  shows inline_call_max_vars: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> max_vars (inline_call e' e) \\<le> max_vars e + max_vars e'\"\n  and inline_calls_max_varss: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     max_vars (inline_call e' e) \\<le> max_vars e + max_vars e') &&&\n    (calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e')", "by(induct e and es rule: call.induct calls.induct)(auto)"], ["", "lemma assumes \"final E\" \"bisim VS E E' xs\"\n  shows inline_call_compE1: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e)\"\n  and inline_calls_compEs1: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e)) &&&\n    (calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es))", "proof(induct Vs e and Vs es rule: compE1_compEs1_induct)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "case (Call Vs obj M params)"], ["proof (state)\nthis:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "note IHobj = \\<open>call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\\<close>"], ["proof (state)\nthis:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "note IHparams = \\<open>calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\\<close>"], ["proof (state)\nthis:\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "obtain a M' vs where [simp]: \"aMvs = (a, M', vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a M' vs.\n        aMvs = (a, M', vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases aMvs, auto)"], ["proof (state)\nthis:\n  aMvs = (a, M', vs)\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "with \\<open>call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)", "have \"call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\""], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)\n\ngoal (1 subgoal):\n 1. call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "proof(induct rule: call_callE)"], ["proof (state)\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "case CallObj"], ["proof (state)\nthis:\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "with IHobj"], ["proof (chain)\npicking this:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>", "have \"inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\""], ["proof (prove)\nusing this:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)", "by auto"], ["proof (state)\nthis:\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "with CallObj"], ["proof (chain)\npicking this:\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)", "show ?case"], ["proof (prove)\nusing this:\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n  inline_call E' (compE1 Vs obj) = compE1 Vs (inline_call E obj)\n\ngoal (1 subgoal):\n 1. inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "by auto"], ["proof (state)\nthis:\n  inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n  compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "case (CallParams v)"], ["proof (state)\nthis:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "with IHparams"], ["proof (chain)\npicking this:\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>", "have \"inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\""], ["proof (prove)\nusing this:\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)", "by auto"], ["proof (state)\nthis:\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (obj\\<bullet>M(params))) =\n                         compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "with CallParams"], ["proof (chain)\npicking this:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)", "show ?case"], ["proof (prove)\nusing this:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n  inline_calls E' (compEs1 Vs params) = compEs1 Vs (inline_calls E params)\n\ngoal (1 subgoal):\n 1. inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "by(auto simp add: is_vals_conv)"], ["proof (state)\nthis:\n  inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n  compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "case Call"], ["proof (state)\nthis:\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n                      compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "with \\<open>final E\\<close> \\<open>bisim VS E E' xs\\<close>"], ["proof (chain)\npicking this:\n  final E\n  bisim VS E E' xs\n  obj = addr a\n  params = map Val vs\n  M = M'", "show ?case"], ["proof (prove)\nusing this:\n  final E\n  bisim VS E E' xs\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n    compE1 Vs (inline_call E (obj\\<bullet>M(params)))", "by(auto simp add: is_vals_conv)"], ["proof (state)\nthis:\n  inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n  compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inline_call E' (compE1 Vs (obj\\<bullet>M(params))) =\n  compE1 Vs (inline_call E (obj\\<bullet>M(params)))\n\ngoal (24 subgoals):\n 1. \\<And>Vs C.\n       call (new C) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (new C)) =\n       compE1 Vs (inline_call E (new C))\n 2. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs (newA T\\<lfloor>e\\<rceil>)) =\n                         compE1 Vs\n                          (inline_call E (newA T\\<lfloor>e\\<rceil>))\n 3. \\<And>Vs T e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (Cast T e)) =\n                         compE1 Vs (inline_call E (Cast T e))\n 4. \\<And>Vs e T.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (e instanceof T)) =\n                         compE1 Vs (inline_call E (e instanceof T))\n 5. \\<And>Vs v.\n       call (Val v) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Val v)) =\n       compE1 Vs (inline_call E (Val v))\n 6. \\<And>Vs V.\n       call (Var V) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       inline_call E' (compE1 Vs (Var V)) =\n       compE1 Vs (inline_call E (Var V))\n 7. \\<And>Vs e bop e'.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call e' = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs e') = compE1 Vs (inline_call E e');\n        call (e \\<guillemotleft>bop\\<guillemotright> e') =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E'\n                          (compE1 Vs\n                            (e \\<guillemotleft>bop\\<guillemotright> e')) =\n                         compE1 Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e'))\n 8. \\<And>Vs V e.\n       \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (V:=e)) =\n                         compE1 Vs (inline_call E (V:=e))\n 9. \\<And>Vs a i.\n       \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n        call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> inline_call E' (compE1 Vs (a\\<lfloor>i\\<rceil>)) =\n                         compE1 Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n 10. \\<And>Vs a i e.\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 inline_call E' (compE1 Vs a) = compE1 Vs (inline_call E a);\n         call i = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs i) = compE1 Vs (inline_call E i);\n         call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         inline_call E' (compE1 Vs e) = compE1 Vs (inline_call E e);\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> inline_call E'\n                           (compE1 Vs (a\\<lfloor>i\\<rceil> := e)) =\n                          compE1 Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\nA total of 24 subgoals...", "qed(auto split: if_split_asm)"], ["", "lemma assumes bisim: \"bisim VS E E' XS\"\n  and final: \"final E\"\n  shows bisim_inline_call:\n  \"\\<lbrakk> bisim Vs e e' xs; call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs \\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\"\n  \n  and bisims_inline_calls: \n  \"\\<lbrakk> bisims Vs es es' xs; calls es = \\<lfloor>aMvs\\<rfloor>; fvs es \\<subseteq> set Vs \\<rbrakk>\n  \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bisim Vs e e' xs; call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                        xs) &&&\n    (\\<lbrakk>bisims Vs es es' xs; calls es = \\<lfloor>aMvs\\<rfloor>;\n      fvs es \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es')\n                        xs)", "proof(induct rule: bisim_bisims.inducts)"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        \\<not> is_val e; \\<not> contains_insync e'';\n        call (e \\<guillemotleft>bop\\<guillemotright> e'') =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (e \\<guillemotleft>bop\\<guillemotright> e'')\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e''))\n                          (inline_call E'\n                            (e' \\<guillemotleft>bop\\<guillemotright> compE1\n                                Vs e''))\n                          xs\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 8. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 10. \\<And>Vs a a' xs i.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n          fv a \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a')\n                            xs;\n         \\<not> is_val a; \\<not> contains_insync i;\n         call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n         fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n                           (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>))\n                           xs\nA total of 36 subgoals...", "case (bisimBinOp1 Vs e e' xs bop e'')"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync bop\n  call (e \\<guillemotleft>e''\\<guillemotright> bop) = \\<lfloor>aMvs\\<rfloor>\n  fv (e \\<guillemotleft>e''\\<guillemotright> bop) \\<subseteq> set Vs\n\ngoal (36 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        \\<not> is_val e; \\<not> contains_insync e'';\n        call (e \\<guillemotleft>bop\\<guillemotright> e'') =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (e \\<guillemotleft>bop\\<guillemotright> e'')\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (e \\<guillemotleft>bop\\<guillemotright> e''))\n                          (inline_call E'\n                            (e' \\<guillemotleft>bop\\<guillemotright> compE1\n                                Vs e''))\n                          xs\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 8. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 10. \\<And>Vs a a' xs i.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n          fv a \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a')\n                            xs;\n         \\<not> is_val a; \\<not> contains_insync i;\n         call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n         fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n                           (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>))\n                           xs\nA total of 36 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync bop\n  call (e \\<guillemotleft>e''\\<guillemotright> bop) = \\<lfloor>aMvs\\<rfloor>\n  fv (e \\<guillemotleft>e''\\<guillemotright> bop) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e \\<guillemotleft>e''\\<guillemotright> bop))\n     (inline_call E'\n       (e' \\<guillemotleft>e''\\<guillemotright> compE1 Vs bop))\n     xs", "by(cases \"is_val (inline_call E e)\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e \\<guillemotleft>e''\\<guillemotright> bop))\n   (inline_call E' (e' \\<guillemotleft>e''\\<guillemotright> compE1 Vs bop))\n   xs\n\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs a a' xs i.\n       \\<lbrakk>bisim Vs a a' xs;\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n         fv a \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs;\n        \\<not> is_val a; \\<not> contains_insync i;\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n                          (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>))\n                          xs\n 10. \\<And>Vs i i' xs v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                           (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs a a' xs i.\n       \\<lbrakk>bisim Vs a a' xs;\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n         fv a \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs;\n        \\<not> is_val a; \\<not> contains_insync i;\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n                          (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>))\n                          xs\n 10. \\<And>Vs i i' xs v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                           (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\nA total of 35 subgoals...", "case (bisimAAcc1 Vs a a' xs i)"], ["proof (state)\nthis:\n  bisim Vs a a' xs\n  \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>; fv a \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs\n  \\<not> is_val a\n  \\<not> contains_insync i\n  call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\n  fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\n\ngoal (35 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs a a' xs i.\n       \\<lbrakk>bisim Vs a a' xs;\n        \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n         fv a \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs;\n        \\<not> is_val a; \\<not> contains_insync i;\n        call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n                          (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>))\n                          xs\n 10. \\<And>Vs i i' xs v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                           (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\nA total of 35 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs a a' xs\n  \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>; fv a \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs\n  \\<not> is_val a\n  \\<not> contains_insync i\n  call (a\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\n  fv (a\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n     (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>)) xs", "by(cases \"is_val (inline_call E a)\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (a\\<lfloor>i\\<rceil>))\n   (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil>)) xs\n\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs a a' xs i e.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n          fv a \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a')\n                            xs;\n         \\<not> is_val a; \\<not> contains_insync i;\n         \\<not> contains_insync e;\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (a'\\<lfloor>compE1 Vs\n    i\\<rceil> := compE1 Vs e))\n                           xs\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs a a' xs i e.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n          fv a \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a')\n                            xs;\n         \\<not> is_val a; \\<not> contains_insync i;\n         \\<not> contains_insync e;\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (a'\\<lfloor>compE1 Vs\n    i\\<rceil> := compE1 Vs e))\n                           xs\nA total of 34 subgoals...", "case (bisimAAss1 Vs a a' xs i e)"], ["proof (state)\nthis:\n  bisim Vs a a' xs\n  \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>; fv a \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs\n  \\<not> is_val a\n  \\<not> contains_insync i\n  \\<not> contains_insync e\n  call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\n  fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\n\ngoal (34 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs a a' xs i e.\n        \\<lbrakk>bisim Vs a a' xs;\n         \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>;\n          fv a \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a')\n                            xs;\n         \\<not> is_val a; \\<not> contains_insync i;\n         \\<not> contains_insync e;\n         call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (a\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (a'\\<lfloor>compE1 Vs\n    i\\<rceil> := compE1 Vs e))\n                           xs\nA total of 34 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs a a' xs\n  \\<lbrakk>call a = \\<lfloor>aMvs\\<rfloor>; fv a \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E a) (inline_call E' a') xs\n  \\<not> is_val a\n  \\<not> contains_insync i\n  \\<not> contains_insync e\n  call (a\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>\n  fv (a\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (a\\<lfloor>i\\<rceil> := e))\n     (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil> := compE1 Vs e)) xs", "by(cases \"is_val (inline_call E a)\", cases \"is_val i\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (a\\<lfloor>i\\<rceil> := e))\n   (inline_call E' (a'\\<lfloor>compE1 Vs i\\<rceil> := compE1 Vs e)) xs\n\ngoal (33 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs i i' xs e v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         \\<not> is_val i; \\<not> contains_insync e;\n         call (Val v\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (Val v\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>i'\\<rceil> := compE1 Vs e))\n                           xs\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs i i' xs e v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         \\<not> is_val i; \\<not> contains_insync e;\n         call (Val v\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (Val v\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>i'\\<rceil> := compE1 Vs e))\n                           xs\nA total of 33 subgoals...", "case (bisimAAss2 Vs i i' xs a e)"], ["proof (state)\nthis:\n  bisim Vs i i' xs\n  \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>; fv i \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs\n  \\<not> is_val i\n  \\<not> contains_insync a\n  call (Val e\\<lfloor>i\\<rceil> := a) = \\<lfloor>aMvs\\<rfloor>\n  fv (Val e\\<lfloor>i\\<rceil> := a) \\<subseteq> set Vs\n\ngoal (33 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs i i' xs e v.\n        \\<lbrakk>bisim Vs i i' xs;\n         \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n          fv i \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i')\n                            xs;\n         \\<not> is_val i; \\<not> contains_insync e;\n         call (Val v\\<lfloor>i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E (Val v\\<lfloor>i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>i'\\<rceil> := compE1 Vs e))\n                           xs\nA total of 33 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs i i' xs\n  \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>; fv i \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs\n  \\<not> is_val i\n  \\<not> contains_insync a\n  call (Val e\\<lfloor>i\\<rceil> := a) = \\<lfloor>aMvs\\<rfloor>\n  fv (Val e\\<lfloor>i\\<rceil> := a) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (Val e\\<lfloor>i\\<rceil> := a))\n     (inline_call E' (Val e\\<lfloor>i'\\<rceil> := compE1 Vs a)) xs", "by(cases \"is_val (inline_call E i)\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (Val e\\<lfloor>i\\<rceil> := a))\n   (inline_call E' (Val e\\<lfloor>i'\\<rceil> := compE1 Vs a)) xs\n\ngoal (32 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 32 subgoals...", "case (bisimFAss1 Vs e e' xs F D e'')"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync F\n  call (e\\<bullet>D{e''} := F) = \\<lfloor>aMvs\\<rfloor>\n  fv (e\\<bullet>D{e''} := F) \\<subseteq> set Vs\n\ngoal (32 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 32 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync F\n  call (e\\<bullet>D{e''} := F) = \\<lfloor>aMvs\\<rfloor>\n  fv (e\\<bullet>D{e''} := F) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>D{e''} := F))\n     (inline_call E' (e'\\<bullet>D{e''} := compE1 Vs F)) xs", "by(cases \"is_val (inline_call E e)\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>D{e''} := F))\n   (inline_call E' (e'\\<bullet>D{e''} := compE1 Vs F)) xs\n\ngoal (31 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 31 subgoals...", "case (bisimCAS1 Vs e e' xs e2 e3 D F)"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync e2\n  \\<not> contains_insync e3\n  call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n  \\<lfloor>aMvs\\<rfloor>\n  fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs\n\ngoal (31 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync e2\n  \\<not> contains_insync e3\n  call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n  \\<lfloor>aMvs\\<rfloor>\n  fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n     (inline_call E'\n       (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs e2, compE1 Vs e3)))\n     xs", "apply(cases \"is_val (inline_call E e)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs\n 2. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     \\<not> is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs", "apply(cases \"is_val e2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     is_val (inline_call E e); is_val e2\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs\n 2. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     is_val (inline_call E e); \\<not> is_val e2\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs\n 3. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     \\<not> is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     is_val (inline_call E e); \\<not> is_val e2\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs\n 2. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     \\<not> is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>bisim Vs e e' xs; \\<not> is_val e;\n        \\<not> contains_insync e2; \\<not> contains_insync e3;\n        call e = \\<lfloor>aMvs\\<rfloor>; \\<not> is_val e2;\n        inline_call E e = Val v; fv e \\<subseteq> set Vs;\n        fv e2 \\<subseteq> set Vs; fv e3 \\<subseteq> set Vs;\n        inline_call E' e' = Val v\\<rbrakk>\n       \\<Longrightarrow> (is_val (compE1 Vs e2) \\<longrightarrow>\n                          (is_val e' \\<longrightarrow>\n                           bisim Vs\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                            (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1\n                               Vs e2, inline_call E' (compE1 Vs e3)))\n                            xs) \\<and>\n                          (\\<not> is_val e' \\<longrightarrow>\n                           bisim Vs\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, compE1\n                                  Vs e2, compE1 Vs e3))\n                            xs)) \\<and>\n                         (\\<not> is_val (compE1 Vs e2) \\<longrightarrow>\n                          (is_val e' \\<longrightarrow>\n                           bisim Vs\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                            (e'\\<bullet>compareAndSwap(D\\<bullet>F, inline_call\n                               E' (compE1 Vs e2), compE1 Vs e3))\n                            xs) \\<and>\n                          (\\<not> is_val e' \\<longrightarrow>\n                           bisim Vs\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                            (Val v\\<bullet>compareAndSwap(D\\<bullet>F, compE1\n                                  Vs e2, compE1 Vs e3))\n                            xs))\n 2. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     \\<not> is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs", "apply(safe; clarsimp?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>bisim Vs e e' xs; \\<not> is_val e;\n        \\<not> contains_insync e2; \\<not> contains_insync e3;\n        call e = \\<lfloor>aMvs\\<rfloor>; \\<not> is_val e2;\n        inline_call E e = Val v; fv e \\<subseteq> set Vs;\n        fv e2 \\<subseteq> set Vs; fv e3 \\<subseteq> set Vs;\n        inline_call E' e' = Val v; \\<not> is_val (compE1 Vs e2);\n        \\<not> is_val e'\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                          (Val v\\<bullet>compareAndSwap(D\\<bullet>F, compE1\n                                Vs e2, compE1 Vs e3))\n                          xs\n 2. \\<lbrakk>bisim Vs e e' xs;\n     \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n      fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n     \\<not> is_val e; \\<not> contains_insync e2; \\<not> contains_insync e3;\n     call (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) =\n     \\<lfloor>aMvs\\<rfloor>;\n     fv (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) \\<subseteq> set Vs;\n     \\<not> is_val (inline_call E e)\\<rbrakk>\n    \\<Longrightarrow> bisim Vs\n                       (inline_call E\n                         (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n                       (inline_call E'\n                         (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs\n                            e2, compE1 Vs e3)))\n                       xs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)))\n   (inline_call E'\n     (e'\\<bullet>compareAndSwap(D\\<bullet>F, compE1 Vs e2, compE1 Vs e3)))\n   xs\n\ngoal (30 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 30 subgoals...", "case (bisimCAS2 Vs e e' xs e3 v D F)"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync e3\n  call (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)) =\n  \\<lfloor>aMvs\\<rfloor>\n  fv (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)) \\<subseteq> set Vs\n\ngoal (30 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 30 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insync e3\n  call (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)) =\n  \\<lfloor>aMvs\\<rfloor>\n  fv (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisim Vs\n     (inline_call E (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)))\n     (inline_call E'\n       (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', compE1 Vs e3)))\n     xs", "by(cases \"is_val (inline_call E e)\"; safe?; clarsimp; fastforce)"], ["proof (state)\nthis:\n  bisim Vs\n   (inline_call E (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3)))\n   (inline_call E'\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', compE1 Vs e3)))\n   xs\n\ngoal (29 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 29 subgoals...", "case (bisimCallObj Vs e e' xs es M)"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insyncs es\n  call (e\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n\ngoal (29 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 29 subgoals...", "obtain a M' vs where \"aMvs = (a, M', vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a M' vs.\n        aMvs = (a, M', vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases aMvs, auto)"], ["proof (state)\nthis:\n  aMvs = (a, M', vs)\n\ngoal (29 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 29 subgoals...", "with \\<open>call (e\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  call (e\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)", "have \"call (e\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\""], ["proof (prove)\nusing this:\n  call (e\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)\n\ngoal (1 subgoal):\n 1. call (e\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  call (e\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (29 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 29 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call (e\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "proof(induct rule: call_callE)"], ["proof (state)\ngoal (3 subgoals):\n 1. call e = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 3. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "case CallObj"], ["proof (state)\nthis:\n  call e = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (3 subgoals):\n 1. call e = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 3. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "with \\<open>fv (e\\<bullet>M(es)) \\<subseteq> set Vs\\<close> \\<open>aMvs = (a, M', vs)\\<close>\n      \\<open>\\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk> \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\\<close>"], ["proof (chain)\npicking this:\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  aMvs = (a, M', vs)\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  call e = \\<lfloor>(a, M', vs)\\<rfloor>", "have IH': \"bisim Vs (inline_call E e) (inline_call E' e') xs\""], ["proof (prove)\nusing this:\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  aMvs = (a, M', vs)\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  call e = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E e) (inline_call E' e') xs", "by(auto)"], ["proof (state)\nthis:\n  bisim Vs (inline_call E e) (inline_call E' e') xs\n\ngoal (3 subgoals):\n 1. call e = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 3. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "with \\<open>bisim Vs e e' xs\\<close> \\<open>fv (e\\<bullet>M(es)) \\<subseteq> set Vs\\<close> CallObj \\<open>\\<not> contains_insyncs es\\<close>"], ["proof (chain)\npicking this:\n  bisim Vs e e' xs\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  call e = \\<lfloor>(a, M', vs)\\<rfloor>\n  \\<not> contains_insyncs es\n  bisim Vs (inline_call E e) (inline_call E' e') xs", "show ?thesis"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  call e = \\<lfloor>(a, M', vs)\\<rfloor>\n  \\<not> contains_insyncs es\n  bisim Vs (inline_call E e) (inline_call E' e') xs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "by(cases \"is_val (inline_call E e)\")(fastforce)+"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>M(es)))\n   (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "case (CallParams v)"], ["proof (state)\nthis:\n  e = Val v\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "hence \"inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\""], ["proof (prove)\nusing this:\n  e = Val v\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)", "by -(rule inline_calls_compEs1[OF final bisim])"], ["proof (state)\nthis:\n  inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "moreover"], ["proof (state)\nthis:\n  inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "from \\<open>fv (e\\<bullet>M(es)) \\<subseteq> set Vs\\<close> final fvs_inline_calls[of E es]"], ["proof (chain)\npicking this:\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  final E\n  fvs (inline_calls E es) \\<subseteq> fvs es \\<union> fv E", "have \"fvs (inline_calls E es) \\<subseteq> set Vs\""], ["proof (prove)\nusing this:\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  final E\n  fvs (inline_calls E es) \\<subseteq> fvs es \\<union> fv E\n\ngoal (1 subgoal):\n 1. fvs (inline_calls E es) \\<subseteq> set Vs", "by(auto elim!: final.cases)"], ["proof (state)\nthis:\n  fvs (inline_calls E es) \\<subseteq> set Vs\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "moreover"], ["proof (state)\nthis:\n  fvs (inline_calls E es) \\<subseteq> set Vs\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "note CallParams \\<open>bisim Vs e e' xs\\<close> \\<open>fv (e\\<bullet>M(es)) \\<subseteq> set Vs\\<close> \\<open>\\<not> contains_insyncs es\\<close> final"], ["proof (state)\nthis:\n  e = Val v\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n  bisim Vs e e' xs\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  \\<not> contains_insyncs es\n  final E\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>e = Val v; calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                          (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n 2. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "ultimately"], ["proof (chain)\npicking this:\n  inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\n  fvs (inline_calls E es) \\<subseteq> set Vs\n  e = Val v\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n  bisim Vs e e' xs\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  \\<not> contains_insyncs es\n  final E", "show ?case"], ["proof (prove)\nusing this:\n  inline_calls E' (compEs1 Vs es) = compEs1 Vs (inline_calls E es)\n  fvs (inline_calls E es) \\<subseteq> set Vs\n  e = Val v\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n  bisim Vs e e' xs\n  fv (e\\<bullet>M(es)) \\<subseteq> set Vs\n  \\<not> contains_insyncs es\n  final E\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "by(auto simp add: is_vals_conv final_iff)"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>M(es)))\n   (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "case Call"], ["proof (state)\nthis:\n  e = addr a\n  es = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (e\\<bullet>M(es)))\n                       (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "with final bisim \\<open>bisim Vs e e' xs\\<close>"], ["proof (chain)\npicking this:\n  final E\n  bisim VS E E' XS\n  bisim Vs e e' xs\n  e = addr a\n  es = map Val vs\n  M = M'", "show ?case"], ["proof (prove)\nusing this:\n  final E\n  bisim VS E E' XS\n  bisim Vs e e' xs\n  e = addr a\n  es = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (e\\<bullet>M(es)))\n     (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs", "by(auto simp add: is_vals_conv)"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>M(es)))\n   (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (e\\<bullet>M(es)))\n   (inline_call E' (e'\\<bullet>M(compEs1 Vs es))) xs\n\ngoal (28 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 28 subgoals...", "case (bisimCallParams Vs es es' xs v M)"], ["proof (state)\nthis:\n  bisims Vs es es' xs\n  \\<lbrakk>calls es = \\<lfloor>aMvs\\<rfloor>;\n   fvs es \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\n  call (Val v\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  fv (Val v\\<bullet>M(es)) \\<subseteq> set Vs\n\ngoal (28 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 28 subgoals...", "obtain a M' vs where [simp]: \"aMvs = (a, M', vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a M' vs.\n        aMvs = (a, M', vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases aMvs, auto)"], ["proof (state)\nthis:\n  aMvs = (a, M', vs)\n\ngoal (28 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 28 subgoals...", "with \\<open>call (Val v\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  call (Val v\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)", "have \"call (Val v\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\""], ["proof (prove)\nusing this:\n  call (Val v\\<bullet>M(es)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)\n\ngoal (1 subgoal):\n 1. call (Val v\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  call (Val v\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (28 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 28 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call (Val v\\<bullet>M(es)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs", "proof(induct rule: call_callE)"], ["proof (state)\ngoal (3 subgoals):\n 1. call (Val v) = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 3. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "case CallObj"], ["proof (state)\nthis:\n  call (Val v) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (3 subgoals):\n 1. call (Val v) = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 3. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "thus ?case"], ["proof (prove)\nusing this:\n  call (Val v) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs", "by simp"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n   (inline_call E' (Val v\\<bullet>M(es'))) xs\n\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "case (CallParams v')"], ["proof (state)\nthis:\n  Val v = Val v'\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "with \\<open> \\<lbrakk>calls es = \\<lfloor>aMvs\\<rfloor>; fvs es \\<subseteq> set Vs\\<rbrakk> \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\\<close> \\<open>fv (Val v\\<bullet>M(es)) \\<subseteq> set Vs\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>calls es = \\<lfloor>aMvs\\<rfloor>;\n   fvs es \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\n  fv (Val v\\<bullet>M(es)) \\<subseteq> set Vs\n  Val v = Val v'\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>", "have \"bisims Vs (inline_calls E es) (inline_calls E' es') xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>calls es = \\<lfloor>aMvs\\<rfloor>;\n   fvs es \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisims Vs (inline_calls E es) (inline_calls E' es') xs\n  fv (Val v\\<bullet>M(es)) \\<subseteq> set Vs\n  Val v = Val v'\n  calls es = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bisims Vs (inline_calls E es) (inline_calls E' es') xs", "by(auto)"], ["proof (state)\nthis:\n  bisims Vs (inline_calls E es) (inline_calls E' es') xs\n\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>Val v = Val va;\n        calls es = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                          (inline_call E' (Val v\\<bullet>M(es'))) xs\n 2. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "with final bisim \\<open>bisims Vs es es' xs\\<close>"], ["proof (chain)\npicking this:\n  final E\n  bisim VS E E' XS\n  bisims Vs es es' xs\n  bisims Vs (inline_calls E es) (inline_calls E' es') xs", "show ?case"], ["proof (prove)\nusing this:\n  final E\n  bisim VS E E' XS\n  bisims Vs es es' xs\n  bisims Vs (inline_calls E es) (inline_calls E' es') xs\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs", "by(auto simp add: is_vals_conv)"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n   (inline_call E' (Val v\\<bullet>M(es'))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "case Call"], ["proof (state)\nthis:\n  Val v = addr a\n  es = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Val v = addr a; es = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n                       (inline_call E' (Val v\\<bullet>M(es'))) xs", "with final bisim \\<open>bisims Vs es es' xs\\<close>"], ["proof (chain)\npicking this:\n  final E\n  bisim VS E E' XS\n  bisims Vs es es' xs\n  Val v = addr a\n  es = map Val vs\n  M = M'", "show ?case"], ["proof (prove)\nusing this:\n  final E\n  bisim VS E E' XS\n  bisims Vs es es' xs\n  Val v = addr a\n  es = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n     (inline_call E' (Val v\\<bullet>M(es'))) xs", "by(auto)"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n   (inline_call E' (Val v\\<bullet>M(es'))) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bisim Vs (inline_call E (Val v\\<bullet>M(es)))\n   (inline_call E' (Val v\\<bullet>M(es'))) xs\n\ngoal (27 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 27 subgoals...", "case (bisimsCons1 Vs e e' xs es)"], ["proof (state)\nthis:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insyncs es\n  calls (e # es) = \\<lfloor>aMvs\\<rfloor>\n  fvs (e # es) \\<subseteq> set Vs\n\ngoal (27 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  bisim Vs e e' xs\n  \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; fv e \\<subseteq> set Vs\\<rbrakk>\n  \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs\n  \\<not> is_val e\n  \\<not> contains_insyncs es\n  calls (e # es) = \\<lfloor>aMvs\\<rfloor>\n  fvs (e # es) \\<subseteq> set Vs\n\ngoal (1 subgoal):\n 1. bisims Vs (inline_calls E (e # es))\n     (inline_calls E' (e' # compEs1 Vs es)) xs", "by(cases \"is_val (inline_call E e)\")(fastforce)+"], ["proof (state)\nthis:\n  bisims Vs (inline_calls E (e # es)) (inline_calls E' (e' # compEs1 Vs es))\n   xs\n\ngoal (26 subgoals):\n 1. \\<And>Vs C xs.\n       \\<lbrakk>call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        fv (new C) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (new C))\n                          (inline_call E' (new C)) xs\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (newA T\\<lfloor>e\\<rceil>))\n                          (inline_call E' (newA T\\<lfloor>e'\\<rceil>)) xs\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Cast T e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Cast T e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Cast T e))\n                          (inline_call E' (Cast T e')) xs\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n        fv (e instanceof T) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (e instanceof T))\n                          (inline_call E' (e' instanceof T)) xs\n 5. \\<And>Vs v xs.\n       \\<lbrakk>call (Val v) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v))\n                          (inline_call E' (Val v)) xs\n 6. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (Val v \\<guillemotleft>bop\\<guillemotright> e) =\n        \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v \\<guillemotleft>bop\\<guillemotright> e)\n        \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs\n                          (inline_call E\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e))\n                          (inline_call E'\n                            (Val v \\<guillemotleft>bop\\<guillemotright> e'))\n                          xs\n 7. \\<And>Vs V xs.\n       \\<lbrakk>call (Var V) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Var V) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Var V))\n                          (inline_call E' (Var (index Vs V))) xs\n 8. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         fv e \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e') xs;\n        call (V:=e) = \\<lfloor>aMvs\\<rfloor>;\n        fv (V:=e) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (V:=e))\n                          (inline_call E' (index Vs V:=e')) xs\n 9. \\<And>Vs i i' xs v.\n       \\<lbrakk>bisim Vs i i' xs;\n        \\<lbrakk>call i = \\<lfloor>aMvs\\<rfloor>;\n         fv i \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs (inline_call E i) (inline_call E' i') xs;\n        call (Val v\\<lfloor>i\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        fv (Val v\\<lfloor>i\\<rceil>) \\<subseteq> set Vs\\<rbrakk>\n       \\<Longrightarrow> bisim Vs (inline_call E (Val v\\<lfloor>i\\<rceil>))\n                          (inline_call E' (Val v\\<lfloor>i'\\<rceil>)) xs\n 10. \\<And>Vs e e' xs v i.\n        \\<lbrakk>bisim Vs e e' xs;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          fv e \\<subseteq> set Vs\\<rbrakk>\n         \\<Longrightarrow> bisim Vs (inline_call E e) (inline_call E' e')\n                            xs;\n         call (Val v\\<lfloor>Val i\\<rceil> := e) = \\<lfloor>aMvs\\<rfloor>;\n         fv (Val v\\<lfloor>Val i\\<rceil> := e) \\<subseteq> set Vs\\<rbrakk>\n        \\<Longrightarrow> bisim Vs\n                           (inline_call E\n                             (Val v\\<lfloor>Val i\\<rceil> := e))\n                           (inline_call E'\n                             (Val v\\<lfloor>Val i\\<rceil> := e'))\n                           xs\nA total of 26 subgoals...", "qed(fastforce)+"], ["", "declare hyperUn_ac [simp del]"], ["", "lemma sqInt_lem3: \"\\<lbrakk> A \\<sqsubseteq> A'; B \\<sqsubseteq> B' \\<rbrakk> \\<Longrightarrow> A \\<sqinter> B \\<sqsubseteq> A' \\<sqinter> B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sqsubseteq> A'; B \\<sqsubseteq> B'\\<rbrakk>\n    \\<Longrightarrow> A \\<sqinter> B \\<sqsubseteq> A' \\<sqinter> B'", "by(auto simp add: hyperset_defs)"], ["", "lemma sqUn_lem3: \"\\<lbrakk> A \\<sqsubseteq> A'; B \\<sqsubseteq> B' \\<rbrakk> \\<Longrightarrow> A \\<squnion> B \\<sqsubseteq> A' \\<squnion> B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sqsubseteq> A'; B \\<sqsubseteq> B'\\<rbrakk>\n    \\<Longrightarrow> A \\<squnion> B \\<sqsubseteq> A' \\<squnion> B'", "by(auto simp add: hyperset_defs)"], ["", "lemma A_inline_call: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<A> e \\<sqsubseteq> \\<A> (inline_call e' e)\"\n  and As_inline_calls: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>  \\<A>s es \\<sqsubseteq> \\<A>s (inline_calls e' es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     \\<A> e \\<sqsubseteq> \\<A> (inline_call e' e)) &&&\n    (calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     \\<A>s es \\<sqsubseteq> \\<A>s (inline_calls e' es))", "proof(induct e and es rule: call.induct calls.induct)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "case (Call obj M params)"], ["proof (state)\nthis:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A>s params \\<sqsubseteq> \\<A>s (inline_calls e' params)\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "obtain a M' vs where [simp]: \"aMvs = (a, M', vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a M' vs.\n        aMvs = (a, M', vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases aMvs, auto)"], ["proof (state)\nthis:\n  aMvs = (a, M', vs)\n\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "with \\<open>call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)", "have \"call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\""], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)\n\ngoal (1 subgoal):\n 1. call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))", "proof(induct rule: call_callE)"], ["proof (state)\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                         \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "case CallObj"], ["proof (state)\nthis:\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                         \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "with \\<open>call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)\\<close>"], ["proof (chain)\npicking this:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  call obj = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))", "by(auto intro: sqUn_lem)"], ["proof (state)\nthis:\n  \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n  \\<A> (inline_call e' (obj\\<bullet>M(params)))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                         \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                         \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "case CallParams"], ["proof (state)\nthis:\n  obj = Val v_\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                         \\<A> (inline_call e' (obj\\<bullet>M(params)))\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "with \\<open>calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<A>s params \\<sqsubseteq> \\<A>s (inline_calls e' params)\\<close>"], ["proof (chain)\npicking this:\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A>s params \\<sqsubseteq> \\<A>s (inline_calls e' params)\n  obj = Val v_\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  calls params = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A>s params \\<sqsubseteq> \\<A>s (inline_calls e' params)\n  obj = Val v_\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))", "by(auto intro: sqUn_lem)"], ["proof (state)\nthis:\n  \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n  \\<A> (inline_call e' (obj\\<bullet>M(params)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "case Call"], ["proof (state)\nthis:\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n                      \\<A> (inline_call e' (obj\\<bullet>M(params)))", "thus ?case"], ["proof (prove)\nusing this:\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n    \\<A> (inline_call e' (obj\\<bullet>M(params)))", "by(auto simp add: hyperset_defs)"], ["proof (state)\nthis:\n  \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n  \\<A> (inline_call e' (obj\\<bullet>M(params)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<A> (obj\\<bullet>M(params)) \\<sqsubseteq>\n  \\<A> (inline_call e' (obj\\<bullet>M(params)))\n\ngoal (24 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 24 subgoals...", "case Block"], ["proof (state)\nthis:\n  call x4_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x4_ \\<sqsubseteq> \\<A> (inline_call e' x4_)\n  call {x1_:x2_=x3_; x4_} = \\<lfloor>aMvs\\<rfloor>\n\ngoal (24 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call x4_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x4_ \\<sqsubseteq> \\<A> (inline_call e' x4_)\n  call {x1_:x2_=x3_; x4_} = \\<lfloor>aMvs\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> {x1_:x2_=x3_; x4_} \\<sqsubseteq>\n    \\<A> (inline_call e' {x1_:x2_=x3_; x4_})", "by(fastforce intro: diff_lem)"], ["proof (state)\nthis:\n  \\<A> {x1_:x2_=x3_; x4_} \\<sqsubseteq>\n  \\<A> (inline_call e' {x1_:x2_=x3_; x4_})\n\ngoal (23 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 23 subgoals...", "case throw"], ["proof (state)\nthis:\n  call x_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x_ \\<sqsubseteq> \\<A> (inline_call e' x_)\n  call (throw x_) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (23 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call x_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x_ \\<sqsubseteq> \\<A> (inline_call e' x_)\n  call (throw x_) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> (throw x_) \\<sqsubseteq> \\<A> (inline_call e' (throw x_))", "by(simp add: hyperset_defs)"], ["proof (state)\nthis:\n  \\<A> (throw x_) \\<sqsubseteq> \\<A> (inline_call e' (throw x_))\n\ngoal (22 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 22 subgoals...", "case TryCatch"], ["proof (state)\nthis:\n  call x1_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x1_ \\<sqsubseteq> \\<A> (inline_call e' x1_)\n  call x4_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x4_ \\<sqsubseteq> \\<A> (inline_call e' x4_)\n  call (try x1_ catch(x2_ x3_) x4_) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (22 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call x1_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x1_ \\<sqsubseteq> \\<A> (inline_call e' x1_)\n  call x4_ = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n  \\<A> x4_ \\<sqsubseteq> \\<A> (inline_call e' x4_)\n  call (try x1_ catch(x2_ x3_) x4_) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> (try x1_ catch(x2_ x3_) x4_) \\<sqsubseteq>\n    \\<A> (inline_call e' (try x1_ catch(x2_ x3_) x4_))", "by(auto intro: sqInt_lem)"], ["proof (state)\nthis:\n  \\<A> (try x1_ catch(x2_ x3_) x4_) \\<sqsubseteq>\n  \\<A> (inline_call e' (try x1_ catch(x2_ x3_) x4_))\n\ngoal (21 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (new x) \\<sqsubseteq> \\<A> (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (newA x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (Cast x1 x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1 instanceof x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Val x) \\<sqsubseteq> \\<A> (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A>\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<sqsubseteq>\n                         \\<A>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<A> (Var x) \\<sqsubseteq> \\<A> (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1:=x2) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil>) \\<sqsubseteq>\n                         \\<A> (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<A> x1 \\<sqsubseteq> \\<A> (inline_call e' x1);\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x2 \\<sqsubseteq> \\<A> (inline_call e' x2);\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<A> x3 \\<sqsubseteq> \\<A> (inline_call e' x3);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<A> (x1\\<lfloor>x2\\<rceil> := x3) \\<sqsubseteq>\n                          \\<A>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 21 subgoals...", "qed(fastforce intro: sqUn_lem sqUn_lem2)+"], ["", "lemma assumes \"final e'\"\n  shows defass_inline_call: \"\\<lbrakk> call e = \\<lfloor>aMvs\\<rfloor>; \\<D> e A \\<rbrakk> \\<Longrightarrow> \\<D> (inline_call e' e) A\"\n  and defasss_inline_calls: \"\\<lbrakk> calls es = \\<lfloor>aMvs\\<rfloor>; \\<D>s es A \\<rbrakk> \\<Longrightarrow> \\<D>s (inline_calls e' es) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>; \\<D> e A\\<rbrakk>\n     \\<Longrightarrow> \\<D> (inline_call e' e) A) &&&\n    (\\<lbrakk>calls es = \\<lfloor>aMvs\\<rfloor>; \\<D>s es A\\<rbrakk>\n     \\<Longrightarrow> \\<D>s (inline_calls e' es) A)", "proof(induct e and es arbitrary: A and A rule: call.induct calls.induct)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 25 subgoals...", "case (Call obj M params A)"], ["proof (state)\nthis:\n  \\<lbrakk>call obj = \\<lfloor>aMvs\\<rfloor>; \\<D> obj ?A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' obj) ?A\n  \\<lbrakk>calls params = \\<lfloor>aMvs\\<rfloor>; \\<D>s params ?A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' params) ?A\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  \\<D> (obj\\<bullet>M(params)) A\n\ngoal (25 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 25 subgoals...", "obtain a M' vs where [simp]: \"aMvs = (a, M', vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a M' vs.\n        aMvs = (a, M', vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases aMvs, auto)"], ["proof (state)\nthis:\n  aMvs = (a, M', vs)\n\ngoal (25 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 25 subgoals...", "with \\<open>call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)", "have \"call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\""], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>aMvs\\<rfloor>\n  aMvs = (a, M', vs)\n\ngoal (1 subgoal):\n 1. call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  call (obj\\<bullet>M(params)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "proof(cases rule: call_callE)"], ["proof (state)\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "case CallObj"], ["proof (state)\nthis:\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "with \\<open>\\<D> (obj\\<bullet>M(params)) A\\<close> \\<open>\\<lbrakk>call obj = \\<lfloor>aMvs\\<rfloor>; \\<D> obj A\\<rbrakk> \\<Longrightarrow> \\<D> (inline_call e' obj) A\\<close>"], ["proof (chain)\npicking this:\n  \\<D> (obj\\<bullet>M(params)) A\n  \\<lbrakk>call obj = \\<lfloor>aMvs\\<rfloor>; \\<D> obj A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' obj) A\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>", "have \"\\<D> (inline_call e' obj) A\""], ["proof (prove)\nusing this:\n  \\<D> (obj\\<bullet>M(params)) A\n  \\<lbrakk>call obj = \\<lfloor>aMvs\\<rfloor>; \\<D> obj A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' obj) A\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' obj) A", "by simp"], ["proof (state)\nthis:\n  \\<D> (inline_call e' obj) A\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "moreover"], ["proof (state)\nthis:\n  \\<D> (inline_call e' obj) A\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "from A_inline_call[OF CallObj, of e']"], ["proof (chain)\npicking this:\n  \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)", "have \"A \\<squnion> (\\<A> obj) \\<sqsubseteq> A \\<squnion> (\\<A> (inline_call e' obj))\""], ["proof (prove)\nusing this:\n  \\<A> obj \\<sqsubseteq> \\<A> (inline_call e' obj)\n\ngoal (1 subgoal):\n 1. A \\<squnion> \\<A> obj \\<sqsubseteq>\n    A \\<squnion> \\<A> (inline_call e' obj)", "by(rule sqUn_lem2)"], ["proof (state)\nthis:\n  A \\<squnion> \\<A> obj \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' obj)\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "with \\<open>\\<D> (obj\\<bullet>M(params)) A\\<close>"], ["proof (chain)\npicking this:\n  \\<D> (obj\\<bullet>M(params)) A\n  A \\<squnion> \\<A> obj \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' obj)", "have \"\\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))\""], ["proof (prove)\nusing this:\n  \\<D> (obj\\<bullet>M(params)) A\n  A \\<squnion> \\<A> obj \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' obj)\n\ngoal (1 subgoal):\n 1. \\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))", "by(auto elim: Ds_mono')"], ["proof (state)\nthis:\n  \\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))\n\ngoal (3 subgoals):\n 1. call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n    \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 3. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "ultimately"], ["proof (chain)\npicking this:\n  \\<D> (inline_call e' obj) A\n  \\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<D> (inline_call e' obj) A\n  \\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "using CallObj"], ["proof (prove)\nusing this:\n  \\<D> (inline_call e' obj) A\n  \\<D>s params (A \\<squnion> \\<A> (inline_call e' obj))\n  call obj = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "by auto"], ["proof (state)\nthis:\n  \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "case (CallParams v)"], ["proof (state)\nthis:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "with \\<open>\\<D> (obj\\<bullet>M(params)) A\\<close> \\<open>\\<lbrakk>calls params = \\<lfloor>aMvs\\<rfloor>; \\<D>s params A\\<rbrakk> \\<Longrightarrow> \\<D>s (inline_calls e' params) A\\<close>"], ["proof (chain)\npicking this:\n  \\<D> (obj\\<bullet>M(params)) A\n  \\<lbrakk>calls params = \\<lfloor>aMvs\\<rfloor>; \\<D>s params A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' params) A\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>", "have \"\\<D>s (inline_calls e' params) A\""], ["proof (prove)\nusing this:\n  \\<D> (obj\\<bullet>M(params)) A\n  \\<lbrakk>calls params = \\<lfloor>aMvs\\<rfloor>; \\<D>s params A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' params) A\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' params) A", "by(simp)"], ["proof (state)\nthis:\n  \\<D>s (inline_calls e' params) A\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>obj = Val v;\n        calls params = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n 2. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "with CallParams"], ["proof (chain)\npicking this:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n  \\<D>s (inline_calls e' params) A", "show ?thesis"], ["proof (prove)\nusing this:\n  obj = Val v\n  calls params = \\<lfloor>(a, M', vs)\\<rfloor>\n  \\<D>s (inline_calls e' params) A\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "by(auto)"], ["proof (state)\nthis:\n  \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "case Call"], ["proof (state)\nthis:\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obj = addr a; params = map Val vs; M = M'\\<rbrakk>\n    \\<Longrightarrow> \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "with \\<open>final e'\\<close>"], ["proof (chain)\npicking this:\n  final e'\n  obj = addr a\n  params = map Val vs\n  M = M'", "show ?thesis"], ["proof (prove)\nusing this:\n  final e'\n  obj = addr a\n  params = map Val vs\n  M = M'\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' (obj\\<bullet>M(params))) A", "by(auto elim!: D_mono' simp add: hyperset_defs)"], ["proof (state)\nthis:\n  \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<D> (inline_call e' (obj\\<bullet>M(params))) A\n\ngoal (24 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 24 subgoals...", "case (Cons_exp exp exps A)"], ["proof (state)\nthis:\n  \\<lbrakk>call exp = \\<lfloor>aMvs\\<rfloor>; \\<D> exp ?A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' exp) ?A\n  \\<lbrakk>calls exps = \\<lfloor>aMvs\\<rfloor>; \\<D>s exps ?A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' exps) ?A\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n  \\<D>s (exp # exps) A\n\ngoal (24 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 24 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' (exp # exps)) A", "proof(cases \"is_val exp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_val exp \\<Longrightarrow> \\<D>s (inline_calls e' (exp # exps)) A\n 2. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "case True"], ["proof (state)\nthis:\n  is_val exp\n\ngoal (2 subgoals):\n 1. is_val exp \\<Longrightarrow> \\<D>s (inline_calls e' (exp # exps)) A\n 2. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "with \\<open>\\<D>s (exp # exps) A\\<close> \\<open>\\<lbrakk>calls exps = \\<lfloor>aMvs\\<rfloor>; \\<D>s exps A\\<rbrakk> \\<Longrightarrow> \\<D>s (inline_calls e' exps) A\\<close> \n      \\<open>calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  \\<D>s (exp # exps) A\n  \\<lbrakk>calls exps = \\<lfloor>aMvs\\<rfloor>; \\<D>s exps A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' exps) A\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n  is_val exp", "have \"\\<D>s (inline_calls e' exps) A\""], ["proof (prove)\nusing this:\n  \\<D>s (exp # exps) A\n  \\<lbrakk>calls exps = \\<lfloor>aMvs\\<rfloor>; \\<D>s exps A\\<rbrakk>\n  \\<Longrightarrow> \\<D>s (inline_calls e' exps) A\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n  is_val exp\n\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' exps) A", "by(auto)"], ["proof (state)\nthis:\n  \\<D>s (inline_calls e' exps) A\n\ngoal (2 subgoals):\n 1. is_val exp \\<Longrightarrow> \\<D>s (inline_calls e' (exp # exps)) A\n 2. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "with True"], ["proof (chain)\npicking this:\n  is_val exp\n  \\<D>s (inline_calls e' exps) A", "show ?thesis"], ["proof (prove)\nusing this:\n  is_val exp\n  \\<D>s (inline_calls e' exps) A\n\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' (exp # exps)) A", "by(auto)"], ["proof (state)\nthis:\n  \\<D>s (inline_calls e' (exp # exps)) A\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "case False"], ["proof (state)\nthis:\n  \\<not> is_val exp\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "with \\<open>\\<lbrakk>call exp = \\<lfloor>aMvs\\<rfloor>; \\<D> exp A\\<rbrakk> \\<Longrightarrow> \\<D> (inline_call e' exp) A\\<close> \\<open>calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\\<close> \\<open>\\<D>s (exp # exps) A\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>call exp = \\<lfloor>aMvs\\<rfloor>; \\<D> exp A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' exp) A\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n  \\<D>s (exp # exps) A\n  \\<not> is_val exp", "have \"\\<D> (inline_call e' exp) A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>call exp = \\<lfloor>aMvs\\<rfloor>; \\<D> exp A\\<rbrakk>\n  \\<Longrightarrow> \\<D> (inline_call e' exp) A\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n  \\<D>s (exp # exps) A\n  \\<not> is_val exp\n\ngoal (1 subgoal):\n 1. \\<D> (inline_call e' exp) A", "by auto"], ["proof (state)\nthis:\n  \\<D> (inline_call e' exp) A\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "moreover"], ["proof (state)\nthis:\n  \\<D> (inline_call e' exp) A\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "from False \\<open>calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  \\<not> is_val exp\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>", "have \"\\<A> exp \\<sqsubseteq> \\<A> (inline_call e' exp)\""], ["proof (prove)\nusing this:\n  \\<not> is_val exp\n  calls (exp # exps) = \\<lfloor>aMvs\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<A> exp \\<sqsubseteq> \\<A> (inline_call e' exp)", "by(auto intro: A_inline_call)"], ["proof (state)\nthis:\n  \\<A> exp \\<sqsubseteq> \\<A> (inline_call e' exp)\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "hence \"A \\<squnion> \\<A> exp \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' exp)\""], ["proof (prove)\nusing this:\n  \\<A> exp \\<sqsubseteq> \\<A> (inline_call e' exp)\n\ngoal (1 subgoal):\n 1. A \\<squnion> \\<A> exp \\<sqsubseteq>\n    A \\<squnion> \\<A> (inline_call e' exp)", "by(rule sqUn_lem2)"], ["proof (state)\nthis:\n  A \\<squnion> \\<A> exp \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' exp)\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "with \\<open>\\<D>s (exp # exps) A\\<close>"], ["proof (chain)\npicking this:\n  \\<D>s (exp # exps) A\n  A \\<squnion> \\<A> exp \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' exp)", "have \"\\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))\""], ["proof (prove)\nusing this:\n  \\<D>s (exp # exps) A\n  A \\<squnion> \\<A> exp \\<sqsubseteq> A \\<squnion> \\<A> (inline_call e' exp)\n\ngoal (1 subgoal):\n 1. \\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))", "by(auto intro: Ds_mono')"], ["proof (state)\nthis:\n  \\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))\n\ngoal (1 subgoal):\n 1. \\<not> is_val exp \\<Longrightarrow>\n    \\<D>s (inline_calls e' (exp # exps)) A", "ultimately"], ["proof (chain)\npicking this:\n  \\<D> (inline_call e' exp) A\n  \\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<D> (inline_call e' exp) A\n  \\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))\n\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' (exp # exps)) A", "using False"], ["proof (prove)\nusing this:\n  \\<D> (inline_call e' exp) A\n  \\<D>s exps (A \\<squnion> \\<A> (inline_call e' exp))\n  \\<not> is_val exp\n\ngoal (1 subgoal):\n 1. \\<D>s (inline_calls e' (exp # exps)) A", "by(auto)"], ["proof (state)\nthis:\n  \\<D>s (inline_calls e' (exp # exps)) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<D>s (inline_calls e' (exp # exps)) A\n\ngoal (23 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (new x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (new x)) A\n 2. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (newA x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n                          A\n 3. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Cast x1 x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Cast x1 x2)) A\n 4. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 instanceof x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1 instanceof x2)) A\n 5. \\<And>x A.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Val x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Val x)) A\n 6. \\<And>x1 x2 x3 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1 \\<guillemotleft>x2\\<guillemotright> x3) A\\<rbrakk>\n       \\<Longrightarrow> \\<D>\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          A\n 7. \\<And>x A.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (Var x) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (Var x)) A\n 8. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x2 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<D> (x1:=x2) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1:=x2)) A\n 9. \\<And>x1 x2 A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                    \\<D> x1 A\\<rbrakk>\n                   \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n        \\<And>A.\n           \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n           \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<D> (x1\\<lfloor>x2\\<rceil>) A\\<rbrakk>\n       \\<Longrightarrow> \\<D> (inline_call e' (x1\\<lfloor>x2\\<rceil>)) A\n 10. \\<And>x1 x2 x3 A.\n        \\<lbrakk>\\<And>A.\n                    \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor>;\n                     \\<D> x1 A\\<rbrakk>\n                    \\<Longrightarrow> \\<D> (inline_call e' x1) A;\n         \\<And>A.\n            \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor>; \\<D> x2 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x2) A;\n         \\<And>A.\n            \\<lbrakk>call x3 = \\<lfloor>aMvs\\<rfloor>; \\<D> x3 A\\<rbrakk>\n            \\<Longrightarrow> \\<D> (inline_call e' x3) A;\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<D> (x1\\<lfloor>x2\\<rceil> := x3) A\\<rbrakk>\n        \\<Longrightarrow> \\<D>\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) A\nA total of 23 subgoals...", "qed(fastforce split: if_split_asm elim: D_mono' intro: sqUn_lem2 sqUn_lem A_inline_call)+"], ["", "lemma bisim_B: \"bisim Vs e E xs \\<Longrightarrow> \\<B> E (length Vs)\"\n  and bisims_Bs: \"bisims Vs es Es xs \\<Longrightarrow> \\<B>s Es (length Vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim Vs e E xs \\<Longrightarrow> \\<B> E (length Vs)) &&&\n    (bisims Vs es Es xs \\<Longrightarrow> \\<B>s Es (length Vs))", "apply(induct rule: bisim_bisims.inducts)"], ["proof (prove)\ngoal (36 subgoals):\n 1. \\<And>Vs C xs. \\<B> (new C) (length Vs)\n 2. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs)\\<rbrakk>\n       \\<Longrightarrow> \\<B> (newA T\\<lfloor>e'\\<rceil>) (length Vs)\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs)\\<rbrakk>\n       \\<Longrightarrow> \\<B> (Cast T e') (length Vs)\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs)\\<rbrakk>\n       \\<Longrightarrow> \\<B> (e' instanceof T) (length Vs)\n 5. \\<And>Vs v xs. \\<B> (Val v) (length Vs)\n 6. \\<And>Vs e e' xs e'' bop.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs); \\<not> is_val e;\n        \\<not> contains_insync e''\\<rbrakk>\n       \\<Longrightarrow> \\<B>\n                          (e' \\<guillemotleft>bop\\<guillemotright> compE1 Vs\n                              e'')\n                          (length Vs)\n 7. \\<And>Vs e e' xs v bop.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs)\\<rbrakk>\n       \\<Longrightarrow> \\<B>\n                          (Val v \\<guillemotleft>bop\\<guillemotright> e')\n                          (length Vs)\n 8. \\<And>Vs V xs. \\<B> (Var (index Vs V)) (length Vs)\n 9. \\<And>Vs e e' xs V.\n       \\<lbrakk>bisim Vs e e' xs; \\<B> e' (length Vs)\\<rbrakk>\n       \\<Longrightarrow> \\<B> (index Vs V:=e') (length Vs)\n 10. \\<And>Vs a a' xs i.\n        \\<lbrakk>bisim Vs a a' xs; \\<B> a' (length Vs); \\<not> is_val a;\n         \\<not> contains_insync i\\<rbrakk>\n        \\<Longrightarrow> \\<B> (a'\\<lfloor>compE1 Vs i\\<rceil>) (length Vs)\nA total of 36 subgoals...", "apply(auto intro: \\<B> \\<B>s)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_expr_locks_eq: \"bisim Vs e e' xs \\<Longrightarrow> expr_locks e = expr_locks e'\"\n  and bisims_expr_lockss_eq: \"bisims Vs es es' xs \\<Longrightarrow> expr_lockss es = expr_lockss es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim Vs e e' xs \\<Longrightarrow> expr_locks e = expr_locks e') &&&\n    (bisims Vs es es' xs \\<Longrightarrow> expr_lockss es = expr_lockss es')", "by(induct rule: bisim_bisims.inducts)(auto intro!: ext)"], ["", "lemma bisim_list_expr_lockss_eq: \"bisim_list es exs' \\<Longrightarrow> expr_lockss es = expr_lockss (map fst exs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_list es exs' \\<Longrightarrow>\n    expr_lockss es = expr_lockss (map fst exs')", "apply(induct rule: bisim_list.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. expr_lockss [] = expr_lockss (map fst [])\n 2. \\<And>es exs' e e' xs aMvs.\n       \\<lbrakk>bisim_list es exs';\n        expr_lockss es = expr_lockss (map fst exs'); bisim [] e e' xs;\n        fv e = {}; \\<D> e \\<lfloor>{}\\<rfloor>; max_vars e' \\<le> length xs;\n        call e = \\<lfloor>aMvs\\<rfloor>;\n        call1 e' = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (e # es) =\n                         expr_lockss (map fst ((e', xs) # exs'))", "apply(auto dest: bisim_expr_locks_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context J1_heap_base begin"], ["", "lemma [simp]:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1_compP: \"\\<tau>move1 (compP f P) h e = \\<tau>move1 P h e\"\n  and \\<tau>moves1_compP: \"\\<tau>moves1 (compP f P) h es = \\<tau>moves1 P h es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move1 (compP f P) h e = \\<tau>move1 P h e &&&\n    \\<tau>moves1 (compP f P) h es = \\<tau>moves1 P h es", "by(induct e and es rule: \\<tau>move1.induct \\<tau>moves1.induct) auto"], ["", "lemma \\<tau>Move1_compP [simp]: \"\\<tau>Move1 (compP f P) = \\<tau>Move1 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Move1 (compP f P) = \\<tau>Move1 P", "by(intro ext) auto"], ["", "lemma red1_preserves_unmod:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; unmod e i \\<rbrakk> \\<Longrightarrow> (lcl s') ! i = (lcl s) ! i\"\n  \n  and reds1_preserves_unmod:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; unmods es i \\<rbrakk> \\<Longrightarrow> (lcl s') ! i = (lcl s) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      unmod e i\\<rbrakk>\n     \\<Longrightarrow> lcl s' ! i = lcl s ! i) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      unmods es i\\<rbrakk>\n     \\<Longrightarrow> lcl s' ! i = lcl s ! i)", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        unmod (new C) i\\<rbrakk>\n       \\<Longrightarrow> lcl (h', l) ! i = lcl (h, l) ! i\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; unmod (new C) i\\<rbrakk>\n       \\<Longrightarrow> lcl (h, l) ! i = lcl (h, l) ! i\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        unmod e i \\<Longrightarrow> lcl s' ! i = lcl s ! i;\n        unmod (newA T\\<lfloor>e\\<rceil>) i\\<rbrakk>\n       \\<Longrightarrow> lcl s' ! i = lcl s ! i\n 4. \\<And>ia h' a h T l.\n       \\<lbrakk>0 \\<le>s ia;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint ia)));\n        unmod (newA T\\<lfloor>Val (Intg ia)\\<rceil>) i\\<rbrakk>\n       \\<Longrightarrow> lcl (h', l) ! i = lcl (h, l) ! i\n 5. \\<And>ia T s.\n       \\<lbrakk>ia <s 0;\n        unmod (newA T\\<lfloor>Val (Intg ia)\\<rceil>) i\\<rbrakk>\n       \\<Longrightarrow> lcl s ! i = lcl s ! i\n 6. \\<And>ia h T l.\n       \\<lbrakk>0 \\<le>s ia; allocate h (Array_type T (nat (sint ia))) = {};\n        unmod (newA T\\<lfloor>Val (Intg ia)\\<rceil>) i\\<rbrakk>\n       \\<Longrightarrow> lcl (h, l) ! i = lcl (h, l) ! i\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        unmod e i \\<Longrightarrow> lcl s' ! i = lcl s ! i;\n        unmod (Cast C e) i\\<rbrakk>\n       \\<Longrightarrow> lcl s' ! i = lcl s ! i\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; unmod (Cast T (Val v)) i\\<rbrakk>\n       \\<Longrightarrow> lcl s ! i = lcl s ! i\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; unmod (Cast T (Val v)) i\\<rbrakk>\n       \\<Longrightarrow> lcl s ! i = lcl s ! i\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         unmod e i \\<Longrightarrow> lcl s' ! i = lcl s ! i;\n         unmod (e instanceof T) i\\<rbrakk>\n        \\<Longrightarrow> lcl s' ! i = lcl s ! i\nA total of 102 subgoals...", "apply(auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red1_unmod_preserved:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\"\n  and reds1_unmods_preserved:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; unmods es i \\<rbrakk> \\<Longrightarrow> unmods es' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      unmod e i\\<rbrakk>\n     \\<Longrightarrow> unmod e' i) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      unmods es i\\<rbrakk>\n     \\<Longrightarrow> unmods es' i)", "by(induct rule: red1_reds1.inducts)(auto split: if_split_asm)"], ["", "lemma \\<tau>red1t_unmod_preserved:\n  \"\\<lbrakk> \\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i\\<rbrakk>\n    \\<Longrightarrow> unmod e' i", "by(induct rule: tranclp_induct2)(auto intro: red1_unmod_preserved)"], ["", "lemma \\<tau>red1r_unmod_preserved:\n  \"\\<lbrakk> \\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i \\<rbrakk> \\<Longrightarrow> unmod e' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i\\<rbrakk>\n    \\<Longrightarrow> unmod e' i", "by(induct rule: rtranclp_induct2)(auto intro: red1_unmod_preserved)"], ["", "lemma \\<tau>red1t_preserves_unmod: \n  \"\\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i; i < length xs \\<rbrakk>\n  \\<Longrightarrow> xs' ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (e', xs'); unmod e i;\n     i < length xs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i = xs ! i", "apply(induct rule: tranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<tau>red1g uf P t h (e, xs) (a, b); unmod e i;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> b ! i = xs ! i\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (a, b);\n        \\<tau>red1g uf P t h (a, b) (aa, ba);\n        \\<lbrakk>unmod e i; i < length xs\\<rbrakk>\n        \\<Longrightarrow> b ! i = xs ! i;\n        unmod e i; i < length xs\\<rbrakk>\n       \\<Longrightarrow> ba ! i = xs ! i", "apply(auto dest: red1_preserves_unmod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (a, b); b ! i = xs ! i;\n        unmod e i; i < length xs;\n        uf,P,t \\<turnstile>1 \\<langle>a,\n                              (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                             \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move1 P h a\\<rbrakk>\n       \\<Longrightarrow> ba ! i = xs ! i", "apply(drule red1_preserves_unmod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (a, b); b ! i = xs ! i;\n        unmod e i; i < length xs; \\<tau>move1 P h a\\<rbrakk>\n       \\<Longrightarrow> unmod a (?i9 a b aa ba)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (a, b); b ! i = xs ! i;\n        unmod e i; i < length xs; \\<tau>move1 P h a;\n        lcl (h, ba) ! ?i9 a b aa ba = lcl (h, b) ! ?i9 a b aa ba\\<rbrakk>\n       \\<Longrightarrow> ba ! i = xs ! i", "apply(erule (1) \\<tau>red1t_unmod_preserved)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gt uf P t h (e, xs) (a, b); b ! i = xs ! i;\n        unmod e i; i < length xs; \\<tau>move1 P h a;\n        lcl (h, ba) ! i = lcl (h, b) ! i\\<rbrakk>\n       \\<Longrightarrow> ba ! i = xs ! i", "apply(drule \\<tau>red1t_preserves_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>b ! i = xs ! i; unmod e i; i < length xs; \\<tau>move1 P h a;\n        lcl (h, ba) ! i = lcl (h, b) ! i; length b = length xs\\<rbrakk>\n       \\<Longrightarrow> ba ! i = xs ! i", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>red1'r_preserves_unmod: \n  \"\\<lbrakk>\\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i; i < length xs \\<rbrakk>\n  \\<Longrightarrow> xs' ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gr uf P t h (e, xs) (e', xs'); unmod e i;\n     i < length xs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i = xs ! i", "apply(induct rule: converse_rtranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unmod e' i; i < length xs'\\<rbrakk>\n    \\<Longrightarrow> xs' ! i = xs' ! i\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1g uf P t h (a, b) (aa, ba);\n        \\<tau>red1gr uf P t h (aa, ba) (e', xs');\n        \\<lbrakk>unmod aa i; i < length ba\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = ba ! i;\n        unmod a i; i < length b\\<rbrakk>\n       \\<Longrightarrow> xs' ! i = b ! i", "apply(auto dest: red1_preserves_unmod red1_unmod_preserved red1_preserves_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gr uf P t h (aa, ba) (e', xs');\n        \\<lbrakk>unmod aa i; i < length ba\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = ba ! i;\n        unmod a i; i < length b;\n        uf,P,t \\<turnstile>1 \\<langle>a,\n                              (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                             \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move1 P h a\\<rbrakk>\n       \\<Longrightarrow> xs' ! i = b ! i", "apply(frule (1) red1_unmod_preserved)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gr uf P t h (aa, ba) (e', xs');\n        \\<lbrakk>unmod aa i; i < length ba\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = ba ! i;\n        unmod a i; i < length b;\n        uf,P,t \\<turnstile>1 \\<langle>a,\n                              (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                             \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move1 P h a; unmod aa i\\<rbrakk>\n       \\<Longrightarrow> xs' ! i = b ! i", "apply(frule red1_preserves_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gr uf P t h (aa, ba) (e', xs');\n        \\<lbrakk>unmod aa i; i < length ba\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = ba ! i;\n        unmod a i; i < length b;\n        uf,P,t \\<turnstile>1 \\<langle>a,\n                              (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                             \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move1 P h a; unmod aa i;\n        length (lcl (h, ba)) = length (lcl (h, b))\\<rbrakk>\n       \\<Longrightarrow> xs' ! i = b ! i", "apply(frule (1) red1_preserves_unmod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red1gr uf P t h (aa, ba) (e', xs');\n        \\<lbrakk>unmod aa i; i < length ba\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = ba ! i;\n        unmod a i; i < length b;\n        uf,P,t \\<turnstile>1 \\<langle>a,\n                              (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                             \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move1 P h a; unmod aa i;\n        length (lcl (h, ba)) = length (lcl (h, b));\n        lcl (h, ba) ! i = lcl (h, b) ! i\\<rbrakk>\n       \\<Longrightarrow> xs' ! i = b ! i", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context J_heap_base begin"], ["", "lemma [simp]:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_compP: \"\\<tau>move0 (compP f P) h e = \\<tau>move0 P h e\"\n  and \\<tau>moves0_compP: \"\\<tau>moves0 (compP f P) h es = \\<tau>moves0 P h es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move0 (compP f P) h e = \\<tau>move0 P h e &&&\n    \\<tau>moves0 (compP f P) h es = \\<tau>moves0 P h es", "by(induct e and es rule: \\<tau>move0.induct \\<tau>moves0.induct) auto"], ["", "lemma \\<tau>Move0_compP [simp]: \"\\<tau>Move0 (compP f P) = \\<tau>Move0 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Move0 (compP f P) = \\<tau>Move0 P", "by(intro ext) auto"], ["", "end"], ["", "end"]]}