{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/State_Refinement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma state_\\<alpha>_conv [simp]:\n  \"locks (state_\\<alpha> s) = locks s\"\n  \"thr (state_\\<alpha> s) = thr_\\<alpha> (thr s)\"\n  \"shr (state_\\<alpha> s) = shr s\"\n  \"wset (state_\\<alpha> s) = ws_\\<alpha> (wset s)\"\n  \"interrupts (state_\\<alpha> s) = is_\\<alpha> (interrupts s)\"", "lemma state_invarD [simp]:\n  assumes \"state_invar s\"\n  shows \"thr_invar (thr s)\" \"ws_invar (wset s)\" \"is_invar (interrupts s)\"", "lemmas [code] =\n  heap_base.start_state_refine_def"], "translations": [["", "lemma state_\\<alpha>_conv [simp]:\n  \"locks (state_\\<alpha> s) = locks s\"\n  \"thr (state_\\<alpha> s) = thr_\\<alpha> (thr s)\"\n  \"shr (state_\\<alpha> s) = shr s\"\n  \"wset (state_\\<alpha> s) = ws_\\<alpha> (wset s)\"\n  \"interrupts (state_\\<alpha> s) = is_\\<alpha> (interrupts s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (locks (state_\\<alpha> s) = locks s &&&\n     thr (state_\\<alpha> s) = thr_\\<alpha> (thr s)) &&&\n    shr (state_\\<alpha> s) = shr s &&&\n    wset (state_\\<alpha> s) = ws_\\<alpha> (wset s) &&&\n    interrupts (state_\\<alpha> s) = is_\\<alpha> (interrupts s)", "by(case_tac [!] s) auto"], ["", "inductive state_invar :: \"('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> bool\"\nwhere \"\\<lbrakk> thr_invar ts; ws_invar ws; is_invar is \\<rbrakk> \\<Longrightarrow> state_invar (ls, (ts, m), ws, is)\""], ["", "inductive_simps state_invar_simps [simp]:\n  \"state_invar (ls, (ts, m), ws, is)\""], ["", "lemma state_invarD [simp]:\n  assumes \"state_invar s\"\n  shows \"thr_invar (thr s)\" \"ws_invar (wset s)\" \"is_invar (interrupts s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_invar (thr s) &&& ws_invar (wset s) &&& is_invar (interrupts s)", "using assms"], ["proof (prove)\nusing this:\n  state_invar s\n\ngoal (1 subgoal):\n 1. thr_invar (thr s) &&& ws_invar (wset s) &&& is_invar (interrupts s)", "by(case_tac [!] s) auto"], ["", "end"], ["", "sublocale state_refine_base < \\<alpha>: final_thread final"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale state_refine_base < \\<alpha>:\n  multithreaded_base\n    final\n    \"\\<lambda>t xm ta x'm'. Predicate.eval (r t xm) (ta, x'm')\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition (in heap_base) start_state_refine :: \n  \"'m_t \\<Rightarrow> ('thread_id \\<Rightarrow> ('x \\<times> 'addr released_locks) \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t) \\<Rightarrow> 'm_w \\<Rightarrow> 's_i\n  \\<Rightarrow> (cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'md \\<Rightarrow> 'addr val list \\<Rightarrow> 'x) \\<Rightarrow> 'md prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> 'addr val list\n  \\<Rightarrow> ('addr, 'thread_id, 'heap, 'm_t, 'm_w, 's_i) state_refine\"\nwhere\n  \"\\<And>is_empty.\n  start_state_refine thr_empty thr_update ws_empty is_empty f P C M vs =\n  (let (D, Ts, T, m) = method P C M\n   in (K$ None, (thr_update start_tid (f D M Ts T (the m) vs, no_wait_locks) thr_empty, start_heap), ws_empty, is_empty))\""], ["", "definition Jinja_output :: \n  \"'s \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'thread_id, 'x, 'heap, 'addr, ('addr, 'thread_id) obs_event) thread_action \n  \\<Rightarrow> ('thread_id \\<times> ('addr, 'thread_id) obs_event list) option\"\nwhere \"Jinja_output \\<sigma> t ta = (if \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [] then None else Some (t, \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\""], ["", "lemmas [code] =\n  heap_base.start_state_refine_def"], ["", "end"]]}