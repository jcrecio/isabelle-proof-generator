{"file_name": "/home/qj213/afp-2021-10-22/thys/Hoare_Time/SepLogAdd/Sep_Algebra_Add.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hoare_Time", "problem_names": ["lemma puree_alt: \"\\<up>\\<Phi> = (\\<langle>\\<Phi>\\<rangle> and \\<box>)\"", "lemma pure_alt: \"\\<langle>\\<Phi>\\<rangle> = (\\<up>\\<Phi> ** sep_true)\"", "lemma sep_reorder[sep_simplify]:  \n  \"((a \\<and>* b) \\<and>* c) = (a \\<and>* b \\<and>* c)\"\n  \"(NO_PURE X a) \\<Longrightarrow> (a ** b) = (b ** a)\"\n  \"(NO_PURE X b) \\<Longrightarrow> (b \\<and>* a \\<and>* c) = (a \\<and>* b \\<and>* c)\"\n  \"(Q ** \\<langle>P\\<rangle>) = (\\<langle>P\\<rangle> ** Q)\"\n  \"(Q ** \\<up>P) = (\\<up>P ** Q)\"\n  \"NO_PURE X Q \\<Longrightarrow> (Q ** \\<langle>P\\<rangle> ** F) = (\\<langle>P\\<rangle> ** Q ** F)\"\n  \"NO_PURE X Q \\<Longrightarrow> (Q ** \\<up>P ** F) = (\\<up>P ** Q ** F)\"", "lemma sep_combine1[simp]:\n  \"(\\<up>P ** \\<up>Q) = \\<up>(P\\<and>Q)\"\n  \"(\\<langle>P\\<rangle> ** \\<langle>Q\\<rangle>) = \\<langle>P\\<and>Q\\<rangle>\"\n  \"(\\<up>P ** \\<langle>Q\\<rangle>) = \\<langle>P\\<and>Q\\<rangle>\"\n  \"(\\<langle>P\\<rangle> ** \\<up>Q) = \\<langle>P\\<and>Q\\<rangle>\"", "lemma sep_combine2[simp]:\n  \"(\\<up>P ** \\<up>Q ** F) = (\\<up>(P\\<and>Q) ** F)\"\n  \"(\\<langle>P\\<rangle> ** \\<langle>Q\\<rangle> ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\"\n  \"(\\<up>P ** \\<langle>Q\\<rangle> ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\"\n  \"(\\<langle>P\\<rangle> ** \\<up>Q ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\"", "lemma sep_extract_pure[simp]:\n  \"NO_MATCH True P \\<Longrightarrow> (\\<langle>P\\<rangle> ** Q) h = (P \\<and> (sep_true ** Q) h)\"\n  \"(\\<up>P ** Q) h = (P \\<and> Q h)\"\n  \"\\<up>True = \\<box>\"\n  \"\\<up>False = sep_false\"", "lemma sep_pure_front2[simp]: \n  \"(\\<up>P ** A ** \\<up>Q ** F) = (\\<up>(P \\<and> Q) ** F ** A)\"", "lemma ex_h_simps[simp]: \n  \"Ex (\\<up>\\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"Ex (\\<up>\\<Phi> ** P) \\<longleftrightarrow> (\\<Phi> \\<and> Ex P)\"", "lemma\n  fixes h :: \"('a \\<Rightarrow> 'b option) * nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\"", "lemma map_le_substate_conv: \"map_le = sep_substate\""], "translations": [["", "lemma puree_alt: \"\\<up>\\<Phi> = (\\<langle>\\<Phi>\\<rangle> and \\<box>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> \\<Phi> = (\\<lambda>s. \\<Phi> \\<and> \\<box> s)", "by (auto simp: puree_def sep_empty_def)"], ["", "lemma pure_alt: \"\\<langle>\\<Phi>\\<rangle> = (\\<up>\\<Phi> ** sep_true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) = (\\<up> \\<Phi> \\<and>* (\\<lambda>s. True))", "apply (clarsimp simp: puree_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "fix aa :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "obtain aaa :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a\" where\n      ff1: \"\\<And>p pa a pb pc aa. (\\<not> (p \\<and>* pa) a \\<or> p (aaa p pb) \\<or> (pb \\<and>*\npa) a) \\<and> (\\<not> pb (aaa p pb) \\<or> \\<not> (p \\<and>* pc) aa \\<or> (pb \\<and>* pc) aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>aaa.\n        (\\<And>p pa a pb pc aa.\n            (\\<not> (p \\<and>* pa) a \\<or>\n             p (aaa p pb) \\<or> (pb \\<and>* pa) a) \\<and>\n            (\\<not> pb (aaa p pb) \\<or>\n             \\<not> (p \\<and>* pc) aa \\<or>\n             (pb \\<and>* pc) aa)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) sep_globalise)"], ["proof (state)\nthis:\n  (\\<not> (?p \\<and>* ?pa) ?a \\<or>\n   ?p (aaa ?p ?pb) \\<or> (?pb \\<and>* ?pa) ?a) \\<and>\n  (\\<not> ?pb (aaa ?p ?pb) \\<or>\n   \\<not> (?p \\<and>* ?pc) ?aa \\<or> (?pb \\<and>* ?pc) ?aa)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "then"], ["proof (chain)\npicking this:\n  (\\<not> (?p \\<and>* ?pa) ?a \\<or>\n   ?p (aaa ?p ?pb) \\<or> (?pb \\<and>* ?pa) ?a) \\<and>\n  (\\<not> ?pb (aaa ?p ?pb) \\<or>\n   \\<not> (?p \\<and>* ?pc) ?aa \\<or> (?pb \\<and>* ?pc) ?aa)", "have \"\\<exists>p. ((\\<lambda>a. a = 0) \\<and>* p) aa\""], ["proof (prove)\nusing this:\n  (\\<not> (?p \\<and>* ?pa) ?a \\<or>\n   ?p (aaa ?p ?pb) \\<or> (?pb \\<and>* ?pa) ?a) \\<and>\n  (\\<not> ?pb (aaa ?p ?pb) \\<or>\n   \\<not> (?p \\<and>* ?pc) ?aa \\<or> (?pb \\<and>* ?pc) ?aa)\n\ngoal (1 subgoal):\n 1. \\<exists>p. ((\\<lambda>a. a = (0::'a)) \\<and>* p) aa", "by (metis (full_types) sep_conj_commuteI sep_conj_sep_emptyE\nsep_empty_def)"], ["proof (state)\nthis:\n  \\<exists>p. ((\\<lambda>a. a = (0::'a)) \\<and>* p) aa\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. ((\\<lambda>a. a = (0::'a)) \\<and>* p) aa", "have \"\\<not> \\<Phi> \\<or> \\<Phi> \\<and> ((\\<lambda>a. a = 0) \\<and>* (\\<lambda>a. True)) aa\""], ["proof (prove)\nusing this:\n  \\<exists>p. ((\\<lambda>a. a = (0::'a)) \\<and>* p) aa\n\ngoal (1 subgoal):\n 1. \\<not> \\<Phi> \\<or>\n    \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) aa", "using ff1"], ["proof (prove)\nusing this:\n  \\<exists>p. ((\\<lambda>a. a = (0::'a)) \\<and>* p) aa\n  (\\<not> (?p \\<and>* ?pa) ?a \\<or>\n   ?p (aaa ?p ?pb) \\<or> (?pb \\<and>* ?pa) ?a) \\<and>\n  (\\<not> ?pb (aaa ?p ?pb) \\<or>\n   \\<not> (?p \\<and>* ?pc) ?aa \\<or> (?pb \\<and>* ?pc) ?aa)\n\ngoal (1 subgoal):\n 1. \\<not> \\<Phi> \\<or>\n    \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) aa", "by (metis (no_types) sep_conj_commuteI)"], ["proof (state)\nthis:\n  \\<not> \\<Phi> \\<or>\n  \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) aa\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "}"], ["proof (state)\nthis:\n  \\<not> \\<Phi> \\<or>\n  \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) ?aa2\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<Phi>) =\n    (\\<lambda>h.\n        \\<Phi> \\<and>\n        ((\\<lambda>h. h = (0::'a)) \\<and>* (\\<lambda>s. True)) h)", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<Phi> \\<or>\n  \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) ?aa2", "show \"(\\<lambda>a. \\<Phi>) = (\\<lambda>a. \\<Phi> \\<and> ((\\<lambda>a. (a::'a) = 0) \\<and>* (\\<lambda>a. True)) a)\""], ["proof (prove)\nusing this:\n  \\<not> \\<Phi> \\<or>\n  \\<Phi> \\<and> ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) ?aa2\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. \\<Phi>) =\n    (\\<lambda>a.\n        \\<Phi> \\<and>\n        ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) a)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>a. \\<Phi>) =\n  (\\<lambda>a.\n      \\<Phi> \\<and>\n      ((\\<lambda>a. a = (0::'a)) \\<and>* (\\<lambda>a. True)) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation NO_PURE :: \"bool \\<Rightarrow> ('h::sep_algebra \\<Rightarrow> bool) \\<Rightarrow> bool\" \n  where \"NO_PURE X Q \\<equiv> (NO_MATCH (\\<langle>X\\<rangle>::'h\\<Rightarrow>bool) Q \\<and> NO_MATCH ((\\<up>X)::'h\\<Rightarrow>bool) Q)\""], ["", "named_theorems sep_simplify \\<open>Assertion simplifications\\<close>"], ["", "lemma sep_reorder[sep_simplify]:  \n  \"((a \\<and>* b) \\<and>* c) = (a \\<and>* b \\<and>* c)\"\n  \"(NO_PURE X a) \\<Longrightarrow> (a ** b) = (b ** a)\"\n  \"(NO_PURE X b) \\<Longrightarrow> (b \\<and>* a \\<and>* c) = (a \\<and>* b \\<and>* c)\"\n  \"(Q ** \\<langle>P\\<rangle>) = (\\<langle>P\\<rangle> ** Q)\"\n  \"(Q ** \\<up>P) = (\\<up>P ** Q)\"\n  \"NO_PURE X Q \\<Longrightarrow> (Q ** \\<langle>P\\<rangle> ** F) = (\\<langle>P\\<rangle> ** Q ** F)\"\n  \"NO_PURE X Q \\<Longrightarrow> (Q ** \\<up>P ** F) = (\\<up>P ** Q ** F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a \\<and>* b) \\<and>* c) = (a \\<and>* b \\<and>* c) &&&\n     (NO_MATCH (\\<lambda>s. X) a \\<and>\n      NO_MATCH (\\<up> X) a \\<Longrightarrow>\n      (a \\<and>* b) = (b \\<and>* a)) &&&\n     (NO_MATCH (\\<lambda>s. X) b \\<and>\n      NO_MATCH (\\<up> X) b \\<Longrightarrow>\n      (b \\<and>* a \\<and>* c) = (a \\<and>* b \\<and>* c))) &&&\n    ((Q \\<and>* (\\<lambda>s. P)) = ((\\<lambda>s. P) \\<and>* Q) &&&\n     (Q \\<and>* \\<up> P) = (\\<up> P \\<and>* Q)) &&&\n    (NO_MATCH (\\<lambda>s. X) Q \\<and>\n     NO_MATCH (\\<up> X) Q \\<Longrightarrow>\n     (Q \\<and>* (\\<lambda>s. P) \\<and>* F) =\n     ((\\<lambda>s. P) \\<and>* Q \\<and>* F)) &&&\n    (NO_MATCH (\\<lambda>s. X) Q \\<and>\n     NO_MATCH (\\<up> X) Q \\<Longrightarrow>\n     (Q \\<and>* \\<up> P \\<and>* F) = (\\<up> P \\<and>* Q \\<and>* F))", "by (simp_all add: sep.add_ac)"], ["", "lemma sep_combine1[simp]:\n  \"(\\<up>P ** \\<up>Q) = \\<up>(P\\<and>Q)\"\n  \"(\\<langle>P\\<rangle> ** \\<langle>Q\\<rangle>) = \\<langle>P\\<and>Q\\<rangle>\"\n  \"(\\<up>P ** \\<langle>Q\\<rangle>) = \\<langle>P\\<and>Q\\<rangle>\"\n  \"(\\<langle>P\\<rangle> ** \\<up>Q) = \\<langle>P\\<and>Q\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<up> P \\<and>* \\<up> Q) = \\<up> (P \\<and> Q) &&&\n     ((\\<lambda>s. P) \\<and>* (\\<lambda>s. Q)) =\n     (\\<lambda>s. P \\<and> Q)) &&&\n    (\\<up> P \\<and>* (\\<lambda>s. Q)) = (\\<lambda>s. P \\<and> Q) &&&\n    ((\\<lambda>s. P) \\<and>* \\<up> Q) = (\\<lambda>s. P \\<and> Q)", "apply (auto simp add: sep_conj_def puree_def intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>P; Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. x ## y \\<and> h = x + y", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>P; Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. (0::'b) ## y \\<and> h = (0::'b) + y", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sep_combine2[simp]:\n  \"(\\<up>P ** \\<up>Q ** F) = (\\<up>(P\\<and>Q) ** F)\"\n  \"(\\<langle>P\\<rangle> ** \\<langle>Q\\<rangle> ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\"\n  \"(\\<up>P ** \\<langle>Q\\<rangle> ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\"\n  \"(\\<langle>P\\<rangle> ** \\<up>Q ** F) = (\\<langle>P\\<and>Q\\<rangle> ** F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<up> P \\<and>* \\<up> Q \\<and>* F) =\n     (\\<up> (P \\<and> Q) \\<and>* F) &&&\n     ((\\<lambda>s. P) \\<and>* (\\<lambda>s. Q) \\<and>* F) =\n     ((\\<lambda>s. P \\<and> Q) \\<and>* F)) &&&\n    (\\<up> P \\<and>* (\\<lambda>s. Q) \\<and>* F) =\n    ((\\<lambda>s. P \\<and> Q) \\<and>* F) &&&\n    ((\\<lambda>s. P) \\<and>* \\<up> Q \\<and>* F) =\n    ((\\<lambda>s. P \\<and> Q) \\<and>* F)", "apply (subst sep.add_assoc[symmetric]; simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sep_extract_pure[simp]:\n  \"NO_MATCH True P \\<Longrightarrow> (\\<langle>P\\<rangle> ** Q) h = (P \\<and> (sep_true ** Q) h)\"\n  \"(\\<up>P ** Q) h = (P \\<and> Q h)\"\n  \"\\<up>True = \\<box>\"\n  \"\\<up>False = sep_false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((NO_MATCH True P \\<Longrightarrow>\n      ((\\<lambda>s. P) \\<and>* Q) h =\n      (P \\<and> ((\\<lambda>s. True) \\<and>* Q) h)) &&&\n     (\\<up> P \\<and>* Q) h = (P \\<and> Q h)) &&&\n    \\<up> True = \\<box> &&& \\<up> False = (\\<lambda>s. False)", "using sep_conj_sep_true_right"], ["proof (prove)\nusing this:\n  (?P \\<and>* ?Q) ?h \\<Longrightarrow> (?P \\<and>* (\\<lambda>s. True)) ?h\n\ngoal (1 subgoal):\n 1. ((NO_MATCH True P \\<Longrightarrow>\n      ((\\<lambda>s. P) \\<and>* Q) h =\n      (P \\<and> ((\\<lambda>s. True) \\<and>* Q) h)) &&&\n     (\\<up> P \\<and>* Q) h = (P \\<and> Q h)) &&&\n    \\<up> True = \\<box> &&& \\<up> False = (\\<lambda>s. False)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<up> P \\<and>* Q) h = (P \\<and> Q h)\n 2. \\<up> True = \\<box>\n 3. \\<up> False = (\\<lambda>s. False)", "by (auto simp: puree_def sep_empty_def[symmetric])"], ["", "lemma sep_pure_front2[simp]: \n  \"(\\<up>P ** A ** \\<up>Q ** F) = (\\<up>(P \\<and> Q) ** F ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> P \\<and>* A \\<and>* \\<up> Q \\<and>* F) =\n    (\\<up> (P \\<and> Q) \\<and>* F \\<and>* A)", "apply (simp add: sep_reorder)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_h_simps[simp]: \n  \"Ex (\\<up>\\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"Ex (\\<up>\\<Phi> ** P) \\<longleftrightarrow> (\\<Phi> \\<and> Ex P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (\\<up> \\<Phi>) = \\<Phi> &&&\n    Ex (\\<up> \\<Phi> \\<and>* P) = (\\<Phi> \\<and> Ex P)", "apply (cases \\<Phi>; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (\\<up> \\<Phi> \\<and>* P) = (\\<Phi> \\<and> Ex P)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  fixes h :: \"('a \\<Rightarrow> 'b option) * nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* H) h = (Q \\<and>* H \\<and>* P) h", "by (simp add: sep_conj_ac)"], ["", "(* map_le *)"], ["", "lemma map_le_substate_conv: \"map_le = sep_substate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<subseteq>\\<^sub>m) = (\\<preceq>)", "unfolding map_le_def sep_substate_def sep_disj_fun_def plus_fun_def domain_def dom_def none_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m\\<^sub>1 m\\<^sub>2.\n        \\<forall>a\\<in>{a. m\\<^sub>1 a \\<noteq> None}.\n           m\\<^sub>1 a = m\\<^sub>2 a) =\n    (\\<lambda>x y.\n        \\<exists>z.\n           {xa. x xa \\<noteq> None} \\<inter> {x. z x \\<noteq> None} =\n           {} \\<and>\n           (\\<lambda>xa. if z xa = None then x xa else z xa) = y)", "apply (auto intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 m\\<^sub>2.\n       \\<forall>a.\n          (\\<exists>y. m\\<^sub>1 a = Some y) \\<longrightarrow>\n          m\\<^sub>1 a = m\\<^sub>2 a \\<Longrightarrow>\n       \\<exists>z.\n          {x. \\<exists>y. m\\<^sub>1 x = Some y} \\<inter>\n          {x. \\<exists>y. z x = Some y} =\n          {} \\<and>\n          (\\<lambda>x. if z x = None then m\\<^sub>1 x else z x) = m\\<^sub>2\n 2. \\<And>m\\<^sub>1 z a y ya.\n       \\<lbrakk>{x. \\<exists>y. m\\<^sub>1 x = Some y} \\<inter>\n                {x. \\<exists>y. z x = Some y} =\n                {};\n        m\\<^sub>1 a = Some y; z a = Some ya\\<rbrakk>\n       \\<Longrightarrow> y = ya", "subgoal for m1 m2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (\\<exists>y. m1 a = Some y) \\<longrightarrow>\n       m1 a = m2 a \\<Longrightarrow>\n    \\<exists>z.\n       {x. \\<exists>y. m1 x = Some y} \\<inter>\n       {x. \\<exists>y. z x = Some y} =\n       {} \\<and>\n       (\\<lambda>x. if z x = None then m1 x else z x) = m2", "apply(rule exI[where x=\"%x. if (\\<exists>y. m1 x = Some y) then None else m2 x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (\\<exists>y. m1 a = Some y) \\<longrightarrow>\n       m1 a = m2 a \\<Longrightarrow>\n    {x. \\<exists>y. m1 x = Some y} \\<inter>\n    {x. \\<exists>y.\n           (if \\<exists>y. m1 x = Some y then None else m2 x) = Some y} =\n    {} \\<and>\n    (\\<lambda>x.\n        if (if \\<exists>y. m1 x = Some y then None else m2 x) = None\n        then m1 x else if \\<exists>y. m1 x = Some y then None else m2 x) =\n    m2", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 z a y ya.\n       \\<lbrakk>{x. \\<exists>y. m\\<^sub>1 x = Some y} \\<inter>\n                {x. \\<exists>y. z x = Some y} =\n                {};\n        m\\<^sub>1 a = Some y; z a = Some ya\\<rbrakk>\n       \\<Longrightarrow> y = ya", "by blast"], ["", "end"]]}