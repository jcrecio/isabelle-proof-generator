{"file_name": "/home/qj213/afp-2021-10-22/thys/Hoare_Time/Nielson_VCG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hoare_Time", "problem_names": ["lemma expr_lupd: \"x \\<notin> supportE Q \\<Longrightarrow> Q (l(x:=n)) = Q l\"", "lemma supportE_if: \"supportE (\\<lambda>l s. if b s then A l s else B l s)\n  \\<subseteq> supportE A \\<union> supportE B\"", "lemma support_eq: \"support (\\<lambda>l s. l x = E l s) \\<subseteq> supportE E \\<union> {x}\"", "lemma support_impl_in: \"G e \\<longrightarrow> support (\\<lambda>l s.  H e l s) \\<subseteq> T\n  \\<Longrightarrow> support (\\<lambda>l s. G e \\<longrightarrow>  H e l s) \\<subseteq> T\"", "lemma support_supportE: \"\\<And>P e. support (\\<lambda>l s.  P (e l) s) \\<subseteq> supportE e\"", "lemma preT_linear: \"preT C (%s. k * e s) = (%s. k * preT C e s)\"", "lemma TQ: \"preT C e s = e (postQ C s)\"", "lemma assumes I: \"I z s\" and\n  i:   \"\\<And>s z. I (Suc z) s \\<Longrightarrow> bval b s \\<and> I z (postQ C s)\"\n  and  ii:  \"\\<And>s. I 0 s \\<Longrightarrow> ~ bval b s\"\nshows times_z: \"times s b C = z\"", "lemma TzQ: \"preTz C e n s = e (postQz C s n)\"", "lemma supportE_preT: \"supportE (%l. preT C (e l)) \\<subseteq> supportE e\"", "lemma supportE_twicepreT: \"supportE (%l. preT C1 (preT C2 (e l))) \\<subseteq> supportE e\"", "lemma supportE_preTz: \"supportE (%l. preTz C (e l) n) \\<subseteq> supportE e\"", "lemma supportE_preTz_Un: (* like in support_wpw_Un *)\n  \"supportE (\\<lambda>l. preTz C (e l) (l x)) \\<subseteq> insert x (UN n. supportE (\\<lambda>l. preTz C (e l) n))\"", "lemma supportE_preTz2: \"supportE (%l. preTz C (e l) (l x)) \\<subseteq> insert x (supportE e)\"", "lemma pff: \"\\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I - {x}\"", "lemma pff: \"\\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I\"", "lemma supportAB: \"support (\\<lambda>l s. A l s \\<and> B s) \\<subseteq> support A\"", "lemma \"support (pre ({(I,(S,(E )))} WHILE b DO C) Q) \\<subseteq> support I\"", "lemma support_pre: \"support (pre C Q) \\<subseteq> support Q \\<union> varacom C\"", "lemma finite_support_pre[simp]: \"finite (support Q)  \\<Longrightarrow> finite (varacom C) \\<Longrightarrow>  finite (support (pre C Q))\"", "lemma supportE_single: \"supportE (\\<lambda>l s. P) = {}\"", "lemma supportE_plus: \"supportE (\\<lambda>l s. e1 l s + e2 l s) \\<subseteq> supportE e1 \\<union> supportE e2\"", "lemma supportE_Suc: \"supportE (\\<lambda>l s. Suc (e1 l s)) = supportE e1\"", "lemma supportE_single2: \"supportE (\\<lambda>l . P) = {}\"", "lemma supportE_time: \"supportE (\\<lambda>l. time C) = {}\"", "lemma \"\\<And>s. (\\<forall>l. I (l(x:=0)) s) = (\\<forall>l. l x = 0 \\<longrightarrow> I l s)\"", "lemma \"\\<And>s. (\\<forall>l. I (l(x:=Suc (l x))) s) = (\\<forall>l. (\\<exists>n. l x = Suc n) \\<longrightarrow> I l s)\"", "lemma pre_mono:\n  \"(\\<forall>l s. P l s \\<longrightarrow> P' l s) \\<Longrightarrow> pre C P l s \\<Longrightarrow> pre C P' l s\"", "lemma vc_mono: \"(\\<forall>l s. P l s \\<longrightarrow> P' l s) \\<Longrightarrow> vc C P \\<Longrightarrow> vc C P'\"", "lemma allg: \n  assumes U2: \"\\<And>l s n x. x\\<in> fst ` upds \\<Longrightarrow> A (l(x := n))  = A l\"\n  shows\n    \"fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow> A (ListUpdate l'' xs q) = A l''\"", "lemma ListUpdate_E: \"ListUpdateE f xs = ListUpdate f xs (%e x. e)\"", "lemma allg_E: fixes A::assn2\n    assumes \n   \" (\\<And>l s n x. x \\<in> fst ` upds \\<Longrightarrow> A (l(x := n)) = A l)\" \"fst ` set xs \\<subseteq> fst ` upds\"\n   shows \"A (ListUpdateE f xs) = A f\"", "lemma ListUpdateE_updates: \"distinct (map fst xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x\"", "lemma ListUpdate_updates: \"x \\<in> fst ` (set xs) \\<Longrightarrow> ListUpdate l'' xs (%e. l) x = l x\"", "lemma preList_Seq: \"preList upds (C1;; C2) l s = preList (map (\\<lambda>(x, e). (x, preT C2 e)) upds) C1 l s\"", "lemma support_True[simp]: \"support (\\<lambda>a b. True) = {}\"", "lemma support_preList: \"support (preList upds C1) \\<subseteq> lesvars upds\"", "lemma preListpreSet: \"preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\"", "lemma preSetpreList: \"preList xs C l s \\<Longrightarrow>  preSet (set xs) C l s\"", "lemma preSetpreList_eq: \"preList xs C l s = preSet (set xs) C l s\"", "lemma support_postList: \"support (postList xs) \\<subseteq> lesvars xs\"", "lemma postpreList_inv: assumes \"S s = S (postQ C s)\" \n  shows \"postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s =  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s\"", "lemma postList_preList: \"postList (map (\\<lambda>(x, e). (x, preT C e)) upds) l s = preList upds C l s\"", "lemma postSetpostList: \"postList xs l s \\<Longrightarrow>  postSet (set xs) l s\"", "lemma postListpostSet: \"postSet (set xs) l s \\<Longrightarrow> postList xs l s\"", "lemma ListAskip: \"preList xs Askip l s = postList xs  l s\"", "lemma SetAskip: \"preSet U Askip l s = postSet U l s\"", "lemma ListAassign: \"preList upds (Aassign x1 x2) l s = postList upds l (s[x2/x1])\"", "lemma SetAassign: \"preSet U (Aassign x1 x2) l s = postSet U l (s[x2/x1])\"", "lemma ListAconseq: \"preList upds (Aconseq x1 x2 x3 C) l s = preList upds C l s\"", "lemma SetAconseq: \"preSet U (Aconseq x1 x2 x3 C) l s = preSet U C l s\"", "lemma ListAif1: \"bval b s \\<Longrightarrow> preList upds (IF b THEN C1 ELSE C2) l s = preList upds C1 l s\"", "lemma SetAif1: \"bval b s \\<Longrightarrow> preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C1 l s\"", "lemma ListAif2: \"~ bval b s \\<Longrightarrow> preList upds (IF b THEN C1 ELSE C2) l s = preList upds C2 l s\"", "lemma SetAif2: \"~ bval b s \\<Longrightarrow> preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C2 l s\"", "lemma vc_sound: \"vc C Q \\<Longrightarrow> finite (support Q) \\<Longrightarrow> finite (varacom C)\n  \\<Longrightarrow> fst ` (set upds) \\<inter> varacom C = {} \\<Longrightarrow> distinct (map fst upds)\n  \\<Longrightarrow>  \\<turnstile>\\<^sub>1 {%l s. pre C Q l s \\<and> preList upds C l s} strip C { time C \\<Down> %l s. Q l s \\<and> postList upds l s}\n  \\<and> (\\<forall>l s. pre C Q l s \\<longrightarrow> Q l (postQ C s))\"", "lemma preT_constant: \"preT C (%_. a) = (%_. a)\"", "lemma vc_complete:\n  \"\\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q} \\<Longrightarrow>   \\<exists>C. strip C = c \\<and> vc C Q \n  \\<and> (\\<forall>l s. P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s))\n  \\<and> (\\<exists>k. \\<forall>l s. P l s \\<longrightarrow>  time C s \\<le> k * e s)  \"\n  (is \"_ \\<Longrightarrow>   \\<exists>C. ?G P c Q C e\")"], "translations": [["", "lemma expr_lupd: \"x \\<notin> supportE Q \\<Longrightarrow> Q (l(x:=n)) = Q l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> supportE Q \\<Longrightarrow> Q (l(x := n)) = Q l", "by(simp add: supportE_def fun_upd_other fun_eq_iff)\n    (metis (no_types, lifting) fun_upd_def)"], ["", "lemma supportE_if: \"supportE (\\<lambda>l s. if b s then A l s else B l s)\n  \\<subseteq> supportE A \\<union> supportE B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l s. if b s then A l s else B l s)\n    \\<subseteq> supportE A \\<union> supportE B", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           (if b s then A l1 s else B l1 s) \\<noteq>\n           (if b s then A l2 s else B l2 s)}\n    \\<subseteq> {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       A l1 s \\<noteq> A l2 s} \\<union>\n                {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       B l1 s \\<noteq> B l2 s}", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 s.\n       \\<lbrakk>\\<forall>l1 l2.\n                   (\\<exists>y.\n                       y \\<noteq> x \\<and> l1 y \\<noteq> l2 y) \\<or>\n                   (\\<forall>s. B l1 s = B l2 s);\n        \\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y; \\<not> b s;\n        B l1 s \\<noteq> B l2 s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> x \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. A l1 s \\<noteq> A l2 s)\n 2. \\<And>x l1 l2 s.\n       \\<lbrakk>\\<forall>l1 l2.\n                   (\\<exists>y.\n                       y \\<noteq> x \\<and> l1 y \\<noteq> l2 y) \\<or>\n                   (\\<forall>s. B l1 s = B l2 s);\n        \\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        A l1 s \\<noteq> A l2 s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> x \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. A l1 s = A l2 s);\n        b s\\<rbrakk>\n       \\<Longrightarrow> False", "by metis+"], ["", "lemma support_eq: \"support (\\<lambda>l s. l x = E l s) \\<subseteq> supportE E \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. l x = E l s) \\<subseteq> supportE E \\<union> {x}", "unfolding support_def supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa.\n     \\<exists>l1 l2 s.\n        (\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y) \\<and>\n        (l1 x = E l1 s) \\<noteq> (l2 x = E l2 s)}\n    \\<subseteq> {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       E l1 s \\<noteq> E l2 s} \\<union>\n                {x}", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa l1 l2 s.\n       \\<lbrakk>xa \\<noteq> x;\n        \\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        l2 x = E l1 s; E l1 s \\<noteq> E l2 s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> xa \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. E l1 s \\<noteq> E l2 s)\n 2. \\<And>xa l1 l2 s.\n       \\<lbrakk>xa \\<noteq> x;\n        \\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        E l2 s \\<noteq> E l1 s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. E l1 s = E l2 s);\n        l2 x = E l2 s\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa l1 l2 s.\n       \\<lbrakk>xa \\<noteq> x;\n        \\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        E l2 s \\<noteq> E l1 s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. E l1 s = E l2 s);\n        l2 x = E l2 s\\<rbrakk>\n       \\<Longrightarrow> False", "by metis"], ["", "lemma support_impl_in: \"G e \\<longrightarrow> support (\\<lambda>l s.  H e l s) \\<subseteq> T\n  \\<Longrightarrow> support (\\<lambda>l s. G e \\<longrightarrow>  H e l s) \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G e \\<longrightarrow> support (H e) \\<subseteq> T \\<Longrightarrow>\n    support (\\<lambda>l s. G e \\<longrightarrow> H e l s) \\<subseteq> T", "unfolding support_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. G e \\<longrightarrow>\n    {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           H e l1 s \\<noteq> H e l2 s}\n    \\<subseteq> T \\<Longrightarrow>\n    {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           (G e \\<longrightarrow> H e l1 s) \\<noteq>\n           (G e \\<longrightarrow> H e l2 s)}\n    \\<subseteq> T", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        {x. \\<exists>l1 l2.\n               (\\<forall>y.\n                   y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n               (\\<exists>s. H e l1 s = (\\<not> H e l2 s))}\n        \\<subseteq> T;\n        G e; \\<not> H e l2 s; H e l1 s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T\n 2. \\<And>x l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        {x. \\<exists>l1 l2.\n               (\\<forall>y.\n                   y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n               (\\<exists>s. H e l1 s = (\\<not> H e l2 s))}\n        \\<subseteq> T;\n        x \\<notin> T; G e; \\<not> H e l1 s; H e l2 s\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma support_supportE: \"\\<And>P e. support (\\<lambda>l s.  P (e l) s) \\<subseteq> supportE e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P e. support (\\<lambda>l. P (e l)) \\<subseteq> supportE e", "unfolding support_def supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P e.\n       {x. \\<exists>l1 l2 s.\n              (\\<forall>y.\n                  y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n              P (e l1) s \\<noteq> P (e l2) s}\n       \\<subseteq> {x. \\<exists>l1 l2 s.\n                          (\\<forall>y.\n                              y \\<noteq> x \\<longrightarrow>\n                              l1 y = l2 y) \\<and>\n                          e l1 s \\<noteq> e l2 s}", "apply(rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P e x.\n       x \\<in> {x. \\<exists>l1 l2 s.\n                      (\\<forall>y.\n                          y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n                      P (e l1) s \\<noteq> P (e l2) s} \\<Longrightarrow>\n       x \\<in> {x. \\<exists>l1 l2 s.\n                      (\\<forall>y.\n                          y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n                      e l1 s \\<noteq> e l2 s}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P e x.\n       \\<exists>l1 l2.\n          (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n          (\\<exists>s. P (e l1) s = (\\<not> P (e l2) s)) \\<Longrightarrow>\n       \\<exists>l1 l2.\n          (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n          (\\<exists>s. e l1 s \\<noteq> e l2 s)", "proof (clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P e x l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        P (e l1) s = (\\<not> P (e l2) s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> x \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. e l1 s \\<noteq> e l2 s)", "case (1 P e x l1 l2 s)"], ["proof (state)\nthis:\n  \\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y\n  P (e l1) s = (\\<not> P (e l2) s)\n\ngoal (1 subgoal):\n 1. \\<And>P e x l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        P (e l1) s = (\\<not> P (e l2) s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> x \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. e l1 s \\<noteq> e l2 s)", "have P: \"\\<forall>s. e l1 s = e l2 s \\<Longrightarrow> e l1 = e l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. e l1 s = e l2 s \\<Longrightarrow> e l1 = e l2", "by fast"], ["proof (state)\nthis:\n  \\<forall>s. e l1 s = e l2 s \\<Longrightarrow> e l1 = e l2\n\ngoal (1 subgoal):\n 1. \\<And>P e x l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        P (e l1) s = (\\<not> P (e l2) s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> x \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. e l1 s \\<noteq> e l2 s)", "show \"\\<exists>l1 l2. (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and> (\\<exists>s. e l1 s \\<noteq> e l2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n       (\\<exists>s. e l1 s \\<noteq> e l2 s)", "apply(rule exI[where x=l1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l2.\n       (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n       (\\<exists>s. e l1 s \\<noteq> e l2 s)", "apply(rule exI[where x=l2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n    (\\<exists>s. e l1 s \\<noteq> e l2 s)", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. y \\<noteq> x \\<Longrightarrow> l1 y = l2 y\n 2. \\<exists>s. e l1 s \\<noteq> e l2 s", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y\n  P (e l1) s = (\\<not> P (e l2) s)\n\ngoal (2 subgoals):\n 1. \\<And>y. y \\<noteq> x \\<Longrightarrow> l1 y = l2 y\n 2. \\<exists>s. e l1 s \\<noteq> e l2 s", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. e l1 s \\<noteq> e l2 s", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>s. e l1 s \\<noteq> e l2 s \\<Longrightarrow> False", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. e l1 s = e l2 s \\<Longrightarrow> False", "using 1(2) P"], ["proof (prove)\nusing this:\n  P (e l1) s = (\\<not> P (e l2) s)\n  \\<forall>s. e l1 s = e l2 s \\<Longrightarrow> e l1 = e l2\n\ngoal (1 subgoal):\n 1. \\<forall>s. e l1 s = e l2 s \\<Longrightarrow> False", "by force"], ["proof (state)\nthis:\n  \\<exists>l1 l2.\n     (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n     (\\<exists>s. e l1 s \\<noteq> e l2 s)\n\ngoal:\nNo subgoals!", "qed \n  \n\\<comment> \\<open>collects the logical variables in the Invariants and Loop Bodies as well as the annotated\n    assertions at CONSEQs of an annotated command\\<close>"], ["", "fun varacom :: \"acom \\<Rightarrow> lvname set\" where\n  \"varacom (C\\<^sub>1;; C\\<^sub>2)= varacom C\\<^sub>1 \\<union> varacom C\\<^sub>2\"\n| \"varacom (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2)= varacom C\\<^sub>1 \\<union> varacom C\\<^sub>2\"\n| \"varacom ({P/Qannot/_} CONSEQ C)= support P \\<union> varacom C \\<union> support Qannot\"\n| \"varacom ({(I,(S,(E)))} WHILE b DO C) = support I \\<union> varacom C\"\n| \"varacom _ = {}\""], ["", "text\\<open>Weakest precondition from annotated commands:\\<close>"], ["", "fun preT :: \"acom \\<Rightarrow> tbd \\<Rightarrow> tbd\" where\n  \"preT SKIP e = e\" |\n  \"preT (x ::= a) e = (\\<lambda>s. e(s(x := aval a s)))\" |\n  \"preT (C\\<^sub>1;; C\\<^sub>2) e = preT C\\<^sub>1 (preT C\\<^sub>2 e)\" |\n  \"preT ({_/_/_} CONSEQ C) e = preT C e\" |\n  \"preT (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2) e =\n  (\\<lambda>s. if bval b s then preT C\\<^sub>1 e s else preT C\\<^sub>2 e s)\" |\n  \"preT ({(_,(S,_))} WHILE b DO C) e = e o S\""], ["", "lemma preT_linear: \"preT C (%s. k * e s) = (%s. k * preT C e s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preT C (\\<lambda>s. k * e s) = (\\<lambda>s. k * preT C e s)", "by (induct C arbitrary: e, auto)"], ["", "fun postQ :: \"acom \\<Rightarrow> state \\<Rightarrow> state\" where (* seems to be forward?! *)\n  \"postQ SKIP s = s\" |\n  \"postQ (x ::= a) s =  s(x := aval a s)\" |\n  \"postQ (C\\<^sub>1;; C\\<^sub>2) s = postQ C\\<^sub>2 (postQ C\\<^sub>1 s)\" |\n  \"postQ ({_/_/_} CONSEQ C) s = postQ C s\" |\n  \"postQ (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2) s =\n  (if bval b s then postQ C\\<^sub>1 s else postQ C\\<^sub>2 s)\" |\n  \"postQ ({(_,(S,_))} WHILE b DO C) s = S s\""], ["", "lemma TQ: \"preT C e s = e (postQ C s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preT C e s = e (postQ C s)", "apply(induct C arbitrary: e s)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>e s. preT SKIP e s = e (postQ SKIP s)\n 2. \\<And>x1 x2 e s. preT (x1 ::= x2) e s = e (postQ (x1 ::= x2) s)\n 3. \\<And>C1 C2 e s.\n       \\<lbrakk>\\<And>e s. preT C1 e s = e (postQ C1 s);\n        \\<And>e s. preT C2 e s = e (postQ C2 s)\\<rbrakk>\n       \\<Longrightarrow> preT (C1;; C2) e s = e (postQ (C1;; C2) s)\n 4. \\<And>x1 C1 C2 e s.\n       \\<lbrakk>\\<And>e s. preT C1 e s = e (postQ C1 s);\n        \\<And>e s. preT C2 e s = e (postQ C2 s)\\<rbrakk>\n       \\<Longrightarrow> preT (IF x1 THEN C1 ELSE C2) e s =\n                         e (postQ (IF x1 THEN C1 ELSE C2) s)\n 5. \\<And>x1 x2 x3 C e s.\n       (\\<And>e s. preT C e s = e (postQ C s)) \\<Longrightarrow>\n       preT ({x1/x2/x3} CONSEQ C) e s = e (postQ ({x1/x2/x3} CONSEQ C) s)\n 6. \\<And>x1 x2 C e s.\n       (\\<And>e s. preT C e s = e (postQ C s)) \\<Longrightarrow>\n       preT ({x1} WHILE x2 DO C) e s = e (postQ ({x1} WHILE x2 DO C) s)", "by (auto)"], ["", "(* given a state, how often will a While loop be evaluated ? *)"], ["", "function (domintros) times :: \"state \\<Rightarrow> bexp \\<Rightarrow> acom \\<Rightarrow> nat\" where\n  \"times s b C = (if bval b s then Suc (times (postQ C s) b C) else 0)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>s b C. x = (s, b, C) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>s b C sa ba Ca.\n       (s, b, C) = (sa, ba, Ca) \\<Longrightarrow>\n       (if bval b s then Suc (times_sumC (postQ C s, b, C)) else 0) =\n       (if bval ba sa then Suc (times_sumC (postQ Ca sa, ba, Ca)) else 0)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes I: \"I z s\" and\n  i:   \"\\<And>s z. I (Suc z) s \\<Longrightarrow> bval b s \\<and> I z (postQ C s)\"\n  and  ii:  \"\\<And>s. I 0 s \\<Longrightarrow> ~ bval b s\"\nshows times_z: \"times s b C = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = z", "have \"I z s \\<Longrightarrow> times_dom (s, b, C) \\<and> times s b C = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I z s \\<Longrightarrow>\n    times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z", "proof(induct z arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       I 0 s \\<Longrightarrow>\n       times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0\n 2. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "case 0"], ["proof (state)\nthis:\n  I 0 s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       I 0 s \\<Longrightarrow>\n       times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0\n 2. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "have A: \"times_dom (s, b, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_dom (s, b, C)", "apply(rule times.domintros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bval b s \\<Longrightarrow> times_dom (postQ C s, b, C)", "apply(simp add:  ii[OF 0] )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  times_dom (s, b, C)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       I 0 s \\<Longrightarrow>\n       times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0\n 2. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "have B: \"times s b C = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = 0", "using times.psimps[OF A]"], ["proof (prove)\nusing this:\n  Nielson_VCG.times s b C =\n  (if bval b s then Suc (Nielson_VCG.times (postQ C s) b C) else 0)\n\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = 0", "by(simp add:  ii[OF 0])"], ["proof (state)\nthis:\n  Nielson_VCG.times s b C = 0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       I 0 s \\<Longrightarrow>\n       times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0\n 2. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0", "using A B"], ["proof (prove)\nusing this:\n  times_dom (s, b, C)\n  Nielson_VCG.times s b C = 0\n\ngoal (1 subgoal):\n 1. times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0", "by simp"], ["proof (state)\nthis:\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = 0\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "case (Suc z)"], ["proof (state)\nthis:\n  I z ?s \\<Longrightarrow>\n  times_dom (?s, b, C) \\<and> Nielson_VCG.times ?s b C = z\n  I (Suc z) s\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "from i[OF Suc(2)]"], ["proof (chain)\npicking this:\n  bval b s \\<and> I z (postQ C s)", "have bv: \"bval b s\"\n      and g:  \"I z (postQ C s)\""], ["proof (prove)\nusing this:\n  bval b s \\<and> I z (postQ C s)\n\ngoal (1 subgoal):\n 1. bval b s &&& I z (postQ C s)", "by simp_all"], ["proof (state)\nthis:\n  bval b s\n  I z (postQ C s)\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "from Suc(1)[OF g]"], ["proof (chain)\npicking this:\n  times_dom (postQ C s, b, C) \\<and> Nielson_VCG.times (postQ C s) b C = z", "have p1: \"times_dom (postQ C s, b, C)\"\n      and p2: \"times (postQ C s) b C = z\""], ["proof (prove)\nusing this:\n  times_dom (postQ C s, b, C) \\<and> Nielson_VCG.times (postQ C s) b C = z\n\ngoal (1 subgoal):\n 1. times_dom (postQ C s, b, C) &&& Nielson_VCG.times (postQ C s) b C = z", "by simp_all"], ["proof (state)\nthis:\n  times_dom (postQ C s, b, C)\n  Nielson_VCG.times (postQ C s) b C = z\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "have A: \"times_dom (s, b, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_dom (s, b, C)", "apply(rule times.domintros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bval b s \\<Longrightarrow> times_dom (postQ C s, b, C)", "apply(rule p1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  times_dom (s, b, C)\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "have B: \"times s b C = Suc z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = Suc z", "using times.psimps[OF A] bv p2"], ["proof (prove)\nusing this:\n  Nielson_VCG.times s b C =\n  (if bval b s then Suc (Nielson_VCG.times (postQ C s) b C) else 0)\n  bval b s\n  Nielson_VCG.times (postQ C s) b C = z\n\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = Suc z", "by simp"], ["proof (state)\nthis:\n  Nielson_VCG.times s b C = Suc z\n\ngoal (1 subgoal):\n 1. \\<And>z s.\n       \\<lbrakk>\\<And>s.\n                   I z s \\<Longrightarrow>\n                   times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z;\n        I (Suc z) s\\<rbrakk>\n       \\<Longrightarrow> times_dom (s, b, C) \\<and>\n                         Nielson_VCG.times s b C = Suc z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = Suc z", "using A B"], ["proof (prove)\nusing this:\n  times_dom (s, b, C)\n  Nielson_VCG.times s b C = Suc z\n\ngoal (1 subgoal):\n 1. times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = Suc z", "by simp"], ["proof (state)\nthis:\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = Suc z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I z s \\<Longrightarrow>\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z\n\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = z", "then"], ["proof (chain)\npicking this:\n  I z s \\<Longrightarrow>\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z", "show \"times s b C = z\""], ["proof (prove)\nusing this:\n  I z s \\<Longrightarrow>\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z\n\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = z", "using I"], ["proof (prove)\nusing this:\n  I z s \\<Longrightarrow>\n  times_dom (s, b, C) \\<and> Nielson_VCG.times s b C = z\n  I z s\n\ngoal (1 subgoal):\n 1. Nielson_VCG.times s b C = z", "by simp"], ["proof (state)\nthis:\n  Nielson_VCG.times s b C = z\n\ngoal:\nNo subgoals!", "qed"], ["", "function (domintros) postQs :: \"acom \\<Rightarrow> bexp \\<Rightarrow> state \\<Rightarrow> state\" where\n  \"postQs C b s = (if bval b s then (postQs C b (postQ C s))  else s)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>C b s. x = (C, b, s) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>C b s Ca ba sa.\n       (C, b, s) = (Ca, ba, sa) \\<Longrightarrow>\n       (if bval b s then postQs_sumC (C, b, postQ C s) else s) =\n       (if bval ba sa then postQs_sumC (Ca, ba, postQ Ca sa) else sa)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun postQz :: \"acom \\<Rightarrow> state \\<Rightarrow> nat \\<Rightarrow> state\" where\n  \"postQz C s 0 = s\" |\n  \"postQz C s (Suc n) =  (postQz C (postQ C s) n)\""], ["", "fun preTz :: \"acom \\<Rightarrow> tbd \\<Rightarrow> nat \\<Rightarrow> tbd\" where\n  \"preTz C e 0 = e\" |\n  \"preTz C e (Suc n) = preT C (preTz C e n)\""], ["", "lemma TzQ: \"preTz C e n s = e (postQz C s n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preTz C e n s = e (postQz C s n)", "by (induct n arbitrary: s, simp_all add: TQ)"], ["", "subsubsection \\<open>Weakest precondition from annotated commands:\\<close>"], ["", "fun pre :: \"acom \\<Rightarrow> assn2 \\<Rightarrow> assn2\" where\n  \"pre SKIP Q  = Q\" |\n  \"pre (x ::= a) Q = (\\<lambda>l s. Q l (s(x := aval a s)))\" |\n  \"pre (C\\<^sub>1;; C\\<^sub>2) Q  = pre C\\<^sub>1 (pre C\\<^sub>2 Q)\" |\n  \"pre ({P'/_/_} CONSEQ C) Q = P'\" |\n  \"pre (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2) Q =\n  (\\<lambda>l s. if bval b s then pre C\\<^sub>1 Q l s else pre C\\<^sub>2 Q l s)\" |\n  \"pre ({(I,(S,(E)))} WHILE b DO C) Q = I\""], ["", "lemma supportE_preT: \"supportE (%l. preT C (e l)) \\<subseteq> supportE e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT C (e l)) \\<subseteq> supportE e", "proof(induct C arbitrary: e)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE\n                          (\\<lambda>l. preT (IF x1 THEN C1 ELSE C2) (e l))\n                         \\<subseteq> supportE e\n 5. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 6. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "case (Aif b C1 C2 e)"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT C1 (?e l)) \\<subseteq> supportE ?e\n  supportE (\\<lambda>l. preT C2 (?e l)) \\<subseteq> supportE ?e\n\ngoal (6 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE\n                          (\\<lambda>l. preT (IF x1 THEN C1 ELSE C2) (e l))\n                         \\<subseteq> supportE e\n 5. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 6. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT (IF b THEN C1 ELSE C2) (e l))\n    \\<subseteq> supportE e", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE\n     (\\<lambda>l a. if bval b a then preT C1 (e l) a else preT C2 (e l) a)\n    \\<subseteq> supportE e", "apply(rule subset_trans[OF supportE_if])"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT C1 (e l)) \\<union>\n    supportE (\\<lambda>l. preT C2 (e l))\n    \\<subseteq> supportE e", "using Aif"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. preT C1 (?e l)) \\<subseteq> supportE ?e\n  supportE (\\<lambda>l. preT C2 (?e l)) \\<subseteq> supportE ?e\n\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT C1 (e l)) \\<union>\n    supportE (\\<lambda>l. preT C2 (e l))\n    \\<subseteq> supportE e", "by fast"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT (IF b THEN C1 ELSE C2) (e l))\n  \\<subseteq> supportE e\n\ngoal (5 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 5. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 5. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "case (Awhile A y C e)"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT C (?e l)) \\<subseteq> supportE ?e\n\ngoal (5 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 5. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "obtain I S E  where A: \"A= (I,S,E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = (I, S, E)\n\ngoal (5 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e\n 5. \\<And>x1 x2 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1} WHILE x2 DO C) (e l))\n       \\<subseteq> supportE e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT ({A} WHILE y DO C) (e l))\n    \\<subseteq> supportE e", "using A"], ["proof (prove)\nusing this:\n  A = (I, S, E)\n\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT ({A} WHILE y DO C) (e l))\n    \\<subseteq> supportE e", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = (I, S, E) \\<Longrightarrow>\n    supportE (\\<lambda>l a. e l (S a)) \\<subseteq> supportE e", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = (I, S, E) \\<Longrightarrow>\n    {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           e l1 (S s) \\<noteq> e l2 (S s)}\n    \\<subseteq> {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       e l1 s \\<noteq> e l2 s}", "by blast"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT ({A} WHILE y DO C) (e l))\n  \\<subseteq> supportE e\n\ngoal (4 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e", "case (Aseq)"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT C1_ (?e l)) \\<subseteq> supportE ?e\n  supportE (\\<lambda>l. preT C2_ (?e l)) \\<subseteq> supportE ?e\n\ngoal (4 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>C1 C2 e.\n       \\<lbrakk>\\<And>e.\n                   supportE (\\<lambda>l. preT C1 (e l))\n                   \\<subseteq> supportE e;\n        \\<And>e.\n           supportE (\\<lambda>l. preT C2 (e l))\n           \\<subseteq> supportE e\\<rbrakk>\n       \\<Longrightarrow> supportE (\\<lambda>l. preT (C1;; C2) (e l))\n                         \\<subseteq> supportE e\n 4. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e", "then"], ["proof (chain)\npicking this:\n  supportE (\\<lambda>l. preT C1_ (?e l)) \\<subseteq> supportE ?e\n  supportE (\\<lambda>l. preT C2_ (?e l)) \\<subseteq> supportE ?e", "show ?case"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. preT C1_ (?e l)) \\<subseteq> supportE ?e\n  supportE (\\<lambda>l. preT C2_ (?e l)) \\<subseteq> supportE ?e\n\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT (C1_;; C2_) (e l)) \\<subseteq> supportE e", "by force"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preT (C1_;; C2_) (e l)) \\<subseteq> supportE e\n\ngoal (3 subgoals):\n 1. \\<And>e. supportE (\\<lambda>l. preT SKIP (e l)) \\<subseteq> supportE e\n 2. \\<And>x1 x2 e.\n       supportE (\\<lambda>l. preT (x1 ::= x2) (e l)) \\<subseteq> supportE e\n 3. \\<And>x1 x2 x3 C e.\n       (\\<And>e.\n           supportE (\\<lambda>l. preT C (e l))\n           \\<subseteq> supportE e) \\<Longrightarrow>\n       supportE (\\<lambda>l. preT ({x1/x2/x3} CONSEQ C) (e l))\n       \\<subseteq> supportE e", "qed (simp_all add: supportE_def, blast)"], ["", "lemma supportE_twicepreT: \"supportE (%l. preT C1 (preT C2 (e l))) \\<subseteq> supportE e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT C1 (preT C2 (e l))) \\<subseteq> supportE e", "by (rule subset_trans[OF supportE_preT supportE_preT])"], ["", "lemma supportE_preTz: \"supportE (%l. preTz C (e l) n) \\<subseteq> supportE e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) n) \\<subseteq> supportE e", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. supportE (\\<lambda>l. preTz C (e l) 0) \\<subseteq> supportE e\n 2. \\<And>n.\n       supportE (\\<lambda>l. preTz C (e l) n)\n       \\<subseteq> supportE e \\<Longrightarrow>\n       supportE (\\<lambda>l. preTz C (e l) (Suc n)) \\<subseteq> supportE e", "case (Suc n)"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preTz C (e l) n) \\<subseteq> supportE e\n\ngoal (2 subgoals):\n 1. supportE (\\<lambda>l. preTz C (e l) 0) \\<subseteq> supportE e\n 2. \\<And>n.\n       supportE (\\<lambda>l. preTz C (e l) n)\n       \\<subseteq> supportE e \\<Longrightarrow>\n       supportE (\\<lambda>l. preTz C (e l) (Suc n)) \\<subseteq> supportE e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) (Suc n)) \\<subseteq> supportE e", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preT C (preTz C (e l) n)) \\<subseteq> supportE e", "apply(rule subset_trans[OF supportE_preT])"], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) n) \\<subseteq> supportE e", "by fact"], ["proof (state)\nthis:\n  supportE (\\<lambda>l. preTz C (e l) (Suc n)) \\<subseteq> supportE e\n\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) 0) \\<subseteq> supportE e", "qed simp"], ["", "lemma supportE_preTz_Un: (* like in support_wpw_Un *)\n  \"supportE (\\<lambda>l. preTz C (e l) (l x)) \\<subseteq> insert x (UN n. supportE (\\<lambda>l. preTz C (e l) n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) (l x))\n    \\<subseteq> insert x (\\<Union>n. supportE (\\<lambda>l. preTz C (e l) n))", "apply(auto simp add: supportE_def subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> t \\<longrightarrow> l1 y = l2 y;\n        preTz C (e l1) (l1 x) s \\<noteq> preTz C (e l2) (l2 x) s;\n        \\<forall>x l1 l2.\n           (\\<exists>y. y \\<noteq> t \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. preTz C (e l1) x s = preTz C (e l2) x s)\\<rbrakk>\n       \\<Longrightarrow> t = x", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma supportE_preTz2: \"supportE (%l. preTz C (e l) (l x)) \\<subseteq> insert x (supportE e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. preTz C (e l) (l x))\n    \\<subseteq> insert x (supportE e)", "apply(rule subset_trans[OF supportE_preTz_Un])"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (\\<Union>n. supportE (\\<lambda>l. preTz C (e l) n))\n    \\<subseteq> insert x (supportE e)", "using supportE_preTz"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. preTz ?C (?e l) ?n) \\<subseteq> supportE ?e\n\ngoal (1 subgoal):\n 1. insert x (\\<Union>n. supportE (\\<lambda>l. preTz C (e l) n))\n    \\<subseteq> insert x (supportE e)", "by blast"], ["", "lemma pff: \"\\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I - {x}", "unfolding support_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       {xa.\n        \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y) \\<and>\n           I (l1(x := n)) s \\<noteq> I (l2(x := n)) s}\n       \\<subseteq> {x. \\<exists>l1 l2 s.\n                          (\\<forall>y.\n                              y \\<noteq> x \\<longrightarrow>\n                              l1 y = l2 y) \\<and>\n                          I l1 s \\<noteq> I l2 s} -\n                   {x}", "apply(auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> xa \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. I l1 s = (\\<not> I l2 s))\n 2. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s; I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (4 subgoals):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> xa \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. I l1 s = (\\<not> I l2 s))\n 2. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s; I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "apply smt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s; I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (smt fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s; I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "oops"], ["", "lemma pff: \"\\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. support (\\<lambda>l. I (l(x := n))) \\<subseteq> support I", "unfolding support_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       {xa.\n        \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y) \\<and>\n           I (l1(x := n)) s \\<noteq> I (l2(x := n)) s}\n       \\<subseteq> {x. \\<exists>l1 l2 s.\n                          (\\<forall>y.\n                              y \\<noteq> x \\<longrightarrow>\n                              l1 y = l2 y) \\<and>\n                          I l1 s \\<noteq> I l2 s}", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> xa \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. I l1 s = (\\<not> I l2 s))\n 2. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (2 subgoals):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        I (l1(x := n)) s; \\<not> I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> xa \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. I l1 s = (\\<not> I l2 s))\n 2. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "apply smt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xa l1 l2 s.\n       \\<lbrakk>\\<forall>y. y \\<noteq> xa \\<longrightarrow> l1 y = l2 y;\n        \\<not> I (l1(x := n)) s;\n        \\<forall>l1 l2.\n           (\\<exists>y. y \\<noteq> xa \\<and> l1 y \\<noteq> l2 y) \\<or>\n           (\\<forall>s. I l1 s = I l2 s);\n        I (l2(x := n)) s\\<rbrakk>\n       \\<Longrightarrow> False", "by (smt fun_upd_apply)"], ["", "lemma supportAB: \"support (\\<lambda>l s. A l s \\<and> B s) \\<subseteq> support A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. A l s \\<and> B s) \\<subseteq> support A", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support A \\<union> support (\\<lambda>l. B) \\<subseteq> support A", "by (simp add: support_inv)"], ["", "lemma \"support (pre ({(I,(S,(E )))} WHILE b DO C) Q) \\<subseteq> support I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre ({(I, S, E)} WHILE b DO C) Q) \\<subseteq> support I", "by (simp add: supportAB)"], ["", "lemma support_pre: \"support (pre C Q) \\<subseteq> support Q \\<union> varacom C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre C Q) \\<subseteq> support Q \\<union> varacom C", "proof (induct C arbitrary: Q)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)\n 6. \\<And>x1 x2 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1} WHILE x2 DO C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1} WHILE x2 DO C)", "case (Awhile A b C Q)"], ["proof (state)\nthis:\n  support (pre C ?Q) \\<subseteq> support ?Q \\<union> varacom C\n\ngoal (6 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)\n 6. \\<And>x1 x2 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1} WHILE x2 DO C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1} WHILE x2 DO C)", "obtain I S E  where A: \"A= (I,(S,(E )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = (I, S, E)\n\ngoal (6 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)\n 6. \\<And>x1 x2 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1} WHILE x2 DO C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1} WHILE x2 DO C)", "have support_inv: \"\\<And>P. support (\\<lambda>l s. P s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. support (\\<lambda>l. P) = {}", "unfolding support_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       {x. \\<exists>l1 l2 s.\n              (\\<forall>y.\n                  y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n              P s \\<noteq> P s} =\n       {}", "by blast"], ["proof (state)\nthis:\n  support (\\<lambda>l. ?P) = {}\n\ngoal (6 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)\n 6. \\<And>x1 x2 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1} WHILE x2 DO C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1} WHILE x2 DO C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre ({A} WHILE b DO C) Q)\n    \\<subseteq> support Q \\<union> varacom ({A} WHILE b DO C)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre ({(I, S, E)} WHILE b DO C) Q)\n    \\<subseteq> support Q \\<union> varacom ({(I, S, E)} WHILE b DO C)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. support I \\<subseteq> support Q \\<union> (support I \\<union> varacom C)", "using supportAB"], ["proof (prove)\nusing this:\n  support (\\<lambda>l s. ?A l s \\<and> ?B s) \\<subseteq> support ?A\n\ngoal (1 subgoal):\n 1. support I \\<subseteq> support Q \\<union> (support I \\<union> varacom C)", "by fast"], ["proof (state)\nthis:\n  support (pre ({A} WHILE b DO C) Q)\n  \\<subseteq> support Q \\<union> varacom ({A} WHILE b DO C)\n\ngoal (5 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "case (Aseq C1 C2)"], ["proof (state)\nthis:\n  support (pre C1 ?Q) \\<subseteq> support ?Q \\<union> varacom C1\n  support (pre C2 ?Q) \\<subseteq> support ?Q \\<union> varacom C2\n\ngoal (5 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (C1;; C2) Q)\n                         \\<subseteq> support Q \\<union> varacom (C1;; C2)\n 4. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 5. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "then"], ["proof (chain)\npicking this:\n  support (pre C1 ?Q) \\<subseteq> support ?Q \\<union> varacom C1\n  support (pre C2 ?Q) \\<subseteq> support ?Q \\<union> varacom C2", "show ?case"], ["proof (prove)\nusing this:\n  support (pre C1 ?Q) \\<subseteq> support ?Q \\<union> varacom C1\n  support (pre C2 ?Q) \\<subseteq> support ?Q \\<union> varacom C2\n\ngoal (1 subgoal):\n 1. support (pre (C1;; C2) Q)\n    \\<subseteq> support Q \\<union> varacom (C1;; C2)", "by(auto)"], ["proof (state)\nthis:\n  support (pre (C1;; C2) Q) \\<subseteq> support Q \\<union> varacom (C1;; C2)\n\ngoal (4 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 4. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 4. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "case (Aif x C1 C2 Q)"], ["proof (state)\nthis:\n  support (pre C1 ?Q) \\<subseteq> support ?Q \\<union> varacom C1\n  support (pre C2 ?Q) \\<subseteq> support ?Q \\<union> varacom C2\n\ngoal (4 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 4. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "have s1: \"support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s) \\<subseteq> support Q \\<union> varacom C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s)\n    \\<subseteq> support Q \\<union> varacom C1", "apply(rule subset_trans[OF support_impl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre C1 Q) \\<subseteq> support Q \\<union> varacom C1", "by(rule Aif)"], ["proof (state)\nthis:\n  support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s)\n  \\<subseteq> support Q \\<union> varacom C1\n\ngoal (4 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 4. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "have s2: \"support (\\<lambda>l s. ~ bval x s \\<longrightarrow> pre C2 Q l s) \\<subseteq> support Q \\<union> varacom C2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. \\<not> bval x s \\<longrightarrow> pre C2 Q l s)\n    \\<subseteq> support Q \\<union> varacom C2", "apply(rule subset_trans[OF support_impl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre C2 Q) \\<subseteq> support Q \\<union> varacom C2", "by(rule Aif)"], ["proof (state)\nthis:\n  support (\\<lambda>l s. \\<not> bval x s \\<longrightarrow> pre C2 Q l s)\n  \\<subseteq> support Q \\<union> varacom C2\n\ngoal (4 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 C1 C2 Q.\n       \\<lbrakk>\\<And>Q.\n                   support (pre C1 Q)\n                   \\<subseteq> support Q \\<union> varacom C1;\n        \\<And>Q.\n           support (pre C2 Q)\n           \\<subseteq> support Q \\<union> varacom C2\\<rbrakk>\n       \\<Longrightarrow> support (pre (IF x1 THEN C1 ELSE C2) Q)\n                         \\<subseteq> support Q \\<union>\n                                     varacom (IF x1 THEN C1 ELSE C2)\n 4. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre (IF x THEN C1 ELSE C2) Q)\n    \\<subseteq> support Q \\<union> varacom (IF x THEN C1 ELSE C2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. support\n     (\\<lambda>xa xaa.\n         (bval x xaa \\<longrightarrow> pre C1 Q xa xaa) \\<and>\n         (\\<not> bval x xaa \\<longrightarrow> pre C2 Q xa xaa))\n    \\<subseteq> support Q \\<union> (varacom C1 \\<union> varacom C2)", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s) \\<union>\n    support (\\<lambda>l s. \\<not> bval x s \\<longrightarrow> pre C2 Q l s)\n    \\<subseteq> support Q \\<union> (varacom C1 \\<union> varacom C2)", "using s1 s2"], ["proof (prove)\nusing this:\n  support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s)\n  \\<subseteq> support Q \\<union> varacom C1\n  support (\\<lambda>l s. \\<not> bval x s \\<longrightarrow> pre C2 Q l s)\n  \\<subseteq> support Q \\<union> varacom C2\n\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. bval x s \\<longrightarrow> pre C1 Q l s) \\<union>\n    support (\\<lambda>l s. \\<not> bval x s \\<longrightarrow> pre C2 Q l s)\n    \\<subseteq> support Q \\<union> (varacom C1 \\<union> varacom C2)", "by blast"], ["proof (state)\nthis:\n  support (pre (IF x THEN C1 ELSE C2) Q)\n  \\<subseteq> support Q \\<union> varacom (IF x THEN C1 ELSE C2)\n\ngoal (3 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "case (Aconseq x1 x2 x3 C)"], ["proof (state)\nthis:\n  support (pre C ?Q) \\<subseteq> support ?Q \\<union> varacom C\n\ngoal (3 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)\n 3. \\<And>x1 x2 x3 C Q.\n       (\\<And>Q.\n           support (pre C Q)\n           \\<subseteq> support Q \\<union> varacom C) \\<Longrightarrow>\n       support (pre ({x1/x2/x3} CONSEQ C) Q)\n       \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "then"], ["proof (chain)\npicking this:\n  support (pre C ?Q) \\<subseteq> support ?Q \\<union> varacom C", "show ?case"], ["proof (prove)\nusing this:\n  support (pre C ?Q) \\<subseteq> support ?Q \\<union> varacom C\n\ngoal (1 subgoal):\n 1. support (pre ({x1/x2/x3} CONSEQ C) Q)\n    \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)", "by(auto)"], ["proof (state)\nthis:\n  support (pre ({x1/x2/x3} CONSEQ C) Q)\n  \\<subseteq> support Q \\<union> varacom ({x1/x2/x3} CONSEQ C)\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       support (pre SKIP Q) \\<subseteq> support Q \\<union> varacom SKIP\n 2. \\<And>x1 x2 Q.\n       support (pre (x1 ::= x2) Q)\n       \\<subseteq> support Q \\<union> varacom (x1 ::= x2)", "qed (auto simp add: support_def)"], ["", "lemma finite_support_pre[simp]: \"finite (support Q)  \\<Longrightarrow> finite (varacom C) \\<Longrightarrow>  finite (support (pre C Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (support Q); finite (varacom C)\\<rbrakk>\n    \\<Longrightarrow> finite (support (pre C Q))", "using finite_subset support_pre finite_UnI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  support (pre ?C ?Q) \\<subseteq> support ?Q \\<union> varacom ?C\n  \\<lbrakk>finite ?F; finite ?G\\<rbrakk>\n  \\<Longrightarrow> finite (?F \\<union> ?G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (support Q); finite (varacom C)\\<rbrakk>\n    \\<Longrightarrow> finite (support (pre C Q))", "by metis"], ["", "fun time :: \"acom \\<Rightarrow> tbd\" where\n  \"time SKIP = (%s. Suc 0)\" |\n  \"time (x ::= a) = (%s. Suc 0)\" |\n  \"time (C\\<^sub>1;; C\\<^sub>2) = (%s. time C\\<^sub>1 s + preT C\\<^sub>1 (time C\\<^sub>2) s)\" |\n  \"time ({_/_/e} CONSEQ C) = e\" |\n  \"time (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2) =\n  (\\<lambda>s. if bval b s then 1 + time C\\<^sub>1 s else 1 + time C\\<^sub>2 s)\" |\n  \"time ({(_,(E',(E )))} WHILE b DO C) = E\""], ["", "lemma supportE_single: \"supportE (\\<lambda>l s. P) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l s. P) = {}", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           P \\<noteq> P} =\n    {}", "by blast"], ["", "lemma supportE_plus: \"supportE (\\<lambda>l s. e1 l s + e2 l s) \\<subseteq> supportE e1 \\<union> supportE e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l s. e1 l s + e2 l s)\n    \\<subseteq> supportE e1 \\<union> supportE e2", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           e1 l1 s + e2 l1 s \\<noteq> e1 l2 s + e2 l2 s}\n    \\<subseteq> {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       e1 l1 s \\<noteq> e1 l2 s} \\<union>\n                {x. \\<exists>l1 l2 s.\n                       (\\<forall>y.\n                           y \\<noteq> x \\<longrightarrow>\n                           l1 y = l2 y) \\<and>\n                       e2 l1 s \\<noteq> e2 l2 s}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l1 l2 s.\n       \\<lbrakk>\\<forall>l1 l2.\n                   (\\<exists>y.\n                       y \\<noteq> x \\<and> l1 y \\<noteq> l2 y) \\<or>\n                   (\\<forall>s. e2 l1 s = e2 l2 s);\n        \\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y;\n        e1 l1 s + e2 l1 s \\<noteq> e1 l2 s + e2 l2 s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (\\<forall>y.\n                                y \\<noteq> x \\<longrightarrow>\n                                l1 y = l2 y) \\<and>\n                            (\\<exists>s. e1 l1 s \\<noteq> e1 l2 s)", "by metis"], ["", "lemma supportE_Suc: \"supportE (\\<lambda>l s. Suc (e1 l s)) = supportE e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l s. Suc (e1 l s)) = supportE e1", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           Suc (e1 l1 s) \\<noteq> Suc (e1 l2 s)} =\n    {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           e1 l1 s \\<noteq> e1 l2 s}", "by (auto)"], ["", "lemma supportE_single2: \"supportE (\\<lambda>l . P) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. P) = {}", "unfolding supportE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           P s \\<noteq> P s} =\n    {}", "by blast"], ["", "lemma supportE_time: \"supportE (\\<lambda>l. time C) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. time C) = {}", "using supportE_single2"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. ?P) = {}\n\ngoal (1 subgoal):\n 1. supportE (\\<lambda>l. time C) = {}", "by simp"], ["", "lemma \"\\<And>s. (\\<forall>l. I (l(x:=0)) s) = (\\<forall>l. l x = 0 \\<longrightarrow> I l s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<forall>l. I (l(x := 0::'c)) s) =\n       (\\<forall>l. l x = (0::'c) \\<longrightarrow> I l s)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l.\n       \\<lbrakk>\\<forall>l. I (l(x := 0::'c)) s; l x = (0::'c)\\<rbrakk>\n       \\<Longrightarrow> I l s", "by (metis fun_upd_triv)"], ["", "lemma \"\\<And>s. (\\<forall>l. I (l(x:=Suc (l x))) s) = (\\<forall>l. (\\<exists>n. l x = Suc n) \\<longrightarrow> I l s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<forall>l. I (l(x := Suc (l x))) s) =\n       (\\<forall>l. (\\<exists>n. l x = Suc n) \\<longrightarrow> I l s)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l n.\n       \\<lbrakk>\\<forall>l. I (l(x := Suc (l x))) s; l x = Suc n\\<rbrakk>\n       \\<Longrightarrow> I l s", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s l n.\n       \\<lbrakk>\\<forall>l. I (l(x := Suc (l x))) s; l x = Suc n\\<rbrakk>\n       \\<Longrightarrow> I l s", "case (1 s l n)"], ["proof (state)\nthis:\n  \\<forall>l. I (l(x := Suc (l x))) s\n  l x = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>s l n.\n       \\<lbrakk>\\<forall>l. I (l(x := Suc (l x))) s; l x = Suc n\\<rbrakk>\n       \\<Longrightarrow> I l s", "then"], ["proof (chain)\npicking this:\n  \\<forall>l. I (l(x := Suc (l x))) s\n  l x = Suc n", "have \"\\<And>l. I (l(x := Suc (l x))) s\""], ["proof (prove)\nusing this:\n  \\<forall>l. I (l(x := Suc (l x))) s\n  l x = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>l. I (l(x := Suc (l x))) s", "by simp"], ["proof (state)\nthis:\n  I (?l(x := Suc (?l x))) s\n\ngoal (1 subgoal):\n 1. \\<And>s l n.\n       \\<lbrakk>\\<forall>l. I (l(x := Suc (l x))) s; l x = Suc n\\<rbrakk>\n       \\<Longrightarrow> I l s", "from this[where l=\"l(x:=n)\"]"], ["proof (chain)\npicking this:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s", "have \"I ((l(x:=n))(x := Suc ((l(x:=n)) x))) s\""], ["proof (prove)\nusing this:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s\n\ngoal (1 subgoal):\n 1. I (l(x := n, x := Suc ((l(x := n)) x))) s", "by simp"], ["proof (state)\nthis:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s\n\ngoal (1 subgoal):\n 1. \\<And>s l n.\n       \\<lbrakk>\\<forall>l. I (l(x := Suc (l x))) s; l x = Suc n\\<rbrakk>\n       \\<Longrightarrow> I l s", "then"], ["proof (chain)\npicking this:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s", "show ?case"], ["proof (prove)\nusing this:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s\n\ngoal (1 subgoal):\n 1. I l s", "using 1(2)"], ["proof (prove)\nusing this:\n  I (l(x := n, x := Suc ((l(x := n)) x))) s\n  l x = Suc n\n\ngoal (1 subgoal):\n 1. I l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I (l(x := Suc n)) s; l x = Suc n\\<rbrakk>\n    \\<Longrightarrow> I l s", "by (metis fun_upd_triv)"], ["proof (state)\nthis:\n  I l s\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Verification condition:\\<close>"], ["", "fun vc :: \"acom \\<Rightarrow> assn2  \\<Rightarrow> bool\" where\n  \"vc SKIP Q = True\" |\n  \"vc (x ::= a) Q = True\" |\n  \"vc (C\\<^sub>1 ;; C\\<^sub>2) Q = ((vc C\\<^sub>1 (pre C\\<^sub>2 Q)) \\<and> (vc C\\<^sub>2 Q) )\" |\n  \"vc (IF b THEN C\\<^sub>1 ELSE C\\<^sub>2) Q = (vc C\\<^sub>1 Q \\<and> vc C\\<^sub>2 Q)\" |  \n  \"vc ({P'/Q/e'} CONSEQ C) Q' = (vc C Q \\<and> (\\<exists>k>0. (\\<forall>l s. P' l s \\<longrightarrow> time C s \\<le> k * e' s  \\<and> (\\<forall>t. \\<exists>l'. (pre C Q) l' s \\<and> ( Q l' t \\<longrightarrow> Q' l t) ))))\" |\n  \n  \"vc ({(I,(S,(E)))} WHILE b DO C) Q = \n  ((\\<forall>l s. (I l s \\<and> bval b s \\<longrightarrow>  pre C I l s \\<and>   E s \\<ge> 1 + preT C E s + time C s\n  \\<and> S s = S (postQ C s)) \\<and>\n  (I l s \\<and> \\<not> bval b s \\<longrightarrow> Q l s \\<and> E s \\<ge> 1 \\<and> S s = s) ) \\<and>\n  vc C I)\""], ["", "lemma pre_mono:\n  \"(\\<forall>l s. P l s \\<longrightarrow> P' l s) \\<Longrightarrow> pre C P l s \\<Longrightarrow> pre C P' l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n     pre C P l s\\<rbrakk>\n    \\<Longrightarrow> pre C P' l s", "proof (induction C arbitrary: P P' l s)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (C1;; C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (C1;; C2) P' l s\n 4. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 5. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 6. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "case (Aseq C1 C2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C1 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C1 ?P' ?l ?s\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C2 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C2 ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre (C1;; C2) P l s\n\ngoal (6 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (C1;; C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (C1;; C2) P' l s\n 4. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 5. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 6. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C1 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C1 ?P' ?l ?s\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C2 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C2 ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre (C1;; C2) P l s", "have A: \"pre C1 (pre C2 P) l s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C1 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C1 ?P' ?l ?s\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C2 ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C2 ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre (C1;; C2) P l s\n\ngoal (1 subgoal):\n 1. pre C1 (pre C2 P) l s", "by(simp)"], ["proof (state)\nthis:\n  pre C1 (pre C2 P) l s\n\ngoal (6 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (C1;; C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (C1;; C2) P' l s\n 4. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 5. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 6. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "from Aseq(2)[OF Aseq(3)] Aseq(1)[OF _ A]"], ["proof (chain)\npicking this:\n  pre C2 P ?l ?s \\<Longrightarrow> pre C2 P' ?l ?s\n  \\<forall>l s. pre C2 P l s \\<longrightarrow> ?P' l s \\<Longrightarrow>\n  pre C1 ?P' l s", "show ?case"], ["proof (prove)\nusing this:\n  pre C2 P ?l ?s \\<Longrightarrow> pre C2 P' ?l ?s\n  \\<forall>l s. pre C2 P l s \\<longrightarrow> ?P' l s \\<Longrightarrow>\n  pre C1 ?P' l s\n\ngoal (1 subgoal):\n 1. pre (C1;; C2) P' l s", "by simp"], ["proof (state)\nthis:\n  pre (C1;; C2) P' l s\n\ngoal (5 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 4. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 5. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 4. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 5. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "case (Awhile A b C)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s\n\ngoal (5 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 4. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 5. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s", "obtain I S E   where A: \"A = (I,S,E )\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s\n\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = (I, S, E)\n\ngoal (5 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 4. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s\n 5. \\<And>x1 x2 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1} WHILE x2 DO C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1} WHILE x2 DO C) P' l s", "from Awhile"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({A} WHILE b DO C) P l s\n\ngoal (1 subgoal):\n 1. pre ({A} WHILE b DO C) P' l s", "unfolding A"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre C ?P' ?l ?s\n  \\<forall>l s. P l s \\<longrightarrow> P' l s\n  pre ({(I, S, E)} WHILE b DO C) P l s\n\ngoal (1 subgoal):\n 1. pre ({(I, S, E)} WHILE b DO C) P' l s", "by simp"], ["proof (state)\nthis:\n  pre ({A} WHILE b DO C) P' l s\n\ngoal (4 subgoals):\n 1. \\<And>P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre SKIP P l s\\<rbrakk>\n       \\<Longrightarrow> pre SKIP P' l s\n 2. \\<And>x1 x2 P P' l s.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (x1 ::= x2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (x1 ::= x2) P' l s\n 3. \\<And>x1 C1 C2 P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C1 P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C1 P' l s;\n        \\<And>P P' l s.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            pre C2 P l s\\<rbrakk>\n           \\<Longrightarrow> pre C2 P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre (IF x1 THEN C1 ELSE C2) P l s\\<rbrakk>\n       \\<Longrightarrow> pre (IF x1 THEN C1 ELSE C2) P' l s\n 4. \\<And>x1 x2 x3 C P P' l s.\n       \\<lbrakk>\\<And>P P' l s.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    pre C P l s\\<rbrakk>\n                   \\<Longrightarrow> pre C P' l s;\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        pre ({x1/x2/x3} CONSEQ C) P l s\\<rbrakk>\n       \\<Longrightarrow> pre ({x1/x2/x3} CONSEQ C) P' l s", "qed simp_all"], ["", "lemma vc_mono: \"(\\<forall>l s. P l s \\<longrightarrow> P' l s) \\<Longrightarrow> vc C P \\<Longrightarrow> vc C P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s; vc C P\\<rbrakk>\n    \\<Longrightarrow> vc C P'", "apply (induct C arbitrary: P P')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>P P'.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc SKIP P\\<rbrakk>\n       \\<Longrightarrow> vc SKIP P'\n 2. \\<And>x1 x2 P P'.\n       \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc (x1 ::= x2) P\\<rbrakk>\n       \\<Longrightarrow> vc (x1 ::= x2) P'\n 3. \\<And>C1 C2 P P'.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C1 P\\<rbrakk>\n                   \\<Longrightarrow> vc C1 P';\n        \\<And>P P'.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            vc C2 P\\<rbrakk>\n           \\<Longrightarrow> vc C2 P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc (C1;; C2) P\\<rbrakk>\n       \\<Longrightarrow> vc (C1;; C2) P'\n 4. \\<And>x1 C1 C2 P P'.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C1 P\\<rbrakk>\n                   \\<Longrightarrow> vc C1 P';\n        \\<And>P P'.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            vc C2 P\\<rbrakk>\n           \\<Longrightarrow> vc C2 P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc (IF x1 THEN C1 ELSE C2) P\\<rbrakk>\n       \\<Longrightarrow> vc (IF x1 THEN C1 ELSE C2) P'\n 5. \\<And>x1 x2 x3 C P P'.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C P\\<rbrakk>\n                   \\<Longrightarrow> vc C P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc ({x1/x2/x3} CONSEQ C) P\\<rbrakk>\n       \\<Longrightarrow> vc ({x1/x2/x3} CONSEQ C) P'\n 6. \\<And>x1 x2 C P P'.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C P\\<rbrakk>\n                   \\<Longrightarrow> vc C P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s;\n        vc ({x1} WHILE x2 DO C) P\\<rbrakk>\n       \\<Longrightarrow> vc ({x1} WHILE x2 DO C) P'", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C1 C2 P P'.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C1 P\\<rbrakk>\n                   \\<Longrightarrow> vc C1 P';\n        \\<And>P P'.\n           \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n            vc C2 P\\<rbrakk>\n           \\<Longrightarrow> vc C2 P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s; vc C1 (pre C2 P);\n        vc C2 P\\<rbrakk>\n       \\<Longrightarrow> vc C1 (pre C2 P')\n 2. \\<And>x1 x2 x3 C P P' k.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C P\\<rbrakk>\n                   \\<Longrightarrow> vc C P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s; vc C x2; 0 < k;\n        \\<forall>l s.\n           x1 l s \\<longrightarrow>\n           time C s \\<le> k * x3 s \\<and>\n           (\\<forall>t.\n               \\<exists>l'.\n                  pre C x2 l' s \\<and>\n                  (x2 l' t \\<longrightarrow> P l t))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k>0.\n                            \\<forall>l s.\n                               x1 l s \\<longrightarrow>\n                               time C s \\<le> k * x3 s \\<and>\n                               (\\<forall>t.\n                                   \\<exists>l'.\npre C x2 l' s \\<and> (x2 l' t \\<longrightarrow> P' l t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P P'.\n                \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                 vc C1_ P\\<rbrakk>\n                \\<Longrightarrow> vc C1_ P';\n     \\<And>P P'.\n        \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n         vc C2_ P\\<rbrakk>\n        \\<Longrightarrow> vc C2_ P';\n     \\<forall>l s. P_ l s \\<longrightarrow> P'_ l s; vc C1_ (pre C2_ P_);\n     vc C2_ P_\\<rbrakk>\n    \\<Longrightarrow> vc C1_ (pre C2_ P'_)", "using pre_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre ?C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre ?C ?P' ?l ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P P'.\n                \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                 vc C1_ P\\<rbrakk>\n                \\<Longrightarrow> vc C1_ P';\n     \\<And>P P'.\n        \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n         vc C2_ P\\<rbrakk>\n        \\<Longrightarrow> vc C2_ P';\n     \\<forall>l s. P_ l s \\<longrightarrow> P'_ l s; vc C1_ (pre C2_ P_);\n     vc C2_ P_\\<rbrakk>\n    \\<Longrightarrow> vc C1_ (pre C2_ P'_)", "by metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 C P P' k.\n       \\<lbrakk>\\<And>P P'.\n                   \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                    vc C P\\<rbrakk>\n                   \\<Longrightarrow> vc C P';\n        \\<forall>l s. P l s \\<longrightarrow> P' l s; vc C x2; 0 < k;\n        \\<forall>l s.\n           x1 l s \\<longrightarrow>\n           time C s \\<le> k * x3 s \\<and>\n           (\\<forall>t.\n               \\<exists>l'.\n                  pre C x2 l' s \\<and>\n                  (x2 l' t \\<longrightarrow> P l t))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k>0.\n                            \\<forall>l s.\n                               x1 l s \\<longrightarrow>\n                               time C s \\<le> k * x3 s \\<and>\n                               (\\<forall>t.\n                                   \\<exists>l'.\npre C x2 l' s \\<and> (x2 l' t \\<longrightarrow> P' l t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P P'.\n                \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                 vc C_ P\\<rbrakk>\n                \\<Longrightarrow> vc C_ P';\n     \\<forall>l s. P_ l s \\<longrightarrow> P'_ l s; vc C_ x2_; 0 < k_;\n     \\<forall>l s.\n        x1_ l s \\<longrightarrow>\n        time C_ s \\<le> k_ * x3_ s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C_ x2_ l' s \\<and>\n               (x2_ l' t \\<longrightarrow> P_ l t))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            x1_ l s \\<longrightarrow>\n                            time C_ s \\<le> k * x3_ s \\<and>\n                            (\\<forall>t.\n                                \\<exists>l'.\n                                   pre C_ x2_ l' s \\<and>\n                                   (x2_ l' t \\<longrightarrow> P'_ l t))", "using pre_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>l s. ?P l s \\<longrightarrow> ?P' l s;\n   pre ?C ?P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> pre ?C ?P' ?l ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P P'.\n                \\<lbrakk>\\<forall>l s. P l s \\<longrightarrow> P' l s;\n                 vc C_ P\\<rbrakk>\n                \\<Longrightarrow> vc C_ P';\n     \\<forall>l s. P_ l s \\<longrightarrow> P'_ l s; vc C_ x2_; 0 < k_;\n     \\<forall>l s.\n        x1_ l s \\<longrightarrow>\n        time C_ s \\<le> k_ * x3_ s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C_ x2_ l' s \\<and>\n               (x2_ l' t \\<longrightarrow> P_ l t))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            x1_ l s \\<longrightarrow>\n                            time C_ s \\<le> k * x3_ s \\<and>\n                            (\\<forall>t.\n                                \\<exists>l'.\n                                   pre C_ x2_ l' s \\<and>\n                                   (x2_ l' t \\<longrightarrow> P'_ l t))", "by metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Soundness:\\<close>"], ["", "abbreviation \"preSet U C l s == (Ball U (%u. case u of (x,e) \\<Rightarrow> l x = preT C e s))\""], ["", "abbreviation \"postSet U l s == (Ball U (%u. case u of (x,e) \\<Rightarrow> l x = e s))\""], ["", "fun ListUpdate where\n  \"ListUpdate f [] l = f\"\n| \"ListUpdate f ((x,e)#xs) q = (ListUpdate f xs q)(x:=q e x)\""], ["", "lemma allg: \n  assumes U2: \"\\<And>l s n x. x\\<in> fst ` upds \\<Longrightarrow> A (l(x := n))  = A l\"\n  shows\n    \"fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow> A (ListUpdate l'' xs q) = A l''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' xs q) = A l''", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "case (Cons a xs)"], ["proof (state)\nthis:\n  fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n  A (ListUpdate l'' xs q) = A l''\n  fst ` set (a # xs) \\<subseteq> fst ` upds\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "obtain x e where axe: \"a = (x,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x e. a = (x, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (x, e)\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "have \"A (ListUpdate l'' (a # xs) q) \n    = A ((ListUpdate l'' xs q)(x := q e x))  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (ListUpdate l'' (a # xs) q) = A ((ListUpdate l'' xs q)(x := q e x))", "unfolding axe"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (ListUpdate l'' ((x, e) # xs) q) =\n    A ((ListUpdate l'' xs q)(x := q e x))", "by(simp)"], ["proof (state)\nthis:\n  A (ListUpdate l'' (a # xs) q) = A ((ListUpdate l'' xs q)(x := q e x))\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "also"], ["proof (state)\nthis:\n  A (ListUpdate l'' (a # xs) q) = A ((ListUpdate l'' xs q)(x := q e x))\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "have\n    \"\\<dots> =  A  (ListUpdate l'' xs q)  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((ListUpdate l'' xs q)(x := q e x)) = A (ListUpdate l'' xs q)", "apply(rule U2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fst ` upds", "using Cons axe"], ["proof (prove)\nusing this:\n  fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n  A (ListUpdate l'' xs q) = A l''\n  fst ` set (a # xs) \\<subseteq> fst ` upds\n  a = (x, e)\n\ngoal (1 subgoal):\n 1. x \\<in> fst ` upds", "by force"], ["proof (state)\nthis:\n  A ((ListUpdate l'' xs q)(x := q e x)) = A (ListUpdate l'' xs q)\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "also"], ["proof (state)\nthis:\n  A ((ListUpdate l'' xs q)(x := q e x)) = A (ListUpdate l'' xs q)\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "have \"\\<dots> = A l'' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (ListUpdate l'' xs q) = A l''", "using Cons"], ["proof (prove)\nusing this:\n  fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n  A (ListUpdate l'' xs q) = A l''\n  fst ` set (a # xs) \\<subseteq> fst ` upds\n\ngoal (1 subgoal):\n 1. A (ListUpdate l'' xs q) = A l''", "by force"], ["proof (state)\nthis:\n  A (ListUpdate l'' xs q) = A l''\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''\n 2. \\<And>a xs.\n       \\<lbrakk>fst ` set xs \\<subseteq> fst ` upds \\<Longrightarrow>\n                A (ListUpdate l'' xs q) = A l'';\n        fst ` set (a # xs) \\<subseteq> fst ` upds\\<rbrakk>\n       \\<Longrightarrow> A (ListUpdate l'' (a # xs) q) = A l''", "finally"], ["proof (chain)\npicking this:\n  A (ListUpdate l'' (a # xs) q) = A l''", "show ?case"], ["proof (prove)\nusing this:\n  A (ListUpdate l'' (a # xs) q) = A l''\n\ngoal (1 subgoal):\n 1. A (ListUpdate l'' (a # xs) q) = A l''", "."], ["proof (state)\nthis:\n  A (ListUpdate l'' (a # xs) q) = A l''\n\ngoal (1 subgoal):\n 1. fst ` set [] \\<subseteq> fst ` upds \\<Longrightarrow>\n    A (ListUpdate l'' [] q) = A l''", "qed simp"], ["", "fun ListUpdateE where\n  \"ListUpdateE f []   = f\"\n| \"ListUpdateE f ((x,v)#xs)  = (ListUpdateE f xs  )(x:=v)\""], ["", "lemma ListUpdate_E: \"ListUpdateE f xs = ListUpdate f xs (%e x. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ListUpdateE f xs = ListUpdate f xs (\\<lambda>e x. e)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ListUpdateE f [] = ListUpdate f [] (\\<lambda>e x. e)\n 2. \\<And>a xs.\n       ListUpdateE f xs =\n       ListUpdate f xs (\\<lambda>e x. e) \\<Longrightarrow>\n       ListUpdateE f (a # xs) = ListUpdate f (a # xs) (\\<lambda>e x. e)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       ListUpdateE f xs =\n       ListUpdate f xs (\\<lambda>e x. e) \\<Longrightarrow>\n       ListUpdateE f (a # xs) = ListUpdate f (a # xs) (\\<lambda>e x. e)", "subgoal for a xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ListUpdateE f xs = ListUpdate f xs (\\<lambda>e x. e) \\<Longrightarrow>\n    ListUpdateE f (a # xs) = ListUpdate f (a # xs) (\\<lambda>e x. e)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>ListUpdateE f xs = ListUpdate f xs (\\<lambda>e x. e);\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE f (a # xs) =\n                         ListUpdate f (a # xs) (\\<lambda>e x. e)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma allg_E: fixes A::assn2\n    assumes \n   \" (\\<And>l s n x. x \\<in> fst ` upds \\<Longrightarrow> A (l(x := n)) = A l)\" \"fst ` set xs \\<subseteq> fst ` upds\"\n   shows \"A (ListUpdateE f xs) = A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (ListUpdateE f xs) = A f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A (ListUpdateE f xs) = A f", "have \" A (ListUpdate f xs (%e x. e)) = A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (ListUpdate f xs (\\<lambda>e x. e)) = A f", "apply(rule allg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s n x. x \\<in> fst ` ?upds \\<Longrightarrow> A (l(x := n)) = A l\n 2. fst ` set xs \\<subseteq> fst ` ?upds", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A (ListUpdate f xs (\\<lambda>e x. e)) = A f\n\ngoal (1 subgoal):\n 1. A (ListUpdateE f xs) = A f", "then"], ["proof (chain)\npicking this:\n  A (ListUpdate f xs (\\<lambda>e x. e)) = A f", "show ?thesis"], ["proof (prove)\nusing this:\n  A (ListUpdate f xs (\\<lambda>e x. e)) = A f\n\ngoal (1 subgoal):\n 1. A (ListUpdateE f xs) = A f", "by(simp only: ListUpdate_E)"], ["proof (state)\nthis:\n  A (ListUpdateE f xs) = A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ListUpdateE_updates: \"distinct (map fst xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> ListUpdateE l'' [] (fst x) = snd x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x;\n        distinct (map fst (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n  x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> ListUpdateE l'' [] (fst x) = snd x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x;\n        distinct (map fst (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])\n  x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n  x \\<in> set []\n\ngoal (1 subgoal):\n 1. ListUpdateE l'' [] (fst x) = snd x", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ListUpdateE l'' [] (fst x) = snd x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x;\n        distinct (map fst (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x;\n        distinct (map fst (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x\n  distinct (map fst (a # xs))\n  x \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> ListUpdateE l'' xs (fst x) = snd x;\n        distinct (map fst (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ListUpdateE l'' (a # xs) (fst x) = snd x", "proof (cases \"fst a = fst x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst a = fst x \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x\n 2. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "case True"], ["proof (state)\nthis:\n  fst a = fst x\n\ngoal (2 subgoals):\n 1. fst a = fst x \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x\n 2. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "then"], ["proof (chain)\npicking this:\n  fst a = fst x", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\nusing this:\n  fst a = fst x\n\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. fst a = fst x \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x\n 2. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "with True"], ["proof (chain)\npicking this:\n  fst a = fst x\n  a = (y, e)", "have fstx: \"fst x=y\""], ["proof (prove)\nusing this:\n  fst a = fst x\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. fst x = y", "by simp"], ["proof (state)\nthis:\n  fst x = y\n\ngoal (2 subgoals):\n 1. fst a = fst x \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x\n 2. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "from Cons(2,3) fstx  a"], ["proof (chain)\npicking this:\n  distinct (map fst (a # xs))\n  x \\<in> set (a # xs)\n  fst x = y\n  a = (y, e)", "have a2: \"x=a\""], ["proof (prove)\nusing this:\n  distinct (map fst (a # xs))\n  x \\<in> set (a # xs)\n  fst x = y\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. x = a", "by force"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. fst a = fst x \\<Longrightarrow> ListUpdateE l'' (a # xs) (fst x) = snd x\n 2. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ListUpdateE l'' (a # xs) (fst x) = snd x", "unfolding a2 a"], ["proof (prove)\ngoal (1 subgoal):\n 1. ListUpdateE l'' ((y, e) # xs) (fst (y, e)) = snd (y, e)", "by(simp)"], ["proof (state)\nthis:\n  ListUpdateE l'' (a # xs) (fst x) = snd x\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "case False"], ["proof (state)\nthis:\n  fst a \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "with Cons(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (a # xs)\n  fst a \\<noteq> fst x", "have A: \"x\\<in>set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set (a # xs)\n  fst a \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (a # xs))", "have B: \"distinct (map fst xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst (a # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> fst x \\<Longrightarrow>\n    ListUpdateE l'' (a # xs) (fst x) = snd x", "from Cons(1)[OF B A] False"], ["proof (chain)\npicking this:\n  ListUpdateE l'' xs (fst x) = snd x\n  fst a \\<noteq> fst x", "show ?thesis"], ["proof (prove)\nusing this:\n  ListUpdateE l'' xs (fst x) = snd x\n  fst a \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. ListUpdateE l'' (a # xs) (fst x) = snd x", "unfolding a"], ["proof (prove)\nusing this:\n  ListUpdateE l'' xs (fst x) = snd x\n  fst (y, e) \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. ListUpdateE l'' ((y, e) # xs) (fst x) = snd x", "by(simp)"], ["proof (state)\nthis:\n  ListUpdateE l'' (a # xs) (fst x) = snd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ListUpdateE l'' (a # xs) (fst x) = snd x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ListUpdate_updates: \"x \\<in> fst ` (set xs) \\<Longrightarrow> ListUpdate l'' xs (%e. l) x = l x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fst ` set xs \\<Longrightarrow>\n    ListUpdate l'' xs (\\<lambda>e. l) x = l x", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> fst ` set [] \\<Longrightarrow>\n    ListUpdate l'' [] (\\<lambda>e. l) x = l x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "case Nil"], ["proof (state)\nthis:\n  x \\<in> fst ` set []\n\ngoal (2 subgoals):\n 1. x \\<in> fst ` set [] \\<Longrightarrow>\n    ListUpdate l'' [] (\\<lambda>e. l) x = l x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "then"], ["proof (chain)\npicking this:\n  x \\<in> fst ` set []", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> fst ` set []\n\ngoal (1 subgoal):\n 1. ListUpdate l'' [] (\\<lambda>e. l) x = l x", "by(simp)"], ["proof (state)\nthis:\n  ListUpdate l'' [] (\\<lambda>e. l) x = l x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "case (Cons a xs)"], ["proof (state)\nthis:\n  x \\<in> fst ` set xs \\<Longrightarrow>\n  ListUpdate l'' xs (\\<lambda>e. l) x = l x\n  x \\<in> fst ` set (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "obtain q p where axe: \"a = (p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q. a = (p, q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n                ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "from Cons"], ["proof (chain)\npicking this:\n  x \\<in> fst ` set xs \\<Longrightarrow>\n  ListUpdate l'' xs (\\<lambda>e. l) x = l x\n  x \\<in> fst ` set (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> fst ` set xs \\<Longrightarrow>\n  ListUpdate l'' xs (\\<lambda>e. l) x = l x\n  x \\<in> fst ` set (a # xs)\n\ngoal (1 subgoal):\n 1. ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x", "unfolding axe"], ["proof (prove)\nusing this:\n  x \\<in> fst ` set xs \\<Longrightarrow>\n  ListUpdate l'' xs (\\<lambda>e. l) x = l x\n  x \\<in> fst ` set ((p, q) # xs)\n\ngoal (1 subgoal):\n 1. ListUpdate l'' ((p, q) # xs) (\\<lambda>e. l) x = l x", "apply(cases \"x=p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n             ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n     x \\<in> fst ` set ((p, q) # xs); x = p\\<rbrakk>\n    \\<Longrightarrow> ListUpdate l'' ((p, q) # xs) (\\<lambda>e. l) x = l x\n 2. \\<lbrakk>x \\<in> fst ` set xs \\<Longrightarrow>\n             ListUpdate l'' xs (\\<lambda>e. l) x = l x;\n     x \\<in> fst ` set ((p, q) # xs); x \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> ListUpdate l'' ((p, q) # xs) (\\<lambda>e. l) x = l x", "by(simp_all)"], ["proof (state)\nthis:\n  ListUpdate l'' (a # xs) (\\<lambda>e. l) x = l x\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"lesvars xs == fst ` (set xs)\""], ["", "fun preList where\n  \"preList [] C l s = True\"\n| \"preList ((x,e)#xs) C l s = (l x = preT C e s \\<and> preList xs C l s)\""], ["", "lemma preList_Seq: \"preList upds (C1;; C2) l s = preList (map (\\<lambda>(x, e). (x, preT C2 e)) upds) C1 l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList upds (C1;; C2) l s =\n    preList (map (\\<lambda>(x, e). (x, preT C2 e)) upds) C1 l s", "proof (induct upds)"], ["proof (state)\ngoal (2 subgoals):\n 1. preList [] (C1;; C2) l s =\n    preList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) []) C1\n     l s\n 2. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. preList [] (C1;; C2) l s =\n    preList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) []) C1\n     l s\n 2. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. preList [] (C1;; C2) l s =\n    preList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) []) C1\n     l s", "by simp"], ["proof (state)\nthis:\n  preList [] (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) []) C1 l\n   s\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  preList xs (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) xs) C1 l\n   s\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        C1 l s \\<Longrightarrow>\n       preList (a # upds) (C1;; C2) l s =\n       preList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          (a # upds))\n        C1 l s", "from Cons"], ["proof (chain)\npicking this:\n  preList xs (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) xs) C1 l\n   s", "show ?case"], ["proof (prove)\nusing this:\n  preList xs (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) xs) C1 l\n   s\n\ngoal (1 subgoal):\n 1. preList (a # xs) (C1;; C2) l s =\n    preList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n       (a # xs))\n     C1 l s", "unfolding a"], ["proof (prove)\nusing this:\n  preList xs (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) xs) C1 l\n   s\n\ngoal (1 subgoal):\n 1. preList ((y, e) # xs) (C1;; C2) l s =\n    preList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n       ((y, e) # xs))\n     C1 l s", "by (simp)"], ["proof (state)\nthis:\n  preList (a # xs) (C1;; C2) l s =\n  preList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n     (a # xs))\n   C1 l s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma support_True[simp]: \"support (\\<lambda>a b. True) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>a b. True) = {}", "unfolding support_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l1 l2 s.\n           (\\<forall>y. y \\<noteq> x \\<longrightarrow> l1 y = l2 y) \\<and>\n           True \\<noteq> True} =\n    {}", "by fast"], ["", "lemma support_preList: \"support (preList upds C1) \\<subseteq> lesvars upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds", "proof (induct upds)"], ["proof (state)\ngoal (2 subgoals):\n 1. support (preList [] C1) \\<subseteq> lesvars []\n 2. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. support (preList [] C1) \\<subseteq> lesvars []\n 2. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList [] C1) \\<subseteq> lesvars []", "by simp"], ["proof (state)\nthis:\n  support (preList [] C1) \\<subseteq> lesvars []\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "case (Cons a upds)"], ["proof (state)\nthis:\n  support (preList upds C1) \\<subseteq> lesvars upds\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n       support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "from Cons"], ["proof (chain)\npicking this:\n  support (preList upds C1) \\<subseteq> lesvars upds", "show ?case"], ["proof (prove)\nusing this:\n  support (preList upds C1) \\<subseteq> lesvars upds\n\ngoal (1 subgoal):\n 1. support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)", "unfolding a"], ["proof (prove)\nusing this:\n  support (preList upds C1) \\<subseteq> lesvars upds\n\ngoal (1 subgoal):\n 1. support (preList ((y, e) # upds) C1) \\<subseteq> lesvars ((y, e) # upds)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (\\<lambda>a b. a y = preT C1 e b \\<and> preList upds C1 a b)\n    \\<subseteq> insert y (lesvars upds)", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (\\<lambda>l s. l y = preT C1 e s) \\<union>\n    support (preList upds C1)\n    \\<subseteq> insert y (lesvars upds)", "apply(rule Un_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (\\<lambda>l s. l y = preT C1 e s)\n    \\<subseteq> insert y (lesvars upds)\n 2. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (preList upds C1) \\<subseteq> insert y (lesvars upds)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (\\<lambda>l s. l y = preT C1 e s)\n    \\<subseteq> insert y (lesvars upds)", "apply(rule subset_trans[OF support_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    supportE (\\<lambda>l. preT C1 e) \\<union> {y}\n    \\<subseteq> insert y (lesvars upds)", "using supportE_twicepreT subset_trans  supportE_single2"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. preT ?C1.0 (preT ?C2.0 (?e l)))\n  \\<subseteq> supportE ?e\n  \\<lbrakk>?A \\<subseteq> ?B; ?B \\<subseteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<subseteq> ?C\n  supportE (\\<lambda>l. ?P) = {}\n\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    supportE (\\<lambda>l. preT C1 e) \\<union> {y}\n    \\<subseteq> insert y (lesvars upds)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (preList upds C1) \\<subseteq> insert y (lesvars upds)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C1) \\<subseteq> lesvars upds \\<Longrightarrow>\n    support (preList upds C1) \\<subseteq> insert y (lesvars upds)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  support (preList (a # upds) C1) \\<subseteq> lesvars (a # upds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma preListpreSet: \"preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preSet (set xs) C l s \\<Longrightarrow> preList xs C l s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. preSet (set []) C l s \\<Longrightarrow> preList [] C l s\n 2. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "case Nil"], ["proof (state)\nthis:\n  preSet (set []) C l s\n\ngoal (2 subgoals):\n 1. preSet (set []) C l s \\<Longrightarrow> preList [] C l s\n 2. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "then"], ["proof (chain)\npicking this:\n  preSet (set []) C l s", "show ?case"], ["proof (prove)\nusing this:\n  preSet (set []) C l s\n\ngoal (1 subgoal):\n 1. preList [] C l s", "by simp"], ["proof (state)\nthis:\n  preList [] C l s\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\n  preSet (set (a # xs)) C l s\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>preSet (set xs) C l s \\<Longrightarrow> preList xs C l s;\n        preSet (set (a # xs)) C l s\\<rbrakk>\n       \\<Longrightarrow> preList (a # xs) C l s", "from Cons"], ["proof (chain)\npicking this:\n  preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\n  preSet (set (a # xs)) C l s", "show ?case"], ["proof (prove)\nusing this:\n  preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\n  preSet (set (a # xs)) C l s\n\ngoal (1 subgoal):\n 1. preList (a # xs) C l s", "unfolding a"], ["proof (prove)\nusing this:\n  preSet (set xs) C l s \\<Longrightarrow> preList xs C l s\n  preSet (set ((y, e) # xs)) C l s\n\ngoal (1 subgoal):\n 1. preList ((y, e) # xs) C l s", "by (simp)"], ["proof (state)\nthis:\n  preList (a # xs) C l s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma preSetpreList: \"preList xs C l s \\<Longrightarrow>  preSet (set xs) C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList xs C l s \\<Longrightarrow> preSet (set xs) C l s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. preList [] C l s \\<Longrightarrow> preSet (set []) C l s\n 2. \\<And>a xs.\n       \\<lbrakk>preList xs C l s \\<Longrightarrow> preSet (set xs) C l s;\n        preList (a # xs) C l s\\<rbrakk>\n       \\<Longrightarrow> preSet (set (a # xs)) C l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  preList xs C l s \\<Longrightarrow> preSet (set xs) C l s\n  preList (a # xs) C l s\n\ngoal (2 subgoals):\n 1. preList [] C l s \\<Longrightarrow> preSet (set []) C l s\n 2. \\<And>a xs.\n       \\<lbrakk>preList xs C l s \\<Longrightarrow> preSet (set xs) C l s;\n        preList (a # xs) C l s\\<rbrakk>\n       \\<Longrightarrow> preSet (set (a # xs)) C l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. preList [] C l s \\<Longrightarrow> preSet (set []) C l s\n 2. \\<And>a xs.\n       \\<lbrakk>preList xs C l s \\<Longrightarrow> preSet (set xs) C l s;\n        preList (a # xs) C l s\\<rbrakk>\n       \\<Longrightarrow> preSet (set (a # xs)) C l s", "from Cons"], ["proof (chain)\npicking this:\n  preList xs C l s \\<Longrightarrow> preSet (set xs) C l s\n  preList (a # xs) C l s", "show ?case"], ["proof (prove)\nusing this:\n  preList xs C l s \\<Longrightarrow> preSet (set xs) C l s\n  preList (a # xs) C l s\n\ngoal (1 subgoal):\n 1. preSet (set (a # xs)) C l s", "unfolding a"], ["proof (prove)\nusing this:\n  preList xs C l s \\<Longrightarrow> preSet (set xs) C l s\n  preList ((y, e) # xs) C l s\n\ngoal (1 subgoal):\n 1. preSet (set ((y, e) # xs)) C l s", "by(simp)"], ["proof (state)\nthis:\n  preSet (set (a # xs)) C l s\n\ngoal (1 subgoal):\n 1. preList [] C l s \\<Longrightarrow> preSet (set []) C l s", "qed simp"], ["", "(* surprise. but makes sense, if the clauses are contradictory on the \n    left side, so are they on the right side *)"], ["", "lemma preSetpreList_eq: \"preList xs C l s = preSet (set xs) C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList xs C l s = preSet (set xs) C l s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. preList [] C l s = preSet (set []) C l s\n 2. \\<And>a xs.\n       preList xs C l s = preSet (set xs) C l s \\<Longrightarrow>\n       preList (a # xs) C l s = preSet (set (a # xs)) C l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  preList xs C l s = preSet (set xs) C l s\n\ngoal (2 subgoals):\n 1. preList [] C l s = preSet (set []) C l s\n 2. \\<And>a xs.\n       preList xs C l s = preSet (set xs) C l s \\<Longrightarrow>\n       preList (a # xs) C l s = preSet (set (a # xs)) C l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. preList [] C l s = preSet (set []) C l s\n 2. \\<And>a xs.\n       preList xs C l s = preSet (set xs) C l s \\<Longrightarrow>\n       preList (a # xs) C l s = preSet (set (a # xs)) C l s", "from Cons"], ["proof (chain)\npicking this:\n  preList xs C l s = preSet (set xs) C l s", "show ?case"], ["proof (prove)\nusing this:\n  preList xs C l s = preSet (set xs) C l s\n\ngoal (1 subgoal):\n 1. preList (a # xs) C l s = preSet (set (a # xs)) C l s", "unfolding a"], ["proof (prove)\nusing this:\n  preList xs C l s = preSet (set xs) C l s\n\ngoal (1 subgoal):\n 1. preList ((y, e) # xs) C l s = preSet (set ((y, e) # xs)) C l s", "by(simp)"], ["proof (state)\nthis:\n  preList (a # xs) C l s = preSet (set (a # xs)) C l s\n\ngoal (1 subgoal):\n 1. preList [] C l s = preSet (set []) C l s", "qed simp"], ["", "fun postList where\n  \"postList []  l s = True\"\n| \"postList ((x,e)#xs)  l s = (l x = e s \\<and> postList xs l s)\""], ["", "lemma support_postList: \"support (postList xs) \\<subseteq> lesvars xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. support (postList []) \\<subseteq> lesvars []\n 2. \\<And>a xs.\n       support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n       support (postList (a # xs)) \\<subseteq> lesvars (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  support (postList xs) \\<subseteq> lesvars xs\n\ngoal (2 subgoals):\n 1. support (postList []) \\<subseteq> lesvars []\n 2. \\<And>a xs.\n       support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n       support (postList (a # xs)) \\<subseteq> lesvars (a # xs)", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. support (postList []) \\<subseteq> lesvars []\n 2. \\<And>a xs.\n       support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n       support (postList (a # xs)) \\<subseteq> lesvars (a # xs)", "from Cons"], ["proof (chain)\npicking this:\n  support (postList xs) \\<subseteq> lesvars xs", "show ?case"], ["proof (prove)\nusing this:\n  support (postList xs) \\<subseteq> lesvars xs\n\ngoal (1 subgoal):\n 1. support (postList (a # xs)) \\<subseteq> lesvars (a # xs)", "unfolding a"], ["proof (prove)\nusing this:\n  support (postList xs) \\<subseteq> lesvars xs\n\ngoal (1 subgoal):\n 1. support (postList ((y, e) # xs)) \\<subseteq> lesvars ((y, e) # xs)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (\\<lambda>a b. a y = e b \\<and> postList xs a b)\n    \\<subseteq> insert y (lesvars xs)", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (\\<lambda>l s. l y = e s) \\<union> support (postList xs)\n    \\<subseteq> insert y (lesvars xs)", "apply(rule Un_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (\\<lambda>l s. l y = e s) \\<subseteq> insert y (lesvars xs)\n 2. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (postList xs) \\<subseteq> insert y (lesvars xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (\\<lambda>l s. l y = e s) \\<subseteq> insert y (lesvars xs)", "apply(rule subset_trans[OF support_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    supportE (\\<lambda>l. e) \\<union> {y} \\<subseteq> insert y (lesvars xs)", "using supportE_twicepreT subset_trans  supportE_single2"], ["proof (prove)\nusing this:\n  supportE (\\<lambda>l. preT ?C1.0 (preT ?C2.0 (?e l)))\n  \\<subseteq> supportE ?e\n  \\<lbrakk>?A \\<subseteq> ?B; ?B \\<subseteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<subseteq> ?C\n  supportE (\\<lambda>l. ?P) = {}\n\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    supportE (\\<lambda>l. e) \\<union> {y} \\<subseteq> insert y (lesvars xs)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (postList xs) \\<subseteq> insert y (lesvars xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (postList xs) \\<subseteq> lesvars xs \\<Longrightarrow>\n    support (postList xs) \\<subseteq> insert y (lesvars xs)", "by(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  support (postList (a # xs)) \\<subseteq> lesvars (a # xs)\n\ngoal (1 subgoal):\n 1. support (postList []) \\<subseteq> lesvars []", "qed simp"], ["", "lemma postpreList_inv: assumes \"S s = S (postQ C s)\" \n  shows \"postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s =  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s =\n    preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s", "proof (induct upds)"], ["proof (state)\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        C l s", "case (Cons a upds)"], ["proof (state)\nthis:\n  postList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   l s =\n  preList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   C l s\n\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        C l s", "obtain y e where axe: \"a = (y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          upds)\n        C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        l s =\n       preList\n        (map (\\<lambda>a.\n                 case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n          (a # upds))\n        C l s", "from Cons"], ["proof (chain)\npicking this:\n  postList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   l s =\n  preList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   C l s", "show ?case"], ["proof (prove)\nusing this:\n  postList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   l s =\n  preList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       (a # upds))\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       (a # upds))\n     C l s", "unfolding axe"], ["proof (prove)\nusing this:\n  postList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   l s =\n  preList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     upds)\n   C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       ((y, e) # upds))\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       ((y, e) # upds))\n     C l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     C l s \\<Longrightarrow>\n    (l y = e (S s) \\<and>\n     preList\n      (map (\\<lambda>a.\n               case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n        upds)\n      C l s) =\n    (l y = preT C (\\<lambda>s. e (S s)) s \\<and>\n     preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s)", "apply(simp only: TQ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     C l s \\<Longrightarrow>\n    (l y = e (S s) \\<and>\n     preList\n      (map (\\<lambda>a.\n               case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n        upds)\n      C l s) =\n    (l y = e (S (postQ C s)) \\<and>\n     preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s)", "using assms"], ["proof (prove)\nusing this:\n  S s = S (postQ C s)\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds)\n     C l s \\<Longrightarrow>\n    (l y = e (S s) \\<and>\n     preList\n      (map (\\<lambda>a.\n               case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n        upds)\n      C l s) =\n    (l y = e (S (postQ C s)) \\<and>\n     preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s)", "by auto"], ["proof (state)\nthis:\n  postList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     (a # upds))\n   l s =\n  preList\n   (map (\\<lambda>a.\n            case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n     (a # upds))\n   C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     l s =\n    preList\n     (map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       [])\n     C l s", "qed simp"], ["", "lemma postList_preList: \"postList (map (\\<lambda>(x, e). (x, preT C e)) upds) l s = preList upds C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. postList (map (\\<lambda>(x, e). (x, preT C e)) upds) l s =\n    preList upds C l s", "proof (induct upds)"], ["proof (state)\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) []) l\n     s =\n    preList [] C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          upds)\n        l s =\n       preList upds C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          (a # upds))\n        l s =\n       preList (a # upds) C l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  postList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) xs) l s =\n  preList xs C l s\n\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) []) l\n     s =\n    preList [] C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          upds)\n        l s =\n       preList upds C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          (a # upds))\n        l s =\n       preList (a # upds) C l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) []) l\n     s =\n    preList [] C l s\n 2. \\<And>a upds.\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          upds)\n        l s =\n       preList upds C l s \\<Longrightarrow>\n       postList\n        (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n          (a # upds))\n        l s =\n       preList (a # upds) C l s", "from Cons"], ["proof (chain)\npicking this:\n  postList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) xs) l s =\n  preList xs C l s", "show ?case"], ["proof (prove)\nusing this:\n  postList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) xs) l s =\n  preList xs C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n       (a # xs))\n     l s =\n    preList (a # xs) C l s", "unfolding a"], ["proof (prove)\nusing this:\n  postList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) xs) l s =\n  preList xs C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e))\n       ((y, e) # xs))\n     l s =\n    preList ((y, e) # xs) C l s", "by(simp)"], ["proof (state)\nthis:\n  postList\n   (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) (a # xs))\n   l s =\n  preList (a # xs) C l s\n\ngoal (1 subgoal):\n 1. postList\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e)) []) l\n     s =\n    preList [] C l s", "qed simp"], ["", "lemma postSetpostList: \"postList xs l s \\<Longrightarrow>  postSet (set xs) l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. postList xs l s \\<Longrightarrow> postSet (set xs) l s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. postList [] l s \\<Longrightarrow> postSet (set []) l s\n 2. \\<And>a xs.\n       \\<lbrakk>postList xs l s \\<Longrightarrow> postSet (set xs) l s;\n        postList (a # xs) l s\\<rbrakk>\n       \\<Longrightarrow> postSet (set (a # xs)) l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  postList xs l s \\<Longrightarrow> postSet (set xs) l s\n  postList (a # xs) l s\n\ngoal (2 subgoals):\n 1. postList [] l s \\<Longrightarrow> postSet (set []) l s\n 2. \\<And>a xs.\n       \\<lbrakk>postList xs l s \\<Longrightarrow> postSet (set xs) l s;\n        postList (a # xs) l s\\<rbrakk>\n       \\<Longrightarrow> postSet (set (a # xs)) l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. postList [] l s \\<Longrightarrow> postSet (set []) l s\n 2. \\<And>a xs.\n       \\<lbrakk>postList xs l s \\<Longrightarrow> postSet (set xs) l s;\n        postList (a # xs) l s\\<rbrakk>\n       \\<Longrightarrow> postSet (set (a # xs)) l s", "from Cons"], ["proof (chain)\npicking this:\n  postList xs l s \\<Longrightarrow> postSet (set xs) l s\n  postList (a # xs) l s", "show ?case"], ["proof (prove)\nusing this:\n  postList xs l s \\<Longrightarrow> postSet (set xs) l s\n  postList (a # xs) l s\n\ngoal (1 subgoal):\n 1. postSet (set (a # xs)) l s", "unfolding a"], ["proof (prove)\nusing this:\n  postList xs l s \\<Longrightarrow> postSet (set xs) l s\n  postList ((y, e) # xs) l s\n\ngoal (1 subgoal):\n 1. postSet (set ((y, e) # xs)) l s", "by(simp)"], ["proof (state)\nthis:\n  postSet (set (a # xs)) l s\n\ngoal (1 subgoal):\n 1. postList [] l s \\<Longrightarrow> postSet (set []) l s", "qed simp"], ["", "lemma postListpostSet: \"postSet (set xs) l s \\<Longrightarrow> postList xs l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. postSet (set xs) l s \\<Longrightarrow> postList xs l s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. postSet (set []) l s \\<Longrightarrow> postList [] l s\n 2. \\<And>a xs.\n       \\<lbrakk>postSet (set xs) l s \\<Longrightarrow> postList xs l s;\n        postSet (set (a # xs)) l s\\<rbrakk>\n       \\<Longrightarrow> postList (a # xs) l s", "case (Cons a xs)"], ["proof (state)\nthis:\n  postSet (set xs) l s \\<Longrightarrow> postList xs l s\n  postSet (set (a # xs)) l s\n\ngoal (2 subgoals):\n 1. postSet (set []) l s \\<Longrightarrow> postList [] l s\n 2. \\<And>a xs.\n       \\<lbrakk>postSet (set xs) l s \\<Longrightarrow> postList xs l s;\n        postSet (set (a # xs)) l s\\<rbrakk>\n       \\<Longrightarrow> postList (a # xs) l s", "obtain y e where a: \"a=(y,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e. a = (y, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (y, e)\n\ngoal (2 subgoals):\n 1. postSet (set []) l s \\<Longrightarrow> postList [] l s\n 2. \\<And>a xs.\n       \\<lbrakk>postSet (set xs) l s \\<Longrightarrow> postList xs l s;\n        postSet (set (a # xs)) l s\\<rbrakk>\n       \\<Longrightarrow> postList (a # xs) l s", "from Cons"], ["proof (chain)\npicking this:\n  postSet (set xs) l s \\<Longrightarrow> postList xs l s\n  postSet (set (a # xs)) l s", "show ?case"], ["proof (prove)\nusing this:\n  postSet (set xs) l s \\<Longrightarrow> postList xs l s\n  postSet (set (a # xs)) l s\n\ngoal (1 subgoal):\n 1. postList (a # xs) l s", "unfolding a"], ["proof (prove)\nusing this:\n  postSet (set xs) l s \\<Longrightarrow> postList xs l s\n  postSet (set ((y, e) # xs)) l s\n\ngoal (1 subgoal):\n 1. postList ((y, e) # xs) l s", "by(simp)"], ["proof (state)\nthis:\n  postList (a # xs) l s\n\ngoal (1 subgoal):\n 1. postSet (set []) l s \\<Longrightarrow> postList [] l s", "qed simp"], ["", "lemma ListAskip: \"preList xs Askip l s = postList xs  l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList xs SKIP l s = postList xs l s", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. preList [] SKIP l s = postList [] l s\n 2. \\<And>a xs.\n       preList xs SKIP l s = postList xs l s \\<Longrightarrow>\n       preList (a # xs) SKIP l s = postList (a # xs) l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       preList xs SKIP l s = postList xs l s \\<Longrightarrow>\n       preList (a # xs) SKIP l s = postList (a # xs) l s", "by force"], ["", "lemma SetAskip: \"preSet U Askip l s = postSet U l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preSet U SKIP l s = postSet U l s", "by simp"], ["", "lemma ListAassign: \"preList upds (Aassign x1 x2) l s = postList upds l (s[x2/x1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList upds (x1 ::= x2) l s = postList upds l (s[x2/x1])", "apply(induct upds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. preList [] (x1 ::= x2) l s = postList [] l (s[x2/x1])\n 2. \\<And>a upds.\n       preList upds (x1 ::= x2) l s =\n       postList upds l (s[x2/x1]) \\<Longrightarrow>\n       preList (a # upds) (x1 ::= x2) l s = postList (a # upds) l (s[x2/x1])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds (x1 ::= x2) l s =\n       postList upds l (s[x2/x1]) \\<Longrightarrow>\n       preList (a # upds) (x1 ::= x2) l s = postList (a # upds) l (s[x2/x1])", "by force"], ["", "lemma SetAassign: \"preSet U (Aassign x1 x2) l s = postSet U l (s[x2/x1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preSet U (x1 ::= x2) l s = postSet U l (s[x2/x1])", "by simp"], ["", "lemma ListAconseq: \"preList upds (Aconseq x1 x2 x3 C) l s = preList upds C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList upds ({x1/x2/x3} CONSEQ C) l s = preList upds C l s", "apply(induct upds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. preList [] ({x1/x2/x3} CONSEQ C) l s = preList [] C l s\n 2. \\<And>a upds.\n       preList upds ({x1/x2/x3} CONSEQ C) l s =\n       preList upds C l s \\<Longrightarrow>\n       preList (a # upds) ({x1/x2/x3} CONSEQ C) l s =\n       preList (a # upds) C l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       preList upds ({x1/x2/x3} CONSEQ C) l s =\n       preList upds C l s \\<Longrightarrow>\n       preList (a # upds) ({x1/x2/x3} CONSEQ C) l s =\n       preList (a # upds) C l s", "by force"], ["", "lemma SetAconseq: \"preSet U (Aconseq x1 x2 x3 C) l s = preSet U C l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preSet U ({x1/x2/x3} CONSEQ C) l s = preSet U C l s", "by simp"], ["", "lemma ListAif1: \"bval b s \\<Longrightarrow> preList upds (IF b THEN C1 ELSE C2) l s = preList upds C1 l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bval b s \\<Longrightarrow>\n    preList upds (IF b THEN C1 ELSE C2) l s = preList upds C1 l s", "apply(induct upds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    preList [] (IF b THEN C1 ELSE C2) l s = preList [] C1 l s\n 2. \\<And>a upds.\n       \\<lbrakk>bval b s \\<Longrightarrow>\n                preList upds (IF b THEN C1 ELSE C2) l s =\n                preList upds C1 l s;\n        bval b s\\<rbrakk>\n       \\<Longrightarrow> preList (a # upds) (IF b THEN C1 ELSE C2) l s =\n                         preList (a # upds) C1 l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       \\<lbrakk>bval b s \\<Longrightarrow>\n                preList upds (IF b THEN C1 ELSE C2) l s =\n                preList upds C1 l s;\n        bval b s\\<rbrakk>\n       \\<Longrightarrow> preList (a # upds) (IF b THEN C1 ELSE C2) l s =\n                         preList (a # upds) C1 l s", "by force"], ["", "lemma SetAif1: \"bval b s \\<Longrightarrow> preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C1 l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bval b s \\<Longrightarrow>\n    preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C1 l s", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ListAif2: \"~ bval b s \\<Longrightarrow> preList upds (IF b THEN C1 ELSE C2) l s = preList upds C2 l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    preList upds (IF b THEN C1 ELSE C2) l s = preList upds C2 l s", "apply(induct upds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> bval b s \\<Longrightarrow>\n    preList [] (IF b THEN C1 ELSE C2) l s = preList [] C2 l s\n 2. \\<And>a upds.\n       \\<lbrakk>\\<not> bval b s \\<Longrightarrow>\n                preList upds (IF b THEN C1 ELSE C2) l s =\n                preList upds C2 l s;\n        \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> preList (a # upds) (IF b THEN C1 ELSE C2) l s =\n                         preList (a # upds) C2 l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a upds.\n       \\<lbrakk>\\<not> bval b s \\<Longrightarrow>\n                preList upds (IF b THEN C1 ELSE C2) l s =\n                preList upds C2 l s;\n        \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> preList (a # upds) (IF b THEN C1 ELSE C2) l s =\n                         preList (a # upds) C2 l s", "by force"], ["", "lemma SetAif2: \"~ bval b s \\<Longrightarrow> preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C2 l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    preSet upds (IF b THEN C1 ELSE C2) l s = preSet upds C2 l s", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n  In upds we collect pairs of logical variables and time expressions, these logical variables\n  are bound to the value of these expressions. postList upds C l s is an assertion stating that\n  for every (x,e) in upds, l x = e s; preList upds C l s does the same, but pulls the expression\n  e through the command c, i.e. stating for ever (x,e) in upds, l x = preT C e s. \n\n  we have to make sure, that no variable is assigned twice (the 5th premise), as well as they are \n  different from all the logical variables that occur in the annotated program C (4th premise)\n\n  we have to make sure that we can always choose new logical variables (premise 2, 3)\n*)"], ["", "lemma vc_sound: \"vc C Q \\<Longrightarrow> finite (support Q) \\<Longrightarrow> finite (varacom C)\n  \\<Longrightarrow> fst ` (set upds) \\<inter> varacom C = {} \\<Longrightarrow> distinct (map fst upds)\n  \\<Longrightarrow>  \\<turnstile>\\<^sub>1 {%l s. pre C Q l s \\<and> preList upds C l s} strip C { time C \\<Down> %l s. Q l s \\<and> postList upds l s}\n  \\<and> (\\<forall>l s. pre C Q l s \\<longrightarrow> Q l (postQ C s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n     lesvars upds \\<inter> varacom C = {}; distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C Q l s \\<and> preList upds C l s}\n     strip C\n     { time C \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                      (\\<forall>l s.\n                          pre C Q l s \\<longrightarrow> Q l (postQ C s))", "proof(induction C arbitrary: Q upds)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>Q upds.\n       \\<lbrakk>vc SKIP Q; finite (support Q); finite (varacom SKIP);\n        lesvars upds \\<inter> varacom SKIP = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre SKIP Q l s \\<and> preList upds SKIP l s}\n        strip SKIP\n        { time\n           SKIP \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre SKIP Q l s \\<longrightarrow>\n                             Q l (postQ SKIP s))\n 2. \\<And>x1 x2 Q upds.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n        strip (x1 ::= x2)\n        { time\n           (x1 ::= x2) \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (x1 ::= x2) Q l s \\<longrightarrow>\n                             Q l (postQ (x1 ::= x2) s))\n 3. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 4. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 5. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 6. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Askip Q upds)"], ["proof (state)\nthis:\n  vc SKIP Q\n  finite (support Q)\n  finite (varacom SKIP)\n  lesvars upds \\<inter> varacom SKIP = {}\n  distinct (map fst upds)\n\ngoal (6 subgoals):\n 1. \\<And>Q upds.\n       \\<lbrakk>vc SKIP Q; finite (support Q); finite (varacom SKIP);\n        lesvars upds \\<inter> varacom SKIP = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre SKIP Q l s \\<and> preList upds SKIP l s}\n        strip SKIP\n        { time\n           SKIP \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre SKIP Q l s \\<longrightarrow>\n                             Q l (postQ SKIP s))\n 2. \\<And>x1 x2 Q upds.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n        strip (x1 ::= x2)\n        { time\n           (x1 ::= x2) \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (x1 ::= x2) Q l s \\<longrightarrow>\n                             Q l (postQ (x1 ::= x2) s))\n 3. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 4. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 5. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 6. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "then"], ["proof (chain)\npicking this:\n  vc SKIP Q\n  finite (support Q)\n  finite (varacom SKIP)\n  lesvars upds \\<inter> varacom SKIP = {}\n  distinct (map fst upds)", "show ?case"], ["proof (prove)\nusing this:\n  vc SKIP Q\n  finite (support Q)\n  finite (varacom SKIP)\n  lesvars upds \\<inter> varacom SKIP = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre SKIP Q l s \\<and> preList upds SKIP l s}\n                         strip SKIP\n                         { time\n                            SKIP \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s. pre SKIP Q l s \\<longrightarrow> Q l (postQ SKIP s))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         Q l s \\<and> preList upds SKIP l s}\n     SKIP\n     { \\<lambda>a.\n          Suc 0 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule weaken_post[where Q=\"%l s. Q l s \\<and> preList upds Askip l s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         Q l s \\<and> preList upds SKIP l s}\n     SKIP\n     { \\<lambda>a.\n          Suc 0 \\<Down> \\<lambda>l s. Q l s \\<and> preList upds SKIP l s}\n 2. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and>\n                         preList upds SKIP l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s", "apply(simp add: Skip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and>\n                         preList upds SKIP l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s", "using ListAskip"], ["proof (prove)\nusing this:\n  preList ?xs SKIP ?l ?s = postList ?xs ?l ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and>\n                         preList upds SKIP l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s", "by fast"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre SKIP Q l s \\<and> preList upds SKIP l s}\n                       strip SKIP\n                       { time\n                          SKIP \\<Down> \\<lambda>l s.\n    Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s. pre SKIP Q l s \\<longrightarrow> Q l (postQ SKIP s))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 Q upds.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n        strip (x1 ::= x2)\n        { time\n           (x1 ::= x2) \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (x1 ::= x2) Q l s \\<longrightarrow>\n                             Q l (postQ (x1 ::= x2) s))\n 2. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 3. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 4. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 5. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 Q upds.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n        strip (x1 ::= x2)\n        { time\n           (x1 ::= x2) \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (x1 ::= x2) Q l s \\<longrightarrow>\n                             Q l (postQ (x1 ::= x2) s))\n 2. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 3. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 4. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 5. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Aassign x1 x2 Q upds)"], ["proof (state)\nthis:\n  vc (x1 ::= x2) Q\n  finite (support Q)\n  finite (varacom (x1 ::= x2))\n  lesvars upds \\<inter> varacom (x1 ::= x2) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 Q upds.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n        strip (x1 ::= x2)\n        { time\n           (x1 ::= x2) \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (x1 ::= x2) Q l s \\<longrightarrow>\n                             Q l (postQ (x1 ::= x2) s))\n 2. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 3. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 4. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 5. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "then"], ["proof (chain)\npicking this:\n  vc (x1 ::= x2) Q\n  finite (support Q)\n  finite (varacom (x1 ::= x2))\n  lesvars upds \\<inter> varacom (x1 ::= x2) = {}\n  distinct (map fst upds)", "show ?case"], ["proof (prove)\nusing this:\n  vc (x1 ::= x2) Q\n  finite (support Q)\n  finite (varacom (x1 ::= x2))\n  lesvars upds \\<inter> varacom (x1 ::= x2) = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre (x1 ::= x2) Q l s \\<and>\n                             preList upds (x1 ::= x2) l s}\n                         strip (x1 ::= x2)\n                         { time\n                            (x1 ::= x2) \\<Down> \\<lambda>l s.\n             Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre (x1 ::= x2) Q l s \\<longrightarrow> Q l (postQ (x1 ::= x2) s))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n     finite (varacom (x1 ::= x2));\n     lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n     distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre (x1 ::= x2) Q l s \\<and> preList upds (x1 ::= x2) l s}\n     strip (x1 ::= x2)\n     { time\n        (x1 ::= x2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply(auto simp add: Assign)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         Q l (s[x2/x1]) \\<and> preList upds (x1 ::= x2) l s}\n     x1 ::= x2\n     { \\<lambda>a.\n          Suc 0 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply(rule weaken_post[where Q=\"%l s. Q l s \\<and> postList upds l s\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         Q l (s[x2/x1]) \\<and> preList upds (x1 ::= x2) l s}\n     x1 ::= x2\n     { \\<lambda>a.\n          Suc 0 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and> postList upds l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s\n 3. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply(simp only: ListAassign)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         Q l (s[x2/x1]) \\<and> postList upds l (s[x2/x1])}\n     x1 ::= x2\n     { \\<lambda>a.\n          Suc 0 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and> postList upds l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s\n 3. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply(rule Assign)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (support Q); distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         Q l s \\<and> postList upds l s \\<longrightarrow>\n                         Q l s \\<and> postList upds l s\n 2. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>vc (x1 ::= x2) Q; finite (support Q);\n        finite (varacom (x1 ::= x2));\n        lesvars upds \\<inter> varacom (x1 ::= x2) = {};\n        distinct (map fst upds); pre (x1 ::= x2) Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ (x1 ::= x2) s)", "apply(simp only: postQ.simps pre.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre (x1 ::= x2) Q l s \\<and>\n                           preList upds (x1 ::= x2) l s}\n                       strip (x1 ::= x2)\n                       { time\n                          (x1 ::= x2) \\<Down> \\<lambda>l s.\n           Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s.\n      pre (x1 ::= x2) Q l s \\<longrightarrow> Q l (postQ (x1 ::= x2) s))\n\ngoal (4 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 3. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 4. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 3. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 4. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Aif b C1 C2 Q upds )"], ["proof (state)\nthis:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (IF b THEN C1 ELSE C2) Q\n  finite (support Q)\n  finite (varacom (IF b THEN C1 ELSE C2))\n  lesvars upds \\<inter> varacom (IF b THEN C1 ELSE C2) = {}\n  distinct (map fst upds)\n\ngoal (4 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (IF x1 THEN C1 ELSE C2) Q; finite (support Q);\n        finite (varacom (IF x1 THEN C1 ELSE C2));\n        lesvars upds \\<inter> varacom (IF x1 THEN C1 ELSE C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (IF x1 THEN C1 ELSE C2) Q l s \\<and>\n            preList upds (IF x1 THEN C1 ELSE C2) l s}\n        strip (IF x1 THEN C1 ELSE C2)\n        { time\n           (IF x1 THEN C1\n            ELSE C2) \\<Down> \\<lambda>l s.\n                                Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (IF x1 THEN C1 ELSE C2) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ (IF x1 THEN C1 ELSE C2) s))\n 3. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 4. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (IF b THEN C1 ELSE C2) Q\n  finite (support Q)\n  finite (varacom (IF b THEN C1 ELSE C2))\n  lesvars upds \\<inter> varacom (IF b THEN C1 ELSE C2) = {}\n  distinct (map fst upds)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (IF b THEN C1 ELSE C2) Q\n  finite (support Q)\n  finite (varacom (IF b THEN C1 ELSE C2))\n  lesvars upds \\<inter> varacom (IF b THEN C1 ELSE C2) = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre (IF b THEN C1 ELSE C2) Q l s \\<and>\n                             preList upds (IF b THEN C1 ELSE C2) l s}\n                         strip (IF b THEN C1 ELSE C2)\n                         { time\n                            (IF b THEN C1\n                             ELSE C2) \\<Down> \\<lambda>l s.\n           Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre (IF b THEN C1 ELSE C2) Q l s \\<longrightarrow>\n        Q l (postQ (IF b THEN C1 ELSE C2) s))", "apply(auto simp add: Assign)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         (bval b s \\<longrightarrow>\n          pre C1 Q l s \\<and>\n          preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n         (\\<not> bval b s \\<longrightarrow>\n          pre C2 Q l s \\<and> preList upds (IF b THEN C1 ELSE C2) l s)}\n     IF b THEN strip C1 ELSE strip C2\n     { \\<lambda>a.\n          if bval b a then 1 + time C1 a\n          else 1 +\n               time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); bval b s; pre C1 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C1 s)\n 3. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); \\<not> bval b s; pre C2 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C2 s)", "apply(rule If2[where e=\"\\<lambda>a. if bval b a then  time C1 a else time C2 a\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         ((bval b s \\<longrightarrow>\n           pre C1 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n          (\\<not> bval b s \\<longrightarrow>\n           pre C2 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s)) \\<and>\n         bval b s}\n     strip C1\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         ((bval b s \\<longrightarrow>\n           pre C1 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n          (\\<not> bval b s \\<longrightarrow>\n           pre C2 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s)) \\<and>\n         \\<not> bval b s}\n     strip C2\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 3. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2);\n        (bval b s \\<longrightarrow>\n         pre C1 Q l s \\<and> preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n        (\\<not> bval b s \\<longrightarrow>\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s)\\<rbrakk>\n       \\<Longrightarrow> (if bval b s then time C1 s else time C2 s) + 1 =\n                         (if bval b s then 1 + time C1 s else 1 + time C2 s)\n 4. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); bval b s; pre C1 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C1 s)\n 5. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); \\<not> bval b s; pre C2 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C2 s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         ((bval b s \\<longrightarrow>\n           pre C1 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n          (\\<not> bval b s \\<longrightarrow>\n           pre C2 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s)) \\<and>\n         bval b s}\n     strip C1\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(simp cong: rev_conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> bval b s}\n     strip C1\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule ub_cost[where e'=\"time C1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            pre C1 Q l s \\<and>\n                            preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                            bval b s \\<longrightarrow>\n                            time C1 s\n                            \\<le> k *\n                                  (if bval b s then time C1 s\n                                   else time C2 s)\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> bval b s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            pre C1 Q l s \\<and>\n                            preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                            bval b s \\<longrightarrow>\n                            0 < time C1 s \\<longrightarrow> Suc 0 \\<le> k\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> bval b s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> bval b s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule strengthen_pre[where P=\"%l s. pre C1 Q l s \\<and> preList upds C1 l s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         pre C1 Q l s \\<and>\n                         preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                         bval b s \\<longrightarrow>\n                         pre C1 Q l s \\<and> preList upds C1 l s\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and> preList upds C1 l s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "using ListAif1"], ["proof (prove)\nusing this:\n  bval ?b ?s \\<Longrightarrow>\n  preList ?upds (IF ?b THEN ?C1.0 ELSE ?C2.0) ?l ?s =\n  preList ?upds ?C1.0 ?l ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         pre C1 Q l s \\<and>\n                         preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                         bval b s \\<longrightarrow>\n                         pre C1 Q l s \\<and> preList upds C1 l s\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and> preList upds C1 l s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C1 Q l s \\<and> preList upds C1 l s}\n     strip C1\n     { time C1 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule Aif(1)[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> vc C1 Q\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> finite (support Q)\n 3. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> finite (varacom C1)\n 4. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> lesvars upds \\<inter> varacom C1 = {}\n 5. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst upds)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         ((bval b s \\<longrightarrow>\n           pre C1 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n          (\\<not> bval b s \\<longrightarrow>\n           pre C2 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s)) \\<and>\n         \\<not> bval b s}\n     strip C2\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\n 2. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2);\n        (bval b s \\<longrightarrow>\n         pre C1 Q l s \\<and> preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n        (\\<not> bval b s \\<longrightarrow>\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s)\\<rbrakk>\n       \\<Longrightarrow> (if bval b s then time C1 s else time C2 s) + 1 =\n                         (if bval b s then 1 + time C1 s else 1 + time C2 s)\n 3. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); bval b s; pre C1 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C1 s)\n 4. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); \\<not> bval b s; pre C2 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C2 s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         ((bval b s \\<longrightarrow>\n           pre C1 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n          (\\<not> bval b s \\<longrightarrow>\n           pre C2 Q l s \\<and>\n           preList upds (IF b THEN C1 ELSE C2) l s)) \\<and>\n         \\<not> bval b s}\n     strip C2\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(simp cong: rev_conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> \\<not> bval b s}\n     strip C2\n     { \\<lambda>a.\n          if bval b a then time C1 a\n          else time C2\n                a \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule ub_cost[where e'=\"time C2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            pre C2 Q l s \\<and>\n                            preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                            \\<not> bval b s \\<longrightarrow>\n                            time C2 s\n                            \\<le> k *\n                                  (if bval b s then time C1 s\n                                   else time C2 s)\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> \\<not> bval b s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "(* k=1 and *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            pre C2 Q l s \\<and>\n                            preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                            \\<not> bval b s \\<longrightarrow>\n                            time C2 s\n                            \\<le> k *\n                                  (if bval b s then time C1 s\n                                   else time C2 s)\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> \\<not> bval b s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            pre C2 Q l s \\<and>\n                            preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                            \\<not> bval b s \\<longrightarrow>\n                            0 < time C2 s \\<longrightarrow> Suc 0 \\<le> k\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> \\<not> bval b s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s \\<and> \\<not> bval b s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule strengthen_pre[where P=\"%l s. pre C2 Q l s \\<and> preList upds C2 l s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         pre C2 Q l s \\<and>\n                         preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                         \\<not> bval b s \\<longrightarrow>\n                         pre C2 Q l s \\<and> preList upds C2 l s\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and> preList upds C2 l s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "using ListAif2"], ["proof (prove)\nusing this:\n  \\<not> bval ?b ?s \\<Longrightarrow>\n  preList ?upds (IF ?b THEN ?C1.0 ELSE ?C2.0) ?l ?s =\n  preList ?upds ?C2.0 ?l ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l s.\n                         pre C2 Q l s \\<and>\n                         preList upds (IF b THEN C1 ELSE C2) l s \\<and>\n                         \\<not> bval b s \\<longrightarrow>\n                         pre C2 Q l s \\<and> preList upds C2 l s\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and> preList upds C2 l s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n         pre C2 Q l s \\<and> preList upds C2 l s}\n     strip C2\n     { time C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}", "apply(rule Aif(2)[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> vc C2 Q\n 2. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> finite (support Q)\n 3. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> finite (varacom C2)\n 4. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> lesvars upds \\<inter> varacom C2 = {}\n 5. \\<lbrakk>\\<And>Q upds.\n                \\<lbrakk>vc C1 Q; finite (support Q);\n                 lesvars upds \\<inter> varacom C1 = {};\n                 distinct (map fst upds)\\<rbrakk>\n                \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                     pre C1 Q l s \\<and> preList upds C1 l s}\n                 strip C1\n                 { time\n                    C1 \\<Down> \\<lambda>l s.\n                                  Q l s \\<and> postList upds l s} \\<and>\n                                  (\\<forall>l s.\npre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n     \\<And>Q upds.\n        \\<lbrakk>vc C2 Q; finite (support Q);\n         lesvars upds \\<inter> varacom C2 = {};\n         distinct (map fst upds)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n             pre C2 Q l s \\<and> preList upds C2 l s}\n         strip C2\n         { time\n            C2 \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                          (\\<forall>l s.\n                              pre C2 Q l s \\<longrightarrow>\n                              Q l (postQ C2 s));\n     finite (support Q);\n     lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n     distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n     finite (varacom C2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst upds)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2);\n        (bval b s \\<longrightarrow>\n         pre C1 Q l s \\<and> preList upds (IF b THEN C1 ELSE C2) l s) \\<and>\n        (\\<not> bval b s \\<longrightarrow>\n         pre C2 Q l s \\<and>\n         preList upds (IF b THEN C1 ELSE C2) l s)\\<rbrakk>\n       \\<Longrightarrow> (if bval b s then time C1 s else time C2 s) + 1 =\n                         (if bval b s then 1 + time C1 s else 1 + time C2 s)\n 2. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); bval b s; pre C1 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C1 s)\n 3. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); \\<not> bval b s; pre C2 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C2 s)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); bval b s; pre C1 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C1 s)\n 2. \\<And>l s.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        finite (support Q);\n        lesvars upds \\<inter> (varacom C1 \\<union> varacom C2) = {};\n        distinct (map fst upds); vc C1 Q; vc C2 Q; finite (varacom C1);\n        finite (varacom C2); \\<not> bval b s; pre C2 Q l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ C2 s)", "apply fast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre (IF b THEN C1 ELSE C2) Q l s \\<and>\n                           preList upds (IF b THEN C1 ELSE C2) l s}\n                       strip (IF b THEN C1 ELSE C2)\n                       { time\n                          (IF b THEN C1\n                           ELSE C2) \\<Down> \\<lambda>l s.\n         Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s.\n      pre (IF b THEN C1 ELSE C2) Q l s \\<longrightarrow>\n      Q l (postQ (IF b THEN C1 ELSE C2) s))\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Aconseq P' Qannot eannot C Q upds)"], ["proof (state)\nthis:\n  \\<lbrakk>vc C ?Q; finite (support ?Q); finite (varacom C);\n   lesvars ?upds \\<inter> varacom C = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C ?Q l s \\<and> preList ?upds C l s}\n   strip C\n   { time C \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C ?Q l s \\<longrightarrow> ?Q l (postQ C s))\n  vc ({P'/Qannot/eannot} CONSEQ C) Q\n  finite (support Q)\n  finite (varacom ({P'/Qannot/eannot} CONSEQ C))\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  distinct (map fst upds)\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>vc C ?Q; finite (support ?Q); finite (varacom C);\n   lesvars ?upds \\<inter> varacom C = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C ?Q l s \\<and> preList ?upds C l s}\n   strip C\n   { time C \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C ?Q l s \\<longrightarrow> ?Q l (postQ C s))\n  vc ({P'/Qannot/eannot} CONSEQ C) Q\n  finite (support Q)\n  finite (varacom ({P'/Qannot/eannot} CONSEQ C))\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  distinct (map fst upds)", "obtain k where k: \"k>0\" and ih1: \"vc C Qannot\"\n    and ih1': \" (\\<forall>l s. P' l s \\<longrightarrow>  time C s \\<le> k * eannot s \\<and> (\\<forall>t. \\<exists>l'. pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>vc C ?Q; finite (support ?Q); finite (varacom C);\n   lesvars ?upds \\<inter> varacom C = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C ?Q l s \\<and> preList ?upds C l s}\n   strip C\n   { time C \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C ?Q l s \\<longrightarrow> ?Q l (postQ C s))\n  vc ({P'/Qannot/eannot} CONSEQ C) Q\n  finite (support Q)\n  finite (varacom ({P'/Qannot/eannot} CONSEQ C))\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>0 < k; vc C Qannot;\n         \\<forall>l s.\n            P' l s \\<longrightarrow>\n            time C s \\<le> k * eannot s \\<and>\n            (\\<forall>t.\n                \\<exists>l'.\n                   pre C Qannot l' s \\<and>\n                   (Qannot l' t \\<longrightarrow> Q l t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < k\n  vc C Qannot\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have ih2': \"\\<forall>l s. pre C Qannot l s \\<longrightarrow> Qannot l (postQ C s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s. pre C Qannot l s \\<longrightarrow> Qannot l (postQ C s)", "apply(rule Aconseq(1)[THEN conjunct2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C Qannot\n 2. finite (support Qannot)\n 3. finite (varacom C)\n 4. lesvars ?upds1 \\<inter> varacom C = {}\n 5. distinct (map fst ?upds1)", "using Aconseq(2-6)"], ["proof (prove)\nusing this:\n  vc ({P'/Qannot/eannot} CONSEQ C) Q\n  finite (support Q)\n  finite (varacom ({P'/Qannot/eannot} CONSEQ C))\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. vc C Qannot\n 2. finite (support Qannot)\n 3. finite (varacom C)\n 4. lesvars ?upds1 \\<inter> varacom C = {}\n 5. distinct (map fst ?upds1)", "by auto"], ["proof (state)\nthis:\n  \\<forall>l s. pre C Qannot l s \\<longrightarrow> Qannot l (postQ C s)\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have G1: \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. P' l s \\<and> preList upds ({P'/Qannot/eannot} CONSEQ C) l s} strip C\n         { eannot \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             P' l s \\<and>\n                             preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                         strip C\n                         { eannot \\<Down> \\<lambda>l s.\n       Q l s \\<and> postList upds l s}", "proof (rule conseq[rotated])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>1 {?P} strip C { ?e \\<Down> ?Q}\n 2. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<and>\n          preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n          ?e s \\<le> k * eannot s \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 ?P l' s \\<and>\n                 (?Q l' t \\<longrightarrow> Q l t \\<and> postList upds l t))", "show \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. pre C Qannot l s \\<and> preList upds C l s} strip C { time C \\<Down> \\<lambda>l s. Qannot l s \\<and> postList upds l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre C Qannot l s \\<and> preList upds C l s}\n                         strip C\n                         { time\n                            C \\<Down> \\<lambda>l s.\n   Qannot l s \\<and> postList upds l s}", "apply(rule Aconseq(1)[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C Qannot\n 2. finite (support Qannot)\n 3. finite (varacom C)\n 4. lesvars upds \\<inter> varacom C = {}\n 5. distinct (map fst upds)", "using Aconseq(2-6)"], ["proof (prove)\nusing this:\n  vc ({P'/Qannot/eannot} CONSEQ C) Q\n  finite (support Q)\n  finite (varacom ({P'/Qannot/eannot} CONSEQ C))\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. vc C Qannot\n 2. finite (support Qannot)\n 3. finite (varacom C)\n 4. lesvars upds \\<inter> varacom C = {}\n 5. distinct (map fst upds)", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre C Qannot l s \\<and> preList upds C l s}\n                       strip C\n                       { time\n                          C \\<Down> \\<lambda>l s.\n Qannot l s \\<and> postList upds l s}\n\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<and>\n          preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n          time C s \\<le> k * eannot s \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n                 (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n                  Q l t \\<and> postList upds l t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<and>\n          preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n          time C s \\<le> k * eannot s \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n                 (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n                  Q l t \\<and> postList upds l t))", "show \"\\<exists>k>0. \\<forall>l s. P' l s \\<and> preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n              time C s \\<le> k * eannot s \\<and>\n              (\\<forall>t. \\<exists>l'. (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n                        (Qannot l' t \\<and> postList upds l' t \\<longrightarrow> Q l t \\<and> postList upds l t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<and>\n          preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n          time C s \\<le> k * eannot s \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n                 (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n                  Q l t \\<and> postList upds l t))", "proof(rule exI[where x=k], safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < k\n 2. \\<And>l s.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> time C s \\<le> k * eannot s\n 3. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "fix l s"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < k\n 2. \\<And>l s.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> time C s \\<le> k * eannot s\n 3. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "assume P': \"P' l s\" and prelist: \"preList upds ({P'/Qannot/eannot} CONSEQ C) l s\""], ["proof (state)\nthis:\n  P' l s\n  preList upds ({P'/Qannot/eannot} CONSEQ C) l s\n\ngoal (3 subgoals):\n 1. 0 < k\n 2. \\<And>l s.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> time C s \\<le> k * eannot s\n 3. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "then"], ["proof (chain)\npicking this:\n  P' l s\n  preList upds ({P'/Qannot/eannot} CONSEQ C) l s", "show \"time C s \\<le> k * eannot s\""], ["proof (prove)\nusing this:\n  P' l s\n  preList upds ({P'/Qannot/eannot} CONSEQ C) l s\n\ngoal (1 subgoal):\n 1. time C s \\<le> k * eannot s", "using ih1'"], ["proof (prove)\nusing this:\n  P' l s\n  preList upds ({P'/Qannot/eannot} CONSEQ C) l s\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n\ngoal (1 subgoal):\n 1. time C s \\<le> k * eannot s", "by simp"], ["proof (state)\nthis:\n  time C s \\<le> k * eannot s\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "fix t\n      \\<comment> \\<open>we now have to construct a logical environment, that both\n          * satisfies the annotated postcondition Qannot (we obtain it from the first IH)\n          * lets the updates come true (we have to show that resetting these logical variables\n              does not interfere with the other variables)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "from ih1' P'"], ["proof (chain)\npicking this:\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n  P' l s", "have satQan:\"(\\<exists>l'. pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\""], ["proof (prove)\nusing this:\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n  P' l s\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t)", "by simp"], ["proof (state)\nthis:\n  \\<exists>l'.\n     pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t)\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "then"], ["proof (chain)\npicking this:\n  \\<exists>l'.\n     pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t)", "obtain l' where i': \"pre C Qannot l' s\" and ii': \"(Qannot l' t \\<longrightarrow> Q l t)\""], ["proof (prove)\nusing this:\n  \\<exists>l'.\n     pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>pre C Qannot l' s;\n         Qannot l' t \\<longrightarrow> Q l t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pre C Qannot l' s\n  Qannot l' t \\<longrightarrow> Q l t\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "let ?upds' = \"(map (%(x,e). (x,preT C e s)) upds)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "let ?l'' = \"(ListUpdateE l' ?upds')\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "fix l s n x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "assume \"x \\<in> fst ` (set upds)\""], ["proof (state)\nthis:\n  x \\<in> lesvars upds\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "then"], ["proof (chain)\npicking this:\n  x \\<in> lesvars upds", "have \"x \\<notin> support (pre C Qannot)\""], ["proof (prove)\nusing this:\n  x \\<in> lesvars upds\n\ngoal (1 subgoal):\n 1. x \\<notin> support (pre C Qannot)", "using Aconseq(5) support_pre"], ["proof (prove)\nusing this:\n  x \\<in> lesvars upds\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n  support (pre ?C ?Q) \\<subseteq> support ?Q \\<union> varacom ?C\n\ngoal (1 subgoal):\n 1. x \\<notin> support (pre C Qannot)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> support (pre C Qannot)\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "from assn2_lupd[OF this]"], ["proof (chain)\npicking this:\n  pre C Qannot (?l(x := ?n)) = pre C Qannot ?l", "have \"pre C Qannot (l(x := n))  = pre C Qannot l\""], ["proof (prove)\nusing this:\n  pre C Qannot (?l(x := ?n)) = pre C Qannot ?l\n\ngoal (1 subgoal):\n 1. pre C Qannot (l(x := n)) = pre C Qannot l", "."], ["proof (state)\nthis:\n  pre C Qannot (l(x := n)) = pre C Qannot l\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> lesvars upds \\<Longrightarrow>\n  pre C Qannot (?la2(?x2 := ?n2)) = pre C Qannot ?la2\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "note U2=this"], ["proof (state)\nthis:\n  ?x2 \\<in> lesvars upds \\<Longrightarrow>\n  pre C Qannot (?la2(?x2 := ?n2)) = pre C Qannot ?la2\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> lesvars upds \\<Longrightarrow>\n  pre C Qannot (?la2(?x2 := ?n2)) = pre C Qannot ?la2\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "fix l s n x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "assume \"x \\<in> fst ` (set upds)\""], ["proof (state)\nthis:\n  x \\<in> lesvars upds\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "then"], ["proof (chain)\npicking this:\n  x \\<in> lesvars upds", "have \"x \\<notin> support Qannot\""], ["proof (prove)\nusing this:\n  x \\<in> lesvars upds\n\ngoal (1 subgoal):\n 1. x \\<notin> support Qannot", "using Aconseq(5)"], ["proof (prove)\nusing this:\n  x \\<in> lesvars upds\n  lesvars upds \\<inter> varacom ({P'/Qannot/eannot} CONSEQ C) = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> support Qannot", "by auto"], ["proof (state)\nthis:\n  x \\<notin> support Qannot\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "from assn2_lupd[OF this]"], ["proof (chain)\npicking this:\n  Qannot (?l(x := ?n)) = Qannot ?l", "have \"Qannot (l(x := n))  = Qannot l\""], ["proof (prove)\nusing this:\n  Qannot (?l(x := ?n)) = Qannot ?l\n\ngoal (1 subgoal):\n 1. Qannot (l(x := n)) = Qannot l", "."], ["proof (state)\nthis:\n  Qannot (l(x := n)) = Qannot l\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> lesvars upds \\<Longrightarrow>\n  Qannot (?la2(?x2 := ?n2)) = Qannot ?la2\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "note K2=this"], ["proof (state)\nthis:\n  ?x2 \\<in> lesvars upds \\<Longrightarrow>\n  Qannot (?la2(?x2 := ?n2)) = Qannot ?la2\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have \"pre C Qannot ?l''  = pre C Qannot l'  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre C Qannot\n     (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n    pre C Qannot l'", "apply(rule allg_E[where ?upds=\"set upds\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s n x.\n       x \\<in> lesvars upds \\<Longrightarrow>\n       pre C Qannot (l(x := n)) = pre C Qannot l\n 2. lesvars\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e s)) upds)\n    \\<subseteq> lesvars upds", "apply(rule U2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s n x.\n       x \\<in> lesvars upds \\<Longrightarrow> x \\<in> lesvars upds\n 2. lesvars\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e s)) upds)\n    \\<subseteq> lesvars upds", "by force+"], ["proof (state)\nthis:\n  pre C Qannot\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  pre C Qannot l'\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "with i'"], ["proof (chain)\npicking this:\n  pre C Qannot l' s\n  pre C Qannot\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  pre C Qannot l'", "have i'': \"pre C Qannot ?l'' s\""], ["proof (prove)\nusing this:\n  pre C Qannot l' s\n  pre C Qannot\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  pre C Qannot l'\n\ngoal (1 subgoal):\n 1. pre C Qannot\n     (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s", "by simp"], ["proof (state)\nthis:\n  pre C Qannot\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have \"Qannot ?l'' = Qannot l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n    Qannot l'", "apply(rule allg_E[where ?upds=\"set upds\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s n x.\n       x \\<in> lesvars upds \\<Longrightarrow> Qannot (l(x := n)) = Qannot l\n 2. lesvars\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e s)) upds)\n    \\<subseteq> lesvars upds", "apply(rule K2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s n x.\n       x \\<in> lesvars upds \\<Longrightarrow> x \\<in> lesvars upds\n 2. lesvars\n     (map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C e s)) upds)\n    \\<subseteq> lesvars upds", "by force+"], ["proof (state)\nthis:\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  Qannot l'\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "then"], ["proof (chain)\npicking this:\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  Qannot l'", "have K: \"(%l' s. Qannot l' t \\<longrightarrow> Q l t) ?l'' s = (%l' s. Qannot l' t \\<longrightarrow> Q l t) l' s\""], ["proof (prove)\nusing this:\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) =\n  Qannot l'\n\ngoal (1 subgoal):\n 1. (Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n      t \\<longrightarrow>\n     Q l t) =\n    (Qannot l' t \\<longrightarrow> Q l t)", "by simp"], ["proof (state)\nthis:\n  (Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n    t \\<longrightarrow>\n   Q l t) =\n  (Qannot l' t \\<longrightarrow> Q l t)\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "with ii'"], ["proof (chain)\npicking this:\n  Qannot l' t \\<longrightarrow> Q l t\n  (Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n    t \\<longrightarrow>\n   Q l t) =\n  (Qannot l' t \\<longrightarrow> Q l t)", "have ii'': \"(Qannot ?l'' t \\<longrightarrow> Q l t)\""], ["proof (prove)\nusing this:\n  Qannot l' t \\<longrightarrow> Q l t\n  (Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n    t \\<longrightarrow>\n   Q l t) =\n  (Qannot l' t \\<longrightarrow> Q l t)\n\ngoal (1 subgoal):\n 1. Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n     t \\<longrightarrow>\n    Q l t", "by simp"], ["proof (state)\nthis:\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n   t \\<longrightarrow>\n  Q l t\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have xs_upds: \"map fst ?upds' = map fst upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>(x, e). (x, preT C e s)) upds) = map fst upds", "by auto"], ["proof (state)\nthis:\n  map fst (map (\\<lambda>(x, e). (x, preT C e s)) upds) = map fst upds\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have resets: \"\\<And>x. x \\<in> set ?upds' \\<Longrightarrow> ListUpdateE l' ?upds' (fst x) = snd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)\n        (fst x) =\n       snd x", "apply(rule ListUpdateE_updates)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       distinct (map fst (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n 2. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)", "apply(simp only: xs_upds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       distinct (map fst upds)\n 2. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)", "using Aconseq(6)"], ["proof (prove)\nusing this:\n  distinct (map fst upds)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       distinct (map fst upds)\n 2. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                     upds) \\<Longrightarrow>\n       x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> set (map (\\<lambda>(x, e). (x, preT C e s))\n                 upds) \\<Longrightarrow>\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) (fst ?x) =\n  snd ?x\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have A: \"preList upds C ?l'' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preList upds C\n     (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s", "proof (rule preListpreSet,safe,goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set upds \\<Longrightarrow>\n       ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) a =\n       preT C b s", "case (1 x e)"], ["proof (state)\nthis:\n  (x, e) \\<in> set upds\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set upds \\<Longrightarrow>\n       ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) a =\n       preT C b s", "then"], ["proof (chain)\npicking this:\n  (x, e) \\<in> set upds", "have \"(x, preT C e s) \\<in> set ?upds'\""], ["proof (prove)\nusing this:\n  (x, e) \\<in> set upds\n\ngoal (1 subgoal):\n 1. (x, preT C e s) \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)", "by fastforce"], ["proof (state)\nthis:\n  (x, preT C e s) \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set upds \\<Longrightarrow>\n       ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) a =\n       preT C b s", "from resets[OF this, simplified]"], ["proof (chain)\npicking this:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  preT C e s", "show ?case"], ["proof (prove)\nusing this:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  preT C e s\n\ngoal (1 subgoal):\n 1. ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n    preT C e s", "."], ["proof (state)\nthis:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  preT C e s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preList upds C\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "have B: \"Qannot ?l'' t \\<Longrightarrow> postList upds ?l'' t \\<Longrightarrow> postList upds l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Qannot\n              (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n              t;\n     postList upds\n      (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n      t\\<rbrakk>\n    \\<Longrightarrow> postList upds l t", "proof (rule postListpostSet, safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "case (1 x e)"], ["proof (state)\nthis:\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t\n  postList upds\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t\n  (x, e) \\<in> set upds\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "from postSetpostList[OF 1(2)]"], ["proof (chain)\npicking this:\n  postSet (set upds)\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t", "have g: \"postSet (set upds) ?l'' t\""], ["proof (prove)\nusing this:\n  postSet (set upds)\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t\n\ngoal (1 subgoal):\n 1. postSet (set upds)\n     (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t", "."], ["proof (state)\nthis:\n  postSet (set upds)\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "with 1(3)"], ["proof (chain)\npicking this:\n  (x, e) \\<in> set upds\n  postSet (set upds)\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t", "have A: \"?l'' x = e t\""], ["proof (prove)\nusing this:\n  (x, e) \\<in> set upds\n  postSet (set upds)\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t\n\ngoal (1 subgoal):\n 1. ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x = e t", "by fast"], ["proof (state)\nthis:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x = e t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "from 1(3) resets[of \"(x,preT C e s)\"]"], ["proof (chain)\npicking this:\n  (x, e) \\<in> set upds\n  (x, preT C e s)\n  \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds) \\<Longrightarrow>\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)\n   (fst (x, preT C e s)) =\n  snd (x, preT C e s)", "have   B: \"?l'' x = snd (x, preT C e s)\""], ["proof (prove)\nusing this:\n  (x, e) \\<in> set upds\n  (x, preT C e s)\n  \\<in> set (map (\\<lambda>(x, e). (x, preT C e s)) upds) \\<Longrightarrow>\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)\n   (fst (x, preT C e s)) =\n  snd (x, preT C e s)\n\ngoal (1 subgoal):\n 1. ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n    snd (x, preT C e s)", "by fastforce"], ["proof (state)\nthis:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  snd (x, preT C e s)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "from A B"], ["proof (chain)\npicking this:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x = e t\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  snd (x, preT C e s)", "have X: \"e t = preT C e s\""], ["proof (prove)\nusing this:\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x = e t\n  ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds) x =\n  snd (x, preT C e s)\n\ngoal (1 subgoal):\n 1. e t = preT C e s", "by fastforce"], ["proof (state)\nthis:\n  e t = preT C e s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "from preSetpreList[OF prelist]"], ["proof (chain)\npicking this:\n  preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s", "have \"preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s\""], ["proof (prove)\nusing this:\n  preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s\n\ngoal (1 subgoal):\n 1. preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s", "."], ["proof (state)\nthis:\n  preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "with 1(3)"], ["proof (chain)\npicking this:\n  (x, e) \\<in> set upds\n  preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s", "have Y: \"l x = preT C e s\""], ["proof (prove)\nusing this:\n  (x, e) \\<in> set upds\n  preSet (set upds) ({P'/Qannot/eannot} CONSEQ C) l s\n\ngoal (1 subgoal):\n 1. l x = preT C e s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, e) \\<in> set upds; preSet (set upds) C l s\\<rbrakk>\n    \\<Longrightarrow> l x = preT C e s", "by fast"], ["proof (state)\nthis:\n  l x = preT C e s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Qannot\n                 (ListUpdateE l'\n                   (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n                 t;\n        postList upds\n         (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) t;\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> l a = b t", "from X Y"], ["proof (chain)\npicking this:\n  e t = preT C e s\n  l x = preT C e s", "show ?case"], ["proof (prove)\nusing this:\n  e t = preT C e s\n  l x = preT C e s\n\ngoal (1 subgoal):\n 1. l x = e t", "by simp"], ["proof (state)\nthis:\n  l x = e t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Qannot\n            (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n            t;\n   postList upds\n    (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n    t\\<rbrakk>\n  \\<Longrightarrow> postList upds l t\n\ngoal (2 subgoals):\n 1. 0 < k\n 2. \\<And>l s t.\n       \\<lbrakk>P' l s;\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (pre C Qannot l' s \\<and>\n                             preList upds C l' s) \\<and>\n                            (Qannot l' t \\<and>\n                             postList upds l' t \\<longrightarrow>\n                             Q l t \\<and> postList upds l t)", "show \"\\<exists>l'. (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n                  (Qannot l' t \\<and> postList upds l' t \\<longrightarrow> Q l t \\<and> postList upds l t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n       (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n        Q l t \\<and> postList upds l t)", "apply(rule exI[where x=\"?l''\"], safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. pre C Qannot\n     (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds)) s\n 2. preList upds C\n     (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds)) s\n 3. \\<lbrakk>Qannot\n              (ListUpdateE l'\n                (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n              t;\n     postList upds\n      (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n      t\\<rbrakk>\n    \\<Longrightarrow> Q l t\n 4. \\<lbrakk>Qannot\n              (ListUpdateE l'\n                (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n              t;\n     postList upds\n      (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n      t\\<rbrakk>\n    \\<Longrightarrow> postList upds l t", "using i'' A ii'' B"], ["proof (prove)\nusing this:\n  pre C Qannot\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s\n  preList upds C\n   (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds)) s\n  Qannot (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n   t \\<longrightarrow>\n  Q l t\n  \\<lbrakk>Qannot\n            (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n            t;\n   postList upds\n    (ListUpdateE l' (map (\\<lambda>(x, e). (x, preT C e s)) upds))\n    t\\<rbrakk>\n  \\<Longrightarrow> postList upds l t\n\ngoal (4 subgoals):\n 1. pre C Qannot\n     (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds)) s\n 2. preList upds C\n     (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds)) s\n 3. \\<lbrakk>Qannot\n              (ListUpdateE l'\n                (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n              t;\n     postList upds\n      (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n      t\\<rbrakk>\n    \\<Longrightarrow> Q l t\n 4. \\<lbrakk>Qannot\n              (ListUpdateE l'\n                (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n              t;\n     postList upds\n      (ListUpdateE l' (map (\\<lambda>(l', e). (l', preT C e s)) upds))\n      t\\<rbrakk>\n    \\<Longrightarrow> postList upds l t", "by auto"], ["proof (state)\nthis:\n  \\<exists>l'.\n     (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n     (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n      Q l t \\<and> postList upds l t)\n\ngoal (1 subgoal):\n 1. 0 < k", "qed fact"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<and>\n        preList upds ({P'/Qannot/eannot} CONSEQ C) l s \\<longrightarrow>\n        time C s \\<le> k * eannot s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               (pre C Qannot l' s \\<and> preList upds C l' s) \\<and>\n               (Qannot l' t \\<and> postList upds l' t \\<longrightarrow>\n                Q l t \\<and> postList upds l t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           P' l s \\<and>\n                           preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                       strip C\n                       { eannot \\<Down> \\<lambda>l s.\n     Q l s \\<and> postList upds l s}\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have G2: \"\\<And>l s. P' l s \\<Longrightarrow> Q l (postQ C s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s. P' l s \\<Longrightarrow> Q l (postQ C s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s. P' l s \\<Longrightarrow> Q l (postQ C s)", "fix l s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s. P' l s \\<Longrightarrow> Q l (postQ C s)", "assume \"P' l s\""], ["proof (state)\nthis:\n  P' l s\n\ngoal (1 subgoal):\n 1. \\<And>l s. P' l s \\<Longrightarrow> Q l (postQ C s)", "with ih1' ih2'"], ["proof (chain)\npicking this:\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n  \\<forall>l s. pre C Qannot l s \\<longrightarrow> Qannot l (postQ C s)\n  P' l s", "show \"Q l (postQ C s)\""], ["proof (prove)\nusing this:\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     time C s \\<le> k * eannot s \\<and>\n     (\\<forall>t.\n         \\<exists>l'.\n            pre C Qannot l' s \\<and> (Qannot l' t \\<longrightarrow> Q l t))\n  \\<forall>l s. pre C Qannot l s \\<longrightarrow> Qannot l (postQ C s)\n  P' l s\n\ngoal (1 subgoal):\n 1. Q l (postQ C s)", "by blast"], ["proof (state)\nthis:\n  Q l (postQ C s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P' ?l ?s \\<Longrightarrow> Q ?l (postQ C ?s)\n\ngoal (3 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 x3 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1/x2/x3} CONSEQ C) Q; finite (support Q);\n        finite (varacom ({x1/x2/x3} CONSEQ C));\n        lesvars upds \\<inter> varacom ({x1/x2/x3} CONSEQ C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1/x2/x3} CONSEQ C) Q l s \\<and>\n            preList upds ({x1/x2/x3} CONSEQ C) l s}\n        strip ({x1/x2/x3} CONSEQ C)\n        { time\n           ({x1/x2/x3}\n            CONSEQ C) \\<Down> \\<lambda>l s.\n                                 Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1/x2/x3} CONSEQ C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1/x2/x3} CONSEQ C) s))\n 3. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<and>\n                             preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                         strip ({P'/Qannot/eannot} CONSEQ C)\n                         { time\n                            ({P'/Qannot/eannot}\n                             CONSEQ C) \\<Down> \\<lambda>l s.\n            Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<longrightarrow>\n        Q l (postQ ({P'/Qannot/eannot} CONSEQ C) s))", "using G1 G2"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           P' l s \\<and>\n                           preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                       strip C\n                       { eannot \\<Down> \\<lambda>l s.\n     Q l s \\<and> postList upds l s}\n  P' ?l ?s \\<Longrightarrow> Q ?l (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<and>\n                             preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                         strip ({P'/Qannot/eannot} CONSEQ C)\n                         { time\n                            ({P'/Qannot/eannot}\n                             CONSEQ C) \\<Down> \\<lambda>l s.\n            Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<longrightarrow>\n        Q l (postQ ({P'/Qannot/eannot} CONSEQ C) s))", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<and>\n                           preList upds ({P'/Qannot/eannot} CONSEQ C) l s}\n                       strip ({P'/Qannot/eannot} CONSEQ C)\n                       { time\n                          ({P'/Qannot/eannot}\n                           CONSEQ C) \\<Down> \\<lambda>l s.\n          Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s.\n      pre ({P'/Qannot/eannot} CONSEQ C) Q l s \\<longrightarrow>\n      Q l (postQ ({P'/Qannot/eannot} CONSEQ C) s))\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Aseq C1 C2 Q upds)"], ["proof (state)\nthis:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (C1;; C2) Q\n  finite (support Q)\n  finite (varacom (C1;; C2))\n  lesvars upds \\<inter> varacom (C1;; C2) = {}\n  distinct (map fst upds)\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?P = \"(\\<lambda>l s. pre (C1;; C2) Q l s \\<and> preList upds (C1;;C2) l s  )\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?P' = \"support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have finite_varacom: \"finite (varacom (C1;; C2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (varacom (C1;; C2))", "by fact"], ["proof (state)\nthis:\n  finite (varacom (C1;; C2))\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have sup_L: \"support (preList upds (C1;;C2)) \\<subseteq> lesvars upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds (C1;; C2)) \\<subseteq> lesvars upds", "apply(rule support_preList)"], ["proof (prove)\ngoal:\nNo subgoals!", "done \n  \n  \\<comment> \\<open>choose a fresh logical variable ?y in order to pull through the cost of the second command\\<close>"], ["proof (state)\nthis:\n  support (preList upds (C1;; C2)) \\<subseteq> lesvars upds\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?y = \"SOME x. x \\<notin> ?P'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have fP': \"finite (?P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n      lesvars upds)", "using finite_varacom Aseq(4,5)"], ["proof (prove)\nusing this:\n  finite (varacom (C1;; C2))\n  finite (support Q)\n  finite (varacom (C1;; C2))\n\ngoal (1 subgoal):\n 1. finite\n     (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n      lesvars upds)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite\n   (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds)\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "from fP'"], ["proof (chain)\npicking this:\n  finite\n   (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds)", "have \"\\<exists>x. x \\<notin> ?P'\""], ["proof (prove)\nusing this:\n  finite\n   (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                  lesvars upds", "using infinite_UNIV_listI"], ["proof (prove)\nusing this:\n  finite\n   (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds)\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                  lesvars upds", "using ex_new_if_finite"], ["proof (prove)\nusing this:\n  finite\n   (support Q \\<union> varacom C1 \\<union> varacom C2 \\<union> lesvars upds)\n  infinite UNIV\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                  lesvars upds", "by metis"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "hence ynP': \"?y \\<notin> ?P'\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n             lesvars upds", "by (rule someI_ex)"], ["proof (state)\nthis:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "hence ysupC1: \"?y \\<notin> varacom C1\""], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> varacom C1", "using support_pre"], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n  support (pre ?C ?Q) \\<subseteq> support ?Q \\<union> varacom ?C\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> varacom C1", "by auto"], ["proof (state)\nthis:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> varacom C1\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have sup_B: \"support ?P \\<subseteq> ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support\n     (\\<lambda>l s. pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre (C1;; C2) Q) \\<union> support (preList upds (C1;; C2))\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre C1 (pre C2 Q))\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds \\<and>\n    support (preList upds (C1;; C2))\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "using support_pre sup_L"], ["proof (prove)\nusing this:\n  support (pre ?C ?Q) \\<subseteq> support ?Q \\<union> varacom ?C\n  support (preList upds (C1;; C2)) \\<subseteq> lesvars upds\n\ngoal (1 subgoal):\n 1. support (pre C1 (pre C2 Q))\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds \\<and>\n    support (preList upds (C1;; C2))\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "by blast   \n        \n  \\<comment> \\<open>we show the first goal: we can deduce the desired Hoare Triple\\<close>"], ["proof (state)\nthis:\n  support\n   (\\<lambda>l s. pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n  \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n              lesvars upds\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have C1: \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s} strip C1;; strip C2\n         { time (C1;; C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre (C1;; C2) Q l s \\<and>\n                             preList upds (C1;; C2) l s}\n                         strip C1;; strip C2\n                         { time\n                            (C1;;\n                             C2) \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s}", "proof (rule Seq[rotated])\n    \\<comment> \\<open>start from the back: we can simply use the IH for C2, \n          and solve the side conditions automatically\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<turnstile>\\<^sub>1 {?P\\<^sub>2} strip C2\n                         { ?e2.0 \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s}\n 2. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 3. ?x \\<notin> support ?P\\<^sub>2\n 4. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 5. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      ?P\\<^sub>2 l s \\<and> ?e2.0 s \\<le> l ?x}", "show \"\\<turnstile>\\<^sub>1 {(%l s. pre C2 Q l s \\<and>  preList upds C2 l s )} strip C2 { time C2 \\<Down> (%l s. Q l s \\<and> postList upds l s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre C2 Q l s \\<and> preList upds C2 l s}\n                         strip C2\n                         { time\n                            C2 \\<Down> \\<lambda>l s.\n    Q l s \\<and> postList upds l s}", "apply(rule Aseq(2)[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C2 Q\n 2. finite (support Q)\n 3. finite (varacom C2)\n 4. lesvars upds \\<inter> varacom C2 = {}\n 5. distinct (map fst upds)", "using Aseq(3-7)"], ["proof (prove)\nusing this:\n  vc (C1;; C2) Q\n  finite (support Q)\n  finite (varacom (C1;; C2))\n  lesvars upds \\<inter> varacom (C1;; C2) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. vc C2 Q\n 2. finite (support Q)\n 3. finite (varacom C2)\n 4. lesvars upds \\<inter> varacom C2 = {}\n 5. distinct (map fst upds)", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre C2 Q l s \\<and> preList upds C2 l s}\n                       strip C2\n                       { time\n                          C2 \\<Down> \\<lambda>l s.\n  Q l s \\<and> postList upds l s}\n\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "next    \n    \\<comment> \\<open>prepare the new updates: pull them through C2 and save the new execution time of C2 in ?y\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "let ?upds = \"map (\\<lambda>a. case a of (x,e) \\<Rightarrow> (x, preT C2 e )) upds\""], ["proof (state)\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "let ?upds' = \"(?y,time C2)#?upds\""], ["proof (state)\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "have dst_upds': \"distinct (map fst ?upds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       ((SOME x.\n            x \\<notin> support Q \\<union> varacom C1 \\<union>\n                       varacom C2 \\<union>\n                       lesvars upds,\n         time C2) #\n        map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n         upds))", "using  ynP' Aseq(7)"], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       ((SOME x.\n            x \\<notin> support Q \\<union> varacom C1 \\<union>\n                       varacom C2 \\<union>\n                       lesvars upds,\n         time C2) #\n        map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n         upds))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(SOME x.\n                 x \\<notin> support Q \\<and>\n                 x \\<notin> varacom C1 \\<and>\n                 x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n             \\<notin> support Q \\<and>\n             (SOME x.\n                 x \\<notin> support Q \\<and>\n                 x \\<notin> varacom C1 \\<and>\n                 x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n             \\<notin> varacom C1 \\<and>\n             (SOME x.\n                 x \\<notin> support Q \\<and>\n                 x \\<notin> varacom C1 \\<and>\n                 x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n             \\<notin> varacom C2 \\<and>\n             (SOME x.\n                 x \\<notin> support Q \\<and>\n                 x \\<notin> varacom C1 \\<and>\n                 x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n             \\<notin> lesvars upds;\n     distinct (map fst upds)\\<rbrakk>\n    \\<Longrightarrow> (SOME x.\n                          x \\<notin> support Q \\<and>\n                          x \\<notin> varacom C1 \\<and>\n                          x \\<notin> varacom C2 \\<and>\n                          x \\<notin> lesvars upds)\n                      \\<notin> (\\<lambda>x.\n                                   fst (case x of\n  (x, e) \\<Rightarrow> (x, preT C2 e))) `\n                               set upds \\<and>\n                      distinct\n                       (map (fst \\<circ> (\\<lambda>(x, e). (x, preT C2 e)))\n                         upds)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>distinct (map fst upds);\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> support Q;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> varacom C1;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> varacom C2;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> lesvars upds;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds) =\n        fst (a, preT C2 b);\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst upds);\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> support Q;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C1;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C2;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> lesvars upds\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (fst \\<circ> (\\<lambda>(x, e). (x, preT C2 e)))\n                         upds)", "using image_iff"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>distinct (map fst upds);\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> support Q;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> varacom C1;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> varacom C2;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n        \\<notin> lesvars upds;\n        (SOME x.\n            x \\<notin> support Q \\<and>\n            x \\<notin> varacom C1 \\<and>\n            x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds) =\n        fst (a, preT C2 b);\n        (a, b) \\<in> set upds\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst upds);\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> support Q;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C1;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C2;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> lesvars upds\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (fst \\<circ> (\\<lambda>(x, e). (x, preT C2 e)))\n                         upds)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst upds);\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> support Q;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C1;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> varacom C2;\n     (SOME x.\n         x \\<notin> support Q \\<and>\n         x \\<notin> varacom C1 \\<and>\n         x \\<notin> varacom C2 \\<and> x \\<notin> lesvars upds)\n     \\<notin> lesvars upds\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (fst \\<circ> (\\<lambda>(x, e). (x, preT C2 e)))\n                         upds)", "by (simp add: case_prod_beta' distinct_conv_nth) \n    \n    \\<comment> \\<open>now use the first induction hypothesis (specialised with the augmented upds list, and the\n        weakest precondition of Q through C as post condition)\\<close>"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     ((SOME x.\n          x \\<notin> support Q \\<union> varacom C1 \\<union>\n                     varacom C2 \\<union>\n                     lesvars upds,\n       time C2) #\n      map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) upds))\n\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "have IH1s: \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. pre C1 (pre C2 Q) l s \\<and> preList ?upds' C1 l s} strip C1\n                    { time C1 \\<Down> \\<lambda>l s. pre C2 Q l s \\<and> postList ?upds' l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre C1 (pre C2 Q) l s \\<and>\n                             preList\n                              ((SOME x.\n                                   x \\<notin> support Q \\<union>\n        varacom C1 \\<union>\n        varacom C2 \\<union>\n        lesvars upds,\n                                time C2) #\n                               map (\\<lambda>a.\n case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n                                upds)\n                              C1 l s}\n                         strip C1\n                         { time\n                            C1 \\<Down> \\<lambda>l s.\n    pre C2 Q l s \\<and>\n    postList\n     ((SOME x.\n          x \\<notin> support Q \\<union> varacom C1 \\<union>\n                     varacom C2 \\<union>\n                     lesvars upds,\n       time C2) #\n      map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) upds)\n     l s}", "apply(rule Aseq(1)[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C1 (pre C2 Q)\n 2. finite (support (pre C2 Q))\n 3. finite (varacom C1)\n 4. lesvars\n     ((SOME x.\n          x \\<notin> support Q \\<union> varacom C1 \\<union>\n                     varacom C2 \\<union>\n                     lesvars upds,\n       time C2) #\n      map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n       upds) \\<inter>\n    varacom C1 =\n    {}\n 5. distinct\n     (map fst\n       ((SOME x.\n            x \\<notin> support Q \\<union> varacom C1 \\<union>\n                       varacom C2 \\<union>\n                       lesvars upds,\n         time C2) #\n        map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n         upds))", "using Aseq(3-7) ysupC1 dst_upds'"], ["proof (prove)\nusing this:\n  vc (C1;; C2) Q\n  finite (support Q)\n  finite (varacom (C1;; C2))\n  lesvars upds \\<inter> varacom (C1;; C2) = {}\n  distinct (map fst upds)\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> varacom C1\n  distinct\n   (map fst\n     ((SOME x.\n          x \\<notin> support Q \\<union> varacom C1 \\<union>\n                     varacom C2 \\<union>\n                     lesvars upds,\n       time C2) #\n      map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) upds))\n\ngoal (5 subgoals):\n 1. vc C1 (pre C2 Q)\n 2. finite (support (pre C2 Q))\n 3. finite (varacom C1)\n 4. lesvars\n     ((SOME x.\n          x \\<notin> support Q \\<union> varacom C1 \\<union>\n                     varacom C2 \\<union>\n                     lesvars upds,\n       time C2) #\n      map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n       upds) \\<inter>\n    varacom C1 =\n    {}\n 5. distinct\n     (map fst\n       ((SOME x.\n            x \\<notin> support Q \\<union> varacom C1 \\<union>\n                       varacom C2 \\<union>\n                       lesvars upds,\n         time C2) #\n        map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n         upds))", "by auto  \n    \n    \\<comment> \\<open>glue it together with a consequence rule, side conditions are automatic\\<close>"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre C1 (pre C2 Q) l s \\<and>\n                           preList\n                            ((SOME x.\n                                 x \\<notin> support Q \\<union>\n      varacom C1 \\<union>\n      varacom C2 \\<union>\n      lesvars upds,\n                              time C2) #\n                             map (\\<lambda>a.\n                                     case a of\n                                     (x, e) \\<Rightarrow> (x, preT C2 e))\n                              upds)\n                            C1 l s}\n                       strip C1\n                       { time\n                          C1 \\<Down> \\<lambda>l s.\n  pre C2 Q l s \\<and>\n  postList\n   ((SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds,\n     time C2) #\n    map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e)) upds)\n   l s}\n\ngoal (4 subgoals):\n 1. ?x \\<notin> support\n                 (\\<lambda>l s.\n                     pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. ?x \\<notin> support\n                 (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       ?e1.0 s + ?e2' s \\<le> time (C1;; C2) s\n 4. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l ?x = ?e2' s}\n                         strip C1\n                         { ?e1.0 \\<Down> \\<lambda>l s.\n      (pre C2 Q l s \\<and> preList upds C2 l s) \\<and> time C2 s \\<le> l ?x}", "show \" \\<turnstile>\\<^sub>1 {\\<lambda>l s. (pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s) \\<and> l ?y = preT C1 (time C2) s} strip C1\n     { time C1 \\<Down> \\<lambda>l s. (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s) l s \\<and> time C2 s \\<le> l ?y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (pre (C1;; C2) Q l s \\<and>\n                              preList upds (C1;; C2) l s) \\<and>\n                             l (SOME x.\n                                   x \\<notin> support Q \\<union>\n        varacom C1 \\<union>\n        varacom C2 \\<union>\n        lesvars upds) =\n                             preT C1 (time C2) s}\n                         strip C1\n                         { time\n                            C1 \\<Down> \\<lambda>l s.\n    (pre C2 Q l s \\<and> preList upds C2 l s) \\<and>\n    time C2 s\n    \\<le> l (SOME x.\n                x \\<notin> support Q \\<union> varacom C1 \\<union>\n                           varacom C2 \\<union>\n                           lesvars upds)}", "apply(rule conseq_old[OF _ IH1s])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          (pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s) \\<and>\n          l (SOME x.\n                x \\<notin> support Q \\<union> varacom C1 \\<union>\n                           varacom C2 \\<union>\n                           lesvars upds) =\n          preT C1 (time C2) s \\<longrightarrow>\n          (pre C1 (pre C2 Q) l s \\<and>\n           preList\n            ((SOME x.\n                 x \\<notin> support Q \\<union> varacom C1 \\<union>\n                            varacom C2 \\<union>\n                            lesvars upds,\n              time C2) #\n             map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n              upds)\n            C1 l s) \\<and>\n          time C1 s \\<le> k * time C1 s\n 2. \\<forall>l s.\n       pre C2 Q l s \\<and>\n       postList\n        ((SOME x.\n             x \\<notin> support Q \\<union> varacom C1 \\<union>\n                        varacom C2 \\<union>\n                        lesvars upds,\n          time C2) #\n         map (\\<lambda>a. case a of (x, e) \\<Rightarrow> (x, preT C2 e))\n          upds)\n        l s \\<longrightarrow>\n       (pre C2 Q l s \\<and> preList upds C2 l s) \\<and>\n       time C2 s\n       \\<le> l (SOME x.\n                   x \\<notin> support Q \\<union> varacom C1 \\<union>\n                              varacom C2 \\<union>\n                              lesvars upds)", "by (auto simp: preList_Seq postList_preList)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           (pre (C1;; C2) Q l s \\<and>\n                            preList upds (C1;; C2) l s) \\<and>\n                           l (SOME x.\n                                 x \\<notin> support Q \\<union>\n      varacom C1 \\<union>\n      varacom C2 \\<union>\n      lesvars upds) =\n                           preT C1 (time C2) s}\n                       strip C1\n                       { time\n                          C1 \\<Down> \\<lambda>l s.\n  (pre C2 Q l s \\<and> preList upds C2 l s) \\<and>\n  time C2 s\n  \\<le> l (SOME x.\n              x \\<notin> support Q \\<union> varacom C1 \\<union>\n                         varacom C2 \\<union>\n                         lesvars upds)}\n\ngoal (3 subgoals):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support\n              (\\<lambda>l s.\n                  pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "next\n    \\<comment> \\<open>solve some side conditions showing that, ?y is indeed fresh\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support\n              (\\<lambda>l s.\n                  pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n 2. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 3. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "show \"?y \\<notin> support ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support\n              (\\<lambda>l s.\n                  pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)", "using sup_B ynP'"], ["proof (prove)\nusing this:\n  support\n   (\\<lambda>l s. pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n  \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n              lesvars upds\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support\n              (\\<lambda>l s.\n                  pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)", "by auto"], ["proof (state)\nthis:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support\n            (\\<lambda>l s.\n                pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s)\n\ngoal (2 subgoals):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 2. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "have F: \"support (preList upds C2) \\<subseteq> lesvars upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (preList upds C2) \\<subseteq> lesvars upds", "apply(rule support_preList)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  support (preList upds C2) \\<subseteq> lesvars upds\n\ngoal (2 subgoals):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 2. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "have \"support (\\<lambda>l s. pre C2 Q  l s \\<and> preList upds C2 l s) \\<subseteq> ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "apply(rule subset_trans[OF support_and])"], ["proof (prove)\ngoal (1 subgoal):\n 1. support (pre C2 Q) \\<union> support (preList upds C2)\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "using F support_pre"], ["proof (prove)\nusing this:\n  support (preList upds C2) \\<subseteq> lesvars upds\n  support (pre ?C ?Q) \\<subseteq> support ?Q \\<union> varacom ?C\n\ngoal (1 subgoal):\n 1. support (pre C2 Q) \\<union> support (preList upds C2)\n    \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                lesvars upds", "by blast"], ["proof (state)\nthis:\n  support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n  \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n              lesvars upds\n\ngoal (2 subgoals):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n 2. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "with ynP'"], ["proof (chain)\npicking this:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n  support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n  \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n              lesvars upds", "show \"?y \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\""], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n           lesvars upds\n  support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n  \\<subseteq> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n              lesvars upds\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<notin> support Q \\<union> varacom C1 \\<union>\n                   varacom C2 \\<union>\n                   lesvars upds)\n    \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)", "by blast"], ["proof (state)\nthis:\n  (SOME x.\n      x \\<notin> support Q \\<union> varacom C1 \\<union> varacom C2 \\<union>\n                 lesvars upds)\n  \\<notin> support (\\<lambda>l s. pre C2 Q l s \\<and> preList upds C2 l s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre (C1;; C2) Q l s \\<and>\n       preList upds (C1;; C2) l s \\<Longrightarrow>\n       time C1 s + preT C1 (time C2) s \\<le> time (C1;; C2) s", "qed simp\n   \n  \\<comment> \\<open>we show the second goal: weakest precondition implies, that\n        Q holds after the execution of C1 and C2\\<close>"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre (C1;; C2) Q l s \\<and>\n                           preList upds (C1;; C2) l s}\n                       strip C1;; strip C2\n                       { time\n                          (C1;;\n                           C2) \\<Down> \\<lambda>l s.\n    Q l s \\<and> postList upds l s}\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have C2: \"\\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "fix l s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "assume p: \"pre (C1;; C2) Q l s\""], ["proof (state)\nthis:\n  pre (C1;; C2) Q l s\n\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "have A: \"\\<forall>l s. pre C1 (pre C2 Q )  l s \\<longrightarrow> pre C2 Q  l (postQ C1 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       pre C1 (pre C2 Q) l s \\<longrightarrow> pre C2 Q l (postQ C1 s)", "apply(rule Aseq(1)[where upds=\"[]\", THEN conjunct2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C1 (pre C2 Q)\n 2. finite (support (pre C2 Q))\n 3. finite (varacom C1)\n 4. lesvars [] \\<inter> varacom C1 = {}\n 5. distinct (map fst [])", "using Aseq"], ["proof (prove)\nusing this:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (C1;; C2) Q\n  finite (support Q)\n  finite (varacom (C1;; C2))\n  lesvars upds \\<inter> varacom (C1;; C2) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. vc C1 (pre C2 Q)\n 2. finite (support (pre C2 Q))\n 3. finite (varacom C1)\n 4. lesvars [] \\<inter> varacom C1 = {}\n 5. distinct (map fst [])", "by auto"], ["proof (state)\nthis:\n  \\<forall>l s.\n     pre C1 (pre C2 Q) l s \\<longrightarrow> pre C2 Q l (postQ C1 s)\n\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "have B: \"(\\<forall>l s. pre C2 Q  l s \\<longrightarrow> Q l (postQ C2 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s. pre C2 Q l s \\<longrightarrow> Q l (postQ C2 s)", "apply(rule Aseq(2)[where upds=\"[]\", THEN conjunct2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C2 Q\n 2. finite (support Q)\n 3. finite (varacom C2)\n 4. lesvars [] \\<inter> varacom C2 = {}\n 5. distinct (map fst [])", "using Aseq"], ["proof (prove)\nusing this:\n  \\<lbrakk>vc C1 ?Q; finite (support ?Q); finite (varacom C1);\n   lesvars ?upds \\<inter> varacom C1 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C1 ?Q l s \\<and> preList ?upds C1 l s}\n   strip C1\n   { time C1 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C1 ?Q l s \\<longrightarrow> ?Q l (postQ C1 s))\n  \\<lbrakk>vc C2 ?Q; finite (support ?Q); finite (varacom C2);\n   lesvars ?upds \\<inter> varacom C2 = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C2 ?Q l s \\<and> preList ?upds C2 l s}\n   strip C2\n   { time C2 \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C2 ?Q l s \\<longrightarrow> ?Q l (postQ C2 s))\n  vc (C1;; C2) Q\n  finite (support Q)\n  finite (varacom (C1;; C2))\n  lesvars upds \\<inter> varacom (C1;; C2) = {}\n  distinct (map fst upds)\n\ngoal (5 subgoals):\n 1. vc C2 Q\n 2. finite (support Q)\n 3. finite (varacom C2)\n 4. lesvars [] \\<inter> varacom C2 = {}\n 5. distinct (map fst [])", "by auto"], ["proof (state)\nthis:\n  \\<forall>l s. pre C2 Q l s \\<longrightarrow> Q l (postQ C2 s)\n\ngoal (1 subgoal):\n 1. \\<And>l s. pre (C1;; C2) Q l s \\<Longrightarrow> Q l (postQ (C1;; C2) s)", "from p A B"], ["proof (chain)\npicking this:\n  pre (C1;; C2) Q l s\n  \\<forall>l s.\n     pre C1 (pre C2 Q) l s \\<longrightarrow> pre C2 Q l (postQ C1 s)\n  \\<forall>l s. pre C2 Q l s \\<longrightarrow> Q l (postQ C2 s)", "show \"Q l (postQ (C1;; C2) s)\""], ["proof (prove)\nusing this:\n  pre (C1;; C2) Q l s\n  \\<forall>l s.\n     pre C1 (pre C2 Q) l s \\<longrightarrow> pre C2 Q l (postQ C1 s)\n  \\<forall>l s. pre C2 Q l s \\<longrightarrow> Q l (postQ C2 s)\n\ngoal (1 subgoal):\n 1. Q l (postQ (C1;; C2) s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ (C1;; C2) s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre (C1;; C2) Q ?l ?s \\<Longrightarrow> Q ?l (postQ (C1;; C2) ?s)\n\ngoal (2 subgoals):\n 1. \\<And>C1 C2 Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C1 Q; finite (support Q);\n                    finite (varacom C1);\n                    lesvars upds \\<inter> varacom C1 = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C1 Q l s \\<and> preList upds C1 l s}\n                    strip C1\n                    { time\n                       C1 \\<Down> \\<lambda>l s.\n                                     Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C1 Q l s \\<longrightarrow> Q l (postQ C1 s));\n        \\<And>Q upds.\n           \\<lbrakk>vc C2 Q; finite (support Q); finite (varacom C2);\n            lesvars upds \\<inter> varacom C2 = {};\n            distinct (map fst upds)\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                pre C2 Q l s \\<and> preList upds C2 l s}\n            strip C2\n            { time\n               C2 \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                             (\\<forall>l s.\n                                 pre C2 Q l s \\<longrightarrow>\n                                 Q l (postQ C2 s));\n        vc (C1;; C2) Q; finite (support Q); finite (varacom (C1;; C2));\n        lesvars upds \\<inter> varacom (C1;; C2) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre (C1;; C2) Q l s \\<and> preList upds (C1;; C2) l s}\n        strip (C1;; C2)\n        { time\n           (C1;;\n            C2) \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre (C1;; C2) Q l s \\<longrightarrow>\n                             Q l (postQ (C1;; C2) s))\n 2. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre (C1;; C2) Q l s \\<and>\n                             preList upds (C1;; C2) l s}\n                         strip (C1;; C2)\n                         { time\n                            (C1;;\n                             C2) \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre (C1;; C2) Q l s \\<longrightarrow> Q l (postQ (C1;; C2) s))", "using C1 C2"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre (C1;; C2) Q l s \\<and>\n                           preList upds (C1;; C2) l s}\n                       strip C1;; strip C2\n                       { time\n                          (C1;;\n                           C2) \\<Down> \\<lambda>l s.\n    Q l s \\<and> postList upds l s}\n  pre (C1;; C2) Q ?l ?s \\<Longrightarrow> Q ?l (postQ (C1;; C2) ?s)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre (C1;; C2) Q l s \\<and>\n                             preList upds (C1;; C2) l s}\n                         strip (C1;; C2)\n                         { time\n                            (C1;;\n                             C2) \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre (C1;; C2) Q l s \\<longrightarrow> Q l (postQ (C1;; C2) s))", "by simp"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre (C1;; C2) Q l s \\<and>\n                           preList upds (C1;; C2) l s}\n                       strip (C1;; C2)\n                       { time\n                          (C1;;\n                           C2) \\<Down> \\<lambda>l s.\n    Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s.\n      pre (C1;; C2) Q l s \\<longrightarrow> Q l (postQ (C1;; C2) s))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "case (Awhile A b C Q upds)\n  \n  \\<comment> \\<open>Let us first see, what we got from the induction hypothesis:\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>vc C ?Q; finite (support ?Q); finite (varacom C);\n   lesvars ?upds \\<inter> varacom C = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C ?Q l s \\<and> preList ?upds C l s}\n   strip C\n   { time C \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C ?Q l s \\<longrightarrow> ?Q l (postQ C s))\n  vc ({A} WHILE b DO C) Q\n  finite (support Q)\n  finite (varacom ({A} WHILE b DO C))\n  lesvars upds \\<inter> varacom ({A} WHILE b DO C) = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "obtain I S E  where [simp]: \"A = (I,(S,(E)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>I S E. A = (I, S, E) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = (I, S, E)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "with \\<open>vc (Awhile A b C) Q\\<close>"], ["proof (chain)\npicking this:\n  vc ({A} WHILE b DO C) Q\n  A = (I, S, E)", "have \"vc (Awhile (I,S,E) b C) Q\""], ["proof (prove)\nusing this:\n  vc ({A} WHILE b DO C) Q\n  A = (I, S, E)\n\ngoal (1 subgoal):\n 1. vc ({(I, S, E)} WHILE b DO C) Q", "by blast"], ["proof (state)\nthis:\n  vc ({(I, S, E)} WHILE b DO C) Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "then"], ["proof (chain)\npicking this:\n  vc ({(I, S, E)} WHILE b DO C) Q", "have vc: \"vc C I\"  and  pre2: \"\\<And>l s. I l s \\<Longrightarrow> \\<not> bval b s \\<Longrightarrow>  Q l s \\<and> 1 \\<le> E s \\<and> S s = s\"\n    and IQ2: \"\\<And>l s. I l s \\<Longrightarrow> bval b s \\<Longrightarrow>\n                         pre C I l s\n                          \\<and>  1 + preT C E s + time C s \\<le> E s \\<and> S s = S (postQ C s)\""], ["proof (prove)\nusing this:\n  vc ({(I, S, E)} WHILE b DO C) Q\n\ngoal (1 subgoal):\n 1. vc C I &&&\n    (\\<And>l s.\n        \\<lbrakk>I l s; \\<not> bval b s\\<rbrakk>\n        \\<Longrightarrow> Q l s \\<and> 1 \\<le> E s \\<and> S s = s) &&&\n    (\\<And>l s.\n        \\<lbrakk>I l s; bval b s\\<rbrakk>\n        \\<Longrightarrow> pre C I l s \\<and>\n                          1 + preT C E s + time C s \\<le> E s \\<and>\n                          S s = S (postQ C s))", "by auto      \n    \n  \\<comment> \\<open>the logical variable x represents the number of loop unfoldings\\<close>"], ["proof (state)\nthis:\n  vc C I\n  \\<lbrakk>I ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l ?s \\<and> 1 \\<le> E ?s \\<and> S ?s = ?s\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "from IQ2"], ["proof (chain)\npicking this:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)", "have IQ_in: \"\\<And>l s. I l s \\<Longrightarrow>   bval b s \\<Longrightarrow> S s = S (postQ C s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> S s = S (postQ C s)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> S ?s = S (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have inv_impl: \"\\<And>l s.  I l s \\<Longrightarrow>   bval b s \\<Longrightarrow>  pre C I  l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s; bval b s\\<rbrakk> \\<Longrightarrow> pre C I l s", "using IQ2"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s; bval b s\\<rbrakk> \\<Longrightarrow> pre C I l s", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk> \\<Longrightarrow> pre C I ?l ?s\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have yC: \" lesvars upds \\<inter> varacom C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lesvars upds \\<inter> varacom C = {}", "using Awhile(5)"], ["proof (prove)\nusing this:\n  lesvars upds \\<inter> varacom ({A} WHILE b DO C) = {}\n\ngoal (1 subgoal):\n 1. lesvars upds \\<inter> varacom C = {}", "by auto"], ["proof (state)\nthis:\n  lesvars upds \\<inter> varacom C = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?upds = \"map (%(x,e). (x, %s. e (S s))) upds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?INV = \"%l s. I l s \\<and> postList ?upds l s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have \"lesvars upds \\<inter> support I = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lesvars upds \\<inter> support I = {}", "using Awhile(5)"], ["proof (prove)\nusing this:\n  lesvars upds \\<inter> varacom ({A} WHILE b DO C) = {}\n\ngoal (1 subgoal):\n 1. lesvars upds \\<inter> support I = {}", "by auto\n    \n    \n  \\<comment> \\<open>we need a fresh variable ?z to remember the time bound of the tail of the loop\\<close>"], ["proof (state)\nthis:\n  lesvars upds \\<inter> support I = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?P=\"lesvars upds \\<union> varacom ({A} WHILE b DO C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?z=\"SOME z::lvname. z \\<notin> ?P\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have \"finite ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))", "using Awhile"], ["proof (prove)\nusing this:\n  \\<lbrakk>vc C ?Q; finite (support ?Q); finite (varacom C);\n   lesvars ?upds \\<inter> varacom C = {}; distinct (map fst ?upds)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n       pre C ?Q l s \\<and> preList ?upds C l s}\n   strip C\n   { time C \\<Down> \\<lambda>l s. ?Q l s \\<and> postList ?upds l s} \\<and>\n                    (\\<forall>l s.\n                        pre C ?Q l s \\<longrightarrow> ?Q l (postQ C s))\n  vc ({A} WHILE b DO C) Q\n  finite (support Q)\n  finite (varacom ({A} WHILE b DO C))\n  lesvars upds \\<inter> varacom ({A} WHILE b DO C) = {}\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))", "by auto"], ["proof (state)\nthis:\n  finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "hence \"\\<exists>z. z\\<notin>?P\""], ["proof (prove)\nusing this:\n  finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)", "using infinite_UNIV_listI"], ["proof (prove)\nusing this:\n  finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)", "using ex_new_if_finite"], ["proof (prove)\nusing this:\n  finite (lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  infinite UNIV\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)", "by metis"], ["proof (state)\nthis:\n  \\<exists>z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "hence znP: \"?z \\<notin> ?P\""], ["proof (prove)\nusing this:\n  \\<exists>z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)", "by (rule someI_ex)"], ["proof (state)\nthis:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "from znP"], ["proof (chain)\npicking this:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)", "have (* znx:  \"?z\\<noteq>x\" \n    and *) zny:  \"?z \\<notin> lesvars upds\"\n    and zI:   \"?z \\<notin> support I\" \n    and blb:  \"?z \\<notin> varacom C\""], ["proof (prove)\nusing this:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> lesvars upds &&&\n    (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support I &&&\n    (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> varacom C", "by (simp_all)"], ["proof (state)\nthis:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars upds\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> support I\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> varacom C\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "from Awhile(4,6)"], ["proof (chain)\npicking this:\n  finite (varacom ({A} WHILE b DO C))\n  distinct (map fst upds)", "have 23: \"finite (varacom C)\" \n    and  26: \"finite (support I)\""], ["proof (prove)\nusing this:\n  finite (varacom ({A} WHILE b DO C))\n  distinct (map fst upds)\n\ngoal (1 subgoal):\n 1. finite (varacom C) &&& finite (support I)", "by auto"], ["proof (state)\nthis:\n  finite (varacom C)\n  finite (support I)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have \"\\<forall>l s.  pre C I  l s \\<longrightarrow> I l (postQ C s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s. pre C I l s \\<longrightarrow> I l (postQ C s)", "apply(rule Awhile(1)[THEN conjunct2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C I\n 2. finite (support I)\n 3. finite (varacom C)\n 4. lesvars ?upds1 \\<inter> varacom C = {}\n 5. distinct (map fst ?upds1)", "by(fact)+"], ["proof (state)\nthis:\n  \\<forall>l s. pre C I l s \\<longrightarrow> I l (postQ C s)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "hence step: \"\\<And>l s. pre C I l s \\<Longrightarrow> I l (postQ C s)\""], ["proof (prove)\nusing this:\n  \\<forall>l s. pre C I l s \\<longrightarrow> I l (postQ C s)\n\ngoal (1 subgoal):\n 1. \\<And>l s. pre C I l s \\<Longrightarrow> I l (postQ C s)", "by simp\n \n      \n  \\<comment> \\<open>we adapt the updates, by pulling them through the loop body \n      and remembering the time bound of the tail of the loop\\<close>"], ["proof (state)\nthis:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?upds = \"map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have fua: \"lesvars ?upds = lesvars upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) =\n    lesvars upds", "by force"], ["proof (state)\nthis:\n  lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) =\n  lesvars upds\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "let ?upds' = \"(?z,E) # ?upds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have g: \"\\<And>e. e \\<circ> S = (%s. e (S s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<circ> S = (\\<lambda>s. e (S s))", "by auto\n       \n  \\<comment> \\<open>show that the Hoare Rule is derivable\\<close>"], ["proof (state)\nthis:\n  ?e \\<circ> S = (\\<lambda>s. ?e (S s))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have G1: \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. I l s \\<and> preList upds ({(I, S, E)} WHILE b DO C) l s} WHILE b DO strip C\n         { E \\<Down> \\<lambda>l s. Q l s \\<and> postList upds l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             I l s \\<and>\n                             preList upds ({(I, S, E)} WHILE b DO C) l s}\n                         WHILE b DO strip C\n                         { E \\<Down> \\<lambda>l s.\n  Q l s \\<and> postList upds l s}", "proof(rule conseq_old)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          I l s \\<and>\n          preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n          ?P l s \\<and> ?e' s \\<le> k * E s\n 2. \\<turnstile>\\<^sub>1 {?P} WHILE b DO strip C { ?e' \\<Down> ?Q}\n 3. \\<forall>l s. ?Q l s \\<longrightarrow> Q l s \\<and> postList upds l s", "show \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. I l s \\<and> postList ?upds l s} WHILE b DO strip C\n              { E \\<Down> \\<lambda>l s. (I l s \\<and> postList ?upds l s) \\<and> \\<not>bval b s }\"\n    \\<comment> \\<open>We use the While Rule and then have to show, that ...\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             I l s \\<and>\n                             postList\n                              (map (\\<lambda>(x, e).\n (x, \\<lambda>s. e (S s)))\n                                upds)\n                              l s}\n                         WHILE b DO strip C\n                         { E \\<Down> \\<lambda>l s.\n  (I l s \\<and>\n   postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n    s) \\<and>\n  \\<not> bval b s}", "proof(rule While, goal_cases) \n      \\<comment> \\<open>A) the loop body preserves the loop invariant\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (I l s \\<and>\n                              postList\n                               (map (\\<lambda>(x, e).\n  (x, \\<lambda>s. e (S s)))\n                                 upds)\n                               l s) \\<and>\n                             bval b s \\<and> ?e' s = l ?y}\n                         strip C\n                         { ?e'' \\<Down> \\<lambda>l s.\n     (I l s \\<and>\n      postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n       s) \\<and>\n     E s \\<le> l ?y}\n 2. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + ?e' s + ?e'' s \\<le> E s\n 3. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 4. ?y \\<notin> support\n                 (\\<lambda>l s.\n                     I l s \\<and>\n                     postList\n                      (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n                      l s)", "have \"lesvars ?upds' \\<inter> varacom C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lesvars\n     ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n       E) #\n      map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) \\<inter>\n    varacom C =\n    {}", "using yC blb"], ["proof (prove)\nusing this:\n  lesvars upds \\<inter> varacom C = {}\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> varacom C\n\ngoal (1 subgoal):\n 1. lesvars\n     ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n       E) #\n      map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) \\<inter>\n    varacom C =\n    {}", "by(auto)"], ["proof (state)\nthis:\n  lesvars\n   ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n     E) #\n    map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) \\<inter>\n  varacom C =\n  {}\n\ngoal (4 subgoals):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (I l s \\<and>\n                              postList\n                               (map (\\<lambda>(x, e).\n  (x, \\<lambda>s. e (S s)))\n                                 upds)\n                               l s) \\<and>\n                             bval b s \\<and> ?e' s = l ?y}\n                         strip C\n                         { ?e'' \\<Down> \\<lambda>l s.\n     (I l s \\<and>\n      postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n       s) \\<and>\n     E s \\<le> l ?y}\n 2. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + ?e' s + ?e'' s \\<le> E s\n 3. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 4. ?y \\<notin> support\n                 (\\<lambda>l s.\n                     I l s \\<and>\n                     postList\n                      (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n                      l s)", "have z: \"(fst \\<circ> (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))) = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) = fst", "by auto"], ["proof (state)\nthis:\n  fst \\<circ> (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) = fst\n\ngoal (4 subgoals):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (I l s \\<and>\n                              postList\n                               (map (\\<lambda>(x, e).\n  (x, \\<lambda>s. e (S s)))\n                                 upds)\n                               l s) \\<and>\n                             bval b s \\<and> ?e' s = l ?y}\n                         strip C\n                         { ?e'' \\<Down> \\<lambda>l s.\n     (I l s \\<and>\n      postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n       s) \\<and>\n     E s \\<le> l ?y}\n 2. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + ?e' s + ?e'' s \\<le> E s\n 3. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 4. ?y \\<notin> support\n                 (\\<lambda>l s.\n                     I l s \\<and>\n                     postList\n                      (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n                      l s)", "have \"distinct (map fst ?upds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       ((SOME z.\n            z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n         E) #\n        map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))", "using Awhile(6) zny"], ["proof (prove)\nusing this:\n  distinct (map fst upds)\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars upds\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       ((SOME z.\n            z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n         E) #\n        map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))", "by (auto simp add: z)       \n      \n      \\<comment> \\<open>for showing preservation of the invariant, use the consequence rule ...\\<close>"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n       E) #\n      map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))\n\ngoal (4 subgoals):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (I l s \\<and>\n                              postList\n                               (map (\\<lambda>(x, e).\n  (x, \\<lambda>s. e (S s)))\n                                 upds)\n                               l s) \\<and>\n                             bval b s \\<and> ?e' s = l ?y}\n                         strip C\n                         { ?e'' \\<Down> \\<lambda>l s.\n     (I l s \\<and>\n      postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n       s) \\<and>\n     E s \\<le> l ?y}\n 2. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + ?e' s + ?e'' s \\<le> E s\n 3. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 4. ?y \\<notin> support\n                 (\\<lambda>l s.\n                     I l s \\<and>\n                     postList\n                      (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n                      l s)", "show \"\\<turnstile>\\<^sub>1 {\\<lambda>l s. (I l s \\<and> postList ?upds l s) \\<and> bval b s \\<and> preT C E s = l ?z}\n       strip C {  time C \\<Down> \\<lambda>l s. (I l s \\<and> postList ?upds l s) \\<and> E s \\<le> l ?z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             (I l s \\<and>\n                              postList\n                               (map (\\<lambda>(x, e).\n  (x, \\<lambda>s. e (S s)))\n                                 upds)\n                               l s) \\<and>\n                             bval b s \\<and>\n                             preT C E s =\n                             l (SOME z.\n                                   z \\<notin> lesvars upds \\<union>\n        varacom ({A} WHILE b DO C))}\n                         strip C\n                         { time\n                            C \\<Down> \\<lambda>l s.\n   (I l s \\<and>\n    postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n     s) \\<and>\n   E s\n   \\<le> l (SOME z.\n               z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))}", "proof (rule conseq_old)\n        \\<comment> \\<open>... and employ the induction hypothesis, ...\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          bval b s \\<and>\n          preT C E s =\n          l (SOME z.\n                z \\<notin> lesvars upds \\<union>\n                           varacom ({A} WHILE b DO C)) \\<longrightarrow>\n          ?P l s \\<and> ?e' s \\<le> k * time C s\n 2. \\<turnstile>\\<^sub>1 {?P} strip C { ?e' \\<Down> ?Q}\n 3. \\<forall>l s.\n       ?Q l s \\<longrightarrow>\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       E s\n       \\<le> l (SOME z.\n                   z \\<notin> lesvars upds \\<union>\n                              varacom ({A} WHILE b DO C))", "show \" \\<turnstile>\\<^sub>1 {\\<lambda>l s. pre C I l s \\<and> preList ?upds' C l s} strip C\n                { time C \\<Down> \\<lambda>l s. I l s \\<and> postList ?upds' l s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre C I l s \\<and>\n                             preList\n                              ((SOME z.\n                                   z \\<notin> lesvars upds \\<union>\n        varacom ({A} WHILE b DO C),\n                                E) #\n                               map (\\<lambda>(x, e).\n (x, \\<lambda>s. e (S s)))\n                                upds)\n                              C l s}\n                         strip C\n                         { time\n                            C \\<Down> \\<lambda>l s.\n   I l s \\<and>\n   postList\n    ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n      E) #\n     map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n    l s}", "apply(rule Awhile.IH[THEN conjunct1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vc C I\n 2. finite (support I)\n 3. finite (varacom C)\n 4. lesvars\n     ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n       E) #\n      map (\\<lambda>a.\n              case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n       upds) \\<inter>\n    varacom C =\n    {}\n 5. distinct\n     (map fst\n       ((SOME z.\n            z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n         E) #\n        map (\\<lambda>a.\n                case a of (x, e) \\<Rightarrow> (x, \\<lambda>s. e (S s)))\n         upds))", "by fact+"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre C I l s \\<and>\n                           preList\n                            ((SOME z.\n                                 z \\<notin> lesvars upds \\<union>\n      varacom ({A} WHILE b DO C),\n                              E) #\n                             map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                              upds)\n                            C l s}\n                       strip C\n                       { time\n                          C \\<Down> \\<lambda>l s.\n I l s \\<and>\n postList\n  ((SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n    E) #\n   map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n  l s}\n\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          bval b s \\<and>\n          preT C E s =\n          l (SOME z.\n                z \\<notin> lesvars upds \\<union>\n                           varacom ({A} WHILE b DO C)) \\<longrightarrow>\n          (pre C I l s \\<and>\n           preList\n            ((SOME z.\n                 z \\<notin> lesvars upds \\<union>\n                            varacom ({A} WHILE b DO C),\n              E) #\n             map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n            C l s) \\<and>\n          time C s \\<le> k * time C s\n 2. \\<forall>l s.\n       I l s \\<and>\n       postList\n        ((SOME z.\n             z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n          E) #\n         map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n        l s \\<longrightarrow>\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       E s\n       \\<le> l (SOME z.\n                   z \\<notin> lesvars upds \\<union>\n                              varacom ({A} WHILE b DO C))", "next\n        \\<comment> \\<open>finally we have to prove the side condition.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          bval b s \\<and>\n          preT C E s =\n          l (SOME z.\n                z \\<notin> lesvars upds \\<union>\n                           varacom ({A} WHILE b DO C)) \\<longrightarrow>\n          (pre C I l s \\<and>\n           preList\n            ((SOME z.\n                 z \\<notin> lesvars upds \\<union>\n                            varacom ({A} WHILE b DO C),\n              E) #\n             map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n            C l s) \\<and>\n          time C s \\<le> k * time C s\n 2. \\<forall>l s.\n       I l s \\<and>\n       postList\n        ((SOME z.\n             z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n          E) #\n         map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n        l s \\<longrightarrow>\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       E s\n       \\<le> l (SOME z.\n                   z \\<notin> lesvars upds \\<union>\n                              varacom ({A} WHILE b DO C))", "show \"\\<exists>k>0. \\<forall>l s. (I l s \\<and> postList ?upds l s) \\<and> bval b s \\<and> preT C E s = l ?z\n                   \\<longrightarrow> (pre C I l s \\<and> preList ?upds' C l s) \\<and> time C s \\<le> k * time C s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          bval b s \\<and>\n          preT C E s =\n          l (SOME z.\n                z \\<notin> lesvars upds \\<union>\n                           varacom ({A} WHILE b DO C)) \\<longrightarrow>\n          (pre C I l s \\<and>\n           preList\n            ((SOME z.\n                 z \\<notin> lesvars upds \\<union>\n                            varacom ({A} WHILE b DO C),\n              E) #\n             map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n            C l s) \\<and>\n          time C s \\<le> k * time C s", "apply(rule exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>l s.\n        (I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s) \\<and>\n        bval b s \\<and>\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<union>\n                         varacom ({A} WHILE b DO C)) \\<longrightarrow>\n        (pre C I l s \\<and>\n         preList\n          ((SOME z.\n               z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n            E) #\n           map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n          C l s) \\<and>\n        time C s \\<le> 1 * time C s)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<and>\n       bval b s \\<and>\n       preT C E s =\n       l (SOME z.\n             z \\<notin> lesvars upds \\<and>\n             z \\<notin> support I \\<and>\n             z \\<notin> varacom C) \\<longrightarrow>\n       pre C I l s \\<and>\n       preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s\n 2. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> preList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          C l s", "case (2 l s)"], ["proof (state)\nthis:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s\n 2. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> preList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          C l s", "note upds_invariant=postpreList_inv[OF IQ_in[OF 2(1)]]"], ["proof (state)\nthis:\n  bval b s \\<Longrightarrow>\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) ?l s =\n  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) C ?l s\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s\n 2. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> preList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          C l s", "from 2  upds_invariant"], ["proof (chain)\npicking this:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n  bval b s \\<Longrightarrow>\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) ?l s =\n  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) C ?l s", "show ?case"], ["proof (prove)\nusing this:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n  bval b s \\<Longrightarrow>\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) ?l s =\n  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) ?upds) C ?l s\n\ngoal (1 subgoal):\n 1. preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s", "by auto"], ["proof (state)\nthis:\n  preList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) C l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s", "case (1 l s)"], ["proof (state)\nthis:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s;\n        bval b s;\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<and>\n              z \\<notin> support I \\<and> z \\<notin> varacom C)\\<rbrakk>\n       \\<Longrightarrow> pre C I l s", "then"], ["proof (chain)\npicking this:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)", "show ?case"], ["proof (prove)\nusing this:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n\ngoal (1 subgoal):\n 1. pre C I l s", "using inv_impl"], ["proof (prove)\nusing this:\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  bval b s\n  preT C E s =\n  l (SOME z.\n        z \\<notin> lesvars upds \\<and>\n        z \\<notin> support I \\<and> z \\<notin> varacom C)\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk> \\<Longrightarrow> pre C I ?l ?s\n\ngoal (1 subgoal):\n 1. pre C I l s", "by auto"], ["proof (state)\nthis:\n  pre C I l s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     \\<forall>l s.\n        (I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s) \\<and>\n        bval b s \\<and>\n        preT C E s =\n        l (SOME z.\n              z \\<notin> lesvars upds \\<union>\n                         varacom ({A} WHILE b DO C)) \\<longrightarrow>\n        (pre C I l s \\<and>\n         preList\n          ((SOME z.\n               z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n            E) #\n           map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n          C l s) \\<and>\n        time C s \\<le> k * time C s\n\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       I l s \\<and>\n       postList\n        ((SOME z.\n             z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C),\n          E) #\n         map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n        l s \\<longrightarrow>\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       E s\n       \\<le> l (SOME z.\n                   z \\<notin> lesvars upds \\<union>\n                              varacom ({A} WHILE b DO C))", "qed auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           (I l s \\<and>\n                            postList\n                             (map (\\<lambda>(x, e).\n(x, \\<lambda>s. e (S s)))\n                               upds)\n                             l s) \\<and>\n                           bval b s \\<and>\n                           preT C E s =\n                           l (SOME z.\n                                 z \\<notin> lesvars upds \\<union>\n      varacom ({A} WHILE b DO C))}\n                       strip C\n                       { time\n                          C \\<Down> \\<lambda>l s.\n (I l s \\<and>\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n   s) \\<and>\n E s\n \\<le> l (SOME z.\n             z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))}\n\ngoal (3 subgoals):\n 1. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + preT C E s + time C s \\<le> E s\n 2. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 3. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "next\n      \\<comment> \\<open>B) the invariant with number of loop unfoldings greater than 0 implies true loop guard\n             and running time is correctly bounded\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + preT C E s + time C s \\<le> E s\n 2. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 3. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "show \"\\<forall>l s. bval b s  \\<and> I l s \\<and> postList ?upds l s \\<longrightarrow> 1 + preT C E s + time C s \\<le> E s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 + preT C E s + time C s \\<le> E s", "proof (clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>bval b s; I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s\\<rbrakk>\n       \\<Longrightarrow> 1 + preT C E s + time C s \\<le> E s", "case (1 l s)"], ["proof (state)\nthis:\n  bval b s\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>bval b s; I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s\\<rbrakk>\n       \\<Longrightarrow> 1 + preT C E s + time C s \\<le> E s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + preT C E s + time C s \\<le> E s", "using IQ2 1(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n  bval b s\n  I l s\n\ngoal (1 subgoal):\n 1. 1 + preT C E s + time C s \\<le> E s", "by auto"], ["proof (state)\nthis:\n  1 + preT C E s + time C s \\<le> E s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l s.\n     bval b s \\<and>\n     I l s \\<and>\n     postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n      s \\<longrightarrow>\n     1 + preT C E s + time C s \\<le> E s\n\ngoal (2 subgoals):\n 1. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 2. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "next\n      \\<comment> \\<open>C) the invariant with number of loop unfoldings equal to 0 implies false loop guard\n             and running time is correctly bounded\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s\n 2. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "show \"\\<forall>l s.  \\<not> bval b s \\<and> I l s \\<and> postList ?upds l s \\<longrightarrow>  1 \\<le> E s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       \\<not> bval b s \\<and>\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n        s \\<longrightarrow>\n       1 \\<le> E s", "proof (clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>\\<not> bval b s; I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> E s", "case (1 l s)"], ["proof (state)\nthis:\n  \\<not> bval b s\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>\\<not> bval b s; I l s;\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> E s", "then"], ["proof (chain)\npicking this:\n  \\<not> bval b s\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> bval b s\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n\ngoal (1 subgoal):\n 1. 1 \\<le> E s", "using pre2 1(2)"], ["proof (prove)\nusing this:\n  \\<not> bval b s\n  I l s\n  postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s\n  \\<lbrakk>I ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l ?s \\<and> 1 \\<le> E ?s \\<and> S ?s = ?s\n  I l s\n\ngoal (1 subgoal):\n 1. 1 \\<le> E s", "by auto"], ["proof (state)\nthis:\n  1 \\<le> E s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l s.\n     \\<not> bval b s \\<and>\n     I l s \\<and>\n     postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n      s \\<longrightarrow>\n     1 \\<le> E s\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "next\n      \\<comment> \\<open>D) ?z is indeed a fresh variable\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "have pff: \"?z \\<notin> lesvars ?upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "apply(simp only: fua)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> lesvars upds", "by fact"], ["proof (state)\nthis:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "have \"support (\\<lambda>l s. I l s \\<and> postList ?upds l s) \\<subseteq> support I \\<union> support (postList ?upds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support\n     (\\<lambda>l s.\n         I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s)\n    \\<subseteq> support I \\<union>\n                support\n                 (postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))", "by(rule support_and)"], ["proof (state)\nthis:\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              support\n               (postList\n                 (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "also"], ["proof (state)\nthis:\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              support\n               (postList\n                 (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "have \"support (postList ?upds) \\<subseteq> lesvars ?upds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support\n     (postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))\n    \\<subseteq> lesvars\n                 (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "apply(rule support_postList)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  support (postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds))\n  \\<subseteq> lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      support I \\<union> x\n      \\<subseteq> support I \\<union> y) \\<Longrightarrow>\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "have \"support (\\<lambda>l s. I l s \\<and> postList ?upds l s) \\<subseteq> support I \\<union> lesvars ?upds\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      support I \\<union> x\n      \\<subseteq> support I \\<union> y) \\<Longrightarrow>\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. support\n     (\\<lambda>l s.\n         I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s)\n    \\<subseteq> support I \\<union>\n                lesvars\n                 (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "by blast"], ["proof (state)\nthis:\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "thus \"?z \\<notin> support (\\<lambda>l s. I l s \\<and> postList ?upds l s)\""], ["proof (prove)\nusing this:\n  support\n   (\\<lambda>l s.\n       I l s \\<and>\n       postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n  \\<subseteq> support I \\<union>\n              lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support\n              (\\<lambda>l s.\n                  I l s \\<and>\n                  postList\n                   (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n                   s)", "apply(rule contra_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support I \\<union>\n             lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "using zI pff"], ["proof (prove)\nusing this:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> support I\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)\n\ngoal (1 subgoal):\n 1. (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n    \\<notin> support I \\<union>\n             lesvars (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds)", "by(simp)"], ["proof (state)\nthis:\n  (SOME z. z \\<notin> lesvars upds \\<union> varacom ({A} WHILE b DO C))\n  \\<notin> support\n            (\\<lambda>l s.\n                I l s \\<and>\n                postList\n                 (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           I l s \\<and>\n                           postList\n                            (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                              upds)\n                            l s}\n                       WHILE b DO strip C\n                       { E \\<Down> \\<lambda>l s.\n(I l s \\<and>\n postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s) \\<and>\n\\<not> bval b s}\n\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          I l s \\<and>\n          preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          E s \\<le> k * E s\n 2. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          I l s \\<and>\n          preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          E s \\<le> k * E s\n 2. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "show \"\\<exists>k>0. \\<forall>l s. I l s  \\<and> preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n              (I l s \\<and> postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s) \\<and> E s \\<le> k * E s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          I l s \\<and>\n          preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n          (I l s \\<and>\n           postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n            s) \\<and>\n          E s \\<le> k * E s", "apply(rule exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>l s.\n        I l s \\<and>\n        preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n        (I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s) \\<and>\n        E s \\<le> 1 * E s)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s; preList upds ({(I, S, E)} WHILE b DO C) l s\\<rbrakk>\n       \\<Longrightarrow> postList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          l s", "apply(simp only: postList_preList[symmetric] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList\n         (map (\\<lambda>(x, e). (x, preT ({(I, S, E)} WHILE b DO C) e))\n           upds)\n         l s\\<rbrakk>\n       \\<Longrightarrow> postList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          l s", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>I l s;\n        postList (map (\\<lambda>(x, e). (x, e \\<circ> S)) upds) l s\\<rbrakk>\n       \\<Longrightarrow> postList\n                          (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s)))\n                            upds)\n                          l s", "apply(simp only:   g)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     \\<forall>l s.\n        I l s \\<and>\n        preList upds ({(I, S, E)} WHILE b DO C) l s \\<longrightarrow>\n        (I l s \\<and>\n         postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n          s) \\<and>\n        E s \\<le> k * E s\n\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "show \"\\<forall>l s. (I l s \\<and> postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l s) \\<and> \\<not> bval b s  \\<longrightarrow> Q l s \\<and> postList upds l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "using pre2"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l ?s \\<and> 1 \\<le> E ?s \\<and> S ?s = ?s\n\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       (I l s \\<and>\n        postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n         s) \\<and>\n       \\<not> bval b s \\<longrightarrow>\n       Q l s \\<and> postList upds l s", "by(induct upds, auto)"], ["proof (state)\nthis:\n  \\<forall>l s.\n     (I l s \\<and>\n      postList (map (\\<lambda>(x, e). (x, \\<lambda>s. e (S s))) upds) l\n       s) \\<and>\n     \\<not> bval b s \\<longrightarrow>\n     Q l s \\<and> postList upds l s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           I l s \\<and>\n                           preList upds ({(I, S, E)} WHILE b DO C) l s}\n                       WHILE b DO strip C\n                       { E \\<Down> \\<lambda>l s.\nQ l s \\<and> postList upds l s}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "have G2: \"\\<And>l s. pre ({A} WHILE b DO C) Q l s \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "fix l s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "assume \"pre ({A} WHILE b DO C) Q l s\""], ["proof (state)\nthis:\n  pre ({A} WHILE b DO C) Q l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "then"], ["proof (chain)\npicking this:\n  pre ({A} WHILE b DO C) Q l s", "have I: \"I l s\""], ["proof (prove)\nusing this:\n  pre ({A} WHILE b DO C) Q l s\n\ngoal (1 subgoal):\n 1. I l s", "by simp"], ["proof (state)\nthis:\n  I l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "{"], ["proof (state)\nthis:\n  I l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "have \"E s = n \\<Longrightarrow> I l s \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E s = n; I l s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "proof (induct n arbitrary: s l rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s l.\n       \\<lbrakk>\\<And>y s l.\n                   \\<lbrakk>y < x; E s = y; I l s\\<rbrakk>\n                   \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n        E s = x; I l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n\ngoal (1 subgoal):\n 1. \\<And>x s l.\n       \\<lbrakk>\\<And>y s l.\n                   \\<lbrakk>y < x; E s = y; I l s\\<rbrakk>\n                   \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n        E s = x; I l s\\<rbrakk>\n       \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) s)", "proof (cases \"bval b s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "case True"], ["proof (state)\nthis:\n  bval b s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with less IQ2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n  bval b s", "have \"pre C I l s\" and S: \"S s = S (postQ C s)\" and t: \"1 + preT C E s + time C s \\<le> E s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n  \\<lbrakk>I ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> pre C I ?l ?s \\<and>\n                    1 + preT C E ?s + time C ?s \\<le> E ?s \\<and>\n                    S ?s = S (postQ C ?s)\n  bval b s\n\ngoal (1 subgoal):\n 1. pre C I l s &&&\n    S s = S (postQ C s) &&& 1 + preT C E s + time C s \\<le> E s", "by auto"], ["proof (state)\nthis:\n  pre C I l s\n  S s = S (postQ C s)\n  1 + preT C E s + time C s \\<le> E s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with step"], ["proof (chain)\npicking this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  pre C I l s\n  S s = S (postQ C s)\n  1 + preT C E s + time C s \\<le> E s", "have I': \"I l (postQ C s)\" and \"1 + E (postQ C s) + time C s \\<le> E s\""], ["proof (prove)\nusing this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  pre C I l s\n  S s = S (postQ C s)\n  1 + preT C E s + time C s \\<le> E s\n\ngoal (1 subgoal):\n 1. I l (postQ C s) &&& 1 + E (postQ C s) + time C s \\<le> E s", "using TQ"], ["proof (prove)\nusing this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  pre C I l s\n  S s = S (postQ C s)\n  1 + preT C E s + time C s \\<le> E s\n  preT ?C ?e ?s = ?e (postQ ?C ?s)\n\ngoal (1 subgoal):\n 1. I l (postQ C s) &&& 1 + E (postQ C s) + time C s \\<le> E s", "by auto"], ["proof (state)\nthis:\n  I l (postQ C s)\n  1 + E (postQ C s) + time C s \\<le> E s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n  I l (postQ C s)\n  1 + E (postQ C s) + time C s \\<le> E s", "have \"E (postQ C s) < n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  E s = n\n  I l s\n  I l (postQ C s)\n  1 + E (postQ C s) + time C s \\<le> E s\n\ngoal (1 subgoal):\n 1. E (postQ C s) < n", "by auto"], ["proof (state)\nthis:\n  E (postQ C s) < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with less(1) I'"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  I l (postQ C s)\n  E (postQ C s) < n", "have \"Q l (postQ ({A} WHILE b DO C) (postQ C s))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y1 < n; E ?s1 = ?y1; I ?l1 ?s1\\<rbrakk>\n  \\<Longrightarrow> Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n  I l (postQ C s)\n  E (postQ C s) < n\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) (postQ C s))", "by auto"], ["proof (state)\nthis:\n  Q l (postQ ({A} WHILE b DO C) (postQ C s))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n 2. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with step"], ["proof (chain)\npicking this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  Q l (postQ ({A} WHILE b DO C) (postQ C s))", "show ?thesis"], ["proof (prove)\nusing this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  Q l (postQ ({A} WHILE b DO C) (postQ C s))\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) s)", "using S"], ["proof (prove)\nusing this:\n  pre C I ?l ?s \\<Longrightarrow> I ?l (postQ C ?s)\n  Q l (postQ ({A} WHILE b DO C) (postQ C s))\n  S s = S (postQ C s)\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ ({A} WHILE b DO C) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "case False"], ["proof (state)\nthis:\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "with pre2 less(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>I ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l ?s \\<and> 1 \\<le> E ?s \\<and> S ?s = ?s\n  I l s\n  \\<not> bval b s", "have \"Q l s\" \"S s = s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l ?s \\<and> 1 \\<le> E ?s \\<and> S ?s = ?s\n  I l s\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. Q l s &&& S s = s", "by auto"], ["proof (state)\nthis:\n  Q l s\n  S s = s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y s l.\n                \\<lbrakk>y < n; E s = y; I l s\\<rbrakk>\n                \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s);\n     E s = n; I l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "then"], ["proof (chain)\npicking this:\n  Q l s\n  S s = s", "show ?thesis"], ["proof (prove)\nusing this:\n  Q l s\n  S s = s\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ ({A} WHILE b DO C) s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q l (postQ ({A} WHILE b DO C) s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>E s = n; I l s\\<rbrakk>\n  \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>E s = ?n3; I l s\\<rbrakk>\n  \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       pre ({A} WHILE b DO C) Q l s \\<Longrightarrow>\n       Q l (postQ ({A} WHILE b DO C) s)", "with I"], ["proof (chain)\npicking this:\n  I l s\n  \\<lbrakk>E s = ?n3; I l s\\<rbrakk>\n  \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)", "show \"Q l (postQ ({A} WHILE b DO C) s)\""], ["proof (prove)\nusing this:\n  I l s\n  \\<lbrakk>E s = ?n3; I l s\\<rbrakk>\n  \\<Longrightarrow> Q l (postQ ({A} WHILE b DO C) s)\n\ngoal (1 subgoal):\n 1. Q l (postQ ({A} WHILE b DO C) s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ ({A} WHILE b DO C) s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre ({A} WHILE b DO C) Q ?l1 ?s1 \\<Longrightarrow>\n  Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 C Q upds.\n       \\<lbrakk>\\<And>Q upds.\n                   \\<lbrakk>vc C Q; finite (support Q); finite (varacom C);\n                    lesvars upds \\<inter> varacom C = {};\n                    distinct (map fst upds)\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                        pre C Q l s \\<and> preList upds C l s}\n                    strip C\n                    { time\n                       C \\<Down> \\<lambda>l s.\n                                    Q l s \\<and> postList upds l s} \\<and>\n                                     (\\<forall>l s.\n   pre C Q l s \\<longrightarrow> Q l (postQ C s));\n        vc ({x1} WHILE x2 DO C) Q; finite (support Q);\n        finite (varacom ({x1} WHILE x2 DO C));\n        lesvars upds \\<inter> varacom ({x1} WHILE x2 DO C) = {};\n        distinct (map fst upds)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n            pre ({x1} WHILE x2 DO C) Q l s \\<and>\n            preList upds ({x1} WHILE x2 DO C) l s}\n        strip ({x1} WHILE x2 DO C)\n        { time\n           ({x1} WHILE x2\n            DO C) \\<Down> \\<lambda>l s.\n                             Q l s \\<and> postList upds l s} \\<and>\n                         (\\<forall>l s.\n                             pre ({x1} WHILE x2 DO C) Q l\n                              s \\<longrightarrow>\n                             Q l (postQ ({x1} WHILE x2 DO C) s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre ({A} WHILE b DO C) Q l s \\<and>\n                             preList upds ({A} WHILE b DO C) l s}\n                         strip ({A} WHILE b DO C)\n                         { time\n                            ({A} WHILE b\n                             DO C) \\<Down> \\<lambda>l s.\n        Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre ({A} WHILE b DO C) Q l s \\<longrightarrow>\n        Q l (postQ ({A} WHILE b DO C) s))", "using G1  G2"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           I l s \\<and>\n                           preList upds ({(I, S, E)} WHILE b DO C) l s}\n                       WHILE b DO strip C\n                       { E \\<Down> \\<lambda>l s.\nQ l s \\<and> postList upds l s}\n  pre ({A} WHILE b DO C) Q ?l1 ?s1 \\<Longrightarrow>\n  Q ?l1 (postQ ({A} WHILE b DO C) ?s1)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                             pre ({A} WHILE b DO C) Q l s \\<and>\n                             preList upds ({A} WHILE b DO C) l s}\n                         strip ({A} WHILE b DO C)\n                         { time\n                            ({A} WHILE b\n                             DO C) \\<Down> \\<lambda>l s.\n        Q l s \\<and> postList upds l s} \\<and>\n    (\\<forall>l s.\n        pre ({A} WHILE b DO C) Q l s \\<longrightarrow>\n        Q l (postQ ({A} WHILE b DO C) s))", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           pre ({A} WHILE b DO C) Q l s \\<and>\n                           preList upds ({A} WHILE b DO C) l s}\n                       strip ({A} WHILE b DO C)\n                       { time\n                          ({A} WHILE b\n                           DO C) \\<Down> \\<lambda>l s.\n      Q l s \\<and> postList upds l s} \\<and>\n  (\\<forall>l s.\n      pre ({A} WHILE b DO C) Q l s \\<longrightarrow>\n      Q l (postQ ({A} WHILE b DO C) s))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary vc_sound':\n  assumes \"vc C Q\" \n          \"finite (support Q)\" \"finite (varacom C)\"\n          \"\\<forall>l s. P l s \\<longrightarrow> pre C Q l s\" \n  shows \"\\<turnstile>\\<^sub>1 {P} strip C {time C \\<Down> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {P} strip C { time C \\<Down> Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {P} strip C { time C \\<Down> Q}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {P} strip C { time C \\<Down> Q}", "apply(rule conseq_old)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow> ?P l s \\<and> ?e' s \\<le> k * time C s\n 2. \\<turnstile>\\<^sub>1 {?P} strip C { ?e' \\<Down> ?Q}\n 3. \\<forall>l s. ?Q l s \\<longrightarrow> Q l s", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<turnstile>\\<^sub>1 {?P} strip C { ?e' \\<Down> ?Q}\n 2. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow> ?P l s \\<and> ?e' s \\<le> k * time C s\n 3. \\<forall>l s. ?Q l s \\<longrightarrow> Q l s", "apply(rule vc_sound[where upds=\"[]\", OF assms(1-3), THEN conjunct1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. lesvars [] \\<inter> varacom C = {}\n 2. distinct (map fst [])\n 3. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          (pre C Q l s \\<and> preList [] C l s) \\<and>\n          time C s \\<le> k * time C s\n 4. \\<forall>l s. Q l s \\<and> postList [] l s \\<longrightarrow> Q l s", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>l s. P l s \\<longrightarrow> pre C Q l s\n\ngoal (4 subgoals):\n 1. lesvars [] \\<inter> varacom C = {}\n 2. distinct (map fst [])\n 3. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          (pre C Q l s \\<and> preList [] C l s) \\<and>\n          time C s \\<le> k * time C s\n 4. \\<forall>l s. Q l s \\<and> postList [] l s \\<longrightarrow> Q l s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {P} strip C { time C \\<Down> Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma preT_constant: \"preT C (%_. a) = (%_. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preT C (\\<lambda>_. a) = (\\<lambda>_. a)", "apply(induct C)"], ["proof (prove)\ngoal (6 subgoals):\n 1. preT SKIP (\\<lambda>_. a) = (\\<lambda>_. a)\n 2. \\<And>x1 x2. preT (x1 ::= x2) (\\<lambda>_. a) = (\\<lambda>_. a)\n 3. \\<And>C1 C2.\n       \\<lbrakk>preT C1 (\\<lambda>_. a) = (\\<lambda>_. a);\n        preT C2 (\\<lambda>_. a) = (\\<lambda>_. a)\\<rbrakk>\n       \\<Longrightarrow> preT (C1;; C2) (\\<lambda>_. a) = (\\<lambda>_. a)\n 4. \\<And>x1 C1 C2.\n       \\<lbrakk>preT C1 (\\<lambda>_. a) = (\\<lambda>_. a);\n        preT C2 (\\<lambda>_. a) = (\\<lambda>_. a)\\<rbrakk>\n       \\<Longrightarrow> preT (IF x1 THEN C1 ELSE C2) (\\<lambda>_. a) =\n                         (\\<lambda>_. a)\n 5. \\<And>x1 x2 x3 C.\n       preT C (\\<lambda>_. a) = (\\<lambda>_. a) \\<Longrightarrow>\n       preT ({x1/x2/x3} CONSEQ C) (\\<lambda>_. a) = (\\<lambda>_. a)\n 6. \\<And>x1 x2 C.\n       preT C (\\<lambda>_. a) = (\\<lambda>_. a) \\<Longrightarrow>\n       preT ({x1} WHILE x2 DO C) (\\<lambda>_. a) = (\\<lambda>_. a)", "by (auto)"], ["", "corollary vc_sound'':\n  \"\\<lbrakk> vc C Q; (\\<exists>k>0. \\<forall>l s. P l s \\<longrightarrow> pre C Q l s \\<and> time C s \\<le> k * e s);\n  finite (support Q); finite (varacom C)\\<rbrakk> \\<Longrightarrow> \\<turnstile>\\<^sub>1 {P} strip C {e \\<Down> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vc C Q;\n     \\<exists>k>0.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s;\n     finite (support Q); finite (varacom C)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {P} strip C { e \\<Down> Q}", "apply(rule ub_cost[where e'=\"time C\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vc C Q;\n     \\<exists>k>0.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s;\n     finite (support Q); finite (varacom C)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k>0.\n                         \\<forall>l s.\n                            P l s \\<longrightarrow> time C s \\<le> k * e s\n 2. \\<lbrakk>vc C Q;\n     \\<exists>k>0.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s;\n     finite (support Q); finite (varacom C)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>1 {P} strip C { time C \\<Down> Q}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>vc C Q; finite (support Q); finite (varacom C); 0 < k;\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>1 {P} strip C\n        { time C \\<Down> Q}", "apply(rule vc_sound')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>vc C Q; finite (support Q); finite (varacom C); 0 < k;\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s\\<rbrakk>\n       \\<Longrightarrow> vc C Q\n 2. \\<And>k.\n       \\<lbrakk>vc C Q; finite (support Q); finite (varacom C); 0 < k;\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s\\<rbrakk>\n       \\<Longrightarrow> finite (support Q)\n 3. \\<And>k.\n       \\<lbrakk>vc C Q; finite (support Q); finite (varacom C); 0 < k;\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s\\<rbrakk>\n       \\<Longrightarrow> finite (varacom C)\n 4. \\<And>k.\n       \\<lbrakk>vc C Q; finite (support Q); finite (varacom C); 0 < k;\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> time C s \\<le> k * e s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l s. P l s \\<longrightarrow> pre C Q l s", "by auto"], ["", "subsubsection \\<open>Completeness:\\<close>"], ["", "lemma vc_complete:\n  \"\\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q} \\<Longrightarrow>   \\<exists>C. strip C = c \\<and> vc C Q \n  \\<and> (\\<forall>l s. P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s))\n  \\<and> (\\<exists>k. \\<forall>l s. P l s \\<longrightarrow>  time C s \\<le> k * e s)  \"\n  (is \"_ \\<Longrightarrow>   \\<exists>C. ?G P c Q C e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q} \\<Longrightarrow>\n    \\<exists>C.\n       strip C = c \\<and>\n       vc C Q \\<and>\n       (\\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)", "proof (induction  rule: hoare1.induct )"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>P.\n       \\<exists>C.\n          strip C = SKIP \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l s \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l s \\<longrightarrow> time C s \\<le> k * Suc 0)\n 2. \\<And>P a x.\n       \\<exists>C.\n          strip C = x ::= a \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n 3. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 4. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 5. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 6. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case Skip"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>P.\n       \\<exists>C.\n          strip C = SKIP \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l s \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l s \\<longrightarrow> time C s \\<le> k * Suc 0)\n 2. \\<And>P a x.\n       \\<exists>C.\n          strip C = x ::= a \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n 3. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 4. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 5. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 6. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case (is \"\\<exists>C. ?C C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = SKIP \\<and>\n       vc C P_ \\<and>\n       (\\<forall>l s.\n           P_ l s \\<longrightarrow>\n           pre C P_ l s \\<and> P_ l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s. P_ l s \\<longrightarrow> time C s \\<le> k * Suc 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strip ?C = SKIP \\<and>\n    vc ?C P_ \\<and>\n    (\\<forall>l s.\n        P_ l s \\<longrightarrow>\n        pre ?C P_ l s \\<and> P_ l (postQ ?C s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s. P_ l s \\<longrightarrow> time ?C s \\<le> k * Suc 0)", "show \"?C Askip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip SKIP = SKIP \\<and>\n    vc SKIP P_ \\<and>\n    (\\<forall>l s.\n        P_ l s \\<longrightarrow>\n        pre SKIP P_ l s \\<and> P_ l (postQ SKIP s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s. P_ l s \\<longrightarrow> time SKIP s \\<le> k * Suc 0)", "by auto"], ["proof (state)\nthis:\n  strip SKIP = SKIP \\<and>\n  vc SKIP P_ \\<and>\n  (\\<forall>l s.\n      P_ l s \\<longrightarrow>\n      pre SKIP P_ l s \\<and> P_ l (postQ SKIP s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s. P_ l s \\<longrightarrow> time SKIP s \\<le> k * Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = SKIP \\<and>\n     vc C P_ \\<and>\n     (\\<forall>l s.\n         P_ l s \\<longrightarrow>\n         pre C P_ l s \\<and> P_ l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P_ l s \\<longrightarrow> time C s \\<le> k * Suc 0)\n\ngoal (5 subgoals):\n 1. \\<And>P a x.\n       \\<exists>C.\n          strip C = x ::= a \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n 2. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 3. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 5. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P a x.\n       \\<exists>C.\n          strip C = x ::= a \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n 2. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 3. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 5. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case (Assign P a x  )"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>P a x.\n       \\<exists>C.\n          strip C = x ::= a \\<and>\n          vc C P \\<and>\n          (\\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow>\n              pre C P l s \\<and> P l (postQ C s)) \\<and>\n          (\\<exists>k.\n              \\<forall>l s.\n                 P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n 2. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 3. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 5. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case (is \"\\<exists>C. ?C C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = x ::= a \\<and>\n       vc C P \\<and>\n       (\\<forall>l s.\n           P l (s[a/x]) \\<longrightarrow>\n           pre C P l s \\<and> P l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s.\n              P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strip ?C = x ::= a \\<and>\n    vc ?C P \\<and>\n    (\\<forall>l s.\n        P l (s[a/x]) \\<longrightarrow>\n        pre ?C P l s \\<and> P l (postQ ?C s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l (s[a/x]) \\<longrightarrow> time ?C s \\<le> k * Suc 0)", "show \"?C(Aassign x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (x ::= a) = x ::= a \\<and>\n    vc (x ::= a) P \\<and>\n    (\\<forall>l s.\n        P l (s[a/x]) \\<longrightarrow>\n        pre (x ::= a) P l s \\<and> P l (postQ (x ::= a) s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l (s[a/x]) \\<longrightarrow> time (x ::= a) s \\<le> k * Suc 0)", "apply (simp del: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l s. P l (s[a/x])) \\<longrightarrow> Ex ((\\<le>) (Suc 0))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip (x ::= a) = x ::= a \\<and>\n  vc (x ::= a) P \\<and>\n  (\\<forall>l s.\n      P l (s[a/x]) \\<longrightarrow>\n      pre (x ::= a) P l s \\<and> P l (postQ (x ::= a) s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l (s[a/x]) \\<longrightarrow> time (x ::= a) s \\<le> k * Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = x ::= a \\<and>\n     vc C P \\<and>\n     (\\<forall>l s.\n         P l (s[a/x]) \\<longrightarrow>\n         pre C P l s \\<and> P l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l (s[a/x]) \\<longrightarrow> time C s \\<le> k * Suc 0)\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case (Seq P x e2' c1 e1 Q e2 c2 R e)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> l x = e2' s} c1\n                       { e1 \\<Down> \\<lambda>l s.\n Q l s \\<and> e2 s \\<le> l x}\n  \\<turnstile>\\<^sub>1 {Q} c2 { e2 \\<Down> R}\n  x \\<notin> support P\n  x \\<notin> support Q\n  P ?l ?s \\<Longrightarrow> e1 ?s + e2' ?s \\<le> e ?s\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         pre C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n         Q l (postQ C s) \\<and> e2 (postQ C s) \\<le> l x) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> l x = e2' s \\<longrightarrow>\n            time C s \\<le> k * e1 s)\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C R \\<and>\n     (\\<forall>l s.\n         Q l s \\<longrightarrow> pre C R l s \\<and> R l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. Q l s \\<longrightarrow> time C s \\<le> k * e2 s)\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from Seq.IH(1)"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         pre C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n         Q l (postQ C s) \\<and> e2 (postQ C s) \\<le> l x) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> l x = e2' s \\<longrightarrow>\n            time C s \\<le> k * e1 s)", "obtain C1 where \"?G (\\<lambda>l s. P l s \\<and> l x = e2' s) c1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) C1 e1 \""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         pre C (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n         Q l (postQ C s) \\<and> e2 (postQ C s) \\<le> l x) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> l x = e2' s \\<longrightarrow>\n            time C s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>C1.\n        strip C1 = c1 \\<and>\n        vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n        (\\<forall>l s.\n            P l s \\<and> l x = e2' s \\<longrightarrow>\n            pre C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n            Q l (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> l x) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               P l s \\<and> l x = e2' s \\<longrightarrow>\n               time C1 s \\<le> k * e1 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C1 = c1 \\<and>\n  vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> l x = e2' s \\<longrightarrow>\n      pre C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n      Q l (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> l x) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         time C1 s \\<le> k * e1 s)\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  strip C1 = c1 \\<and>\n  vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> l x = e2' s \\<longrightarrow>\n      pre C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n      Q l (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> l x) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         time C1 s \\<le> k * e1 s)", "obtain k where ih1: \"strip C1 = c1\"\n    \"vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x)\"\n    \"\\<And>l s. P l s \\<Longrightarrow> l x = e2' s \\<Longrightarrow> pre C1 (\\<lambda>la sa. (Q la sa \\<and> e2 sa \\<le> la x)) l s\"\n    \"(\\<forall>l s. P l s \\<and> l x = e2' s \\<longrightarrow>  time C1 s \\<le> k * e1 s)\" \n    \"\\<And>l s.  P l s \\<Longrightarrow> l x = e2' s \\<Longrightarrow> Q l (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> l x\""], ["proof (prove)\nusing this:\n  strip C1 = c1 \\<and>\n  vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> l x = e2' s \\<longrightarrow>\n      pre C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x) l s \\<and>\n      Q l (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> l x) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> l x = e2' s \\<longrightarrow>\n         time C1 s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>strip C1 = c1;\n         vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x);\n         \\<And>l s.\n            \\<lbrakk>P l s; l x = e2' s\\<rbrakk>\n            \\<Longrightarrow> pre C1\n                               (\\<lambda>la sa.\n                                   Q la sa \\<and> e2 sa \\<le> la x)\n                               l s;\n         \\<forall>l s.\n            P l s \\<and> l x = e2' s \\<longrightarrow>\n            time C1 s \\<le> k * e1 s;\n         \\<And>l s.\n            \\<lbrakk>P l s; l x = e2' s\\<rbrakk>\n            \\<Longrightarrow> Q l (postQ C1 s) \\<and>\n                              e2 (postQ C1 s) \\<le> l x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip C1 = c1\n  vc C1 (\\<lambda>a b. Q a b \\<and> e2 b \\<le> a x)\n  \\<lbrakk>P ?l ?s; ?l x = e2' ?s\\<rbrakk>\n  \\<Longrightarrow> pre C1 (\\<lambda>la sa. Q la sa \\<and> e2 sa \\<le> la x)\n                     ?l ?s\n  \\<forall>l s.\n     P l s \\<and> l x = e2' s \\<longrightarrow> time C1 s \\<le> k * e1 s\n  \\<lbrakk>P ?l ?s; ?l x = e2' ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?l (postQ C1 ?s) \\<and> e2 (postQ C1 ?s) \\<le> ?l x\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from Seq.IH(2)"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C R \\<and>\n     (\\<forall>l s.\n         Q l s \\<longrightarrow> pre C R l s \\<and> R l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. Q l s \\<longrightarrow> time C s \\<le> k * e2 s)", "obtain C2 where ih2: \"?G Q c2 R C2 e2  \""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C R \\<and>\n     (\\<forall>l s.\n         Q l s \\<longrightarrow> pre C R l s \\<and> R l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. Q l s \\<longrightarrow> time C s \\<le> k * e2 s)\n\ngoal (1 subgoal):\n 1. (\\<And>C2.\n        strip C2 = c2 \\<and>\n        vc C2 R \\<and>\n        (\\<forall>l s.\n            Q l s \\<longrightarrow>\n            pre C2 R l s \\<and> R l (postQ C2 s)) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               Q l s \\<longrightarrow>\n               time C2 s \\<le> k * e2 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C2 = c2 \\<and>\n  vc C2 R \\<and>\n  (\\<forall>l s.\n      Q l s \\<longrightarrow> pre C2 R l s \\<and> R l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k * e2 s)\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  strip C2 = c2 \\<and>\n  vc C2 R \\<and>\n  (\\<forall>l s.\n      Q l s \\<longrightarrow> pre C2 R l s \\<and> R l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k * e2 s)", "obtain k2 where ih2: \"strip C2 = c2\"\n    \"vc C2 R\"\n    \"(\\<And>l s. Q l s \\<Longrightarrow> pre C2 R l s)\"\n    \"(\\<forall>l s. Q l s \\<longrightarrow>  time C2 s \\<le> k2 * e2 s)\"\n    \"\\<And>l s . Q l s \\<Longrightarrow> R l (postQ C2 s)\""], ["proof (prove)\nusing this:\n  strip C2 = c2 \\<and>\n  vc C2 R \\<and>\n  (\\<forall>l s.\n      Q l s \\<longrightarrow> pre C2 R l s \\<and> R l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k * e2 s)\n\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        \\<lbrakk>strip C2 = c2; vc C2 R;\n         \\<And>l s. Q l s \\<Longrightarrow> pre C2 R l s;\n         \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k2 * e2 s;\n         \\<And>l s. Q l s \\<Longrightarrow> R l (postQ C2 s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip C2 = c2\n  vc C2 R\n  Q ?l ?s \\<Longrightarrow> pre C2 R ?l ?s\n  \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k2 * e2 s\n  Q ?l ?s \\<Longrightarrow> R ?l (postQ C2 ?s)\n\ngoal (4 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P\\<^sub>1 x e2' c\\<^sub>1 e1 P\\<^sub>2 e2 c\\<^sub>2 P\\<^sub>3 e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P\\<^sub>1 l s \\<and> l x = e2' s}\n                                     c\\<^sub>1\n                                     { e1 \\<Down> \\<lambda>l s.\n               P\\<^sub>2 l s \\<and> e2 s \\<le> l x};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) \\<and>\n           (\\<forall>l s.\n               P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n               pre C (\\<lambda>a b. P\\<^sub>2 a b \\<and> e2 b \\<le> a x) l\n                s \\<and>\n               P\\<^sub>2 l (postQ C s) \\<and>\n               e2 (postQ C s) \\<le> l x) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>1 l s \\<and> l x = e2' s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {P\\<^sub>2} c\\<^sub>2 { e2 \\<Down> P\\<^sub>3};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C P\\<^sub>3 \\<and>\n           (\\<forall>l s.\n               P\\<^sub>2 l s \\<longrightarrow>\n               pre C P\\<^sub>3 l s \\<and> P\\<^sub>3 l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P\\<^sub>2 l s \\<longrightarrow> time C s \\<le> k * e2 s);\n        x \\<notin> support P\\<^sub>1; x \\<notin> support P\\<^sub>2;\n        \\<And>l s.\n           P\\<^sub>1 l s \\<Longrightarrow> e1 s + e2' s \\<le> e s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c\\<^sub>1;; c\\<^sub>2 \\<and>\n                            vc C P\\<^sub>3 \\<and>\n                            (\\<forall>l s.\n                                P\\<^sub>1 l s \\<longrightarrow>\n                                pre C P\\<^sub>3 l s \\<and>\n                                P\\<^sub>3 l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P\\<^sub>1 l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 4. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case (is \"\\<exists>C. ?C C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = c1;; c2 \\<and>\n       vc C R \\<and>\n       (\\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C R l s \\<and> R l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strip ?C = c1;; c2 \\<and>\n    vc ?C R \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow> pre ?C R l s \\<and> R l (postQ ?C s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s. P l s \\<longrightarrow> time ?C s \\<le> k * e s)", "show \"?C(Aseq (Aconseq P Q (time C1) C1) C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2 \\<and>\n    vc ({P/Q/time C1} CONSEQ C1;; C2) R \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        pre ({P/Q/time C1} CONSEQ C1;; C2) R l s \\<and>\n        R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s)", "(* with Q being (\\<lambda>la sa. (Q la sa \\<and> e2 sa \\<le> la x)) some less mono is needed *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2 \\<and>\n    vc ({P/Q/time C1} CONSEQ C1;; C2) R \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        pre ({P/Q/time C1} CONSEQ C1;; C2) R l s \\<and>\n        R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2\n 2. vc ({P/Q/time C1} CONSEQ C1;; C2) R\n 3. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 4. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 5. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2\n 2. vc ({P/Q/time C1} CONSEQ C1;; C2) R\n 3. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 4. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 5. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2", "apply(simp add: ih1(1) ih2(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2\n\ngoal (4 subgoals):\n 1. vc ({P/Q/time C1} CONSEQ C1;; C2) R\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 4. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. vc ({P/Q/time C1} CONSEQ C1;; C2) R\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 4. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. vc ({P/Q/time C1} CONSEQ C1;; C2) R\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 4. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc ({P/Q/time C1} CONSEQ C1;; C2) R", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C1 Q \\<and>\n    (\\<exists>k>0.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           (0 < time C1 s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n           (\\<forall>t.\n               \\<exists>l'.\n                  pre C1 Q l' s \\<and>\n                  (Q l' t \\<longrightarrow> pre C2 R l t))) \\<and>\n    vc C2 R", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. vc C1 Q\n 2. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          (0 < time C1 s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C1 Q l' s \\<and>\n                 (Q l' t \\<longrightarrow> pre C2 R l t))\n 3. vc C2 R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C1 Q", "apply(rule vc_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>l s. ?P l s \\<longrightarrow> Q l s\n 2. vc C1 ?P", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. vc C1 ?P\n 2. \\<forall>l s. ?P l s \\<longrightarrow> Q l s", "apply (rule ih1(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s. Q l s \\<and> e2 s \\<le> l x \\<longrightarrow> Q l s", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          (0 < time C1 s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C1 Q l' s \\<and>\n                 (Q l' t \\<longrightarrow> pre C2 R l t))\n 2. vc C2 R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          (0 < time C1 s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C1 Q l' s \\<and>\n                 (Q l' t \\<longrightarrow> pre C2 R l t))", "apply(rule exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        (0 < time C1 s \\<longrightarrow> Suc 0 \\<le> 1) \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C1 Q l' s \\<and>\n               (Q l' t \\<longrightarrow> pre C2 R l t)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; 0 < time C1 s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> 1\n 2. \\<And>l s t.\n       P l s \\<Longrightarrow>\n       \\<exists>l'.\n          pre C1 Q l' s \\<and> (Q l' t \\<longrightarrow> pre C2 R l t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l_ s_; 0 < time C1 s_\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> 1", "by(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s t.\n       P l s \\<Longrightarrow>\n       \\<exists>l'.\n          pre C1 Q l' s \\<and> (Q l' t \\<longrightarrow> pre C2 R l t)", "subgoal for l s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. P l s \\<Longrightarrow>\n    \\<exists>l'.\n       pre C1 Q l' s \\<and> (Q l' t \\<longrightarrow> pre C2 R l t)", "apply(rule exI[where x=\"l(x:= e2' s)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P l s \\<Longrightarrow>\n    pre C1 Q (l(x := e2' s)) s \\<and>\n    (Q (l(x := e2' s)) t \\<longrightarrow> pre C2 R l t)", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P l s \\<Longrightarrow> pre C1 Q (l(x := e2' s)) s\n 2. \\<lbrakk>P l s; Q (l(x := e2' s)) t\\<rbrakk>\n    \\<Longrightarrow> pre C2 R l t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P l s \\<Longrightarrow> pre C1 Q (l(x := e2' s)) s", "apply(rule pre_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P l s \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q l s\n 2. P l s \\<Longrightarrow> pre C1 ?P (l(x := e2' s)) s", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. P l s \\<Longrightarrow> pre C1 ?P (l(x := e2' s)) s\n 2. P l s \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q l s", "apply (rule ih1(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. P l s \\<Longrightarrow> P (l(x := e2' s)) s\n 2. P l s \\<Longrightarrow> (l(x := e2' s)) x = e2' s\n 3. P l s \\<Longrightarrow>\n    \\<forall>l s. Q l s \\<and> e2 s \\<le> l x \\<longrightarrow> Q l s", "apply(subst assn2_lupd)"], ["proof (prove)\ngoal (4 subgoals):\n 1. P l s \\<Longrightarrow> x \\<notin> support P\n 2. P l s \\<Longrightarrow> P l s\n 3. P l s \\<Longrightarrow> (l(x := e2' s)) x = e2' s\n 4. P l s \\<Longrightarrow>\n    \\<forall>l s. Q l s \\<and> e2 s \\<le> l x \\<longrightarrow> Q l s", "using Seq(3)"], ["proof (prove)\nusing this:\n  x \\<notin> support P\n\ngoal (4 subgoals):\n 1. P l s \\<Longrightarrow> x \\<notin> support P\n 2. P l s \\<Longrightarrow> P l s\n 3. P l s \\<Longrightarrow> (l(x := e2' s)) x = e2' s\n 4. P l s \\<Longrightarrow>\n    \\<forall>l s. Q l s \\<and> e2 s \\<le> l x \\<longrightarrow> Q l s", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; Q (l(x := e2' s)) t\\<rbrakk>\n    \\<Longrightarrow> pre C2 R l t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; Q (l(x := e2' s)) t\\<rbrakk>\n    \\<Longrightarrow> pre C2 R l t", "apply(rule ih2(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; Q (l(x := e2' s)) t\\<rbrakk> \\<Longrightarrow> Q l t", "using assn2_lupd[OF Seq(4)]"], ["proof (prove)\nusing this:\n  Q (?l(x := ?n)) = Q ?l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; Q (l(x := e2' s)) t\\<rbrakk> \\<Longrightarrow> Q l t", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C2 R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C2 R", "by (rule ih2(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vc ({P/Q/time C1} CONSEQ C1;; C2) R\n\ngoal (3 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 3. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 3. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "case (3 l s)"], ["proof (state)\nthis:\n  P l s\n\ngoal (3 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 3. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "then"], ["proof (chain)\npicking this:\n  P l s", "show ?case"], ["proof (prove)\nusing this:\n  P l s\n\ngoal (1 subgoal):\n 1. pre ({P/Q/time C1} CONSEQ C1;; C2) R l s", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pre ({P/Q/time C1} CONSEQ C1;; C2) R l s\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "case (4 l s)"], ["proof (state)\nthis:\n  P l s\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "from 4"], ["proof (chain)\npicking this:\n  P l s", "have \"P (l(x:=e2' s)) s\""], ["proof (prove)\nusing this:\n  P l s\n\ngoal (1 subgoal):\n 1. P (l(x := e2' s)) s", "using assn2_lupd[OF Seq(3)]"], ["proof (prove)\nusing this:\n  P l s\n  P (?l(x := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P (l(x := e2' s)) s", "by simp"], ["proof (state)\nthis:\n  P (l(x := e2' s)) s\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "with ih1(5)[where l=\"l(x:=e2' s)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>P (l(x := e2' s)) ?s; (l(x := e2' s)) x = e2' ?s\\<rbrakk>\n  \\<Longrightarrow> Q (l(x := e2' s)) (postQ C1 ?s) \\<and>\n                    e2 (postQ C1 ?s) \\<le> (l(x := e2' s)) x\n  P (l(x := e2' s)) s", "have \"Q (l(x := e2' s)) (postQ C1 s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P (l(x := e2' s)) ?s; (l(x := e2' s)) x = e2' ?s\\<rbrakk>\n  \\<Longrightarrow> Q (l(x := e2' s)) (postQ C1 ?s) \\<and>\n                    e2 (postQ C1 ?s) \\<le> (l(x := e2' s)) x\n  P (l(x := e2' s)) s\n\ngoal (1 subgoal):\n 1. Q (l(x := e2' s)) (postQ C1 s)", "by simp"], ["proof (state)\nthis:\n  Q (l(x := e2' s)) (postQ C1 s)\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "then"], ["proof (chain)\npicking this:\n  Q (l(x := e2' s)) (postQ C1 s)", "have \"Q l (postQ C1 s)\""], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s)\n\ngoal (1 subgoal):\n 1. Q l (postQ C1 s)", "using assn2_lupd[OF Seq(4)]"], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s)\n  Q (?l(x := ?n)) = Q ?l\n\ngoal (1 subgoal):\n 1. Q l (postQ C1 s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ C1 s)\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "with ih2(3)"], ["proof (chain)\npicking this:\n  Q ?l ?s \\<Longrightarrow> pre C2 R ?l ?s\n  Q l (postQ C1 s)", "have \"Q l (postQ C1 s)\""], ["proof (prove)\nusing this:\n  Q ?l ?s \\<Longrightarrow> pre C2 R ?l ?s\n  Q l (postQ C1 s)\n\ngoal (1 subgoal):\n 1. Q l (postQ C1 s)", "by simp"], ["proof (state)\nthis:\n  Q l (postQ C1 s)\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow> R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "with  ih2(5)"], ["proof (chain)\npicking this:\n  Q ?l ?s \\<Longrightarrow> R ?l (postQ C2 ?s)\n  Q l (postQ C1 s)", "show ?case"], ["proof (prove)\nusing this:\n  Q ?l ?s \\<Longrightarrow> R ?l (postQ C2 ?s)\n  Q l (postQ C1 s)\n\ngoal (1 subgoal):\n 1. R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "from ih1(4)"], ["proof (chain)\npicking this:\n  \\<forall>l s.\n     P l s \\<and> l x = e2' s \\<longrightarrow> time C1 s \\<le> k * e1 s", "have\n        gg: \"\\<And>l s. \\<lbrakk>P l s; e2' s = l x\\<rbrakk> \\<Longrightarrow>   time C1 s \\<le> k * e1 s\""], ["proof (prove)\nusing this:\n  \\<forall>l s.\n     P l s \\<and> l x = e2' s \\<longrightarrow> time C1 s \\<le> k * e1 s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; e2' s = l x\\<rbrakk>\n       \\<Longrightarrow> time C1 s \\<le> k * e1 s", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>P ?l ?s; e2' ?s = ?l x\\<rbrakk>\n  \\<Longrightarrow> time C1 ?s \\<le> k * e1 ?s\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s", "proof (rule exI[where x=\"(max k  k2)\"], safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "case (1 l s)"], ["proof (state)\nthis:\n  P l s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have xnP: \"x \\<notin> support P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> support P", "by fact"], ["proof (state)\nthis:\n  x \\<notin> support P\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have 41: \"P (l(x := e2' s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l(x := e2' s)) s", "apply(subst assn2_lupd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> support P\n 2. P l s", "apply(fact xnP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P l s", "apply(fact 5)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (l(x := e2' s)) s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have A: \"  time C1 s \\<le> k * e1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time C1 s \\<le> k * e1 s", "apply(rule gg[where l=\"l(x:=e2' s)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. P (l(x := e2' s)) s\n 2. e2' s = (l(x := e2' s)) x", "apply(rule 41)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2' s = (l(x := e2' s)) x", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  time C1 s \\<le> k * e1 s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have B: \"preT C1 (time C2) s \\<le> k2 * e2' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "from  1"], ["proof (chain)\npicking this:\n  P l s", "have \"P (l(x := e2' s)) s\""], ["proof (prove)\nusing this:\n  P l s\n\ngoal (1 subgoal):\n 1. P (l(x := e2' s)) s", "using assn2_lupd[OF xnP]"], ["proof (prove)\nusing this:\n  P l s\n  P (?l(x := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P (l(x := e2' s)) s", "by simp"], ["proof (state)\nthis:\n  P (l(x := e2' s)) s\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "have F: \"Q (l(x:=e2' s)) (postQ C1 s) \\<and> e2 (postQ C1 s) \\<le> (l(x:=e2' s)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (l(x := e2' s)) (postQ C1 s) \\<and>\n    e2 (postQ C1 s) \\<le> (l(x := e2' s)) x", "apply(rule ih1(5)[where l=\"l(x:=e2' s)\" and s=s])"], ["proof (prove)\ngoal (2 subgoals):\n 1. P (l(x := e2' s)) s\n 2. (l(x := e2' s)) x = e2' s", "apply(fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l(x := e2' s)) x = e2' s", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "then"], ["proof (chain)\npicking this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x", "have \" time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)\""], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n\ngoal (1 subgoal):\n 1. time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)", "using ih2(4)"], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n  \\<forall>l s. Q l s \\<longrightarrow> time C2 s \\<le> k2 * e2 s\n\ngoal (1 subgoal):\n 1. time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)", "by auto"], ["proof (state)\nthis:\n  time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "with F"], ["proof (chain)\npicking this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n  time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)", "have \"time C2 (postQ C1 s) \\<le> k2 * e2' s\""], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n  time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)\n\ngoal (1 subgoal):\n 1. time C2 (postQ C1 s) \\<le> k2 * e2' s", "using order_subst1"], ["proof (prove)\nusing this:\n  Q (l(x := e2' s)) (postQ C1 s) \\<and>\n  e2 (postQ C1 s) \\<le> (l(x := e2' s)) x\n  time C2 (postQ C1 s) \\<le> k2 * e2 (postQ C1 s)\n  \\<lbrakk>?a \\<le> ?f ?b; ?b \\<le> ?c;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> ?f x \\<le> ?f y\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?f ?c\n\ngoal (1 subgoal):\n 1. time C2 (postQ C1 s) \\<le> k2 * e2' s", "by fastforce"], ["proof (state)\nthis:\n  time C2 (postQ C1 s) \\<le> k2 * e2' s\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "then"], ["proof (chain)\npicking this:\n  time C2 (postQ C1 s) \\<le> k2 * e2' s", "show \"preT C1 (time C2) s \\<le> k2 * e2' s\""], ["proof (prove)\nusing this:\n  time C2 (postQ C1 s) \\<le> k2 * e2' s\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "using TQ"], ["proof (prove)\nusing this:\n  time C2 (postQ C1 s) \\<le> k2 * e2' s\n  preT ?C ?e ?s = ?e (postQ ?C ?s)\n\ngoal (1 subgoal):\n 1. preT C1 (time C2) s \\<le> k2 * e2' s", "by simp"], ["proof (state)\nthis:\n  preT C1 (time C2) s \\<le> k2 * e2' s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preT C1 (time C2) s \\<le> k2 * e2' s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have \"time C1 s + preT C1 (time C2) s \\<le> k  * e1 s + k2 * e2' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time C1 s + preT C1 (time C2) s \\<le> k * e1 s + k2 * e2' s", "using A B"], ["proof (prove)\nusing this:\n  time C1 s \\<le> k * e1 s\n  preT C1 (time C2) s \\<le> k2 * e2' s\n\ngoal (1 subgoal):\n 1. time C1 s + preT C1 (time C2) s \\<le> k * e1 s + k2 * e2' s", "by linarith"], ["proof (state)\nthis:\n  time C1 s + preT C1 (time C2) s \\<le> k * e1 s + k2 * e2' s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "also"], ["proof (state)\nthis:\n  time C1 s + preT C1 (time C2) s \\<le> k * e1 s + k2 * e2' s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have \"\\<dots> \\<le> (max k  k2) * e1 s + (max k  k2) * e2' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * e1 s + k2 * e2' s \\<le> max k k2 * e1 s + max k k2 * e2' s", "using nat_mult_max_left"], ["proof (prove)\nusing this:\n  max ?m ?n * ?q = max (?m * ?q) (?n * ?q)\n\ngoal (1 subgoal):\n 1. k * e1 s + k2 * e2' s \\<le> max k k2 * e1 s + max k k2 * e2' s", "by auto"], ["proof (state)\nthis:\n  k * e1 s + k2 * e2' s \\<le> max k k2 * e1 s + max k k2 * e2' s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "also"], ["proof (state)\nthis:\n  k * e1 s + k2 * e2' s \\<le> max k k2 * e1 s + max k k2 * e2' s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have \"\\<dots> = (max k  k2) * (e1 s + e2' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max k k2 * e1 s + max k k2 * e2' s = max k k2 * (e1 s + e2' s)", "by algebra"], ["proof (state)\nthis:\n  max k k2 * e1 s + max k k2 * e2' s = max k k2 * (e1 s + e2' s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "also"], ["proof (state)\nthis:\n  max k k2 * e1 s + max k k2 * e2' s = max k k2 * (e1 s + e2' s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "have \"\\<dots> \\<le> (max k  k2) * e s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max k k2 * (e1 s + e2' s) \\<le> max k k2 * e s", "using Seq(5)[OF 1]"], ["proof (prove)\nusing this:\n  e1 s + e2' s \\<le> e s\n\ngoal (1 subgoal):\n 1. max k k2 * (e1 s + e2' s) \\<le> max k k2 * e s", "by auto"], ["proof (state)\nthis:\n  max k k2 * (e1 s + e2' s) \\<le> max k k2 * e s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "finally"], ["proof (chain)\npicking this:\n  time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s", "have \"time C1 s + preT C1 (time C2) s \\<le> (max k  k2) * e s\""], ["proof (prove)\nusing this:\n  time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s\n\ngoal (1 subgoal):\n 1. time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s", "."], ["proof (state)\nthis:\n  time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "then"], ["proof (chain)\npicking this:\n  time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s", "show ?case"], ["proof (prove)\nusing this:\n  time C1 s + preT C1 (time C2) s \\<le> max k k2 * e s\n\ngoal (1 subgoal):\n 1. time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s", "by auto"], ["proof (state)\nthis:\n  time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> max k k2 * e s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k.\n     \\<forall>l s.\n        P l s \\<longrightarrow>\n        time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strip ({P/Q/time C1} CONSEQ C1;; C2) = c1;; c2 \\<and>\n  vc ({P/Q/time C1} CONSEQ C1;; C2) R \\<and>\n  (\\<forall>l s.\n      P l s \\<longrightarrow>\n      pre ({P/Q/time C1} CONSEQ C1;; C2) R l s \\<and>\n      R l (postQ ({P/Q/time C1} CONSEQ C1;; C2) s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<longrightarrow>\n         time ({P/Q/time C1} CONSEQ C1;; C2) s \\<le> k * e s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = c1;; c2 \\<and>\n     vc C R \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C R l s \\<and> R l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case (If P b c1 e1 Q c2)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s} c1\n                       { e1 \\<Down> Q}\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s} c2\n                       { e1 \\<Down> Q}\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow> time C s \\<le> k * e1 s)\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            time C s \\<le> k * e1 s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from If.IH(1)"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow> time C s \\<le> k * e1 s)", "obtain C1 where \"?G (\\<lambda>l s. P l s \\<and> bval b s) c1 Q C1 e1\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c1 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow> time C s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>C1.\n        strip C1 = c1 \\<and>\n        vc C1 Q \\<and>\n        (\\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow>\n            pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               time C1 s \\<le> k * e1 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k * e1 s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k * e1 s)", "obtain k1 where ih1: \" strip C1 = c1 \\<and> vc C1 Q \\<and> (\\<forall>l s. P l s \\<and> bval b s \\<longrightarrow> pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>  ( \\<forall>l s. P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s) \""], ["proof (prove)\nusing this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>k1.\n        strip C1 = c1 \\<and>\n        vc C1 Q \\<and>\n        (\\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow>\n            pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n        (\\<forall>l s.\n            P l s \\<and> bval b s \\<longrightarrow>\n            time C1 s \\<le> k1 * e1 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from If.IH(2)"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            time C s \\<le> k * e1 s)", "obtain C2 where \"?G (\\<lambda>l s. P l s \\<and> \\<not>bval b s) c2 Q C2 e1\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c2 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            time C s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>C2.\n        strip C2 = c2 \\<and>\n        vc C2 Q \\<and>\n        (\\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               time C2 s \\<le> k * e1 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         time C2 s \\<le> k * e1 s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         time C2 s \\<le> k * e1 s)", "obtain k2 where ih2: \" strip C2 = c2 \\<and> vc C2 Q \\<and> (\\<forall>l s. P l s \\<and> \\<not>bval b s \\<longrightarrow> pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>  ( \\<forall>l s. P l s \\<and> \\<not>bval b s \\<longrightarrow> time C2 s \\<le> k2 * e1 s )\""], ["proof (prove)\nusing this:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> \\<not> bval b s \\<longrightarrow>\n         time C2 s \\<le> k * e1 s)\n\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        strip C2 = c2 \\<and>\n        vc C2 Q \\<and>\n        (\\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n        (\\<forall>l s.\n            P l s \\<and> \\<not> bval b s \\<longrightarrow>\n            time C2 s \\<le> k2 * e1 s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      time C2 s \\<le> k2 * e1 s)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "define k' where \"k' == max (k1+1) (k2+1)\""], ["proof (state)\nthis:\n  k' \\<equiv> max (k1 + 1) (k2 + 1)\n\ngoal (3 subgoals):\n 1. \\<And>P b c\\<^sub>1 e1 Q c\\<^sub>2.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> bval b s}\n                                     c\\<^sub>1 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>1 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s);\n        \\<turnstile>\\<^sub>1 {\\<lambda>l s. P l s \\<and> \\<not> bval b s}\n                             c\\<^sub>2 { e1 \\<Down> Q};\n        \\<exists>C.\n           strip C = c\\<^sub>2 \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<and> \\<not> bval b s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> \\<not> bval b s \\<longrightarrow>\n                  time C s \\<le> k * e1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C =\n                            IF b THEN c\\<^sub>1 ELSE c\\<^sub>2 \\<and>\n                            vc C Q \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * (e1 s + Suc 0))\n 2. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 3. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case (is \"\\<exists>C. ?C C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = IF b THEN c1 ELSE c2 \\<and>\n       vc C Q \\<and>\n       (\\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s.\n              P l s \\<longrightarrow> time C s \\<le> k * (e1 s + Suc 0))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strip ?C = IF b THEN c1 ELSE c2 \\<and>\n    vc ?C Q \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow> pre ?C Q l s \\<and> Q l (postQ ?C s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l s \\<longrightarrow> time ?C s \\<le> k * (e1 s + Suc 0))", "show \"?C(Aif b C1 C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2 \\<and>\n    vc (IF b THEN C1 ELSE C2) Q \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        pre (IF b THEN C1 ELSE C2) Q l s \\<and>\n        Q l (postQ (IF b THEN C1 ELSE C2) s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           time (IF b THEN C1 ELSE C2) s \\<le> k * (e1 s + Suc 0))", "apply(safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 2. vc (IF b THEN C1 ELSE C2) Q\n 3. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 4. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)\n 5. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time (IF b THEN C1 ELSE C2) s \\<le> k * (e1 s + Suc 0)", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time (IF b THEN C1 ELSE C2) s \\<le> k * (e1 s + Suc 0)\n 2. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 3. vc (IF b THEN C1 ELSE C2) Q\n 4. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 5. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "apply(rule exI[where x=\"k'\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>l s.\n       P l s \\<longrightarrow>\n       time (IF b THEN C1 ELSE C2) s \\<le> k' * (e1 s + Suc 0)\n 2. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 3. vc (IF b THEN C1 ELSE C2) Q\n 4. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 5. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "apply(safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       time (IF b THEN C1 ELSE C2) s \\<le> k' * (e1 s + Suc 0)\n 2. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 3. vc (IF b THEN C1 ELSE C2) Q\n 4. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 5. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "subgoal for l s"], ["proof (prove)\ngoal (1 subgoal):\n 1. P l s \\<Longrightarrow>\n    time (IF b THEN C1 ELSE C2) s \\<le> k' * (e1 s + Suc 0)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "proof(goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "case 1"], ["proof (state)\nthis:\n  P l s\n  bval b s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "with ih1"], ["proof (chain)\npicking this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s)\n  P l s\n  bval b s", "have \"time C1 s \\<le> k1 * e1 s\""], ["proof (prove)\nusing this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s)\n  P l s\n  bval b s\n\ngoal (1 subgoal):\n 1. time C1 s \\<le> k1 * e1 s", "by blast"], ["proof (state)\nthis:\n  time C1 s \\<le> k1 * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "then"], ["proof (chain)\npicking this:\n  time C1 s \\<le> k1 * e1 s", "have \"Suc (time C1 s) \\<le> 1 + k1 * e1 s\""], ["proof (prove)\nusing this:\n  time C1 s \\<le> k1 * e1 s\n\ngoal (1 subgoal):\n 1. Suc (time C1 s) \\<le> 1 + k1 * e1 s", "by auto"], ["proof (state)\nthis:\n  Suc (time C1 s) \\<le> 1 + k1 * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "also"], ["proof (state)\nthis:\n  Suc (time C1 s) \\<le> 1 + k1 * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "have \"\\<dots> \\<le> k' + k1 * e1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + k1 * e1 s \\<le> k' + k1 * e1 s", "unfolding k'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + k1 * e1 s \\<le> max (k1 + 1) (k2 + 1) + k1 * e1 s", "by(auto)"], ["proof (state)\nthis:\n  1 + k1 * e1 s \\<le> k' + k1 * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "also"], ["proof (state)\nthis:\n  1 + k1 * e1 s \\<le> k' + k1 * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "have \"\\<dots> \\<le> k' + k' * e1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' + k1 * e1 s \\<le> k' + k' * e1 s", "unfolding k'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (k1 + 1) (k2 + 1) + k1 * e1 s\n    \\<le> max (k1 + 1) (k2 + 1) + max (k1 + 1) (k2 + 1) * e1 s", "by (simp add: max_def)"], ["proof (state)\nthis:\n  k' + k1 * e1 s \\<le> k' + k' * e1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C1 s) \\<le> k' + k' * e1 s\n 2. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "finally"], ["proof (chain)\npicking this:\n  Suc (time C1 s) \\<le> k' + k' * e1 s", "show ?case"], ["proof (prove)\nusing this:\n  Suc (time C1 s) \\<le> k' + k' * e1 s\n\ngoal (1 subgoal):\n 1. Suc (time C1 s) \\<le> k' + k' * e1 s", "."], ["proof (state)\nthis:\n  Suc (time C1 s) \\<le> k' + k' * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "case 2"], ["proof (state)\nthis:\n  P l s\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "with ih2"], ["proof (chain)\npicking this:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      time C2 s \\<le> k2 * e1 s)\n  P l s\n  \\<not> bval b s", "have \"time C2 s \\<le> k2 * e1 s\""], ["proof (prove)\nusing this:\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      time C2 s \\<le> k2 * e1 s)\n  P l s\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. time C2 s \\<le> k2 * e1 s", "by blast"], ["proof (state)\nthis:\n  time C2 s \\<le> k2 * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "then"], ["proof (chain)\npicking this:\n  time C2 s \\<le> k2 * e1 s", "have \"Suc (time C2 s) \\<le> 1 + k2 * e1 s\""], ["proof (prove)\nusing this:\n  time C2 s \\<le> k2 * e1 s\n\ngoal (1 subgoal):\n 1. Suc (time C2 s) \\<le> 1 + k2 * e1 s", "by auto"], ["proof (state)\nthis:\n  Suc (time C2 s) \\<le> 1 + k2 * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "also"], ["proof (state)\nthis:\n  Suc (time C2 s) \\<le> 1 + k2 * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "have \"\\<dots> \\<le> k' + k2 * e1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + k2 * e1 s \\<le> k' + k2 * e1 s", "unfolding k'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + k2 * e1 s \\<le> max (k1 + 1) (k2 + 1) + k2 * e1 s", "by(auto)"], ["proof (state)\nthis:\n  1 + k2 * e1 s \\<le> k' + k2 * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "also"], ["proof (state)\nthis:\n  1 + k2 * e1 s \\<le> k' + k2 * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "have \"\\<dots> \\<le> k' + k' * e1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' + k2 * e1 s \\<le> k' + k' * e1 s", "unfolding k'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (k1 + 1) (k2 + 1) + k2 * e1 s\n    \\<le> max (k1 + 1) (k2 + 1) + max (k1 + 1) (k2 + 1) * e1 s", "by (simp add: max_def)"], ["proof (state)\nthis:\n  k' + k2 * e1 s \\<le> k' + k' * e1 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n    \\<Longrightarrow> Suc (time C2 s) \\<le> k' + k' * e1 s", "finally"], ["proof (chain)\npicking this:\n  Suc (time C2 s) \\<le> k' + k' * e1 s", "show ?case"], ["proof (prove)\nusing this:\n  Suc (time C2 s) \\<le> k' + k' * e1 s\n\ngoal (1 subgoal):\n 1. Suc (time C2 s) \\<le> k' + k' * e1 s", "."], ["proof (state)\nthis:\n  Suc (time C2 s) \\<le> k' + k' * e1 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 2. vc (IF b THEN C1 ELSE C2) Q\n 3. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 4. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "using ih1 ih2"], ["proof (prove)\nusing this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s)\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      time C2 s \\<le> k2 * e1 s)\n\ngoal (4 subgoals):\n 1. strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2\n 2. vc (IF b THEN C1 ELSE C2) Q\n 3. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 4. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. vc (IF b THEN C1 ELSE C2) Q\n 2. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 3. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "using ih1 ih2"], ["proof (prove)\nusing this:\n  strip C1 = c1 \\<and>\n  vc C1 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow>\n      pre C1 Q l s \\<and> Q l (postQ C1 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<longrightarrow> time C1 s \\<le> k1 * e1 s)\n  strip C2 = c2 \\<and>\n  vc C2 Q \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      pre C2 Q l s \\<and> Q l (postQ C2 s)) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> \\<not> bval b s \\<longrightarrow>\n      time C2 s \\<le> k2 * e1 s)\n\ngoal (3 subgoals):\n 1. vc (IF b THEN C1 ELSE C2) Q\n 2. \\<And>l s. P l s \\<Longrightarrow> pre (IF b THEN C1 ELSE C2) Q l s\n 3. \\<And>l s. P l s \\<Longrightarrow> Q l (postQ (IF b THEN C1 ELSE C2) s)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip (IF b THEN C1 ELSE C2) = IF b THEN c1 ELSE c2 \\<and>\n  vc (IF b THEN C1 ELSE C2) Q \\<and>\n  (\\<forall>l s.\n      P l s \\<longrightarrow>\n      pre (IF b THEN C1 ELSE C2) Q l s \\<and>\n      Q l (postQ (IF b THEN C1 ELSE C2) s)) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<longrightarrow>\n         time (IF b THEN C1 ELSE C2) s \\<le> k * (e1 s + Suc 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = IF b THEN c1 ELSE c2 \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<longrightarrow> time C s \\<le> k * (e1 s + Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case (While P b e' y c e'' e)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>1 {\\<lambda>l s.\n                           P l s \\<and> bval b s \\<and> e' s = l y}\n                       c { e'' \\<Down> \\<lambda>l s.\n    P l s \\<and> e s \\<le> l y}\n  \\<forall>l s.\n     bval b s \\<and> P l s \\<longrightarrow> 1 + e' s + e'' s \\<le> e s\n  \\<forall>l s. \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s\n  y \\<notin> support P\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n         P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            time C s \\<le> k * e'' s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have supportPre: \"support (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y) \\<subseteq> support P \\<union> {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y)\n    \\<subseteq> support P \\<union> {y}", "using support_and support_single"], ["proof (prove)\nusing this:\n  support (\\<lambda>l s. ?P l s \\<and> ?Q l s)\n  \\<subseteq> support ?P \\<union> support ?Q\n  support (\\<lambda>l. ?P (l ?a)) \\<subseteq> {?a}\n\ngoal (1 subgoal):\n 1. support (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y)\n    \\<subseteq> support P \\<union> {y}", "by fast"], ["proof (state)\nthis:\n  support (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y)\n  \\<subseteq> support P \\<union> {y}\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from   While.IH"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n         P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            time C s \\<le> k * e'' s)", "obtain C where\n    ih: \"?G (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y) c (\\<lambda>a b. P a b \\<and> e b \\<le> a y) C e''\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n         P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            time C s \\<le> k * e'' s)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        strip C = c \\<and>\n        vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n        (\\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n            P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               time C s \\<le> k * e'' s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using supportPre"], ["proof (prove)\nusing this:\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n     (\\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n         P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n     (\\<exists>k.\n         \\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            time C s \\<le> k * e'' s)\n  support (\\<lambda>l s. P l s \\<and> bval b s \\<and> e' s = l y)\n  \\<subseteq> support P \\<union> {y}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        strip C = c \\<and>\n        vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n        (\\<forall>l s.\n            P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n            pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n            P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n        (\\<exists>k.\n            \\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               time C s \\<le> k * e'' s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strip C = c \\<and>\n  vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n      pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n      P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         time C s \\<le> k * e'' s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  strip C = c \\<and>\n  vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n      pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n      P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         time C s \\<le> k * e'' s)", "obtain k where ih2: \"vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y)\"\n    \"\\<And>l s. \\<lbrakk> P l s ; bval b s ; e' s = l y \\<rbrakk> \\<Longrightarrow> pre C (\\<lambda>la sa. (P la sa \\<and> e sa \\<le> la y)) l s\" \n    \"\\<And>l s. \\<lbrakk> P l s ; bval b s ; e' s = l y \\<rbrakk> \\<Longrightarrow>   time C s \\<le> k * e'' s \" \n    \"\\<And>l s.\\<lbrakk> P l s ; bval b s ; e' s = l y\\<rbrakk> \\<Longrightarrow> P l (postQ C s) \\<and> e (postQ C s) \\<le> l y\""], ["proof (prove)\nusing this:\n  strip C = c \\<and>\n  vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n      pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n      P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         time C s \\<le> k * e'' s)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y);\n         \\<And>l s.\n            \\<lbrakk>P l s; bval b s; e' s = l y\\<rbrakk>\n            \\<Longrightarrow> pre C\n                               (\\<lambda>la sa.\n                                   P la sa \\<and> e sa \\<le> la y)\n                               l s;\n         \\<And>l s.\n            \\<lbrakk>P l s; bval b s; e' s = l y\\<rbrakk>\n            \\<Longrightarrow> time C s \\<le> k * e'' s;\n         \\<And>l s.\n            \\<lbrakk>P l s; bval b s; e' s = l y\\<rbrakk>\n            \\<Longrightarrow> P l (postQ C s) \\<and>\n                              e (postQ C s) \\<le> l y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y)\n  \\<lbrakk>P ?l ?s; bval b ?s; e' ?s = ?l y\\<rbrakk>\n  \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                     ?l ?s\n  \\<lbrakk>P ?l ?s; bval b ?s; e' ?s = ?l y\\<rbrakk>\n  \\<Longrightarrow> time C ?s \\<le> k * e'' ?s\n  \\<lbrakk>P ?l ?s; bval b ?s; e' ?s = ?l y\\<rbrakk>\n  \\<Longrightarrow> P ?l (postQ C ?s) \\<and> e (postQ C ?s) \\<le> ?l y\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "let ?S = \"postQs C b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "fix l s n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have \"e s = n \\<Longrightarrow> P l s \\<Longrightarrow> postQs_dom (C, b, s) \\<and> P l (?S s) \\<and> ~ bval b (?S s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e s = n; P l s\\<rbrakk>\n    \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                      P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "proof (induct n arbitrary: l s rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l s.\n       \\<lbrakk>\\<And>y l s.\n                   \\<lbrakk>y < x; e s = y; P l s\\<rbrakk>\n                   \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                                     P l (postQs C b s) \\<and>\n                                     \\<not> bval b (postQs C b s);\n        e s = x; P l s\\<rbrakk>\n       \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                         P l (postQs C b s) \\<and>\n                         \\<not> bval b (postQs C b s)", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < x; e ?s = ?y; P ?l ?s\\<rbrakk>\n  \\<Longrightarrow> postQs_dom (C, b, ?s) \\<and>\n                    P ?l (postQs C b ?s) \\<and>\n                    \\<not> bval b (postQs C b ?s)\n  e s = x\n  P l s\n\ngoal (1 subgoal):\n 1. \\<And>x l s.\n       \\<lbrakk>\\<And>y l s.\n                   \\<lbrakk>y < x; e s = y; P l s\\<rbrakk>\n                   \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                                     P l (postQs C b s) \\<and>\n                                     \\<not> bval b (postQs C b s);\n        e s = x; P l s\\<rbrakk>\n       \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                         P l (postQs C b s) \\<and>\n                         \\<not> bval b (postQs C b s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "proof (cases \"bval b s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "case True"], ["proof (state)\nthis:\n  bval b s\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "with While(2) less(3)"], ["proof (chain)\npicking this:\n  \\<forall>l s.\n     bval b s \\<and> P l s \\<longrightarrow> 1 + e' s + e'' s \\<le> e s\n  P l s\n  bval b s", "have \"1 + e' s + e'' s \\<le> e s\""], ["proof (prove)\nusing this:\n  \\<forall>l s.\n     bval b s \\<and> P l s \\<longrightarrow> 1 + e' s + e'' s \\<le> e s\n  P l s\n  bval b s\n\ngoal (1 subgoal):\n 1. 1 + e' s + e'' s \\<le> e s", "by auto"], ["proof (state)\nthis:\n  1 + e' s + e'' s \\<le> e s\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "then"], ["proof (chain)\npicking this:\n  1 + e' s + e'' s \\<le> e s", "have e'e: \"e' s < e s\""], ["proof (prove)\nusing this:\n  1 + e' s + e'' s \\<le> e s\n\ngoal (1 subgoal):\n 1. e' s < e s", "by simp"], ["proof (state)\nthis:\n  e' s < e s\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "have \"P (l(y:=e' s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "using less(3) assn2_lupd[OF While(4)]"], ["proof (prove)\nusing this:\n  P l s\n  P (?l(y := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "by simp"], ["proof (state)\nthis:\n  P (l(y := e' s)) s\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from ih2(4)[OF this] True"], ["proof (chain)\npicking this:\n  \\<lbrakk>bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                    e (postQ C s) \\<le> (l(y := e' s)) y\n  bval b s", "have ee': \"e (postQ C s) \\<le> e' s\" and P': \"P (l(y := e' s)) (postQ C s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                    e (postQ C s) \\<le> (l(y := e' s)) y\n  bval b s\n\ngoal (1 subgoal):\n 1. e (postQ C s) \\<le> e' s &&& P (l(y := e' s)) (postQ C s)", "by auto"], ["proof (state)\nthis:\n  e (postQ C s) \\<le> e' s\n  P (l(y := e' s)) (postQ C s)\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from P'"], ["proof (chain)\npicking this:\n  P (l(y := e' s)) (postQ C s)", "have P'': \"P l (postQ C s)\""], ["proof (prove)\nusing this:\n  P (l(y := e' s)) (postQ C s)\n\ngoal (1 subgoal):\n 1. P l (postQ C s)", "using less(3) assn2_lupd[OF While(4)]"], ["proof (prove)\nusing this:\n  P (l(y := e' s)) (postQ C s)\n  P l s\n  P (?l(y := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P l (postQ C s)", "by simp"], ["proof (state)\nthis:\n  P l (postQ C s)\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from ee' e'e less(2)"], ["proof (chain)\npicking this:\n  e (postQ C s) \\<le> e' s\n  e' s < e s\n  e s = x", "have \"e (postQ C s) < x\""], ["proof (prove)\nusing this:\n  e (postQ C s) \\<le> e' s\n  e' s < e s\n  e s = x\n\ngoal (1 subgoal):\n 1. e (postQ C s) < x", "by auto"], ["proof (state)\nthis:\n  e (postQ C s) < x\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from less(1)[OF this _ P'']"], ["proof (chain)\npicking this:\n  e (postQ C s) = e (postQ C s) \\<Longrightarrow>\n  postQs_dom (C, b, postQ C s) \\<and>\n  P l (postQs C b (postQ C s)) \\<and> \\<not> bval b (postQs C b (postQ C s))", "have d: \"postQs_dom (C, b, postQ C s)\" \n              and p: \"P l (postQs C b (postQ C s))\"\n              and b: \"\\<not> bval b (postQs C b (postQ C s))\""], ["proof (prove)\nusing this:\n  e (postQ C s) = e (postQ C s) \\<Longrightarrow>\n  postQs_dom (C, b, postQ C s) \\<and>\n  P l (postQs C b (postQ C s)) \\<and> \\<not> bval b (postQs C b (postQ C s))\n\ngoal (1 subgoal):\n 1. postQs_dom (C, b, postQ C s) &&&\n    P l (postQs C b (postQ C s)) &&& \\<not> bval b (postQs C b (postQ C s))", "by auto"], ["proof (state)\nthis:\n  postQs_dom (C, b, postQ C s)\n  P l (postQs C b (postQ C s))\n  \\<not> bval b (postQs C b (postQ C s))\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "have d': \"postQs_dom (C, b, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s)", "by (simp add: d postQs.domintros)"], ["proof (state)\nthis:\n  postQs_dom (C, b, s)\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "have p': \" P l (postQs C b s) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l (postQs C b s)", "using True d p postQs.domintros postQs.psimps"], ["proof (prove)\nusing this:\n  bval b s\n  postQs_dom (C, b, postQ C s)\n  P l (postQs C b (postQ C s))\n  (bval ?b ?s \\<Longrightarrow>\n   postQs_dom (?C, ?b, postQ ?C ?s)) \\<Longrightarrow>\n  postQs_dom (?C, ?b, ?s)\n  postQs_dom (?C, ?b, ?s) \\<Longrightarrow>\n  postQs ?C ?b ?s = (if bval ?b ?s then postQs ?C ?b (postQ ?C ?s) else ?s)\n\ngoal (1 subgoal):\n 1. P l (postQs C b s)", "by fastforce"], ["proof (state)\nthis:\n  P l (postQs C b s)\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "have b': \"\\<not> bval b (postQs C b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bval b (postQs C b s)", "by (metis b d postQs.domintros postQs.pelims)"], ["proof (state)\nthis:\n  \\<not> bval b (postQs C b s)\n\ngoal (2 subgoals):\n 1. bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n 2. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from d' p' b'"], ["proof (chain)\npicking this:\n  postQs_dom (C, b, s)\n  P l (postQs C b s)\n  \\<not> bval b (postQs C b s)", "show ?thesis"], ["proof (prove)\nusing this:\n  postQs_dom (C, b, s)\n  P l (postQs C b s)\n  \\<not> bval b (postQs C b s)\n\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "by auto"], ["proof (state)\nthis:\n  postQs_dom (C, b, s) \\<and>\n  P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "case False"], ["proof (state)\nthis:\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "then"], ["proof (chain)\npicking this:\n  \\<not> bval b s", "have 1: \"postQs_dom (C, b, s)\""], ["proof (prove)\nusing this:\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s)", "using postQs.domintros"], ["proof (prove)\nusing this:\n  \\<not> bval b s\n  (bval ?b ?s \\<Longrightarrow>\n   postQs_dom (?C, ?b, postQ ?C ?s)) \\<Longrightarrow>\n  postQs_dom (?C, ?b, ?s)\n\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s)", "by blast"], ["proof (state)\nthis:\n  postQs_dom (C, b, s)\n\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "then"], ["proof (chain)\npicking this:\n  postQs_dom (C, b, s)", "have 2: \"?S s = s\""], ["proof (prove)\nusing this:\n  postQs_dom (C, b, s)\n\ngoal (1 subgoal):\n 1. postQs C b s = s", "using postQs.psimps False"], ["proof (prove)\nusing this:\n  postQs_dom (C, b, s)\n  postQs_dom (?C, ?b, ?s) \\<Longrightarrow>\n  postQs ?C ?b ?s = (if bval ?b ?s then postQs ?C ?b (postQ ?C ?s) else ?s)\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. postQs C b s = s", "by force"], ["proof (state)\nthis:\n  postQs C b s = s\n\ngoal (1 subgoal):\n 1. \\<not> bval b s \\<Longrightarrow>\n    postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "from 1 2 less(3) False"], ["proof (chain)\npicking this:\n  postQs_dom (C, b, s)\n  postQs C b s = s\n  P l s\n  \\<not> bval b s", "show ?thesis"], ["proof (prove)\nusing this:\n  postQs_dom (C, b, s)\n  postQs C b s = s\n  P l s\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. postQs_dom (C, b, s) \\<and>\n    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "by simp"], ["proof (state)\nthis:\n  postQs_dom (C, b, s) \\<and>\n  P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  postQs_dom (C, b, s) \\<and>\n  P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>e s = n; P l s\\<rbrakk>\n  \\<Longrightarrow> postQs_dom (C, b, s) \\<and>\n                    P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>e ?s2 = ?n2; P ?l2 ?s2\\<rbrakk>\n  \\<Longrightarrow> postQs_dom (C, b, ?s2) \\<and>\n                    P ?l2 (postQs C b ?s2) \\<and>\n                    \\<not> bval b (postQs C b ?s2)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>e ?s2 = ?n2; P ?l2 ?s2\\<rbrakk>\n  \\<Longrightarrow> postQs_dom (C, b, ?s2) \\<and>\n                    P ?l2 (postQs C b ?s2) \\<and>\n                    \\<not> bval b (postQs C b ?s2)", "have Pdom: \"\\<And>l s. P l s \\<Longrightarrow> postQs_dom (C, b, s) \\<and> P l (?S s) \\<and> ~ bval b (?S s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>e ?s2 = ?n2; P ?l2 ?s2\\<rbrakk>\n  \\<Longrightarrow> postQs_dom (C, b, ?s2) \\<and>\n                    P ?l2 (postQs C b ?s2) \\<and>\n                    \\<not> bval b (postQs C b ?s2)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       postQs_dom (C, b, s) \\<and>\n       P l (postQs C b s) \\<and> \\<not> bval b (postQs C b s)", "by simp"], ["proof (state)\nthis:\n  P ?l ?s \\<Longrightarrow>\n  postQs_dom (C, b, ?s) \\<and>\n  P ?l (postQs C b ?s) \\<and> \\<not> bval b (postQs C b ?s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have S1: \"\\<And>l s. P l s \\<Longrightarrow> P l (?S s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s. P l s \\<Longrightarrow> P l (postQs C b s)", "using Pdom"], ["proof (prove)\nusing this:\n  P ?l ?s \\<Longrightarrow>\n  postQs_dom (C, b, ?s) \\<and>\n  P ?l (postQs C b ?s) \\<and> \\<not> bval b (postQs C b ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s. P l s \\<Longrightarrow> P l (postQs C b s)", "by simp"], ["proof (state)\nthis:\n  P ?l ?s \\<Longrightarrow> P ?l (postQs C b ?s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have S2: \"\\<And>l s. P l s \\<Longrightarrow> ~ bval b (?S s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s. P l s \\<Longrightarrow> \\<not> bval b (postQs C b s)", "using Pdom"], ["proof (prove)\nusing this:\n  P ?l ?s \\<Longrightarrow>\n  postQs_dom (C, b, ?s) \\<and>\n  P ?l (postQs C b ?s) \\<and> \\<not> bval b (postQs C b ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s. P l s \\<Longrightarrow> \\<not> bval b (postQs C b s)", "by simp"], ["proof (state)\nthis:\n  P ?l ?s \\<Longrightarrow> \\<not> bval b (postQs C b ?s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have S3: \"\\<And>l s. P l s \\<Longrightarrow> bval b s \\<Longrightarrow> ?S s = ?S (postQ C s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)", "using postQs.psimps Pdom"], ["proof (prove)\nusing this:\n  postQs_dom (?C, ?b, ?s) \\<Longrightarrow>\n  postQs ?C ?b ?s = (if bval ?b ?s then postQs ?C ?b (postQ ?C ?s) else ?s)\n  P ?l ?s \\<Longrightarrow>\n  postQs_dom (C, b, ?s) \\<and>\n  P ?l (postQs C b ?s) \\<and> \\<not> bval b (postQs C b ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>P ?l ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> postQs C b ?s = postQs C b (postQ C ?s)\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "have S4: \"\\<And>l s. P l s \\<Longrightarrow> \\<not> bval b s \\<Longrightarrow> ?S s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s", "using postQs.psimps Pdom"], ["proof (prove)\nusing this:\n  postQs_dom (?C, ?b, ?s) \\<Longrightarrow>\n  postQs ?C ?b ?s = (if bval ?b ?s then postQs ?C ?b (postQ ?C ?s) else ?s)\n  P ?l ?s \\<Longrightarrow>\n  postQs_dom (C, b, ?s) \\<and>\n  P ?l (postQs C b ?s) \\<and> \\<not> bval b (postQs C b ?s)\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>P ?l ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> postQs C b ?s = ?s\n\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "let ?w = \"{(P,?S,(%s. max k 1 * e s))} WHILE b DO (Aconseq (\\<lambda>l s. P l s \\<and> bval b s) (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) (time C) C)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P b e' y c e'' e.\n       \\<lbrakk>\\<turnstile>\\<^sub>1 {\\<lambda>l s.\n   P l s \\<and> bval b s \\<and> e' s = l y}\n                                     c { e'' \\<Down> \\<lambda>l s.\n                  P l s \\<and> e s \\<le> l y};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n           (\\<forall>l s.\n               P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n               pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n               P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n                  time C s \\<le> k * e'' s);\n        \\<forall>l s.\n           bval b s \\<and> P l s \\<longrightarrow>\n           1 + e' s + e'' s \\<le> e s;\n        \\<forall>l s.\n           \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s;\n        y \\<notin> support P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = WHILE b DO c \\<and>\n                            vc C\n                             (\\<lambda>a c.\n                                 P a c \\<and> \\<not> bval b c) \\<and>\n                            (\\<forall>l s.\n                                P l s \\<longrightarrow>\n                                pre C\n                                 (\\<lambda>a c.\n                                     P a c \\<and> \\<not> bval b c)\n                                 l s \\<and>\n                                P l (postQ C s) \\<and>\n                                \\<not> bval b (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P l s \\<longrightarrow>\n                                   time C s \\<le> k * e s)\n 2. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case (is \"\\<exists>C. ?C C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = WHILE b DO c \\<and>\n       vc C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) \\<and>\n       (\\<forall>l s.\n           P l s \\<longrightarrow>\n           pre C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s \\<and>\n           P l (postQ C s) \\<and> \\<not> bval b (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. strip ?C = WHILE b DO c \\<and>\n    vc ?C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        pre ?C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s \\<and>\n        P l (postQ ?C s) \\<and> \\<not> bval b (postQ ?C s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s. P l s \\<longrightarrow> time ?C s \\<le> k * e s)", "show \"?C ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip\n     ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C) =\n    WHILE b DO c \\<and>\n    vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c) \\<and>\n    (\\<forall>l s.\n        P l s \\<longrightarrow>\n        pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n             DO {\\<lambda>l s.\n                    P l s \\<and>\n                    bval b\n                     s/\\<lambda>la sa.\n                          P la sa \\<and> e sa \\<le> la y/time C}\n                CONSEQ C)\n         (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s \\<and>\n        P l (postQ\n              ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n               DO {\\<lambda>l s.\n                      P l s \\<and>\n                      bval b\n                       s/\\<lambda>la sa.\n                            P la sa \\<and> e sa \\<le> la y/time C}\n                  CONSEQ C)\n              s) \\<and>\n        \\<not> bval b\n                (postQ\n                  ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n                   DO {\\<lambda>l s.\n                          P l s \\<and>\n                          bval b\n                           s/\\<lambda>la sa.\n                                P la sa \\<and> e sa \\<le> la y/time C}\n                      CONSEQ C)\n                  s)) \\<and>\n    (\\<exists>ka.\n        \\<forall>l s.\n           P l s \\<longrightarrow>\n           time\n            ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n             DO {\\<lambda>l s.\n                    P l s \\<and>\n                    bval b\n                     s/\\<lambda>la sa.\n                          P la sa \\<and> e sa \\<le> la y/time C}\n                CONSEQ C)\n            s\n           \\<le> ka * e s)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. strip\n     ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C) =\n    WHILE b DO c\n 2. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n 3. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 4. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 5. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. strip\n     ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C) =\n    WHILE b DO c\n 2. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n 3. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 4. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 5. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip\n     ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C) =\n    WHILE b DO c", "using ih"], ["proof (prove)\nusing this:\n  strip C = c \\<and>\n  vc C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) \\<and>\n  (\\<forall>l s.\n      P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n      pre C (\\<lambda>a b. P a b \\<and> e b \\<le> a y) l s \\<and>\n      P l (postQ C s) \\<and> e (postQ C s) \\<le> l y) \\<and>\n  (\\<exists>k.\n      \\<forall>l s.\n         P l s \\<and> bval b s \\<and> e' s = l y \\<longrightarrow>\n         time C s \\<le> k * e'' s)\n\ngoal (1 subgoal):\n 1. strip\n     ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C) =\n    WHILE b DO c", "by(simp)"], ["proof (state)\nthis:\n  strip\n   ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n    DO {\\<lambda>l s.\n           P l s \\<and>\n           bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n       CONSEQ C) =\n  WHILE b DO c\n\ngoal (5 subgoals):\n 1. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 4. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 4. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 3. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 4. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n        DO {\\<lambda>l s.\n               P l s \\<and>\n               bval b\n                s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n           CONSEQ C)\n     (\\<lambda>a c. P a c \\<and> \\<not> bval b c)", "proof(simp, safe, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "case (1 l s)"], ["proof (state)\nthis:\n  P l s\n  bval b s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "from 2"], ["proof (chain)\npicking this:", "have z: \"P (l(y := e' s)) s \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "using 1 assn2_lupd[OF While(4)]"], ["proof (prove)\nusing this:\n  P l s\n  bval b s\n  P (?l(y := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "by metis"], ["proof (state)\nthis:\n  P (l(y := e' s)) s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "from ih2(3)[where l=\"l(y := e' s)\" and s=s]"], ["proof (chain)\npicking this:\n  \\<lbrakk>P (l(y := e' s)) s; bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> time C s \\<le> k * e'' s", "have A: \" time C s \\<le> k * e'' s \""], ["proof (prove)\nusing this:\n  \\<lbrakk>P (l(y := e' s)) s; bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> time C s \\<le> k * e'' s\n\ngoal (1 subgoal):\n 1. time C s \\<le> k * e'' s", "using 1 z"], ["proof (prove)\nusing this:\n  \\<lbrakk>P (l(y := e' s)) s; bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> time C s \\<le> k * e'' s\n  P l s\n  bval b s\n  P (l(y := e' s)) s\n\ngoal (1 subgoal):\n 1. time C s \\<le> k * e'' s", "by(simp)"], ["proof (state)\nthis:\n  time C s \\<le> k * e'' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "from ih2(4)[where l=\"l(y := e' s)\" and s=s]"], ["proof (chain)\npicking this:\n  \\<lbrakk>P (l(y := e' s)) s; bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                    e (postQ C s) \\<le> (l(y := e' s)) y", "have \"e (postQ C s) \\<le> (l(y := e' s)) y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P (l(y := e' s)) s; bval b s; e' s = (l(y := e' s)) y\\<rbrakk>\n  \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                    e (postQ C s) \\<le> (l(y := e' s)) y\n\ngoal (1 subgoal):\n 1. e (postQ C s) \\<le> (l(y := e' s)) y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P (l(y := e' s)) s; bval b s\\<rbrakk>\n     \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                       e (postQ C s) \\<le> e' s) \\<Longrightarrow>\n    e (postQ C s) \\<le> e' s", "using 1 z"], ["proof (prove)\nusing this:\n  P l s\n  bval b s\n  P (l(y := e' s)) s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P (l(y := e' s)) s; bval b s\\<rbrakk>\n     \\<Longrightarrow> P (l(y := e' s)) (postQ C s) \\<and>\n                       e (postQ C s) \\<le> e' s) \\<Longrightarrow>\n    e (postQ C s) \\<le> e' s", "by(simp)"], ["proof (state)\nthis:\n  e (postQ C s) \\<le> (l(y := e' s)) y\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "then"], ["proof (chain)\npicking this:\n  e (postQ C s) \\<le> (l(y := e' s)) y", "have \"e (postQ C s) \\<le> e' s\""], ["proof (prove)\nusing this:\n  e (postQ C s) \\<le> (l(y := e' s)) y\n\ngoal (1 subgoal):\n 1. e (postQ C s) \\<le> e' s", "by simp"], ["proof (state)\nthis:\n  e (postQ C s) \\<le> e' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "with TQ"], ["proof (chain)\npicking this:\n  preT ?C ?e ?s = ?e (postQ ?C ?s)\n  e (postQ C s) \\<le> e' s", "have B: \"preT C e s \\<le> e' s\""], ["proof (prove)\nusing this:\n  preT ?C ?e ?s = ?e (postQ ?C ?s)\n  e (postQ C s) \\<le> e' s\n\ngoal (1 subgoal):\n 1. preT C e s \\<le> e' s", "by simp"], ["proof (state)\nthis:\n  preT C e s \\<le> e' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "let ?eskal = \"(\\<lambda>s. max k (Suc 0) * e s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "have \"preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s", "using preT_linear"], ["proof (prove)\nusing this:\n  preT ?C (\\<lambda>s. ?k * ?e s) = (\\<lambda>s. ?k * preT ?C ?e s)\n\ngoal (1 subgoal):\n 1. preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s", "by simp"], ["proof (state)\nthis:\n  preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "with B"], ["proof (chain)\npicking this:\n  preT C e s \\<le> e' s\n  preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s", "have  B: \"preT C ?eskal s \\<le> max k (Suc 0) * e' s\""], ["proof (prove)\nusing this:\n  preT C e s \\<le> e' s\n  preT C (\\<lambda>s. max k (Suc 0) * e s) s = max k (Suc 0) * preT C e s\n\ngoal (1 subgoal):\n 1. preT C (\\<lambda>s. max k (Suc 0) * e s) s \\<le> max k (Suc 0) * e' s", "by auto"], ["proof (state)\nthis:\n  preT C (\\<lambda>s. max k (Suc 0) * e s) s \\<le> max k (Suc 0) * e' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "from  While.hyps(2) 1"], ["proof (chain)\npicking this:\n  \\<forall>l s.\n     bval b s \\<and> P l s \\<longrightarrow> 1 + e' s + e'' s \\<le> e s\n  P l s\n  bval b s", "have C: \"1 + e' s + e'' s \\<le> e s\""], ["proof (prove)\nusing this:\n  \\<forall>l s.\n     bval b s \\<and> P l s \\<longrightarrow> 1 + e' s + e'' s \\<le> e s\n  P l s\n  bval b s\n\ngoal (1 subgoal):\n 1. 1 + e' s + e'' s \\<le> e s", "by auto"], ["proof (state)\nthis:\n  1 + e' s + e'' s \\<le> e s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "have \"Suc (preT C ?eskal s + time C s) \\<le> 1 + (max k 1) * e' s + k * e'' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n    \\<le> 1 + max k 1 * e' s + k * e'' s", "using A B"], ["proof (prove)\nusing this:\n  time C s \\<le> k * e'' s\n  preT C (\\<lambda>s. max k (Suc 0) * e s) s \\<le> max k (Suc 0) * e' s\n\ngoal (1 subgoal):\n 1. Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n    \\<le> 1 + max k 1 * e' s + k * e'' s", "by linarith"], ["proof (state)\nthis:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> 1 + max k 1 * e' s + k * e'' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "also"], ["proof (state)\nthis:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> 1 + max k 1 * e' s + k * e'' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "have \"\\<dots> \\<le> (max k 1) + (max k 1) * e' s + (max k 1) * e'' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + max k 1 * e' s + k * e'' s\n    \\<le> max k 1 + max k 1 * e' s + max k 1 * e'' s", "using nat_mult_max_left"], ["proof (prove)\nusing this:\n  max ?m ?n * ?q = max (?m * ?q) (?n * ?q)\n\ngoal (1 subgoal):\n 1. 1 + max k 1 * e' s + k * e'' s\n    \\<le> max k 1 + max k 1 * e' s + max k 1 * e'' s", "by auto"], ["proof (state)\nthis:\n  1 + max k 1 * e' s + k * e'' s\n  \\<le> max k 1 + max k 1 * e' s + max k 1 * e'' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "also"], ["proof (state)\nthis:\n  1 + max k 1 * e' s + k * e'' s\n  \\<le> max k 1 + max k 1 * e' s + max k 1 * e'' s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "have \"\\<dots> = (max k 1) * (1 + e' s + e'' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max k 1 + max k 1 * e' s + max k 1 * e'' s =\n    max k 1 * (1 + e' s + e'' s)", "by algebra"], ["proof (state)\nthis:\n  max k 1 + max k 1 * e' s + max k 1 * e'' s = max k 1 * (1 + e' s + e'' s)\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "also"], ["proof (state)\nthis:\n  max k 1 + max k 1 * e' s + max k 1 * e'' s = max k 1 * (1 + e' s + e'' s)\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "have \"\\<dots> \\<le> (max k 1) * e s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max k 1 * (1 + e' s + e'' s) \\<le> max k 1 * e s", "using C"], ["proof (prove)\nusing this:\n  1 + e' s + e'' s \\<le> e s\n\ngoal (1 subgoal):\n 1. max k 1 * (1 + e' s + e'' s) \\<le> max k 1 * e s", "by (metis mult.assoc mult_le_mono2)"], ["proof (state)\nthis:\n  max k 1 * (1 + e' s + e'' s) \\<le> max k 1 * e s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "finally"], ["proof (chain)\npicking this:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> max k 1 * e s", "have \"Suc (preT C ?eskal s + time C s) \\<le> ((max k 1) ) * e s\""], ["proof (prove)\nusing this:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> max k 1 * e s\n\ngoal (1 subgoal):\n 1. Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n    \\<le> max k 1 * e s", "."], ["proof (state)\nthis:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> max k 1 * e s\n\ngoal (6 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s +\n                              time C s)\n                         \\<le> max k (Suc 0) * e s\n 2. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 4. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 5. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 6. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "thus ?case"], ["proof (prove)\nusing this:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> max k 1 * e s\n\ngoal (1 subgoal):\n 1. Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n    \\<le> max k (Suc 0) * e s", "by auto"], ["proof (state)\nthis:\n  Suc (preT C (\\<lambda>s. max k (Suc 0) * e s) s + time C s)\n  \\<le> max k (Suc 0) * e s\n\ngoal (5 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 4. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 5. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 4. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 5. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "case (3 l s)"], ["proof (state)\nthis:\n  P l s\n  \\<not> bval b s\n\ngoal (5 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> e s\n 3. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 4. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 5. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "with While.hyps(3)"], ["proof (chain)\npicking this:\n  \\<forall>l s. \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s\n  P l s\n  \\<not> bval b s", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>l s. \\<not> bval b s \\<and> P l s \\<longrightarrow> 1 \\<le> e s\n  P l s\n  \\<not> bval b s\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> e s", "by auto"], ["proof (state)\nthis:\n  Suc 0 \\<le> e s\n\ngoal (4 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 4. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 4. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n 4. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)", "apply(rule vc_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>l s. ?P l s \\<longrightarrow> P l s \\<and> e s \\<le> l y\n 2. vc C ?P", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. vc C ?P\n 2. \\<forall>l s. ?P l s \\<longrightarrow> P l s \\<and> e s \\<le> l y", "apply(fact ih2(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       P l s \\<and> e s \\<le> l y \\<longrightarrow>\n       P l s \\<and> e s \\<le> l y", "by auto"], ["proof (state)\nthis:\n  vc C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n\ngoal (3 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s\n 3. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P l s \\<and> bval b s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                  s \\<and>\n                 (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))", "apply(rule exI[where x=\"1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>l s.\n        P l s \\<and> bval b s \\<longrightarrow>\n        (0 < time C s \\<longrightarrow> Suc 0 \\<le> 1) \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                s \\<and>\n               (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t)))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s; 0 < time C s\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> 1\n 2. \\<And>l s t.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            pre C\n                             (\\<lambda>la sa.\n                                 P la sa \\<and> e sa \\<le> la y)\n                             l' s \\<and>\n                            (P l' t \\<and> e t \\<le> l' y \\<longrightarrow>\n                             P l t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l_ s_; bval b s_; 0 < time C s_\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> 1", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s t.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            pre C\n                             (\\<lambda>la sa.\n                                 P la sa \\<and> e sa \\<le> la y)\n                             l' s \\<and>\n                            (P l' t \\<and> e t \\<le> l' y \\<longrightarrow>\n                             P l t)", "subgoal for l s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'.\n                         pre C\n                          (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                          l' s \\<and>\n                         (P l' t \\<and> e t \\<le> l' y \\<longrightarrow>\n                          P l t)", "apply(rule exI[where x=\"l(y:=e' s)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                       (l(y := e' s)) s \\<and>\n                      (P (l(y := e' s)) t \\<and>\n                       e t \\<le> (l(y := e' s)) y \\<longrightarrow>\n                       P l t)", "proof (safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                       (l(y := e' s)) s\n 2. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t;\n     e t \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t", "assume 8: \"P l s\" and b: \" bval b s\""], ["proof (state)\nthis:\n  P l s\n  bval b s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                       (l(y := e' s)) s\n 2. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t;\n     e t \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t", "then"], ["proof (chain)\npicking this:\n  P l s\n  bval b s", "have \"P (l(y := e' s)) s\""], ["proof (prove)\nusing this:\n  P l s\n  bval b s\n\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "using assn2_lupd[OF While(4)]"], ["proof (prove)\nusing this:\n  P l s\n  bval b s\n  P (?l(y := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P (l(y := e' s)) s", "by metis"], ["proof (state)\nthis:\n  P (l(y := e' s)) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P l s; bval b s\\<rbrakk>\n    \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                       (l(y := e' s)) s\n 2. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t;\n     e t \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t", "with b ih2(2)"], ["proof (chain)\npicking this:\n  bval b s\n  \\<lbrakk>P ?l ?s; bval b ?s; e' ?s = ?l y\\<rbrakk>\n  \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                     ?l ?s\n  P (l(y := e' s)) s", "show \"pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) (l(y := e' s)) s\""], ["proof (prove)\nusing this:\n  bval b s\n  \\<lbrakk>P ?l ?s; bval b ?s; e' ?s = ?l y\\<rbrakk>\n  \\<Longrightarrow> pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y)\n                     ?l ?s\n  P (l(y := e' s)) s\n\ngoal (1 subgoal):\n 1. pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) (l(y := e' s)) s", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) (l(y := e' s)) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t;\n     e t \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t__;\n     e t__ \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t__", "assume \"P (l(y := e' s)) t\""], ["proof (state)\nthis:\n  P (l(y := e' s)) t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P l s; bval b s; P (l(y := e' s)) t__;\n     e t__ \\<le> (l(y := e' s)) y\\<rbrakk>\n    \\<Longrightarrow> P l t__", "thus \"P l t\""], ["proof (prove)\nusing this:\n  P (l(y := e' s)) t\n\ngoal (1 subgoal):\n 1. P l t", "using assn2_lupd[OF While(4)]"], ["proof (prove)\nusing this:\n  P (l(y := e' s)) t\n  P (?l(y := ?n)) = P ?l\n\ngoal (1 subgoal):\n 1. P l t", "by simp"], ["proof (state)\nthis:\n  P l t\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P l s \\<and> bval b s \\<longrightarrow>\n        (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C (\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y) l'\n                s \\<and>\n               (P l' t \\<and> e t \\<le> l' y \\<longrightarrow> P l t))\n\ngoal (2 subgoals):\n 1. \\<And>l s.\n       \\<lbrakk>P l s; bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = postQs C b (postQ C s)\n 2. \\<And>l s.\n       \\<lbrakk>P l s; \\<not> bval b s\\<rbrakk>\n       \\<Longrightarrow> postQs C b s = s", "qed (simp_all add: S4 S3)"], ["proof (state)\nthis:\n  vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C)\n   (\\<lambda>a c. P a c \\<and> \\<not> bval b c)\n\ngoal (4 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ka.\n       \\<forall>l s.\n          P l s \\<longrightarrow>\n          time\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s\n          \\<le> ka * e s", "apply(rule exI[where x=\"k+1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       P l s \\<longrightarrow>\n       time\n        ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n         DO {\\<lambda>l s.\n                P l s \\<and>\n                bval b\n                 s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n            CONSEQ C)\n        s\n       \\<le> (k + 1) * e s", "by auto"], ["proof (state)\nthis:\n  \\<exists>ka.\n     \\<forall>l s.\n        P l s \\<longrightarrow>\n        time\n         ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n          DO {\\<lambda>l s.\n                 P l s \\<and>\n                 bval b\n                  s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n             CONSEQ C)\n         s\n        \\<le> ka * e s\n\ngoal (3 subgoals):\n 1. \\<And>l s.\n       P l s \\<Longrightarrow>\n       pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n        (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s\n 2. \\<And>l s.\n       P l s \\<Longrightarrow>\n       P l (postQ\n             ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n              DO {\\<lambda>l s.\n                     P l s \\<and>\n                     bval b\n                      s/\\<lambda>la sa.\n                           P la sa \\<and> e sa \\<le> la y/time C}\n                 CONSEQ C)\n             s)\n 3. \\<And>l s.\n       \\<lbrakk>P l s;\n        bval b\n         (postQ\n           ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n            DO {\\<lambda>l s.\n                   P l s \\<and>\n                   bval b\n                    s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n               CONSEQ C)\n           s)\\<rbrakk>\n       \\<Longrightarrow> False", "qed (simp_all add: S1 S2)"], ["proof (state)\nthis:\n  strip\n   ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n    DO {\\<lambda>l s.\n           P l s \\<and>\n           bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n       CONSEQ C) =\n  WHILE b DO c \\<and>\n  vc ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n      DO {\\<lambda>l s.\n             P l s \\<and>\n             bval b s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n         CONSEQ C)\n   (\\<lambda>a c. P a c \\<and> \\<not> bval b c) \\<and>\n  (\\<forall>l s.\n      P l s \\<longrightarrow>\n      pre ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n           DO {\\<lambda>l s.\n                  P l s \\<and>\n                  bval b\n                   s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n              CONSEQ C)\n       (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s \\<and>\n      P l (postQ\n            ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n             DO {\\<lambda>l s.\n                    P l s \\<and>\n                    bval b\n                     s/\\<lambda>la sa.\n                          P la sa \\<and> e sa \\<le> la y/time C}\n                CONSEQ C)\n            s) \\<and>\n      \\<not> bval b\n              (postQ\n                ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n                 DO {\\<lambda>l s.\n                        P l s \\<and>\n                        bval b\n                         s/\\<lambda>la sa.\n                              P la sa \\<and> e sa \\<le> la y/time C}\n                    CONSEQ C)\n                s)) \\<and>\n  (\\<exists>ka.\n      \\<forall>l s.\n         P l s \\<longrightarrow>\n         time\n          ({(P, postQs C b, \\<lambda>s. max k 1 * e s)} WHILE b\n           DO {\\<lambda>l s.\n                  P l s \\<and>\n                  bval b\n                   s/\\<lambda>la sa. P la sa \\<and> e sa \\<le> la y/time C}\n              CONSEQ C)\n          s\n         \\<le> ka * e s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = WHILE b DO c \\<and>\n     vc C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow>\n         pre C (\\<lambda>a c. P a c \\<and> \\<not> bval b c) l s \\<and>\n         P l (postQ C s) \\<and> \\<not> bval b (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)\n\ngoal (1 subgoal):\n 1. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "case (conseq P' e e' P Q Q' c)"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n  \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q}\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)\n\ngoal (1 subgoal):\n 1. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n  \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q}\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)", "obtain C k where C: \"strip C = c\"\n    \"vc C Q\"\n    \"(\\<forall>l s  . P l s \\<longrightarrow> pre C Q  l s )\"\n    \"(\\<forall>l s . P l s \\<longrightarrow> Q l (postQ C s))\"\n    \"(\\<forall>l s. P l s \\<longrightarrow>  time C s \\<le> k * e s)\""], ["proof (prove)\nusing this:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n  \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q}\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)\n\ngoal (1 subgoal):\n 1. (\\<And>C k.\n        \\<lbrakk>strip C = c; vc C Q;\n         \\<forall>l s. P l s \\<longrightarrow> pre C Q l s;\n         \\<forall>l s. P l s \\<longrightarrow> Q l (postQ C s);\n         \\<forall>l s.\n            P l s \\<longrightarrow> time C s \\<le> k * e s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  strip C = c\n  vc C Q\n  \\<forall>l s. P l s \\<longrightarrow> pre C Q l s\n  \\<forall>l s. P l s \\<longrightarrow> Q l (postQ C s)\n  \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s\n\ngoal (1 subgoal):\n 1. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "from conseq(1)"], ["proof (chain)\npicking this:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))", "obtain k2 where cons: \" \\<forall>l s. P' l s \\<longrightarrow> e s \\<le> k2 * e' s \\<and> (\\<forall>t. \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\""], ["proof (prove)\nusing this:\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        \\<forall>l s.\n           P' l s \\<longrightarrow>\n           e s \\<le> k2 * e' s \\<and>\n           (\\<forall>t.\n               \\<exists>l'.\n                  P l' s \\<and>\n                  (Q l' t \\<longrightarrow> Q' l t)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. \\<And>P' e e' P Q Q' c.\n       \\<lbrakk>\\<exists>k>0.\n                   \\<forall>l s.\n                      P' l s \\<longrightarrow>\n                      e s \\<le> k * e' s \\<and>\n                      (\\<forall>t.\n                          \\<exists>l'.\n                             P l' s \\<and>\n                             (Q l' t \\<longrightarrow> Q' l t));\n        \\<turnstile>\\<^sub>1 {P} c { e \\<Down> Q};\n        \\<exists>C.\n           strip C = c \\<and>\n           vc C Q \\<and>\n           (\\<forall>l s.\n               P l s \\<longrightarrow>\n               pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n           (\\<exists>k.\n               \\<forall>l s.\n                  P l s \\<longrightarrow> time C s \\<le> k * e s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            strip C = c \\<and>\n                            vc C Q' \\<and>\n                            (\\<forall>l s.\n                                P' l s \\<longrightarrow>\n                                pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n                            (\\<exists>k.\n                                \\<forall>l s.\n                                   P' l s \\<longrightarrow>\n                                   time C s \\<le> k * e' s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       strip C = c \\<and>\n       vc C Q' \\<and>\n       (\\<forall>l s.\n           P' l s \\<longrightarrow>\n           pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n       (\\<exists>k.\n           \\<forall>l s. P' l s \\<longrightarrow> time C s \\<le> k * e' s)", "apply(rule exI[where x=\"Aconseq P' Q (time C) C\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ({P'/Q/time C} CONSEQ C) = c \\<and>\n    vc ({P'/Q/time C} CONSEQ C) Q' \\<and>\n    (\\<forall>l s.\n        P' l s \\<longrightarrow>\n        pre ({P'/Q/time C} CONSEQ C) Q' l s \\<and>\n        Q' l (postQ ({P'/Q/time C} CONSEQ C) s)) \\<and>\n    (\\<exists>k.\n        \\<forall>l s.\n           P' l s \\<longrightarrow>\n           time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s)", "apply(safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. strip ({P'/Q/time C} CONSEQ C) = c\n 2. vc ({P'/Q/time C} CONSEQ C) Q'\n 3. \\<And>l s. P' l s \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) Q' l s\n 4. \\<And>l s.\n       P' l s \\<Longrightarrow> Q' l (postQ ({P'/Q/time C} CONSEQ C) s)\n 5. \\<exists>k.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ({P'/Q/time C} CONSEQ C) = c", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip C = c", "by(fact)"], ["proof (prove)\ngoal (4 subgoals):\n 1. vc ({P'/Q/time C} CONSEQ C) Q'\n 2. \\<And>l s. P' l s \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) Q' l s\n 3. \\<And>l s.\n       P' l s \\<Longrightarrow> Q' l (postQ ({P'/Q/time C} CONSEQ C) s)\n 4. \\<exists>k.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc ({P'/Q/time C} CONSEQ C) Q'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C Q \\<and>\n    (\\<exists>k>0.\n        \\<forall>l s.\n           P' l s \\<longrightarrow>\n           (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n           (\\<forall>t.\n               \\<exists>l'.\n                  pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t)))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vc C Q\n 2. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vc C Q", "using C(2)"], ["proof (prove)\nusing this:\n  vc C Q\n\ngoal (1 subgoal):\n 1. vc C Q", "apply(fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          (0 < time C s \\<longrightarrow> Suc 0 \\<le> k) \\<and>\n          (\\<forall>t.\n              \\<exists>l'.\n                 pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))", "apply(rule exI[where x=\"k+1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k + 1 \\<and>\n    (\\<forall>l s.\n        P' l s \\<longrightarrow>\n        (0 < time C s \\<longrightarrow> Suc 0 \\<le> k + 1) \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s t.\n       P' l s \\<Longrightarrow>\n       \\<exists>l'. pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t)", "using C(2) cons C(3)"], ["proof (prove)\nusing this:\n  vc C Q\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n  \\<forall>l s. P l s \\<longrightarrow> pre C Q l s\n\ngoal (1 subgoal):\n 1. \\<And>l s t.\n       P' l s \\<Longrightarrow>\n       \\<exists>l'. pre C Q l' s \\<and> (Q l' t \\<longrightarrow> Q' l t)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s. P' l s \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) Q' l s\n 2. \\<And>l s.\n       P' l s \\<Longrightarrow> Q' l (postQ ({P'/Q/time C} CONSEQ C) s)\n 3. \\<exists>k.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) Q' l_ s_", "apply(rule pre_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P' l_ s_ \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q' l s\n 2. P' l_ s_ \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) ?P l_ s_", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. P' l_ s_ \\<Longrightarrow> pre ({P'/Q/time C} CONSEQ C) ?P l_ s_\n 2. P' l_ s_ \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q' l s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q' l s", "using C(3) conseq(1)"], ["proof (prove)\nusing this:\n  \\<forall>l s. P l s \\<longrightarrow> pre C Q l s\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> \\<forall>l s. ?P l s \\<longrightarrow> Q' l s", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s.\n       P' l s \\<Longrightarrow> Q' l (postQ ({P'/Q/time C} CONSEQ C) s)\n 2. \\<exists>k.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> Q' l_ (postQ ({P'/Q/time C} CONSEQ C) s_)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> Q' l_ (postQ C s_)", "using C(4) conseq(1,3)"], ["proof (prove)\nusing this:\n  \\<forall>l s. P l s \\<longrightarrow> Q l (postQ C s)\n  \\<exists>k>0.\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C Q \\<and>\n     (\\<forall>l s.\n         P l s \\<longrightarrow> pre C Q l s \\<and> Q l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s)\n\ngoal (1 subgoal):\n 1. P' l_ s_ \\<Longrightarrow> Q' l_ (postQ C s_)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       \\<forall>l s.\n          P' l s \\<longrightarrow>\n          time ({P'/Q/time C} CONSEQ C) s \\<le> k * e' s", "apply(rule exI[where x=\"k*k2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l s.\n       P' l s \\<longrightarrow>\n       time ({P'/Q/time C} CONSEQ C) s \\<le> k * k2 * e' s", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s.\n       P' l s \\<Longrightarrow>\n       time ({P'/Q/time C} CONSEQ C) s \\<le> k * k2 * e' s", "subgoal for l s"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' l s \\<Longrightarrow>\n    time ({P'/Q/time C} CONSEQ C) s \\<le> k * k2 * e' s", "using C(5) cons"], ["proof (prove)\nusing this:\n  \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. P' l s \\<Longrightarrow>\n    time ({P'/Q/time C} CONSEQ C) s \\<le> k * k2 * e' s", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P' l s;\n     \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s;\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k2 * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\\<rbrakk>\n    \\<Longrightarrow> time C s \\<le> k * k2 * e' s", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P' l s;\n     \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s;\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k2 * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\\<rbrakk>\n    \\<Longrightarrow> time C s \\<le> k * k2 * e' s", "case 1"], ["proof (state)\nthis:\n  P' l s\n  \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P' l s;\n     \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s;\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k2 * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\\<rbrakk>\n    \\<Longrightarrow> time C s \\<le> k * k2 * e' s", "then"], ["proof (chain)\npicking this:\n  P' l s\n  \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))", "have absch: \"e s \\<le> k2 * e' s\" \"time C s \\<le> k  * e s\""], ["proof (prove)\nusing this:\n  P' l s\n  \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s\n  \\<forall>l s.\n     P' l s \\<longrightarrow>\n     e s \\<le> k2 * e' s \\<and>\n     (\\<forall>t.\n         \\<exists>l'. P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\n\ngoal (1 subgoal):\n 1. e s \\<le> k2 * e' s &&& time C s \\<le> k * e s", "by blast+"], ["proof (state)\nthis:\n  e s \\<le> k2 * e' s\n  time C s \\<le> k * e s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P' l s;\n     \\<forall>l s. P l s \\<longrightarrow> time C s \\<le> k * e s;\n     \\<forall>l s.\n        P' l s \\<longrightarrow>\n        e s \\<le> k2 * e' s \\<and>\n        (\\<forall>t.\n            \\<exists>l'.\n               P l' s \\<and> (Q l' t \\<longrightarrow> Q' l t))\\<rbrakk>\n    \\<Longrightarrow> time C s \\<le> k * k2 * e' s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. time C s \\<le> k * k2 * e' s", "using absch order_trans"], ["proof (prove)\nusing this:\n  e s \\<le> k2 * e' s\n  time C s \\<le> k * e s\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. time C s \\<le> k * k2 * e' s", "by fastforce"], ["proof (state)\nthis:\n  time C s \\<le> k * k2 * e' s\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>C.\n     strip C = c \\<and>\n     vc C Q' \\<and>\n     (\\<forall>l s.\n         P' l s \\<longrightarrow>\n         pre C Q' l s \\<and> Q' l (postQ C s)) \\<and>\n     (\\<exists>k.\n         \\<forall>l s. P' l s \\<longrightarrow> time C s \\<le> k * e' s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}