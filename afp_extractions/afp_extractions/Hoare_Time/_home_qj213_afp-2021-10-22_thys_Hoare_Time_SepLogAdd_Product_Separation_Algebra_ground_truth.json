{"file_name": "/home/qj213/afp-2021-10-22/thys/Hoare_Time/SepLogAdd/Product_Separation_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hoare_Time", "problem_names": ["lemma sep_disj_prod_commute[simp]: \"(ps, 0) ## (0, n)\"   \"(0, n) ## (ps, 0)\"", "lemma sep_disj_prod_conv[simp]: \"(a, x) ## (b, y) = (a##b \\<and> x##y)\"", "lemma sep_plus_prod_conv[simp]: \"(ps, n) + (ps', n') = (ps + ps', n + n')\"", "lemma\n  fixes h :: \"('a::sep_algebra) * ('b::sep_algebra)\"\n  shows \"((%(a,b). P a \\<and> b = 0) ** (%(a,b). a = 0 \\<and> Q b)) =\n   (%(a,b). P a \\<and> Q b)\"", "lemma\n  fixes h :: \"nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\"", "lemma\n  fixes h :: \"('a::sep_algebra) * ('b::sep_algebra)\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\"", "lemma\n  fixes h :: \"nat * nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\""], "translations": [["", "lemma sep_disj_prod_commute[simp]: \"(ps, 0) ## (0, n)\"   \"(0, n) ## (ps, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps, 0::'b) ## (0::'a, n) &&& (0::'a, n) ## (ps, 0::'b)", "unfolding sep_disj_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ps, 0::'b) ## fst (0::'a, n) \\<and>\n    snd (ps, 0::'b) ## snd (0::'a, n) &&&\n    fst (0::'a, n) ## fst (ps, 0::'b) \\<and>\n    snd (0::'a, n) ## snd (ps, 0::'b)", "by auto"], ["", "lemma sep_disj_prod_conv[simp]: \"(a, x) ## (b, y) = (a##b \\<and> x##y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, x) ## (b, y) = (a ## b \\<and> x ## y)", "unfolding sep_disj_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (a, x) ## fst (b, y) \\<and> snd (a, x) ## snd (b, y)) =\n    (a ## b \\<and> x ## y)", "by auto"], ["", "lemma sep_plus_prod_conv[simp]: \"(ps, n) + (ps', n') = (ps + ps', n + n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps, n) + (ps', n') = (ps + ps', n + n')", "unfolding plus_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (ps, n) + fst (ps', n'), snd (ps, n) + snd (ps', n')) =\n    (ps + ps', n + n')", "by auto"], ["", "lemma\n  fixes h :: \"('a::sep_algebra) * ('b::sep_algebra)\"\n  shows \"((%(a,b). P a \\<and> b = 0) ** (%(a,b). a = 0 \\<and> Q b)) =\n   (%(a,b). P a \\<and> Q b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(a, b). P a \\<and> b = (0::'d)) \\<and>*\n     (\\<lambda>(a, b). a = (0::'c) \\<and> Q b)) =\n    (\\<lambda>(a, b). P a \\<and> Q b)", "unfolding sep_conj_def sep_disj_prod_def plus_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h.\n        \\<exists>x y.\n           (fst x ## fst y \\<and> snd x ## snd y) \\<and>\n           h = (fst x + fst y, snd x + snd y) \\<and>\n           (case x of (a, b) \\<Rightarrow> P a \\<and> b = (0::'d)) \\<and>\n           (case y of (a, b) \\<Rightarrow> a = (0::'c) \\<and> Q b)) =\n    (\\<lambda>(a, b). P a \\<and> Q b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h.\n        \\<exists>a b aa.\n           a ## aa \\<and>\n           (\\<exists>ba.\n               b ## ba \\<and>\n               h = (a + aa, b + ba) \\<and>\n               P a \\<and> b = (0::'d) \\<and> aa = (0::'c) \\<and> Q ba)) =\n    (\\<lambda>(a, b). P a \\<and> Q b)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (\\<exists>a b aa.\n           a ## aa \\<and>\n           (\\<exists>ba.\n               b ## ba \\<and>\n               h = (a + aa, b + ba) \\<and>\n               P a \\<and> b = (0::'d) \\<and> aa = (0::'c) \\<and> Q ba)) =\n       (case h of (a, b) \\<Rightarrow> P a \\<and> Q b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>P a; Q b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba ab.\n                            aa ## ab \\<and>\n                            (\\<exists>bb.\n                                ba ## bb \\<and>\n                                a = aa + ab \\<and>\n                                b = ba + bb \\<and>\n                                P aa \\<and>\n                                ba = (0::'d) \\<and>\n                                ab = (0::'c) \\<and> Q bb)", "by force"], ["", "instantiation nat :: sep_algebra\nbegin"], ["", "definition\n  sep_disj_nat_def[simp]: \"sep_disj (m1::nat) m2 \\<equiv> True\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, sep_algebra_class)", "apply standard"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x. x ## 0\n 2. \\<And>x y. x ## y \\<Longrightarrow> y ## x\n 3. \\<And>x. x + 0 = x\n 4. \\<And>x y. x ## y \\<Longrightarrow> x + y = y + x\n 5. \\<And>x y z.\n       \\<lbrakk>x ## y; y ## z; x ## z\\<rbrakk>\n       \\<Longrightarrow> x + y + z = x + (y + z)\n 6. \\<And>x y z.\n       \\<lbrakk>x ## y + z; y ## z\\<rbrakk> \\<Longrightarrow> x ## y\n 7. \\<And>x y z.\n       \\<lbrakk>x ## y + z; y ## z\\<rbrakk> \\<Longrightarrow> x + y ## z", "by(auto)"], ["", "end"], ["", "(* examples *)\n   \n(* now nat can be used as a separation algebra *)"], ["", "lemma\n  fixes h :: \"nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* H) h = (Q \\<and>* H \\<and>* P) h", "by (simp add: sep_conj_ac)"], ["", "(* and any pair of separation algebras also is *)"], ["", "lemma\n  fixes h :: \"('a::sep_algebra) * ('b::sep_algebra)\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* H) h = (Q \\<and>* H \\<and>* P) h", "by (simp add: sep_conj_ac)"], ["", "lemma\n  fixes h :: \"nat * nat\"\n  shows \"(P ** Q ** H) h = (Q ** H ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* H) h = (Q \\<and>* H \\<and>* P) h", "by (simp add: sep_conj_ac)"], ["", "end"]]}