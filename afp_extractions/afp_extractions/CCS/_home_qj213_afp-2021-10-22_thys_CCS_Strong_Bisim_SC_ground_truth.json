{"file_name": "/home/qj213/afp-2021-10-22/thys/CCS/Strong_Bisim_SC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CCS", "problem_names": ["lemma resNil:\n  fixes x :: name\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>\"", "lemma scopeExt:\n  fixes x :: name\n  and   P :: ccs\n  and   Q :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q\"", "lemma sumComm:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  shows \"P \\<oplus> Q \\<sim> Q \\<oplus> P\"", "lemma sumAssoc:\n  fixes P :: ccs\n  and   Q :: ccs\n  and   R :: ccs\n\n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\"", "lemma sumId:\n  fixes P :: ccs\n\n  shows \"P \\<oplus> \\<zero> \\<sim> P\"", "lemma parComm:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  shows \"P \\<parallel> Q \\<sim> Q \\<parallel> P\"", "lemma parAssoc:\n  fixes P :: ccs\n  and   Q :: ccs\n  and   R :: ccs\n\n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\"", "lemma parId:\n  fixes P :: ccs\n\n  shows \"P \\<parallel> \\<zero> \\<sim> P\"", "lemma scopeFresh:\n  fixes x :: name\n  and   P :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>P \\<sim> P\"", "lemma scopeExtSum:\n  fixes x :: name\n  and   P :: ccs\n  and   Q :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q\"", "lemma resAct:\n  fixes x :: name\n  and   \\<alpha> :: act\n  and   P :: ccs\n\n  assumes \"x \\<sharp> \\<alpha>\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<alpha>.(P)) \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)\"", "lemma resComm:\n  fixes x :: name\n  and   y :: name\n  and   P :: ccs\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\"", "lemma bangUnfold:\n  fixes P\n\n  shows \"!P \\<sim> P \\<parallel> !P\"", "lemma bisimStructCong:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim> Q\""], "translations": [["", "lemma resNil:\n  fixes x :: name\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>", "have \"(\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>) \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>), (\\<zero>, \\<lparr>\\<nu>x\\<rparr>\\<zero>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>)\n    \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>),\n           (\\<zero>, \\<lparr>\\<nu>x\\<rparr>\\<zero>)}", "by simp"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>),\n         (\\<zero>, \\<lparr>\\<nu>x\\<rparr>\\<zero>)}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<zero>, \\<zero>),\n         (\\<zero>, \\<lparr>\\<nu>x\\<rparr>\\<zero>)}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct)\n      (auto intro: resNilLeft resNilRight)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExt:\n  fixes x :: name\n  and   P :: ccs\n  and   Q :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "let ?X = \"{(\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q), P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q) | x P Q. x \\<sharp> P} \\<union> {(P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q, \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q)) | x P Q. x \\<sharp> P}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "from assms"], ["proof (chain)\npicking this:\n  x \\<sharp> P", "have \"(\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q), P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n     P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q)\n    \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n            P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q) |\n           x P Q. x \\<sharp> P} \\<union>\n          {(P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q,\n            \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q)) |\n           x P Q. x \\<sharp> P}", "by auto"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n   P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n          P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q) |\n         x P Q. x \\<sharp> P} \\<union>\n        {(P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q,\n          \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q)) |\n         x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n   P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q),\n          P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q) |\n         x P Q. x \\<sharp> P} \\<union>\n        {(P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q,\n          \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q)) |\n         x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "by(coinduct rule: bisimCoinduct) (force intro: scopeExtLeft scopeExtRight)+"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                         Q) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumComm:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  shows \"P \\<oplus> Q \\<sim> Q \\<oplus> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "have \"(P \\<oplus> Q, Q \\<oplus> P) \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q, Q \\<oplus> P)\n    \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> Q, Q \\<oplus> P)\n  \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> Q, Q \\<oplus> P)\n  \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "by(coinduct rule: bisimCoinduct) (auto intro: sumComm reflexive)"], ["proof (state)\nthis:\n  P \\<oplus> Q \\<sim> Q \\<oplus> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumAssoc:\n  fixes P :: ccs\n  and   Q :: ccs\n  and   R :: ccs\n\n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)", "have \"((P \\<oplus> Q) \\<oplus> R, P \\<oplus> (Q \\<oplus> R)) \\<in> {((P \\<oplus> Q) \\<oplus> R, P \\<oplus> (Q \\<oplus> R)), (P \\<oplus> (Q \\<oplus> R), (P \\<oplus> Q) \\<oplus> R)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R))\n    \\<in> {(P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R)),\n           (P \\<oplus> (Q \\<oplus> R), P \\<oplus> Q \\<oplus> R)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R))\n  \\<in> {(P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R)),\n         (P \\<oplus> (Q \\<oplus> R), P \\<oplus> Q \\<oplus> R)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R))\n  \\<in> {(P \\<oplus> Q \\<oplus> R, P \\<oplus> (Q \\<oplus> R)),\n         (P \\<oplus> (Q \\<oplus> R), P \\<oplus> Q \\<oplus> R)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)", "by(coinduct rule: bisimCoinduct) (auto intro: sumAssocLeft sumAssocRight reflexive)"], ["proof (state)\nthis:\n  P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumId:\n  fixes P :: ccs\n\n  shows \"P \\<oplus> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "have \"(P \\<oplus> \\<zero>, P) \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> \\<zero>, P)\n    \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> \\<zero>, P)\n  \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> \\<zero>, P)\n  \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: sumIdLeft sumIdRight reflexive)"], ["proof (state)\nthis:\n  P \\<oplus> \\<zero> \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parComm:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  shows \"P \\<parallel> Q \\<sim> Q \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "have \"(P \\<parallel> Q, Q \\<parallel> P) \\<in> {(P \\<parallel> Q, Q \\<parallel> P) | P Q. True} \\<union> {(Q \\<parallel> P, P \\<parallel> Q) | P Q. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q, Q \\<parallel> P)\n    \\<in> {(P \\<parallel> Q, Q \\<parallel> P) |P Q. True} \\<union>\n          {(Q \\<parallel> P, P \\<parallel> Q) |P Q. True}", "by auto"], ["proof (state)\nthis:\n  (P \\<parallel> Q, Q \\<parallel> P)\n  \\<in> {(P \\<parallel> Q, Q \\<parallel> P) |P Q. True} \\<union>\n        {(Q \\<parallel> P, P \\<parallel> Q) |P Q. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<parallel> Q, Q \\<parallel> P)\n  \\<in> {(P \\<parallel> Q, Q \\<parallel> P) |P Q. True} \\<union>\n        {(Q \\<parallel> P, P \\<parallel> Q) |P Q. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "by(coinduct rule: bisimCoinduct) (auto intro: parComm)"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<sim> Q \\<parallel> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parAssoc:\n  fixes P :: ccs\n  and   Q :: ccs\n  and   R :: ccs\n\n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)", "have \"((P \\<parallel> Q) \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) \\<in> {((P \\<parallel> Q) \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) | P Q R. True} \\<union>  \n                                     {(P \\<parallel> (Q \\<parallel> R), (P \\<parallel> Q) \\<parallel> R) | P Q R. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q \\<parallel> R, P \\<parallel> (Q \\<parallel> R))\n    \\<in> {(P \\<parallel> Q \\<parallel> R,\n            P \\<parallel> (Q \\<parallel> R)) |\n           P Q R. True} \\<union>\n          {(P \\<parallel> (Q \\<parallel> R),\n            P \\<parallel> Q \\<parallel> R) |\n           P Q R. True}", "by auto"], ["proof (state)\nthis:\n  (P \\<parallel> Q \\<parallel> R, P \\<parallel> (Q \\<parallel> R))\n  \\<in> {(P \\<parallel> Q \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) |P\n         Q R. True} \\<union>\n        {(P \\<parallel> (Q \\<parallel> R), P \\<parallel> Q \\<parallel> R) |P\n         Q R. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<parallel> Q \\<parallel> R, P \\<parallel> (Q \\<parallel> R))\n  \\<in> {(P \\<parallel> Q \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) |P\n         Q R. True} \\<union>\n        {(P \\<parallel> (Q \\<parallel> R), P \\<parallel> Q \\<parallel> R) |P\n         Q R. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)", "by(coinduct rule: bisimCoinduct) (force intro: parAssocLeft parAssocRight)+"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parId:\n  fixes P :: ccs\n\n  shows \"P \\<parallel> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "have \"(P \\<parallel> \\<zero>, P) \\<in> {(P \\<parallel> \\<zero>, P) | P. True} \\<union> {(P, P \\<parallel> \\<zero>) | P. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> \\<zero>, P)\n    \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n          {(P, P \\<parallel> \\<zero>) |P. True}", "by simp"], ["proof (state)\nthis:\n  (P \\<parallel> \\<zero>, P)\n  \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n        {(P, P \\<parallel> \\<zero>) |P. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<parallel> \\<zero>, P)\n  \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n        {(P, P \\<parallel> \\<zero>) |P. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: parIdLeft parIdRight)"], ["proof (state)\nthis:\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeFresh:\n  fixes x :: name\n  and   P :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>P \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n                                   \\<zero>", "by(rule parId[THEN symmetric])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n    \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P", "by(rule parComm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n  \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n  \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> \\<parallel>\n    \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                    P)", "by(rule scopeExt[THEN symmetric]) auto"], ["proof (state)\nthis:\n  \\<zero> \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                  P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<zero> \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                  P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel> P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> \\<zero>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                           P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                      \\<zero>)", "by(rule resPres[OF parComm])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                         P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                    \\<zero>)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                         P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                    \\<zero>)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "from \\<open>x \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> P", "have \"\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>\\<zero>\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                           \\<zero>) \\<sim> P \\<parallel>\n     \\<lparr>\\<nu>x\\<rparr>\\<zero>", "by(rule scopeExt)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                         \\<zero>) \\<sim> P \\<parallel>\n   \\<lparr>\\<nu>x\\<rparr>\\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                         \\<zero>) \\<sim> P \\<parallel>\n   \\<lparr>\\<nu>x\\<rparr>\\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have  \"P \\<parallel> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel>\n    \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel>\n   P", "by(rule parComm)"], ["proof (state)\nthis:\n  P \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel>\n P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  P \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel>\n P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P", "by(rule parPres[OF resNil])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"\\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>", "by(rule parComm)"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "have \"P \\<parallel> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "by(rule parId)"], ["proof (state)\nthis:\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero>\n  \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n  \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P\n  \\<zero> \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                  P)\n  \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                         P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                    \\<zero>)\n  \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                         \\<zero>) \\<sim> P \\<parallel>\n   \\<lparr>\\<nu>x\\<rparr>\\<zero>\n  P \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel>\n P\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n  P \\<parallel> \\<zero> \\<sim> P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>P \\<parallel> \\<zero>\n  \\<lparr>\\<nu>x\\<rparr>P \\<parallel>\n  \\<zero> \\<sim> \\<zero> \\<parallel> \\<lparr>\\<nu>x\\<rparr>P\n  \\<zero> \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                  P)\n  \\<lparr>\\<nu>x\\<rparr>(\\<zero> \\<parallel>\n                         P) \\<sim> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                    \\<zero>)\n  \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n                         \\<zero>) \\<sim> P \\<parallel>\n   \\<lparr>\\<nu>x\\<rparr>\\<zero>\n  P \\<parallel>\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel>\n P\n  \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P \\<sim> P", "by(metis transitive)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtSum:\n  fixes x :: name\n  and   P :: ccs\n  and   Q :: ccs\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                           Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                           Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q", "have \"(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q), P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q) \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q), P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q), (P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q, \\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q),\n     P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q)\n    \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q),\n            P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q),\n           (P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q,\n            \\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q))}", "by simp"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q), P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q),\n          P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q),\n         (P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q,\n          \\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q))}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                           Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q), P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q),\n          P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q),\n         (P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q,\n          \\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q))}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                           Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q", "using \\<open>x \\<sharp> P\\<close>"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q), P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q),\n          P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q),\n         (P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q,\n          \\<lparr>\\<nu>x\\<rparr>(P \\<oplus> Q))}\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                           Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q", "by(coinduct rule: bisimCoinduct) \n      (auto intro: scopeExtSumLeft scopeExtSumRight reflexive scopeFresh scopeFresh[THEN symmetric])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(P \\<oplus>\n                         Q) \\<sim> P \\<oplus> \\<lparr>\\<nu>x\\<rparr>Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resAct:\n  fixes x :: name\n  and   \\<alpha> :: act\n  and   P :: ccs\n\n  assumes \"x \\<sharp> \\<alpha>\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<alpha>.(P)) \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)", "have \"(\\<lparr>\\<nu>x\\<rparr>(\\<alpha>.(P)), \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)) \\<in> {(\\<lparr>\\<nu>x\\<rparr>(\\<alpha>.(P)), \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)), (\\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P), \\<lparr>\\<nu>x\\<rparr>(\\<alpha>.(P)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P, \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P))\n    \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P,\n            \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)),\n           (\\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P),\n            \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P)}", "by simp"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P, \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P))\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P,\n          \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)),\n         (\\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P),\n          \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P)}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P, \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P))\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P,\n          \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)),\n         (\\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P),\n          \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P)}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)", "using \\<open>x \\<sharp> \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P, \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P))\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<alpha>.P,\n          \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)),\n         (\\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P),\n          \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P)}\n  x \\<sharp> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)", "by(coinduct rule: bisimCoinduct) (auto intro: resActLeft resActRight reflexive)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<alpha>.P \\<sim> \\<alpha>.(\\<lparr>\\<nu>x\\<rparr>P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resComm:\n  fixes x :: name\n  and   y :: name\n  and   P :: ccs\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P \\<sim> \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P \\<sim> \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P", "have \"(\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P), \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)) \\<in> {(\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P), \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)) | x y P. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n     \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P)\n    \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n            \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P) |\n           x y P. True}", "by auto"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n   \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n          \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P) |\n         x y P. True}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P \\<sim> \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n   \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P)\n  \\<in> {(\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P,\n          \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P) |\n         x y P. True}\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P \\<sim> \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P", "by(coinduct rule: bisimCoinduct) (auto intro: resComm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>P \\<sim> \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bangUnfold:\n  fixes P\n\n  shows \"!P \\<sim> P \\<parallel> !P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "have \"(!P, P \\<parallel> !P) \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!P, P \\<parallel> !P)\n    \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}", "by auto"], ["proof (state)\nthis:\n  (!P, P \\<parallel> !P)\n  \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\n\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (!P, P \\<parallel> !P)\n  \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\n\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "by(coinduct rule: bisimCoinduct) (auto intro: bangUnfoldLeft bangUnfoldRight reflexive)"], ["proof (state)\nthis:\n  !P \\<sim> P \\<parallel> !P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimStructCong:\n  fixes P :: ccs\n  and   Q :: ccs\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sim> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<equiv>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. P \\<sim> Q", "apply(nominal_induct rule: Struct_Cong.strong_induct)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>P. P \\<sim> P\n 2. \\<And>P Q.\n       \\<lbrakk>P \\<equiv>\\<^sub>s Q; P \\<sim> Q\\<rbrakk>\n       \\<Longrightarrow> Q \\<sim> P\n 3. \\<And>P Q R.\n       \\<lbrakk>P \\<equiv>\\<^sub>s Q; P \\<sim> Q; Q \\<equiv>\\<^sub>s R;\n        Q \\<sim> R\\<rbrakk>\n       \\<Longrightarrow> P \\<sim> R\n 4. \\<And>P Q. P \\<parallel> Q \\<sim> Q \\<parallel> P\n 5. \\<And>P Q R.\n       P \\<parallel> Q \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\n 6. \\<And>P. P \\<parallel> \\<zero> \\<sim> P\n 7. \\<And>P Q. P \\<oplus> Q \\<sim> Q \\<oplus> P\n 8. \\<And>P Q R. P \\<oplus> Q \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\n 9. \\<And>P. P \\<oplus> \\<zero> \\<sim> P\n 10. \\<And>x. \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim> \\<zero>\nA total of 15 subgoals...", "by(auto intro: reflexive symmetric transitive parComm parAssoc parId sumComm\n   sumAssoc sumId resNil scopeExt scopeExtSum resAct resComm bangUnfold)"], ["", "end"]]}