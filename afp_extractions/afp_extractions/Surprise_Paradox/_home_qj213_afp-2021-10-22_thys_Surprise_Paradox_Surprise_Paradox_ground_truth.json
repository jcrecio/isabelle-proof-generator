{"file_name": "/home/qj213/afp-2021-10-22/thys/Surprise_Paradox/Surprise_Paradox.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Surprise_Paradox", "problem_names": ["lemma subst_hfml_Conj[simp]:\n  \"(HConj A B)(i:::=x) = HConj (A(i:::=x)) (B(i:::=x))\"", "lemma subst_quot_hfm[simp]: \"subst i \\<guillemotleft>P\\<guillemotright> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>A(i:::=P)\\<guillemotright>\"", "lemma hfm_to_fm_Conj[simp]:\n  \"hfm_to_fm (HConj A B) = Conj (hfm_to_fm A) (hfm_to_fm B)\"", "lemma closed_hfm_Conj[simp]:\n  \"closed_hfm (HConj A B) \\<longleftrightarrow> closed_hfm A \\<and> closed_hfm B\"", "lemma quot_closed_hfm[simp]: \"closed_hfm A \\<Longrightarrow> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>hfm_to_fm A\\<guillemotright>\"", "lemma P': \"{} \\<turnstile> P IFF H(X0 ::= \\<guillemotleft>P\\<guillemotright>)\"", "lemma 7: \"{} \\<turnstile> P IFF\n     (Q\\<^sub>1 AND Neg (PfP \\<guillemotleft>P IMP Q\\<^sub>1\\<guillemotright>) XOR\n      Q\\<^sub>2 AND Neg (PfP \\<guillemotleft>P AND Neg Q\\<^sub>1 IMP Q\\<^sub>2\\<guillemotright>))\"", "lemmas \"7_E\" = 7[THEN thin0, THEN Iff_MP_left', OF Conj_E, OF thin2]", "lemmas propositional_calculus = \n    AssumeH Neg_I Imp_I Conj_E Disj_E ExFalso[OF Neg_E]\n    ExFalso[OF rotate2, OF Neg_E] ExFalso[OF rotate3, OF Neg_E]", "lemma 8: \"{} \\<turnstile> (P AND Neg Q\\<^sub>1) IMP Q\\<^sub>2\"", "lemma 10: \"{} \\<turnstile> PfP \\<guillemotleft>(P AND Neg Q\\<^sub>1) IMP Q\\<^sub>2\\<guillemotright>\"", "lemmas \"10_I\" = 10[THEN thin0]", "lemma 11: \"{} \\<turnstile> P IMP Q\\<^sub>1\"", "lemma 12: \"{} \\<turnstile> PfP \\<guillemotleft>P IMP Q\\<^sub>1\\<guillemotright>\"", "lemmas \"12_I\" = 12[THEN thin0]", "lemma 13: \"{} \\<turnstile> Neg P\"", "lemma trans_tm_forgets: \"atom ` set is \\<sharp>* t \\<Longrightarrow> trans_tm is t = trans_tm [] t\"", "lemma vquot_dbtm_fresh: \"atom ` V \\<sharp>* t \\<Longrightarrow> vquot_dbtm V t = quot_dbtm t\"", "lemma subst_vquot_dbtm_trans_tm[simp]:\n  \"atom i \\<sharp> is \\<Longrightarrow> atom ` set is \\<sharp>* t \\<Longrightarrow>\n   subst i \\<guillemotleft>t\\<guillemotright> (vquot_dbtm {i} (trans_tm is t')) =\n   quot_dbtm (trans_tm is (subst i t t'))\"", "lemma subst_vquot_dbtm_trans_fm[simp]:\n  \"atom i \\<sharp> is \\<Longrightarrow> atom ` set is \\<sharp>* t \\<Longrightarrow>\n   subst i \\<guillemotleft>t\\<guillemotright> (vquot_dbfm {i} (trans_fm is A)) =\n   quot_dbfm (trans_fm is (subst_fm A i t))\"", "lemma subst_vquot[simp]:\n  \"subst i \\<guillemotleft>t\\<guillemotright> \\<lfloor>A\\<rfloor>{i} = \\<guillemotleft>A(i ::= t)\\<guillemotright>\""], "translations": [["", "lemma subst_hfml_Conj[simp]:\n  \"(HConj A B)(i:::=x) = HConj (A(i:::=x)) (B(i:::=x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A HAND B)(i:::=x) = A(i:::=x) HAND B(i:::=x)", "unfolding HConj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HNeg (A HIMP HNeg B))(i:::=x) = HNeg (A(i:::=x) HIMP HNeg (B(i:::=x)))", "by simp"], ["", "instantiation hfm :: quot\nbegin"], ["", "fun quot_hfm :: \"hfm \\<Rightarrow> tm\"\n  where\n   \"quot_hfm (HVar name) = (Var name)\"\n | \"quot_hfm (HFm A) = \\<guillemotleft>A\\<guillemotright>\"\n | \"quot_hfm (HDisj A B) = HPair (HTuple 3) (HPair (quot_hfm A) (quot_hfm B))\"\n | \"quot_hfm (HNeg A) = HPair (HTuple 4) (quot_hfm A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hfm, quot_class)", ".."], ["", "end"], ["", "lemma subst_quot_hfm[simp]: \"subst i \\<guillemotleft>P\\<guillemotright> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>A(i:::=P)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst i \\<guillemotleft>P\\<guillemotright>\n     \\<guillemotleft>A\\<guillemotright> =\n    \\<guillemotleft>A(i:::=P)\\<guillemotright>", "by (induction A) auto"], ["", "fun hfm_to_fm :: \"hfm \\<Rightarrow> fm\"\n  where\n   \"hfm_to_fm (HVar name) = undefined\"\n | \"hfm_to_fm (HFm A) = A\"\n | \"hfm_to_fm (HDisj A B) = Disj (hfm_to_fm A) (hfm_to_fm B)\"\n | \"hfm_to_fm (HNeg A) = Neg (hfm_to_fm A)\""], ["", "lemma hfm_to_fm_Conj[simp]:\n  \"hfm_to_fm (HConj A B) = Conj (hfm_to_fm A) (hfm_to_fm B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfm_to_fm (A HAND B) = hfm_to_fm A AND hfm_to_fm B", "unfolding HConj_def Conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hfm_to_fm (HNeg (A HIMP HNeg B)) =\n    Neg (hfm_to_fm A IMP Neg (hfm_to_fm B))", "by simp"], ["", "fun closed_hfm  :: \"hfm \\<Rightarrow> bool\"\n  where\n   \"closed_hfm (HVar name) \\<longleftrightarrow> False\"\n | \"closed_hfm (HFm A) \\<longleftrightarrow> True\"\n | \"closed_hfm (HDisj A B) \\<longleftrightarrow> closed_hfm A \\<and> closed_hfm B\"\n | \"closed_hfm (HNeg A) \\<longleftrightarrow> closed_hfm A\""], ["", "lemma closed_hfm_Conj[simp]:\n  \"closed_hfm (HConj A B) \\<longleftrightarrow> closed_hfm A \\<and> closed_hfm B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_hfm (A HAND B) = (closed_hfm A \\<and> closed_hfm B)", "unfolding HConj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_hfm (HNeg (A HIMP HNeg B)) = (closed_hfm A \\<and> closed_hfm B)", "by simp"], ["", "lemma quot_closed_hfm[simp]: \"closed_hfm A \\<Longrightarrow> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>hfm_to_fm A\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_hfm A \\<Longrightarrow>\n    \\<guillemotleft>A\\<guillemotright> =\n    \\<guillemotleft>hfm_to_fm A\\<guillemotright>", "by (induction A) (auto simp add: quot_fm_def)"], ["", "declare quot_hfm.simps[simp del]"], ["", "section \\<open>Fitch's proof\\<close>"], ["", "text \\<open>\nFor simplicity, Fitch (and we) restrict the week to two days. Propositions \\<open>Q\\<^sub>1\\<close> and \\<open>Q\\<^sub>2\\<close>\nrepresent the propositions that the hanging occurs on the first resp.\\@ the second day, but\nthese can obviously be any propositions.\n\\<close>"], ["", "context\n  fixes Q\\<^sub>1 :: fm and Q\\<^sub>2 :: fm\n  assumes Q_closed: \"supp Q\\<^sub>1 = {}\" \"supp Q\\<^sub>2 = {}\"\nbegin"], ["", "text \\<open>\n  In order to define the judge's proposition, which is self-referential, we apply the usual trick\n  of defining a proposition with a variable, and then using G?del's diagonalisation lemma.\n  \\<close>"], ["", "definition H :: fm where\n    \"H = Q\\<^sub>1 AND Neg (PfP \\<guillemotleft>HVar X0 HIMP HFm Q\\<^sub>1\\<guillemotright>) XOR \n     Q\\<^sub>2 AND Neg (PfP \\<guillemotleft>HVar X0 HAND HNeg (HFm Q\\<^sub>1) HIMP (HFm Q\\<^sub>2)\\<guillemotright>)\""], ["", "definition P where \"P = (SOME P. {} \\<turnstile> P IFF H(X0 ::= \\<guillemotleft>P\\<guillemotright>))\""], ["", "lemma P': \"{} \\<turnstile> P IFF H(X0 ::= \\<guillemotleft>P\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)", "from diagonal[where \\<alpha> = \"H\" and i = X0]"], ["proof (chain)\npicking this:\n  (\\<And>\\<delta>.\n      \\<lbrakk>{} \\<turnstile>\n               \\<delta> IFF\n               local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>);\n       supp \\<delta> = supp local.H - {atom X0}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain \\<delta> where \"{} \\<turnstile> \\<delta> IFF H(X0 ::= \\<guillemotleft>\\<delta>\\<guillemotright>)\""], ["proof (prove)\nusing this:\n  (\\<And>\\<delta>.\n      \\<lbrakk>{} \\<turnstile>\n               \\<delta> IFF\n               local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>);\n       supp \\<delta> = supp local.H - {atom X0}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        {} \\<turnstile>\n        \\<delta> IFF\n        local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  {} \\<turnstile>\n  \\<delta> IFF local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  \\<delta> IFF local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)", "unfolding P_def"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  \\<delta> IFF local.H(X0::=\\<guillemotleft>\\<delta>\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    (SOME P.\n        {} \\<turnstile>\n        P IFF local.H(X0::=\\<guillemotleft>P\\<guillemotright>)) IFF\n    local.H(X0::=\\<guillemotleft>SOME P.\n                                    {} \\<turnstile>\n                                    P IFF\n                                    local.H(X0::=\\<guillemotleft>P\\<guillemotright>)\\<guillemotright>)", "by (rule someI)"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  From now on, the lemmas are named after their number in Fitch's paper, and correspond to his\n  statements pleasingly closely.\n  \\<close>"], ["", "lemma 7: \"{} \\<turnstile> P IFF\n     (Q\\<^sub>1 AND Neg (PfP \\<guillemotleft>P IMP Q\\<^sub>1\\<guillemotright>) XOR\n      Q\\<^sub>2 AND Neg (PfP \\<guillemotleft>P AND Neg Q\\<^sub>1 IMP Q\\<^sub>2\\<guillemotright>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF\n    (Q\\<^sub>1 AND\n     Neg (PfP \\<guillemotleft>local.P IMP Q\\<^sub>1\\<guillemotright>) XOR\n     Q\\<^sub>2 AND\n     Neg (PfP \\<guillemotleft>local.P AND Neg Q\\<^sub>1 IMP\n                              Q\\<^sub>2\\<guillemotright>))", "using P'"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  local.P IFF local.H(X0::=\\<guillemotleft>local.P\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF\n    (Q\\<^sub>1 AND\n     Neg (PfP \\<guillemotleft>local.P IMP Q\\<^sub>1\\<guillemotright>) XOR\n     Q\\<^sub>2 AND\n     Neg (PfP \\<guillemotleft>local.P AND Neg Q\\<^sub>1 IMP\n                              Q\\<^sub>2\\<guillemotright>))", "unfolding H_def"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  local.P IFF\n  (Q\\<^sub>1 AND\n   Neg (PfP \\<guillemotleft>HVar X0 HIMP HFm Q\\<^sub>1\\<guillemotright>) XOR\n   Q\\<^sub>2 AND\n   Neg (PfP \\<guillemotleft>HVar X0 HAND HNeg (HFm Q\\<^sub>1) HIMP\n                            HFm Q\\<^sub>2\\<guillemotright>))(X0::=\\<guillemotleft>local.P\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    local.P IFF\n    (Q\\<^sub>1 AND\n     Neg (PfP \\<guillemotleft>local.P IMP Q\\<^sub>1\\<guillemotright>) XOR\n     Q\\<^sub>2 AND\n     Neg (PfP \\<guillemotleft>local.P AND Neg Q\\<^sub>1 IMP\n                              Q\\<^sub>2\\<guillemotright>))", "by (simp add: Q_closed forget_subst_fm[unfolded fresh_def])"], ["", "lemmas \"7_E\" = 7[THEN thin0, THEN Iff_MP_left', OF Conj_E, OF thin2]"], ["", "lemmas propositional_calculus = \n    AssumeH Neg_I Imp_I Conj_E Disj_E ExFalso[OF Neg_E]\n    ExFalso[OF rotate2, OF Neg_E] ExFalso[OF rotate3, OF Neg_E]"], ["", "lemma 8: \"{} \\<turnstile> (P AND Neg Q\\<^sub>1) IMP Q\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> local.P AND Neg Q\\<^sub>1 IMP Q\\<^sub>2", "by (intro propositional_calculus \"7_E\")"], ["", "lemma 10: \"{} \\<turnstile> PfP \\<guillemotleft>(P AND Neg Q\\<^sub>1) IMP Q\\<^sub>2\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    PfP \\<guillemotleft>local.P AND Neg Q\\<^sub>1 IMP\n                        Q\\<^sub>2\\<guillemotright>", "using 8"], ["proof (prove)\nusing this:\n  {} \\<turnstile> local.P AND Neg Q\\<^sub>1 IMP Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    PfP \\<guillemotleft>local.P AND Neg Q\\<^sub>1 IMP\n                        Q\\<^sub>2\\<guillemotright>", "by (rule proved_imp_proved_PfP)"], ["", "lemmas \"10_I\" = 10[THEN thin0]"], ["", "lemma 11: \"{} \\<turnstile> P IMP Q\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> local.P IMP Q\\<^sub>1", "by (intro propositional_calculus \"7_E\" \"10_I\")"], ["", "lemma 12: \"{} \\<turnstile> PfP \\<guillemotleft>P IMP Q\\<^sub>1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    PfP \\<guillemotleft>local.P IMP Q\\<^sub>1\\<guillemotright>", "using 11"], ["proof (prove)\nusing this:\n  {} \\<turnstile> local.P IMP Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    PfP \\<guillemotleft>local.P IMP Q\\<^sub>1\\<guillemotright>", "by (rule proved_imp_proved_PfP)"], ["", "lemmas \"12_I\" = 12[THEN thin0]"], ["", "lemma 13: \"{} \\<turnstile> Neg P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg local.P", "by (intro propositional_calculus \"7_E\" \"10_I\" \"12_I\")"], ["", "end"], ["", "section \\<open>Substitution, quoting and V-quoting\\<close>"], ["", "text \\<open>In the end, we did not need the lemma at the end of this section, but it may be useful to\nothers.\\<close>"], ["", "lemma trans_tm_forgets: \"atom ` set is \\<sharp>* t \\<Longrightarrow> trans_tm is t = trans_tm [] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` set is \\<sharp>* t \\<Longrightarrow>\n    trans_tm is t = trans_tm [] t", "by (induct t rule: tm.induct)\n     (auto simp: lookup_notin fresh_star_def fresh_at_base)"], ["", "lemma vquot_dbtm_fresh: \"atom ` V \\<sharp>* t \\<Longrightarrow> vquot_dbtm V t = quot_dbtm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` V \\<sharp>* t \\<Longrightarrow> vquot_dbtm V t = quot_dbtm t", "by (nominal_induct t rule: dbtm.strong_induct)\n     (auto simp add: fresh_star_def fresh_at_base)"], ["", "lemma subst_vquot_dbtm_trans_tm[simp]:\n  \"atom i \\<sharp> is \\<Longrightarrow> atom ` set is \\<sharp>* t \\<Longrightarrow>\n   subst i \\<guillemotleft>t\\<guillemotright> (vquot_dbtm {i} (trans_tm is t')) =\n   quot_dbtm (trans_tm is (subst i t t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> is; atom ` set is \\<sharp>* t\\<rbrakk>\n    \\<Longrightarrow> subst i \\<guillemotleft>t\\<guillemotright>\n                       (vquot_dbtm {i} (trans_tm is t')) =\n                      quot_dbtm (trans_tm is (subst i t t'))", "by (nominal_induct t' avoiding: \"is\" i t rule: tm.strong_induct)\n     (auto simp add:  quot_tm_def lookup_notin fresh_imp_notin_env\n                      vquot_dbtm_fresh lookup_fresh\n           intro: trans_tm_forgets[symmetric])"], ["", "lemma subst_vquot_dbtm_trans_fm[simp]:\n  \"atom i \\<sharp> is \\<Longrightarrow> atom ` set is \\<sharp>* t \\<Longrightarrow>\n   subst i \\<guillemotleft>t\\<guillemotright> (vquot_dbfm {i} (trans_fm is A)) =\n   quot_dbfm (trans_fm is (subst_fm A i t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> is; atom ` set is \\<sharp>* t\\<rbrakk>\n    \\<Longrightarrow> subst i \\<guillemotleft>t\\<guillemotright>\n                       (vquot_dbfm {i} (trans_fm is A)) =\n                      quot_dbfm (trans_fm is (A(i::=t)))", "by (nominal_induct A avoiding: \"is\" i t rule: fm.strong_induct)\n     (auto simp add: quot_fm_def fresh_Cons)"], ["", "lemma subst_vquot[simp]:\n  \"subst i \\<guillemotleft>t\\<guillemotright> \\<lfloor>A\\<rfloor>{i} = \\<guillemotleft>A(i ::= t)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst i \\<guillemotleft>t\\<guillemotright> \\<lfloor>A\\<rfloor>{i} =\n    \\<guillemotleft>A(i::=t)\\<guillemotright>", "by (nominal_induct A avoiding: i t rule: fm.strong_induct)\n     (auto simp add: vquot_fm_def quot_fm_def fresh_Cons)"], ["", "end"]]}