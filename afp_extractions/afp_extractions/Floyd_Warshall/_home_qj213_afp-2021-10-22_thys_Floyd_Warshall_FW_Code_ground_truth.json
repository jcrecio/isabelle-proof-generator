{"file_name": "/home/qj213/afp-2021-10-22/thys/Floyd_Warshall/FW_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Floyd_Warshall", "problem_names": ["lemma fwi'_simps:\n  \"fwi' m n k 0       0        = fw_upd' m k 0 0\"\n  \"fwi' m n k (Suc i) 0        = do {m' \\<leftarrow> fwi' m n k i n; fw_upd' m' k (Suc i) 0}\"\n  \"fwi' m n k i       (Suc j)  = do {m' \\<leftarrow> fwi' m n k i j; fw_upd' m' k i (Suc j)}\"", "lemma\n  \"fwi' m n k i j \\<le> SPEC (\\<lambda> r. r = uncurry (fwi (curry m) n k i j))\"", "lemma fw_upd'_spec:\n  \"fw_upd' M k i j \\<le> SPEC (\\<lambda> M'. M' = uncurry (fw_upd (curry M) k i j))\"", "lemma for_rec2_fwi:\n  \"for_rec2 (\\<lambda> M. fw_upd' M k) M n i j \\<le> SPEC (\\<lambda> M'. M' = uncurry (fwi (curry M) n k i j))\"", "lemma fw'_spec:\n  \"fw' m n k \\<le> SPEC (\\<lambda> M'. M' = uncurry (fw (curry m) n k))\"", "lemma [sepref_import_param]: \"((+),(+)::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemma [sepref_import_param]: \"(min,min::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemma D_diag_nonnegI:\n  assumes \"cycle_free M n\" \"i \\<le> n\"\n  shows \"D M i i n \\<ge> 0\"", "lemma fw_fw_spec:\n  \"RETURN (FW M n) \\<le> fw_spec n M\"", "lemma fw_impl'_correct:\n  \"(fw_impl', fw_spec) \\<in> Id \\<rightarrow> br curry (\\<lambda> _. True) \\<rightarrow> \\<langle>br curry (\\<lambda> _. True)\\<rangle> nres_rel\"", "theorem fw_impl_correct:\n  \"(fw_impl n, fw_spec n) \\<in> (mtx_curry_assn n)\\<^sup>d \\<rightarrow>\\<^sub>a mtx_curry_assn n\"", "lemma fwi_impl'_refine_FWI':\n  \"(fwi_impl' n, RETURN oo PR_CONST (\\<lambda> M. FWI' M n)) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"", "lemmas fwi_impl_refine_FWI' = fwi_impl.refine[FCOMP fwi_impl'_refine_FWI']", "lemma fw_impl'_refine_FW'':\n  \"(fw_impl' n, RETURN o PR_CONST (FW'' n)) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"", "lemmas fw_impl_refine_FW'' = fw_impl.refine[FCOMP fw_impl'_refine_FW'']"], "translations": [["", "lemma fwi'_simps:\n  \"fwi' m n k 0       0        = fw_upd' m k 0 0\"\n  \"fwi' m n k (Suc i) 0        = do {m' \\<leftarrow> fwi' m n k i n; fw_upd' m' k (Suc i) 0}\"\n  \"fwi' m n k i       (Suc j)  = do {m' \\<leftarrow> fwi' m n k i j; fw_upd' m' k i (Suc j)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fwi' m n k 0 0 = fw_upd' m k 0 0 &&&\n    fwi' m n k (Suc i) 0 =\n    fwi' m n k i n \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc i) 0) &&&\n    fwi' m n k i (Suc j) =\n    fwi' m n k i j \\<bind> (\\<lambda>m'. fw_upd' m' k i (Suc j))", "unfolding fwi'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>fw (m, k, i, j).\n         case (i, j) of (0, 0) \\<Rightarrow> fw_upd' m k 0 0\n         | (0, Suc j) \\<Rightarrow>\n             fw (m, k, 0, j) \\<bind> (\\<lambda>m'. fw_upd' m' k 0 (Suc j))\n         | (Suc ia, 0) \\<Rightarrow>\n             fw (m, k, ia, n) \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc ia) 0)\n         | (Suc ia, Suc j) \\<Rightarrow>\n             fw (m, k, Suc ia, j) \\<bind>\n             (\\<lambda>m'. fw_upd' m' k (Suc ia) (Suc j)))\n     (m, k, 0, 0) =\n    fw_upd' m k 0 0 &&&\n    REC\\<^sub>T\n     (\\<lambda>fw (m, k, i, j).\n         case (i, j) of (0, 0) \\<Rightarrow> fw_upd' m k 0 0\n         | (0, Suc j) \\<Rightarrow>\n             fw (m, k, 0, j) \\<bind> (\\<lambda>m'. fw_upd' m' k 0 (Suc j))\n         | (Suc ia, 0) \\<Rightarrow>\n             fw (m, k, ia, n) \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc ia) 0)\n         | (Suc ia, Suc j) \\<Rightarrow>\n             fw (m, k, Suc ia, j) \\<bind>\n             (\\<lambda>m'. fw_upd' m' k (Suc ia) (Suc j)))\n     (m, k, Suc i, 0) =\n    REC\\<^sub>T\n     (\\<lambda>fw (m, k, i, j).\n         case (i, j) of (0, 0) \\<Rightarrow> fw_upd' m k 0 0\n         | (0, Suc j) \\<Rightarrow>\n             fw (m, k, 0, j) \\<bind> (\\<lambda>m'. fw_upd' m' k 0 (Suc j))\n         | (Suc ia, 0) \\<Rightarrow>\n             fw (m, k, ia, n) \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc ia) 0)\n         | (Suc ia, Suc j) \\<Rightarrow>\n             fw (m, k, Suc ia, j) \\<bind>\n             (\\<lambda>m'. fw_upd' m' k (Suc ia) (Suc j)))\n     (m, k, i, n) \\<bind>\n    (\\<lambda>m'. fw_upd' m' k (Suc i) 0) &&&\n    REC\\<^sub>T\n     (\\<lambda>fw (m, k, i, j).\n         case (i, j) of (0, 0) \\<Rightarrow> fw_upd' m k 0 0\n         | (0, Suc j) \\<Rightarrow>\n             fw (m, k, 0, j) \\<bind> (\\<lambda>m'. fw_upd' m' k 0 (Suc j))\n         | (Suc ia, 0) \\<Rightarrow>\n             fw (m, k, ia, n) \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc ia) 0)\n         | (Suc ia, Suc j) \\<Rightarrow>\n             fw (m, k, Suc ia, j) \\<bind>\n             (\\<lambda>m'. fw_upd' m' k (Suc ia) (Suc j)))\n     (m, k, i, Suc j) =\n    REC\\<^sub>T\n     (\\<lambda>fw (m, k, i, j).\n         case (i, j) of (0, 0) \\<Rightarrow> fw_upd' m k 0 0\n         | (0, Suc j) \\<Rightarrow>\n             fw (m, k, 0, j) \\<bind> (\\<lambda>m'. fw_upd' m' k 0 (Suc j))\n         | (Suc ia, 0) \\<Rightarrow>\n             fw (m, k, ia, n) \\<bind> (\\<lambda>m'. fw_upd' m' k (Suc ia) 0)\n         | (Suc ia, Suc j) \\<Rightarrow>\n             fw (m, k, Suc ia, j) \\<bind>\n             (\\<lambda>m'. fw_upd' m' k (Suc ia) (Suc j)))\n     (m, k, i, j) \\<bind>\n    (\\<lambda>m'. fw_upd' m' k i (Suc j))", "by (subst RECT_unfold, (refine_mono; fail), (auto split: nat.split; fail))+"], ["", "lemma\n  \"fwi' m n k i j \\<le> SPEC (\\<lambda> r. r = uncurry (fwi (curry m) n k i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fwi' m n k i j\n    \\<le> SPEC (\\<lambda>r. r = uncurry (fwi (curry m) n k i j))", "by (induction \"curry m\" n k i j arbitrary: m rule: fwi.induct)\n   (fastforce simp add: fw_upd'_def fw_upd_def upd_def fwi'_simps pw_le_iff refine_pw_simps)+"], ["", "lemma fw_upd'_spec:\n  \"fw_upd' M k i j \\<le> SPEC (\\<lambda> M'. M' = uncurry (fw_upd (curry M) k i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fw_upd' M k i j\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw_upd (curry M) k i j))", "by (auto simp: fw_upd'_def fw_upd_def upd_def pw_le_iff refine_pw_simps)"], ["", "lemma for_rec2_fwi:\n  \"for_rec2 (\\<lambda> M. fw_upd' M k) M n i j \\<le> SPEC (\\<lambda> M'. M' = uncurry (fwi (curry M) n k i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. for_rec2 (\\<lambda>M. fw_upd' M k) M n i j\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fwi (curry M) n k i j))", "using fw_upd'_spec"], ["proof (prove)\nusing this:\n  fw_upd' ?M ?k ?i ?j\n  \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw_upd (curry ?M) ?k ?i ?j))\n\ngoal (1 subgoal):\n 1. for_rec2 (\\<lambda>M. fw_upd' M k) M n i j\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fwi (curry M) n k i j))", "by (induction \"\\<lambda> M. fw_upd' (M :: (nat \\<times> nat \\<Rightarrow> 'a)) k\" M n i j rule: for_rec2.induct)\n   (fastforce simp: pw_le_iff refine_pw_simps)+"], ["", "definition fw' ::  \"('a::linordered_ab_monoid_add) mtx \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mtx nres\" where\n  \"fw' m n k = nfoldli [0..<k + 1] (\\<lambda> _. True) (\\<lambda> k M. for_rec2 (\\<lambda> M. fw_upd' M k) M n n n) m\""], ["", "lemma fw'_spec:\n  \"fw' m n k \\<le> SPEC (\\<lambda> M'. M' = uncurry (fw (curry m) n k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fw' m n k \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n k))", "unfolding fw'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<k + 1] (\\<lambda>_. True)\n     (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n k))", "apply (induction k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nfoldli [0..<0 + 1] (\\<lambda>_. True)\n     (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n 0))\n 2. \\<And>k.\n       nfoldli [0..<k + 1] (\\<lambda>_. True)\n        (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n       \\<le> SPEC\n              (\\<lambda>M'.\n                  M' = uncurry (fw (curry m) n k)) \\<Longrightarrow>\n       nfoldli [0..<Suc k + 1] (\\<lambda>_. True)\n        (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n       \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n (Suc k)))", "using for_rec2_fwi"], ["proof (prove)\nusing this:\n  for_rec2 (\\<lambda>M. fw_upd' M ?k) ?M ?n ?i ?j\n  \\<le> SPEC (\\<lambda>M'. M' = uncurry (fwi (curry ?M) ?n ?k ?i ?j))\n\ngoal (2 subgoals):\n 1. nfoldli [0..<0 + 1] (\\<lambda>_. True)\n     (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n    \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n 0))\n 2. \\<And>k.\n       nfoldli [0..<k + 1] (\\<lambda>_. True)\n        (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n       \\<le> SPEC\n              (\\<lambda>M'.\n                  M' = uncurry (fw (curry m) n k)) \\<Longrightarrow>\n       nfoldli [0..<Suc k + 1] (\\<lambda>_. True)\n        (\\<lambda>k M. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n) m\n       \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry m) n (Suc k)))", "by (fastforce simp add: pw_le_iff refine_pw_simps curry_def)+"], ["", "context\n  fixes n :: nat\n  fixes dummy :: \"'a::{linordered_ab_monoid_add,zero,heap}\"\nbegin"], ["", "lemma [sepref_import_param]: \"((+),(+)::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((+), (+)) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id", "by simp"], ["", "lemma [sepref_import_param]: \"(min,min::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min, min) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id", "by simp"], ["", "abbreviation \"node_assn \\<equiv> nat_assn\""], ["", "abbreviation \"mtx_assn \\<equiv> asmtx_assn (Suc n) id_assn::('a mtx \\<Rightarrow>_)\""], ["", "sepref_definition fw_upd_impl is\n  \"uncurry2 (uncurry fw_upd')\" ::\n  \"[\\<lambda> (((_,k),i),j). k \\<le> n \\<and> i \\<le> n \\<and> j \\<le> n]\\<^sub>a mtx_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k\n  \\<rightarrow> mtx_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry fw_upd'))\n    \\<in> [\\<lambda>(((uu_, k), i), j).\n              k \\<le> n \\<and>\n              i \\<le> n \\<and>\n              j \\<le> n]\\<^sub>a local.mtx_assn\\<^sup>d *\\<^sub>a\n                                 node_assn\\<^sup>k *\\<^sub>a\n                                 node_assn\\<^sup>k *\\<^sub>a\n                                 node_assn\\<^sup>k \\<rightarrow> local.mtx_assn", "unfolding fw_upd'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>m k i j.\n            RETURN\n             (op_mtx_set m (i, j)\n               (min (op_mtx_get m (i, j))\n                 (op_mtx_get m (i, k) + op_mtx_get m (k, j)))))))\n    \\<in> [\\<lambda>(((uu_, k), i), j).\n              k \\<le> n \\<and>\n              i \\<le> n \\<and>\n              j \\<le> n]\\<^sub>a local.mtx_assn\\<^sup>d *\\<^sub>a\n                                 node_assn\\<^sup>k *\\<^sub>a\n                                 node_assn\\<^sup>k *\\<^sub>a\n                                 node_assn\\<^sup>k \\<rightarrow> local.mtx_assn", "by sepref"], ["", "declare fw_upd_impl.refine[sepref_fr_rules]"], ["", "sepref_register fw_upd' :: \"'a i_mtx \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a i_mtx nres\""], ["", "definition\n  \"fwi_impl' (M :: 'a mtx) k = for_rec2 (\\<lambda> M. fw_upd' M k) M n n n\""], ["", "definition\n  \"fw_impl' (M :: 'a mtx) = fw' M n n\""], ["", "context\n  notes [id_rules] = itypeI[of n \"TYPE (nat)\"]\n    and [sepref_import_param] = IdI[of n]\nbegin"], ["", "sepref_definition fw_impl is\n  \"fw_impl'\" :: \"mtx_assn\\<^sup>d \\<rightarrow>\\<^sub>a mtx_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, local.fw_impl')\n    \\<in> local.mtx_assn\\<^sup>d \\<rightarrow>\\<^sub>a local.mtx_assn", "unfolding fw_impl'_def[abs_def] fw'_def for_rec2_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     nfoldli [0..<n + 1] (\\<lambda>_. True)\n      (\\<lambda>k.\n          nfoldli [0..<n + 1] (\\<lambda>x. True)\n           (\\<lambda>i.\n               nfoldli [0..<n + 1] (\\<lambda>x. True)\n                (\\<lambda>j a. fw_upd' a k i j))))\n    \\<in> local.mtx_assn\\<^sup>d \\<rightarrow>\\<^sub>a local.mtx_assn", "by sepref"], ["", "sepref_definition fwi_impl is\n  \"uncurry fwi_impl'\" :: \"[\\<lambda> (_,k). k \\<le> n]\\<^sub>a mtx_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow> mtx_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.fwi_impl')\n    \\<in> [\\<lambda>(uu_, k).\n              k \\<le> n]\\<^sub>a local.mtx_assn\\<^sup>d *\\<^sub>a\n                                 node_assn\\<^sup>k \\<rightarrow> local.mtx_assn", "unfolding fwi_impl'_def[abs_def] for_rec2_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>M k.\n          nfoldli [0..<n + 1] (\\<lambda>x. True)\n           (\\<lambda>i.\n               nfoldli [0..<n + 1] (\\<lambda>x. True)\n                (\\<lambda>j a. fw_upd' a k i j))\n           M))\n    \\<in> [\\<lambda>(uu_, k).\n              k \\<le> n]\\<^sub>a local.mtx_assn\\<^sup>d *\\<^sub>a\n                                 node_assn\\<^sup>k \\<rightarrow> local.mtx_assn", "by sepref"], ["", "end"], ["", "(* End of sepref setup *)"], ["", "end"], ["", "(* End of n *)"], ["", "export_code fw_impl checking SML_imp"], ["", "text \\<open>\n  A compact specification for the characteristic property of the \\fw.\n\\<close>"], ["", "definition fw_spec where\n  \"fw_spec n M \\<equiv> SPEC (\\<lambda> M'.\n    if (\\<exists> i \\<le> n. M' i i < 0)\n    then \\<not> cyc_free M n\n    else \\<forall>i \\<le> n. \\<forall>j \\<le> n. M' i j = D M i j n \\<and> cyc_free M n)\""], ["", "lemma D_diag_nonnegI:\n  assumes \"cycle_free M n\" \"i \\<le> n\"\n  shows \"D M i i n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> D M i i n", "using assms D_dest''[OF refl, of M i i n]"], ["proof (prove)\nusing this:\n  cycle_free M n\n  i \\<le> n\n  D M i i n \\<in> {len M i i xs |xs. set xs \\<subseteq> {0..n}}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> D M i i n", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     (\\<forall>j\\<le>n.\n         len M i j (rem_cycles i j xs) \\<le> len M i j xs) \\<and>\n     (0::'a) \\<le> len M i i xs\n  i \\<le> n\n  D M i i n \\<in> {len M i i xs |xs. set xs \\<subseteq> {0..n}}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> D M i i n", "by auto"], ["", "lemma fw_fw_spec:\n  \"RETURN (FW M n) \\<le> fw_spec n M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (FW M n) \\<le> fw_spec n M", "unfolding fw_spec_def cycle_free_diag_equiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (FW M n)\n    \\<le> SPEC\n           (\\<lambda>M'.\n               if \\<exists>i\\<le>n. M' i i < (0::'a)\n               then \\<not> cycle_free M n\n               else \\<forall>i\\<le>n.\n                       \\<forall>j\\<le>n.\n                          M' i j = D M i j n \\<and> cycle_free M n)", "proof (simp, safe, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; FW M n i i < (0::'a); cycle_free M n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> FW M n i j = D M i j n\n 3. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "case prems: (1 i)"], ["proof (state)\nthis:\n  i \\<le> n\n  FW M n i i < (0::'a)\n  cycle_free M n\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; FW M n i i < (0::'a); cycle_free M n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> FW M n i j = D M i j n\n 3. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "with fw_shortest_path[unfolded cycle_free_diag_equiv, OF prems(3)] D_diag_nonnegI"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<le> n; ?j \\<le> n; ?k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M ?i ?j ?k = fw M n ?k ?i ?j\n  \\<lbrakk>cycle_free ?M ?n; ?i \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> D ?M ?i ?i ?n\n  i \\<le> n\n  FW M n i i < (0::'a)\n  cycle_free M n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; ?j \\<le> n; ?k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M ?i ?j ?k = fw M n ?k ?i ?j\n  \\<lbrakk>cycle_free ?M ?n; ?i \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> D ?M ?i ?i ?n\n  i \\<le> n\n  FW M n i i < (0::'a)\n  cycle_free M n\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> FW M n i j = D M i j n\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> FW M n i j = D M i j n\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "case 2"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> FW M n i j = D M i j n\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n\ngoal (1 subgoal):\n 1. FW M n i_ j_ = D M i_ j_ n", "using FW_neg_cycle_detect[unfolded cycle_free_diag_equiv]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n  \\<not> cycle_free ?m ?n \\<Longrightarrow>\n  \\<exists>i\\<le>?n. FW ?m ?n i i < (0::?'a)\n\ngoal (1 subgoal):\n 1. FW M n i_ j_ = D M i_ j_ n", "by (force intro: fw_shortest_path[symmetric, unfolded cycle_free_diag_equiv])"], ["proof (state)\nthis:\n  FW M n i_ j_ = D M i_ j_ n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "case 3"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a); i \\<le> n;\n        j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cycle_free M n", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n\ngoal (1 subgoal):\n 1. cycle_free M n", "using FW_neg_cycle_detect[unfolded cycle_free_diag_equiv]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<not> FW M n i i < (0::'a)\n  i_ \\<le> n\n  j_ \\<le> n\n  \\<not> cycle_free ?m ?n \\<Longrightarrow>\n  \\<exists>i\\<le>?n. FW ?m ?n i i < (0::?'a)\n\ngoal (1 subgoal):\n 1. cycle_free M n", "by blast"], ["proof (state)\nthis:\n  cycle_free M n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"mat_curry_rel = {(Mu, Mc). curry Mu = Mc}\""], ["", "definition\n  \"mtx_curry_assn n = hr_comp (mtx_assn n) (br curry (\\<lambda>_. True))\""], ["", "declare mtx_curry_assn_def[symmetric, fcomp_norm_unfold]"], ["", "lemma fw_impl'_correct:\n  \"(fw_impl', fw_spec) \\<in> Id \\<rightarrow> br curry (\\<lambda> _. True) \\<rightarrow> \\<langle>br curry (\\<lambda> _. True)\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fw_impl', fw_spec)\n    \\<in> nat_rel \\<rightarrow>\n          br curry (\\<lambda>_. True) \\<rightarrow>\n          \\<langle>br curry (\\<lambda>_. True)\\<rangle>nres_rel", "unfolding fw_impl'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n M. fw' M n n, fw_spec)\n    \\<in> nat_rel \\<rightarrow>\n          br curry (\\<lambda>_. True) \\<rightarrow>\n          \\<langle>br curry (\\<lambda>_. True)\\<rangle>nres_rel", "using fw'_spec fw_fw_spec"], ["proof (prove)\nusing this:\n  fw' ?m ?n ?k \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry ?m) ?n ?k))\n  RETURN (FW ?M ?n) \\<le> fw_spec ?n ?M\n\ngoal (1 subgoal):\n 1. (\\<lambda>n M. fw' M n n, fw_spec)\n    \\<in> nat_rel \\<rightarrow>\n          br curry (\\<lambda>_. True) \\<rightarrow>\n          \\<langle>br curry (\\<lambda>_. True)\\<rangle>nres_rel", "by (fastforce simp: in_br_conv pw_le_iff refine_pw_simps intro!: nres_relI)"], ["", "subsection \\<open>Main Result\\<close>"], ["", "text \\<open>This is one way to state that \\<open>fw_impl\\<close> fulfills the specification \\<open>fw_spec\\<close>.\\<close>"], ["", "theorem fw_impl_correct:\n  \"(fw_impl n, fw_spec n) \\<in> (mtx_curry_assn n)\\<^sup>d \\<rightarrow>\\<^sub>a mtx_curry_assn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fw_impl n, fw_spec n)\n    \\<in> (mtx_curry_assn n)\\<^sup>d \\<rightarrow>\\<^sub>a mtx_curry_assn n", "using fw_impl.refine[FCOMP fw_impl'_correct[THEN fun_relD, OF IdI]]"], ["proof (prove)\nusing this:\n  (fw_impl ?x18, fw_spec ?x18)\n  \\<in> (mtx_curry_assn\n          ?x18)\\<^sup>d \\<rightarrow>\\<^sub>a mtx_curry_assn ?x18\n\ngoal (1 subgoal):\n 1. (fw_impl n, fw_spec n)\n    \\<in> (mtx_curry_assn n)\\<^sup>d \\<rightarrow>\\<^sub>a mtx_curry_assn n", "."], ["", "text \\<open>An alternative version: a Hoare triple for total correctness.\\<close>"], ["", "corollary\n  \"<mtx_curry_assn n M Mi> fw_impl n Mi <\\<lambda> Mi'. \\<exists>\\<^sub>A M'. mtx_curry_assn n M' Mi' * \\<up>\n    (if (\\<exists> i \\<le> n. M' i i < 0)\n    then \\<not> cyc_free M n\n    else \\<forall>i \\<le> n. \\<forall>j \\<le> n. M' i j = D M i j n \\<and> cyc_free M n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <mtx_curry_assn n M\n      Mi> fw_impl n\n           Mi <\\<lambda>r.\n                  \\<exists>\\<^sub>AM'.\n                     mtx_curry_assn n M' r *\n                     \\<up>\n                      (if \\<exists>i\\<le>n. M' i i < (0::'a)\n                       then \\<not> (\\<forall>i xs.\n i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n (0::'a) \\<le> len M i i xs)\n                       else \\<forall>i\\<le>n.\n                               \\<forall>j\\<le>n.\n                                  M' i j = D M i j n \\<and>\n                                  (\\<forall>i xs.\ni \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n(0::'a) \\<le> len M i i xs))>\\<^sub>t", "unfolding cycle_free_diag_equiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. <mtx_curry_assn n M\n      Mi> fw_impl n\n           Mi <\\<lambda>r.\n                  \\<exists>\\<^sub>AM'.\n                     mtx_curry_assn n M' r *\n                     \\<up>\n                      (if \\<exists>i\\<le>n. M' i i < (0::'a)\n                       then \\<not> cycle_free M n\n                       else \\<forall>i\\<le>n.\n                               \\<forall>j\\<le>n.\n                                  M' i j = D M i j n \\<and>\n                                  cycle_free M n)>\\<^sub>t", "by (rule cons_rule[OF _ _ fw_impl_correct[THEN hfrefD, THEN hn_refineD]])\n   (sep_auto simp: fw_spec_def[unfolded cycle_free_diag_equiv])+"], ["", "subsection \\<open>Alternative Versions for Uncurried Matrices.\\<close>"], ["", "definition \"FWI' = uncurry ooo FWI o curry\""], ["", "lemma fwi_impl'_refine_FWI':\n  \"(fwi_impl' n, RETURN oo PR_CONST (\\<lambda> M. FWI' M n)) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fwi_impl' n,\n     (RETURN \\<circ>\\<circ>\\<circ> PR_CONST) (\\<lambda>M. FWI' M n))\n    \\<in> Id \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding fwi_impl'_def[abs_def] FWI_def[abs_def] FWI'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>M k. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n,\n     (RETURN \\<circ>\\<circ>\\<circ> PR_CONST)\n      (\\<lambda>M.\n          ((\\<lambda>x xa.\n               uncurry \\<circ> (\\<lambda>k. fwi x xa k xa xa)) \\<circ>\n           curry)\n           M n))\n    \\<in> Id \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "using for_rec2_fwi"], ["proof (prove)\nusing this:\n  for_rec2 (\\<lambda>M. fw_upd' M ?k) ?M ?n ?i ?j\n  \\<le> SPEC (\\<lambda>M'. M' = uncurry (fwi (curry ?M) ?n ?k ?i ?j))\n\ngoal (1 subgoal):\n 1. (\\<lambda>M k. for_rec2 (\\<lambda>M. fw_upd' M k) M n n n,\n     (RETURN \\<circ>\\<circ>\\<circ> PR_CONST)\n      (\\<lambda>M.\n          ((\\<lambda>x xa.\n               uncurry \\<circ> (\\<lambda>k. fwi x xa k xa xa)) \\<circ>\n           curry)\n           M n))\n    \\<in> Id \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (force simp: pw_le_iff pw_nres_rel_iff refine_pw_simps)"], ["", "lemmas fwi_impl_refine_FWI' = fwi_impl.refine[FCOMP fwi_impl'_refine_FWI']"], ["", "definition \"FW' = uncurry oo FW o curry\""], ["", "definition \"FW'' n M = FW' M n\""], ["", "lemma fw_impl'_refine_FW'':\n  \"(fw_impl' n, RETURN o PR_CONST (FW'' n)) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fw_impl' n, (RETURN \\<circ>\\<circ> PR_CONST) (FW'' n))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding fw_impl'_def[abs_def] FW''_def[abs_def] FW'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>M. fw' M n n,\n     (RETURN \\<circ>\\<circ> PR_CONST)\n      (\\<lambda>M. (uncurry \\<circ>\\<circ> FW \\<circ> curry) M n))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "using fw'_spec"], ["proof (prove)\nusing this:\n  fw' ?m ?n ?k \\<le> SPEC (\\<lambda>M'. M' = uncurry (fw (curry ?m) ?n ?k))\n\ngoal (1 subgoal):\n 1. (\\<lambda>M. fw' M n n,\n     (RETURN \\<circ>\\<circ> PR_CONST)\n      (\\<lambda>M. (uncurry \\<circ>\\<circ> FW \\<circ> curry) M n))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (force simp: pw_le_iff pw_nres_rel_iff refine_pw_simps)"], ["", "lemmas fw_impl_refine_FW'' = fw_impl.refine[FCOMP fw_impl'_refine_FW'']"], ["", "end"]]}