{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/TS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma TSnopaid: \"(snd (fst (snd (rTS initH) is q))) = []\"", "lemma TSdet_Suc: \"Suc n \\<le> length qs \\<Longrightarrow> TSdet init initH qs (Suc n) = Step (rTS initH) (TSdet init initH qs n) (qs!n)\"", "lemma sndTSdet: \"n\\<le>length xs \\<Longrightarrow> snd (TSdet init initH xs n) = rev (take n xs) @ initH\"", "lemma \n  fixes hs x y\n  assumes \"x\\<noteq>y\"\n  shows oneTS_step :    \"TS_step_d ([x, y], x#y#hs)     y = ((1, []), y # x # y # hs)\"\n    and oneTS_stepyyy:  \"TS_step_d ([x, y], y#x#hs)     y = ((Suc 0, []), y#y#x#hs)\"\n    and oneTS_stepx:    \"TS_step_d ([x, y], x#x#hs)     y = ((0, []), y # x # x # hs)\"\n    and oneTS_stepy:    \"TS_step_d ([x, y], [])         y = ((0, []), [y])\"\n    and oneTS_stepxy:   \"TS_step_d ([x, y], [x])        y = ((0, []), [y, x])\"\n    and oneTS_stepyy:   \"TS_step_d ([x, y], [y])        y = ((Suc 0, []), [y, y])\"\n    and oneTS_stepyx:   \"TS_step_d ([x, y], hs)         x = ((0, []), x # hs)\"", "lemmas oneTS_steps = oneTS_stepx oneTS_stepxy oneTS_stepyx oneTS_stepy oneTS_stepyy oneTS_stepyyy oneTS_step", "lemma TS_inv_sym: \"a\\<noteq>b \\<Longrightarrow> {a,b}={x,y} \\<Longrightarrow> z\\<in>{x,y} \\<Longrightarrow> TS_inv c z [a,b] = TS_inv c z [x,y]\"", "lemma TS_inv'_det: \"TS_inv' s x i = ((\\<exists>hs. s = ((if x=hd i then i else rev i),[x,x]@hs) )\n                      \\<or> s = ((if x=hd i then i else rev i),[]))\"", "lemma TS_inv'_det2: \"TS_inv' (s,h) x i = (\\<exists>hs. (s,h) = ((if x=hd i then i else rev i),[x,x]@hs) )\n                      \\<or>  (s,h) = ((if x=hd i then i else rev i),[])\"", "lemma TS_yx': assumes \"x \\<noteq> y\" \"qs \\<in> lang (Star(Times (Atom y) (Atom x)))\"\n      \"\\<exists>hs. h=[x,y]@hs\"\n   shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = length qs + T_on' (rTS h0) ([x,y],((rev qs) @h))  r\n        \\<and> (\\<exists>hs. ((rev qs) @h) = [x, y] @ hs)\n        \\<and> config' (rTS h0) ([x, y],h) qs = ([x,y],rev qs @ h)\"", "lemma TS_x': \"T_on' (rTS h0) ([x,y],h) [x] = 0 \\<and> config' (rTS h0) ([x, y],h) [x] = ([x,y], rev [x] @ h)\"", "lemma TS_yy': assumes \"x \\<noteq> y\" \"\\<exists>hs. h = [x, y] @ hs\"\n  shows \"T_on' (rTS h0) ([x,y],h) [y, y] = 1\" \"config' (rTS h0) ([x, y],h) [y,y] = ([y,x],rev [y,y] @ h)\"", "lemma TS_yxyx': assumes [simp]: \"x \\<noteq> y\" and \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n  \"(\\<exists>hs. h=[x,x]@hs) \\<or> index h y = length h\"\n  shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = length qs - 1 + T_on' (rTS h0) ([x,y],rev qs @ h) r \n        \\<and> (\\<exists>hs. (rev qs @ h) = [x, y] @ hs)\n            \\<and> config' (rTS h0) ([x, y],h) qs = ([x,y], rev qs @ h)\"", "lemma TS_xr': assumes \"x \\<noteq> y\" \"qs \\<in> lang (Plus (Atom x) One)\"\n   \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs) \"\n  shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = T_on' (rTS h0) ([x,y],rev qs@h) r\"\n          \"((\\<exists>hs. (rev qs @ h) = [x, x] @ hs) \\<or> (rev qs @ h) = [x] \\<or> (rev qs @ h)=[]) \" \n            \"config' (rTS h0) ([x,y],h) (qs@r) = config' (rTS h0) ([x,y],rev qs @ h) r\"", "lemma ts_b': assumes \"x \\<noteq> y\"\n  \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\n            \\<and>  (\\<exists>hs. (rev v @ h) = [y,y]@hs) \\<and> config' (rTS h0) ([x,y], h) v = ([y,x], rev v @ h)\"", "lemma TS_b'1: assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 2)\n       \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\"", "lemma TS_b1'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 2)\"", "lemma ts_b2': assumes \"x \\<noteq> y\"\n  \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 3)\n            \\<and>  config' (rTS h0) ([x,y], h) qs = ([y,x],rev qs@h) \\<and> (\\<exists>hs. (rev qs @ h) = [y,y]@hs)\"", "lemma TS_b2'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 3)\"", "lemma TS_b': assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n   \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\"", "lemma ts_a': assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n   \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  shows \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\n          \\<and> T_on' (rTS h0) ([x, y], h) qs = 2\"", "lemma TS_a': assumes  \"x \\<noteq> y\"\n    \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  and \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y])\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x, y]\n    \\<and> T_on' (rTS h0) ([x, y], h) qs = 2\"", "lemma TS_a'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n shows  \n    \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T\\<^sub>p_on_rand' (embed (rTS h0)) s qs = 2\"", "lemma ts_c': assumes \"x \\<noteq> y\"\n  \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\n            \\<and>  config' (rTS h0) ([x,y], h) v = ([x,y],rev v@h) \\<and> (\\<exists>hs. (rev v @ h) = [x,x]@hs)\"", "lemma TS_c1'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 2)\"", "lemma ts_c2': assumes \"x \\<noteq> y\"\n  \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 3)\n            \\<and>  config' (rTS h0) ([x,y], h) qs = ([x,y],rev qs@h) \\<and> (\\<exists>hs. (rev qs @ h) = [x,x]@hs)\"", "lemma TS_c2'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 3)\"", "lemma TS_c': assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>  TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\"", "lemma request_first: \"x\\<noteq>y \\<Longrightarrow> Step (rTS h) ([x, y], is) x = ([x,y],x#is)\"", "lemma ts_d': \"qs \\<in> Lxx x y \\<Longrightarrow>\n    x \\<noteq> y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs) \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n    T_on' (rTS h0) ([x, y], h) qs = 0 \\<and>\n     TS_inv' (config' (rTS h0) ([x, y], h) qs) x [x,y]\"", "lemma TS_d': assumes xny: \"x \\<noteq> y\" and \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n    and qsis: \"qs \\<in> lang (seq [Atom x, Atom x])\"\n    shows \"T_on' (rTS h0) ([x,y],h) qs \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \"\n      and \"TS_inv' (config' (rTS h0) ([x,y],h) qs)  (last qs) [x, y]\"\n      and \"T_on' (rTS h0) ([x,y],h) qs = 0\"", "lemma TS_d'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = 0\"", "lemma D': assumes \"\\<sigma>' \\<in> Lxx x y\" and \"x \\<noteq> y\" and \"TS_inv' ([x, y], h) x [x, y]\"\n  shows  \"T_on' (rTS h0) ([x, y], h) \\<sigma>' \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \n      \\<and>  TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) \\<sigma>') (last \\<sigma>') [x, y]\"", "theorem TS_OPT2':  \"(x::nat) \\<noteq> y \\<Longrightarrow> set \\<sigma> \\<subseteq> {x,y}\n     \\<Longrightarrow> T\\<^sub>p_on (rTS []) [x,y] \\<sigma>  \\<le> 2 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 2\"", "lemma config'_distinct[simp]: \n  shows \"distinct (fst (config' A S qs)) = distinct (fst S)\"", "lemma config'_set[simp]: \n  shows \"set (fst (config' A S qs)) = set (fst S)\"", "lemma s_TS_append: \"i\\<le>length as \\<Longrightarrow>s_TS init h (as@bs) i = s_TS init h as i\"", "lemma s_TS_distinct: \"distinct init \\<Longrightarrow> i<length qs \\<Longrightarrow> distinct (fst (TSdet init h qs i))\"", "lemma othersdontinterfere: \"distinct init \\<Longrightarrow> i < length qs \\<Longrightarrow> a\\<in>set init \\<Longrightarrow> b\\<in>set init\n     \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> qs!i\\<notin>{a,b} \\<Longrightarrow> a < b in s_TS init h qs i \\<Longrightarrow> a < b in s_TS init h qs (Suc i)\"", "lemma  TS_mono:\n    fixes l::nat\n    assumes 1: \"x < y in s_TS init h xs (length xs)\"\n     and l_in_cs: \"l \\<le> length cs\"\n     and firstocc: \"\\<forall>j<l. cs ! j \\<noteq> y\"\n     and \"x \\<notin> set cs\" \n     and di: \"distinct init\"  \n     and inin: \"set (xs @ cs) \\<subseteq> set init\"\n    shows \"x < y in s_TS init h (xs@cs) (length (xs)+l)\"", "lemma step_no_action: \"step s q (0,[]) = s\"", "lemma s_TS_set: \"i \\<le> length qs \\<Longrightarrow> set (s_TS init h qs i) = set init\"", "lemma count_notin2: \"count_list xs x = 0 \\<Longrightarrow> x \\<notin> set xs\"", "lemma count_append: \"count_list (xs@ys) x = count_list xs x + count_list ys x\"", "lemma count_rev: \"count_list (rev xs) x = count_list xs x\"", "lemma mtf2_q_passes: assumes \"q \\<in> set xs\" \"distinct xs\" \n  and \"index xs q - n \\<le> index xs x\" \"index xs x < index xs q\"\n  shows \"q < x in (mtf2 n q xs)\"", "lemma twotox:\n    assumes \"count_list bs y \\<le> 1\"\n      and \"distinct init\"\n      and \"x \\<in> set init\"\n      and \"y : set init\" \n      and \"x \\<notin> set bs\"\n      and \"x\\<noteq>y\"\n    shows \"x < y in s_TS init h (as@[x]@bs@[x]) (length (as@[x]@bs@[x]))\"", "lemma count_drop: \"count_list (drop n cs) x \\<le> count_list cs x\"", "lemma count_take_less: assumes \"n\\<le>m\" \n  shows \"count_list (take n cs) x \\<le> count_list (take m cs) x\"", "lemma count_take: \"count_list (take n cs) x \\<le> count_list cs x\"", "lemma casexxy: assumes \"\\<sigma>=as@[x]@bs@[x]@cs\"\n    and \"x \\<notin> set cs\"\n    and \"set cs \\<subseteq> set init\"\n    and \"x \\<in> set init\"\n    and \"distinct init\"\n    and \"x \\<notin> set bs\"\n    and \"set as \\<subseteq> set init\"\n    and \"set bs \\<subseteq> set init\"\n  shows \"(%i. i<length cs \\<longrightarrow> (\\<forall>j<i. cs!j\\<noteq>cs!i) \\<longrightarrow> cs!i\\<noteq>x\n      \\<longrightarrow> (cs!i) \\<notin> set bs\n      \\<longrightarrow> x < (cs!i) in  (s_TS init h \\<sigma> (length (as@[x]@bs@[x]) + i+1))) i\"", "lemma nopaid: \"snd (fst (TS_step_d s q)) = []\"", "lemma staysuntouched:\n   assumes d[simp]: \"distinct (fst S)\"\n    and x: \"x \\<in> set (fst S)\"\n    and y: \"y \\<in> set (fst S)\" \n   shows \"set qs \\<subseteq> set (fst S) \\<Longrightarrow> x \\<notin> set qs \\<Longrightarrow> y \\<notin> set qs\n        \\<Longrightarrow> x < y in fst (config' (rTS []) S qs) =  x < y in fst S\"", "lemma staysuntouched':\n   assumes d[simp]: \"distinct init\"\n    and x: \"x \\<in> set init\"\n    and y: \"y \\<in> set init\"\n    and \"set qs \\<subseteq> set init\"\n    and \"x \\<notin> set qs\" and \"y \\<notin> set qs\"\n   shows \"x < y in fst (config (rTS []) init qs) =  x < y in init\"", "lemma projEmpty: \"Lxy qs S = [] \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> set qs\"", "lemma Lxy_index_mono:\n  assumes \"x\\<in>S\" \"y\\<in>S\"\n    and \"index xs x < index xs y\"\n    and \"index xs y < length xs\"\n    and \"x\\<noteq>y\"\n  shows \"index (Lxy xs S) x < index (Lxy xs S) y\"", "lemma proj_Cons: \n  assumes filterd_cons: \"Lxy qs S = a#as\"\n    and a_filter: \"a\\<in>S\"\n  obtains pre suf where \"qs = pre @ [a] @ suf\" and \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre\"\n                  and \"Lxy suf S = as\"", "lemma Lxy_rev: \"rev (Lxy qs S) = Lxy (rev qs) S\"", "lemma proj_Snoc: \n  assumes filterd_cons: \"Lxy qs S = as@[a]\"\n    and a_filter: \"a\\<in>S\"\n  obtains pre suf where \"qs = pre @ [a] @ suf\" and \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf\"\n                  and \"Lxy pre S = as\"", "lemma sndTSconfig': \"snd (config' (rTS initH) (init,[]) qs) = rev qs @ []\"", "lemma projxx: \n  fixes e a bs\n  assumes axy: \"a\\<in>{x,y}\"\n  assumes ane: \"a\\<noteq>e\"\n  assumes exy: \"e\\<in>{x,y}\"\n  assumes add: \"f\\<in>{[],[e]}\" \n  assumes bsaxy: \"set (bs @ [a] @ f) \\<subseteq> {x,y}\"\n  assumes Lxyinitxy: \"Lxy init {x, y} \\<in> {[x,y],[y,x]}\"\n  shows \"a < e in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ f) @ [a]))\"", "lemma oneposs: \n   assumes \"set xs = {x,y}\"\n      assumes \"x\\<noteq>y\"\n      assumes \"distinct xs\"\n      assumes True: \"x<y in xs\"\n      shows \"xs = [x,y]\"", "lemma twoposs: \n   assumes \"set xs = {x,y}\"\n      assumes \"x\\<noteq>y\"\n      assumes \"distinct xs\"\n      shows \"xs \\<in> {[x,y], [y,x]}\"", "lemma TS_pairwise': assumes \"qs \\<in> {xs. set xs \\<subseteq> set init}\"\n       \"(x, y) \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\"\n       \"x \\<noteq> y\" \"distinct init\"\n   shows \"Pbefore_in x y (embed (rTS [])) qs init =\n       Pbefore_in x y (embed (rTS [])) (Lxy qs {x, y}) (Lxy init {x, y})\"", "theorem TS_pairwise: \"pairwise (embed (rTS []))\"", "lemma TS_compet':   \"pairwise (embed (rTS [])) \\<Longrightarrow> \n      \\<forall>s0\\<in>{init::(nat list). distinct init \\<and> init\\<noteq>[]}. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. T\\<^sub>p_on_rand (embed (rTS [])) s0 qs \\<le> (2::real) *  T\\<^sub>p_opt s0 qs + b\"", "lemma TS_compet: \"compet_rand (embed (rTS [])) 2 {init. distinct init \\<and> init \\<noteq> []}\""], "translations": [["", "lemma TSnopaid: \"(snd (fst (snd (rTS initH) is q))) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (snd (rTS initH) is q)) = []", "unfolding rTS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (snd (\\<lambda>s. initH, TS_step_d) is q)) = []", "by(simp add: TS_step_d_def)"], ["", "abbreviation TSdet where\n  \"TSdet init initH qs n == config (rTS initH) init (take n qs)\""], ["", "lemma TSdet_Suc: \"Suc n \\<le> length qs \\<Longrightarrow> TSdet init initH qs (Suc n) = Step (rTS initH) (TSdet init initH qs n) (qs!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<le> length qs \\<Longrightarrow>\n    TSdet init initH qs (Suc n) =\n    Partial_Cost_Model.Step (rTS initH) (TSdet init initH qs n) (qs ! n)", "by(simp add: take_Suc_conv_app_nth config_snoc)"], ["", "(* now do the proof with TSdet *)"], ["", "definition s_TS where \"s_TS init initH qs n  = fst (TSdet init initH qs n)\""], ["", "lemma sndTSdet: \"n\\<le>length xs \\<Longrightarrow> snd (TSdet init initH xs n) = rev (take n xs) @ initH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    snd (TSdet init initH xs n) = rev (take n xs) @ initH", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    snd (TSdet init initH xs 0) = rev (take 0 xs) @ initH\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                snd (TSdet init initH xs n) = rev (take n xs) @ initH;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> snd (TSdet init initH xs (Suc n)) =\n                         rev (take (Suc n) xs) @ initH", "apply(simp add: rTS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                snd (TSdet init initH xs n) = rev (take n xs) @ initH;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> snd (TSdet init initH xs (Suc n)) =\n                         rev (take (Suc n) xs) @ initH", "by(simp add: split_def TS_step_d_def take_Suc_conv_app_nth config'_snoc Step_def rTS_def)"], ["", "subsection \"Behaviour of TS on lists of length 2\""], ["", "lemma \n  fixes hs x y\n  assumes \"x\\<noteq>y\"\n  shows oneTS_step :    \"TS_step_d ([x, y], x#y#hs)     y = ((1, []), y # x # y # hs)\"\n    and oneTS_stepyyy:  \"TS_step_d ([x, y], y#x#hs)     y = ((Suc 0, []), y#y#x#hs)\"\n    and oneTS_stepx:    \"TS_step_d ([x, y], x#x#hs)     y = ((0, []), y # x # x # hs)\"\n    and oneTS_stepy:    \"TS_step_d ([x, y], [])         y = ((0, []), [y])\"\n    and oneTS_stepxy:   \"TS_step_d ([x, y], [x])        y = ((0, []), [y, x])\"\n    and oneTS_stepyy:   \"TS_step_d ([x, y], [y])        y = ((Suc 0, []), [y, y])\"\n    and oneTS_stepyx:   \"TS_step_d ([x, y], hs)         x = ((0, []), x # hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TS_step_d ([x, y], x # y # hs) y = ((1, []), y # x # y # hs) &&&\n     TS_step_d ([x, y], y # x # hs) y = ((Suc 0, []), y # y # x # hs) &&&\n     TS_step_d ([x, y], x # x # hs) y = ((0, []), y # x # x # hs)) &&&\n    (TS_step_d ([x, y], []) y = ((0, []), [y]) &&&\n     TS_step_d ([x, y], [x]) y = ((0, []), [y, x])) &&&\n    TS_step_d ([x, y], [y]) y = ((Suc 0, []), [y, y]) &&&\n    TS_step_d ([x, y], hs) x = ((0, []), x # hs)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (TS_step_d ([x, y], x # y # hs) y = ((1, []), y # x # y # hs) &&&\n     TS_step_d ([x, y], y # x # hs) y = ((Suc 0, []), y # y # x # hs) &&&\n     TS_step_d ([x, y], x # x # hs) y = ((0, []), y # x # x # hs)) &&&\n    (TS_step_d ([x, y], []) y = ((0, []), [y]) &&&\n     TS_step_d ([x, y], [x]) y = ((0, []), [y, x])) &&&\n    TS_step_d ([x, y], [y]) y = ((Suc 0, []), [y, y]) &&&\n    TS_step_d ([x, y], hs) x = ((0, []), x # hs)", "by(auto simp add: step_def mtf2_def swap_def TS_step_d_def before_in_def)"], ["", "lemmas oneTS_steps = oneTS_stepx oneTS_stepxy oneTS_stepyx oneTS_stepy oneTS_stepyy oneTS_stepyyy oneTS_step"], ["", "subsection \"Analysis of the Phases\""], ["", "definition \"TS_inv c x i \\<equiv> (\\<exists>hs. c = return_pmf ((if x=hd i then i else rev i),[x,x]@hs) )\n                      \\<or> c = return_pmf ((if x=hd i then i else rev i),[])\""], ["", "lemma TS_inv_sym: \"a\\<noteq>b \\<Longrightarrow> {a,b}={x,y} \\<Longrightarrow> z\\<in>{x,y} \\<Longrightarrow> TS_inv c z [a,b] = TS_inv c z [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; z \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> TS_inv c z [a, b] = TS_inv c z [x, y]", "unfolding TS_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; z \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>hs.\n                           c =\n                           return_pmf\n                            (if z = hd [a, b] then [a, b] else rev [a, b],\n                             [z, z] @ hs)) \\<or>\n                       c =\n                       return_pmf\n                        (if z = hd [a, b] then [a, b] else rev [a, b],\n                         [])) =\n                      ((\\<exists>hs.\n                           c =\n                           return_pmf\n                            (if z = hd [x, y] then [x, y] else rev [x, y],\n                             [z, z] @ hs)) \\<or>\n                       c =\n                       return_pmf\n                        (if z = hd [x, y] then [x, y] else rev [x, y], []))", "by auto"], ["", "abbreviation \"TS_inv' s x i == TS_inv (return_pmf s) x i\""], ["", "lemma TS_inv'_det: \"TS_inv' s x i = ((\\<exists>hs. s = ((if x=hd i then i else rev i),[x,x]@hs) )\n                      \\<or> s = ((if x=hd i then i else rev i),[]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' s x i =\n    ((\\<exists>hs. s = (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n     s = (if x = hd i then i else rev i, []))", "unfolding TS_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         return_pmf s =\n         return_pmf (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n     return_pmf s = return_pmf (if x = hd i then i else rev i, [])) =\n    ((\\<exists>hs. s = (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n     s = (if x = hd i then i else rev i, []))", "by auto"], ["", "lemma TS_inv'_det2: \"TS_inv' (s,h) x i = (\\<exists>hs. (s,h) = ((if x=hd i then i else rev i),[x,x]@hs) )\n                      \\<or>  (s,h) = ((if x=hd i then i else rev i),[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (s, h) x i =\n    (\\<exists>hs.\n        (s, h) = (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n    (s, h) = (if x = hd i then i else rev i, [])", "unfolding TS_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         return_pmf (s, h) =\n         return_pmf (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n     return_pmf (s, h) = return_pmf (if x = hd i then i else rev i, [])) =\n    (\\<exists>hs.\n        (s, h) = (if x = hd i then i else rev i, [x, x] @ hs)) \\<or>\n    (s, h) = (if x = hd i then i else rev i, [])", "by auto"], ["", "(*\nTS_A   (x+1)yy \\<rightarrow>         Plus(Atom (x::nat)) One,(Atom y), (Atom y)]\nTS_B   (x+1)yx(yx)*yy \\<rightarrow>  Plus(Atom x) One,(Atom y),(Atom x),Star(Times (Atom y)(Atom x)),(Atom y),(Atom y)]\nTS_C   (x+1)yx(yx)*x  \\<rightarrow>  Plus(Atom x) One,(Atom y),(Atom x),Star(Times (Atom y)(Atom x)),(Atom x)]\nTD_D   xx             \\<rightarrow>  seq[(Atom x),(Atom x)]\n*)"], ["", "subsubsection \"(yx)*?\""], ["", "lemma TS_yx': assumes \"x \\<noteq> y\" \"qs \\<in> lang (Star(Times (Atom y) (Atom x)))\"\n      \"\\<exists>hs. h=[x,y]@hs\"\n   shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = length qs + T_on' (rTS h0) ([x,y],((rev qs) @h))  r\n        \\<and> (\\<exists>hs. ((rev qs) @h) = [x, y] @ hs)\n        \\<and> config' (rTS h0) ([x, y],h) qs = ([x,y],rev qs @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))\n  \\<exists>hs. h = [x, y] @ hs", "have \"qs \\<in> star ({[y]} @@ {[x]})\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. qs \\<in> star ({[y]} @@ {[x]})", "by (simp)"], ["proof (state)\nthis:\n  qs \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "from this assms(3)"], ["proof (chain)\npicking this:\n  qs \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. h = [x, y] @ hs", "show ?thesis"], ["proof (prove)\nusing this:\n  qs \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "proof (induct qs arbitrary: h rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n       Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([] @ r) =\n       length [] +\n       Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev [] @ h) r \\<and>\n       (\\<exists>hs. rev [] @ h = [x, y] @ hs) \\<and>\n       Partial_Cost_Model.config' (rTS h0) ([x, y], h) [] =\n       ([x, y], rev [] @ h)\n 2. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "case Nil"], ["proof (state)\nthis:\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n       Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([] @ r) =\n       length [] +\n       Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev [] @ h) r \\<and>\n       (\\<exists>hs. rev [] @ h = [x, y] @ hs) \\<and>\n       Partial_Cost_Model.config' (rTS h0) ([x, y], h) [] =\n       ([x, y], rev [] @ h)\n 2. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "then"], ["proof (chain)\npicking this:\n  \\<exists>hs. h = [x, y] @ hs", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([] @ r) =\n    length [] +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev [] @ h) r \\<and>\n    (\\<exists>hs. rev [] @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) [] =\n    ([x, y], rev [] @ h)", "by(simp add: rTS_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([] @ r) =\n  length [] +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev [] @ h) r \\<and>\n  (\\<exists>hs. rev [] @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) [] = ([x, y], rev [] @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "case (append u v)"], ["proof (state)\nthis:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. ?h = [x, y] @ hs \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], ?h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ ?h) r \\<and>\n  (\\<exists>hs. rev v @ ?h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], ?h) v = ([x, y], rev v @ ?h)\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "then"], ["proof (chain)\npicking this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. ?h = [x, y] @ hs \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], ?h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ ?h) r \\<and>\n  (\\<exists>hs. rev v @ ?h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], ?h) v = ([x, y], rev v @ ?h)\n  \\<exists>hs. h = [x, y] @ hs", "have uyx: \"u = [y,x]\""], ["proof (prove)\nusing this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. ?h = [x, y] @ hs \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], ?h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ ?h) r \\<and>\n  (\\<exists>hs. rev v @ ?h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], ?h) v = ([x, y], rev v @ ?h)\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. u = [y, x]", "by auto"], ["proof (state)\nthis:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "from append"], ["proof (chain)\npicking this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. ?h = [x, y] @ hs \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], ?h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ ?h) r \\<and>\n  (\\<exists>hs. rev v @ ?h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], ?h) v = ([x, y], rev v @ ?h)\n  \\<exists>hs. h = [x, y] @ hs", "obtain hs where a: \"h = [x,y]@hs\""], ["proof (prove)\nusing this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<exists>hs. ?h = [x, y] @ hs \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], ?h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ ?h) r \\<and>\n  (\\<exists>hs. rev v @ ?h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], ?h) v = ([x, y], rev v @ ?h)\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. (\\<And>hs. h = [x, y] @ hs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"T_on' (rTS h0) ([x, y], (rev u @ h)) (v @ r) = length v + T_on' (rTS h0) ([x, y], rev v @ (rev u @ h)) r\n        \\<and> (\\<exists>hs. rev v @ (rev u @ h) = [x, y] @ hs)\n        \\<and> config' (rTS h0) ([x, y], (rev u @ h)) v = ([x, y], rev v @ (rev u @ h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n    length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n    (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([x, y], rev v @ rev u @ h)", "apply(simp only: uyx)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev [y, x] @ h) (v @ r) =\n    length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev [y, x] @ h)\n     r \\<and>\n    (\\<exists>hs. rev v @ rev [y, x] @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev [y, x] @ h) v =\n    ([x, y], rev v @ rev [y, x] @ h)", "apply(rule append(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hs. rev [y, x] @ h = [x, y] @ hs", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)", "have yy: \"T_on' (rTS h0) ([x, y], (rev u @ h)) (v @ r) = length v + T_on' (rTS h0) ([x, y], rev v @ (rev u @ h)) r\"\n          and history: \"(\\<exists>hs. rev v @ (rev u @ h) = [x, y] @ hs)\"\n          and state: \"config' (rTS h0) ([x, y], (rev u @ h)) v = ([x, y], rev v @ (rev u @ h))\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n    length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r &&&\n    \\<exists>hs. rev v @ rev u @ h = [x, y] @ hs &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([x, y], rev v @ rev u @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n  \\<exists>hs. rev v @ rev u @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have s0: \"s_TS [x, y] h [y, x] 0 = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS [x, y] h [y, x] 0 = [x, y]", "unfolding s_TS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet [x, y] h [y, x] 0) = [x, y]", "by(simp)"], ["proof (state)\nthis:\n  s_TS [x, y] h [y, x] 0 = [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "from assms(1)"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have hahah: \" {xa. xa < y in [x, y] \\<and> count_list [x] xa \\<le> 1} = {x}\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. {xa. xa < y in [x, y] \\<and> count_list [x] xa \\<le> 1} = {x}", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. {xa.\n     (index [x, y] xa < index [x, y] y \\<and> y \\<in> set [x, y]) \\<and>\n     count_list [x] xa \\<le> 1} =\n    {x}", "by auto"], ["proof (state)\nthis:\n  {xa. xa < y in [x, y] \\<and> count_list [x] xa \\<le> 1} = {x}\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"config' (rTS h0) ([x, y],h) u = ([x, y], x # y # x # y # hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) u =\n    ([x, y], x # y # x # y # hs)", "apply(simp add: split_def rTS_def uyx a )"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n     (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n       ([x, y], x # y # hs) y)\n     x =\n    ([x, y], x # y # x # y # hs)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n     (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n       ([x, y], x # y # hs) y)\n     x =\n    ([x, y], x # y # x # y # hs)", "by(auto simp add: Step_def oneTS_steps step_def mtf2_def swap_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u =\n  ([x, y], x # y # x # y # hs)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u =\n  ([x, y], x # y # x # y # hs)", "have s2: \"config' (rTS h0) ([x, y],h) u =  ([x, y], ((rev u) @ h))\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u =\n  ([x, y], x # y # x # y # hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], rev u @ h)", "unfolding a uyx"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], [x, y] @ hs) [y, x] =\n  ([x, y], x # y # x # y # hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], [x, y] @ hs) [y, x] =\n    ([x, y], rev [y, x] @ [x, y] @ hs)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], rev u @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"config' (rTS h0) ([x, y], h) (u @ v) = \n            config' (rTS h0) (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.config' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v", "by (rule config'_append2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = config' (rTS h0)  ([x, y], ((rev u) @ h)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v", "by(simp only: s2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = ([x, y], rev (u @ v) @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([x, y], rev (u @ v) @ h)", "by (simp add: state)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev (u @ v) @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  ([x, y], rev (u @ v) @ h)", "have alles: \"config' (rTS h0) ([x, y], h) (u @ v) = ([x, y], rev (u @ v) @ h)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  ([x, y], rev (u @ v) @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    ([x, y], rev (u @ v) @ h)", "."], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  ([x, y], rev (u @ v) @ h)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have ta: \"T_on' (rTS h0) ([x,y],h) u = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 2", "unfolding rTS_def uyx a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d)\n     ([x, y], [x, y] @ hs) [y, x] =\n    2", "apply(simp only: T_on'.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p (fst ([x, y], [x, y] @ hs)) y\n     (fst (snd (\\<lambda>s. h0, TS_step_d) ([x, y], [x, y] @ hs) y)) +\n    (t\\<^sub>p\n      (fst (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n             ([x, y], [x, y] @ hs) y))\n      x (fst (snd (\\<lambda>s. h0, TS_step_d)\n               (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n                 ([x, y], [x, y] @ hs) y)\n               x)) +\n     Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d)\n      (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n        (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n          ([x, y], [x, y] @ hs) y)\n        x)\n      []) =\n    2", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. t\\<^sub>p (fst ([x, y], [x, y] @ hs)) y\n     (fst (snd (\\<lambda>s. h0, TS_step_d) ([x, y], [x, y] @ hs) y)) +\n    (t\\<^sub>p\n      (fst (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n             ([x, y], [x, y] @ hs) y))\n      x (fst (snd (\\<lambda>s. h0, TS_step_d)\n               (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n                 ([x, y], [x, y] @ hs) y)\n               x)) +\n     Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d)\n      (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n        (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n          ([x, y], [x, y] @ hs) y)\n        x)\n      []) =\n    2", "apply(auto simp add: Step_def step_def mtf2_def swap_def oneTS_steps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    t\\<^sub>p [x, y] y (Suc 0, []) + t\\<^sub>p [y, x] x (Suc 0, []) = 2", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 2\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"T_on' (rTS h0) ([x,y],h) ((u @ v) @ r)\n            = T_on' (rTS h0) ([x,y],h) (u @ (v @ r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots>\n        = T_on' (rTS h0) ([x,y],h) u\n            + T_on' (rTS h0) (config' (rTS h0) ([x, y],h) u) (v @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)", "by(rule T_on'_append)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = T_on' (rTS h0) ([x,y],h) u\n          + T_on' (rTS h0) ([x, y],(rev u @ h)) (v @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r)", "by(simp only: s2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r)\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = T_on' (rTS h0) ([x,y],h) u + length v + T_on' (rTS h0) ([x, y], rev v @ (rev u @ h)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r", "by(simp only: yy)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = 2 + length v + T_on' (rTS h0) ([x, y], rev v @ (rev u @ h)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n    2 + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r", "by(simp only: ta)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n  2 + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n  2 + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = length (u @ v) + T_on' (rTS h0) ([x, y], rev v @ (rev u @ h)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n    length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r", "using uyx"], ["proof (prove)\nusing this:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. 2 + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n    length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r", "by auto"], ["proof (state)\nthis:\n  2 + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "also"], ["proof (state)\nthis:\n  2 + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "have \"\\<dots> = length (u @ v) + T_on' (rTS h0) ([x, y], (rev (u @ v) @ h)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n    length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r", "by auto"], ["proof (state)\nthis:\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r\n\ngoal (1 subgoal):\n 1. \\<And>u v h.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<And>h.\n           \\<exists>hs. h = [x, y] @ hs \\<Longrightarrow>\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (v @ r) =\n           length v +\n           Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ h) r \\<and>\n           (\\<exists>hs. rev v @ h = [x, y] @ hs) \\<and>\n           Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n           ([x, y], rev v @ h);\n        \\<exists>hs. h = [x, y] @ hs\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h)\n                          ((u @ v) @ r) =\n                         length (u @ v) +\n                         Partial_Cost_Model.T_on' (rTS h0)\n                          ([x, y], rev (u @ v) @ h) r \\<and>\n                         (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n                         Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                          (u @ v) =\n                         ([x, y], rev (u @ v) @ h)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r", "show ?case"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n    length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r \\<and>\n    (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    ([x, y], rev (u @ v) @ h)", "using history alles"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r\n  \\<exists>hs. rev v @ rev u @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  ([x, y], rev (u @ v) @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n    length (u @ v) +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r \\<and>\n    (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    ([x, y], rev (u @ v) @ h)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ((u @ v) @ r) =\n  length (u @ v) +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev (u @ v) @ h) r \\<and>\n  (\\<exists>hs. rev (u @ v) @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  ([x, y], rev (u @ v) @ h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  length qs +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n  (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"?x\""], ["", "lemma TS_x': \"T_on' (rTS h0) ([x,y],h) [x] = 0 \\<and> config' (rTS h0) ([x, y],h) [x] = ([x,y], rev [x] @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [x] = 0 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) [x] =\n    ([x, y], rev [x] @ h)", "by(auto simp add: t\\<^sub>p_def rTS_def TS_step_d_def Step_def step_def)"], ["", "subsubsection \"?yy\""], ["", "lemma TS_yy': assumes \"x \\<noteq> y\" \"\\<exists>hs. h = [x, y] @ hs\"\n  shows \"T_on' (rTS h0) ([x,y],h) [y, y] = 1\" \"config' (rTS h0) ([x, y],h) [y,y] = ([y,x],rev [y,y] @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [y, y] = 1 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n    ([y, x], rev [y, y] @ h)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [y, y] = 1\n 2. Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n    ([y, x], rev [y, y] @ h)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  \\<exists>hs. h = [x, y] @ hs", "obtain hs where a: \"h = [x,y]@hs\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<exists>hs. h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. (\\<And>hs. h = [x, y] @ hs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = [x, y] @ hs\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [y, y] = 1\n 2. Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n    ([y, x], rev [y, y] @ h)", "from a"], ["proof (chain)\npicking this:\n  h = [x, y] @ hs", "show \"T_on' (rTS h0) ([x,y],h) [y, y] = 1\""], ["proof (prove)\nusing this:\n  h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [y, y] = 1", "unfolding rTS_def"], ["proof (prove)\nusing this:\n  h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n     [y, y] =\n    1", "using assms(1)"], ["proof (prove)\nusing this:\n  h = [x, y] @ hs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n     [y, y] =\n    1", "apply(auto simp add: oneTS_steps Step_def step_def mtf2_def swap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h = x # y # hs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] y (Suc 0, []) +\n                      t\\<^sub>p [y, x] y (0, []) =\n                      Suc 0", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [y, y] = 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n    ([y, x], rev [y, y] @ h)", "show \"config' (rTS h0) ([x, y],h) [y,y] = ([y,x],rev [y,y] @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n    ([y, x], rev [y, y] @ h)", "unfolding rTS_def a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (\\<lambda>s. h0, TS_step_d)\n     ([x, y], [x, y] @ hs) [y, y] =\n    ([y, x], rev [y, y] @ [x, y] @ hs)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (\\<lambda>s. h0, TS_step_d)\n     ([x, y], [x, y] @ hs) [y, y] =\n    ([y, x], rev [y, y] @ [x, y] @ hs)", "by(simp add: Step_def oneTS_steps step_def mtf2_def swap_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) [y, y] =\n  ([y, x], rev [y, y] @ h)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"yx(yx)*?\""], ["", "lemma TS_yxyx': assumes [simp]: \"x \\<noteq> y\" and \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n  \"(\\<exists>hs. h=[x,x]@hs) \\<or> index h y = length h\"\n  shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = length qs - 1 + T_on' (rTS h0) ([x,y],rev qs @ h) r \n        \\<and> (\\<exists>hs. (rev qs @ h) = [x, y] @ hs)\n            \\<and> config' (rTS h0) ([x, y],h) qs = ([x,y], rev qs @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "obtain u v where uu: \"u \\<in> lang (Times (Atom y) (Atom x))\"\n                      and vv: \"v \\<in> lang (seq[ Star(Times (Atom y) (Atom x))])\"\n                      and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (Times (Atom y) (Atom x));\n         v \\<in> lang (seq [Star (Times (Atom y) (Atom x))]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (Times (Atom y) (Atom x));\n         v \\<in> lang (seq [Star (Times (Atom y) (Atom x))]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (Times (Atom y) (Atom x))\n  v \\<in> lang (seq [Star (Times (Atom y) (Atom x))])\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (Times (Atom y) (Atom x))", "have uyx: \"u = [y,x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (Times (Atom y) (Atom x))\n\ngoal (1 subgoal):\n 1. u = [y, x]", "by(auto)"], ["proof (state)\nthis:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "from qsuv uyx"], ["proof (chain)\npicking this:\n  qs = u @ v\n  u = [y, x]", "have vqs: \"length v = length qs - 2\""], ["proof (prove)\nusing this:\n  qs = u @ v\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. length v = length qs - 2", "by auto"], ["proof (state)\nthis:\n  length v = length qs - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "from qsuv uyx"], ["proof (chain)\npicking this:\n  qs = u @ v\n  u = [y, x]", "have vqs2: \"length v + 1 = length qs - 1\""], ["proof (prove)\nusing this:\n  qs = u @ v\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. length v + 1 = length qs - 1", "by auto"], ["proof (state)\nthis:\n  length v + 1 = length qs - 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have firststep: \"TS_step_d ([x, y], h) y = ((0, []), y # h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_step_d ([x, y], h) y = ((0, []), y # h)", "proof (cases \"index h y = length h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. index h y = length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)\n 2. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "case True"], ["proof (state)\nthis:\n  index h y = length h\n\ngoal (2 subgoals):\n 1. index h y = length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)\n 2. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "then"], ["proof (chain)\npicking this:\n  index h y = length h", "show ?thesis"], ["proof (prove)\nusing this:\n  index h y = length h\n\ngoal (1 subgoal):\n 1. TS_step_d ([x, y], h) y = ((0, []), y # h)", "unfolding TS_step_d_def"], ["proof (prove)\nusing this:\n  index h y = length h\n\ngoal (1 subgoal):\n 1. ((let li = index (snd ([x, y], h)) y\n      in if li = length (snd ([x, y], h)) then 0\n         else let sincelast = take li (snd ([x, y], h));\n                  S = {xa.\n                       xa < y in fst ([x, y], h) \\<and>\n                       count_list sincelast xa \\<le> 1}\n              in if S = {} then 0\n                 else index (fst ([x, y], h)) y -\n                      Min (index (fst ([x, y], h)) ` S),\n      []),\n     y # snd ([x, y], h)) =\n    ((0, []), y # h)", "by(simp)"], ["proof (state)\nthis:\n  TS_step_d ([x, y], h) y = ((0, []), y # h)\n\ngoal (1 subgoal):\n 1. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "case False"], ["proof (state)\nthis:\n  index h y \\<noteq> length h\n\ngoal (1 subgoal):\n 1. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "with assms(3)"], ["proof (chain)\npicking this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\n  index h y \\<noteq> length h", "obtain hs where a: \"h = [x,x]@hs\""], ["proof (prove)\nusing this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\n  index h y \\<noteq> length h\n\ngoal (1 subgoal):\n 1. (\\<And>hs. h = [x, x] @ hs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h = [x, x] @ hs\n\ngoal (1 subgoal):\n 1. index h y \\<noteq> length h \\<Longrightarrow>\n    TS_step_d ([x, y], h) y = ((0, []), y # h)", "then"], ["proof (chain)\npicking this:\n  h = [x, x] @ hs", "show ?thesis"], ["proof (prove)\nusing this:\n  h = [x, x] @ hs\n\ngoal (1 subgoal):\n 1. TS_step_d ([x, y], h) y = ((0, []), y # h)", "by(simp add: oneTS_steps)"], ["proof (state)\nthis:\n  TS_step_d ([x, y], h) y = ((0, []), y # h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  TS_step_d ([x, y], h) y = ((0, []), y # h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have s2: \"config' (rTS h0) ([x,y],h) u = ([x, y], x # y # h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], x # y # h)", "unfolding rTS_def uyx"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n     [y, x] =\n    ([x, y], x # y # h)", "apply(simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n     (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d) ([x, y], h) y) x =\n    ([x, y], x # y # h)", "unfolding Step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (a, ya) =\n           snd (\\<lambda>s. h0, TS_step_d)\n            (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n             in (step (fst ([x, y], h)) y a, ya))\n            x\n     in (step\n          (fst (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n                in (step (fst ([x, y], h)) y a, ya)))\n          x a,\n         ya)) =\n    ([x, y], x # y # h)", "by(simp add: firststep step_def oneTS_steps)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], x # y # h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have ta: \"T_on' (rTS h0) ([x,y],h) u = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 1", "unfolding rTS_def uyx"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n     [y, x] =\n    1", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (fst (TS_step_d ([x, y], h) y)) +\n    t\\<^sub>p\n     (fst (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n            y))\n     x (fst (TS_step_d\n              (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n                ([x, y], h) y)\n              x)) =\n    Suc 0", "apply(simp add: firststep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) +\n    t\\<^sub>p\n     (fst (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d) ([x, y], h)\n            y))\n     x (fst (TS_step_d\n              (Partial_Cost_Model.Step (\\<lambda>s. h0, TS_step_d)\n                ([x, y], h) y)\n              x)) =\n    Suc 0", "unfolding Step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) +\n    t\\<^sub>p\n     (fst (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n           in (step (fst ([x, y], h)) y a, ya)))\n     x (fst (TS_step_d\n              (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n               in (step (fst ([x, y], h)) y a, ya))\n              x)) =\n    Suc 0", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) +\n    t\\<^sub>p\n     (fst (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n           in (step (fst ([x, y], h)) y a, ya)))\n     x (fst (TS_step_d\n              (let (a, ya) = snd (\\<lambda>s. h0, TS_step_d) ([x, y], h) y\n               in (step (fst ([x, y], h)) y a, ya))\n              x)) =\n    Suc 0", "by (simp add: firststep step_def oneTS_steps t\\<^sub>p_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have ttt: \n    \"T_on' (rTS h0) ([x,y],rev u @ h) (v@r) = length v + T_on' (rTS h0) ([x,y],((rev v) @(rev u @ h)))  r\n      \\<and> (\\<exists>hs. ((rev v) @(rev u @ h)) = [x, y] @ hs)\n      \\<and> config' (rTS h0) ([x, y],(rev u @ h)) v = ([x,y],rev v @ (rev u @ h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n    length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n    (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([x, y], rev v @ rev u @ h)", "apply(rule TS_yx')"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<noteq> y\n 2. v \\<in> lang (Star (Times (Atom y) (Atom x)))\n 3. \\<exists>hs. rev u @ h = [x, y] @ hs", "apply(fact)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))\n 2. \\<exists>hs. rev u @ h = [x, y] @ hs", "using vv"], ["proof (prove)\nusing this:\n  v \\<in> lang (seq [Star (Times (Atom y) (Atom x))])\n\ngoal (2 subgoals):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))\n 2. \\<exists>hs. rev u @ h = [x, y] @ hs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hs. rev u @ h = [x, y] @ hs", "using uyx"], ["proof (prove)\nusing this:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. \\<exists>hs. rev u @ h = [x, y] @ hs", "by(simp)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)", "have tat: \"T_on' (rTS h0) ([x,y], x # y # h) (v@r) = \n          length v + T_on' (rTS h0) ([x,y],rev qs @ h)  r\" \n        and history:  \"(\\<exists>hs. (rev qs @ h) = [x, y] @ hs)\"                                \n        and state: \"config' (rTS h0) ([x, y], x # y # h) v = ([x,y],rev qs @ h)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n    length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r &&&\n    \\<exists>hs. rev qs @ h = [x, y] @ hs &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], x # y # h) v =\n    ([x, y], rev qs @ h)", "using qsuv uyx"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) (v @ r) =\n  length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev v @ rev u @ h) r \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n  qs = u @ v\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n    length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r &&&\n    \\<exists>hs. rev qs @ h = [x, y] @ hs &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], x # y # h) v =\n    ([x, y], rev qs @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n  length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n  \\<exists>hs. rev qs @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], x # y # h) v =\n  ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"config' (rTS h0) ([x, y], h) qs = config' (rTS h0) (config' (rTS h0) ([x, y], h) u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    Partial_Cost_Model.config' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v", "unfolding qsuv"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.config' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v", "by (rule config'_append2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots> = ([x, y], rev qs @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n    ([x, y], rev qs @ h)", "by(simp add: s2 state)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n  ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)", "have his: \"config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "."], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"T_on' (rTS h0) ([x,y],h) (qs@r) = T_on' (rTS h0) ([x,y],h) (u @ v @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)", "using qsuv"], ["proof (prove)\nusing this:\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots>\n      = T_on' (rTS h0) ([x,y],h) u + T_on' (rTS h0) (config' (rTS h0) ([x,y],h) u) (v @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)", "by(rule T_on'_append)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots> = T_on' (rTS h0) ([x,y],h) u + T_on' (rTS h0) ([x, y], x # y # h) (v @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r)", "by(simp only: s2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots> = T_on' (rTS h0) ([x,y],h) u + length v + T_on' (rTS h0) ([x,y],rev qs @ h) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r", "by (simp only: tat)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # y # h) (v @ r) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots> = 1 + length v + T_on' (rTS h0) ([x,y],rev qs @ h) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n    1 + length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r", "by(simp only: ta)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n  1 + length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + length v +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n  1 + length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "have \"\\<dots> = length qs - 1 + T_on' (rTS h0) ([x,y],rev qs @ h) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n    length qs - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r", "using vqs2"], ["proof (prove)\nusing this:\n  length v + 1 = length qs - 1\n\ngoal (1 subgoal):\n 1. 1 + length v +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n    length qs - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r", "by auto"], ["proof (state)\nthis:\n  1 + length v + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r =\n  length qs - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  length qs - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  length qs - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n    (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    \\<exists>hs. rev qs @ h = [x, y] @ hs\n 2. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "using history"], ["proof (prove)\nusing this:\n  \\<exists>hs. rev qs @ h = [x, y] @ hs\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    \\<exists>hs. rev qs @ h = [x, y] @ hs\n 2. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "using his"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    length qs - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h)\n     r \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n  length qs - 1 +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r \\<and>\n  (\\<exists>hs. rev qs @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_xr': assumes \"x \\<noteq> y\" \"qs \\<in> lang (Plus (Atom x) One)\"\n   \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs) \"\n  shows \"T_on' (rTS h0) ([x,y],h) (qs@r) = T_on' (rTS h0) ([x,y],rev qs@h) r\"\n          \"((\\<exists>hs. (rev qs @ h) = [x, x] @ hs) \\<or> (rev qs @ h) = [x] \\<or> (rev qs @ h)=[]) \" \n            \"config' (rTS h0) ([x,y],h) (qs@r) = config' (rTS h0) ([x,y],rev qs @ h) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r &&&\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs) \\<or>\n    rev qs @ h = [x] \\<or> rev qs @ h = [] &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev qs @ h) r", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  qs \\<in> lang (question (Atom x))\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev qs @ h) r &&&\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs) \\<or>\n    rev qs @ h = [x] \\<or> rev qs @ h = [] &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (qs @ r) =\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev qs @ h) r", "by (auto simp add: T_on'_append Step_def rTS_def TS_step_d_def step_def t\\<^sub>p_def)"], ["", "subsubsection \"(x+1)yx(yx)*yy\""], ["", "lemma ts_b': assumes \"x \\<noteq> y\"\n  \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\n            \\<and>  (\\<exists>hs. (rev v @ h) = [y,y]@hs) \\<and> config' (rTS h0) ([x,y], h) v = ([y,x], rev v @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []", "have lenvmod: \"length v mod 2 = 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "assume \"v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\""], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in> {[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[y]} @@ {[y]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}", "have \"p = [y,x]\" \"r=[y,y]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [y, y]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]", "have a: \"length v = 4+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v = 4 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 4 + length q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = 0", "from a b"], ["proof (chain)\npicking this:\n  length v = 4 + length q\n  length q mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length v = 4 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "with assms(1,3)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n  length v mod 2 = 0", "have fall: \"(\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n  length v mod 2 = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h", "by(auto)"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom y, Atom y])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                      and \"b \\<in> lang (seq[Atom y, Atom y])\"\n                      and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom y, Atom y]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "then"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b", "have bb: \"b=[y,y]\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. b = [y, y]", "by auto"], ["proof (state)\nthis:\n  b = [y, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from aa"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])", "have lena: \"length a > 0\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. 0 < length a", "by auto"], ["proof (state)\nthis:\n  0 < length a\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from TS_yxyx'[OF assms(1) aa fall]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (a @ ?r) =\n  length a - 1 +\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev a @ h) ?r \\<and>\n  (\\<exists>hs. rev a @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) a = ([x, y], rev a @ h)", "have stars: \"T_on' (rTS h0) ([x, y], h) (a @ b) =\n    length a - 1 + T_on' (rTS h0) ([x, y], rev a @ h) b\" \n    and history: \"(\\<exists>hs. rev a @ h = [x, y] @ hs)\"\n    and state: \"config' (rTS h0) ([x, y], h) a = ([x,y],rev a @ h)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (a @ ?r) =\n  length a - 1 +\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev a @ h) ?r \\<and>\n  (\\<exists>hs. rev a @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) a = ([x, y], rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n    length a - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b &&&\n    \\<exists>hs. rev a @ h = [x, y] @ hs &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) a = ([x, y], rev a @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) a = ([x, y], rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "(* \"T_on' (rTS h0) ([x,y],h) [y, y] = 1\" \"config' (rTS h0) ([x, y],h) [y,y] = ([y,x],rev [y,y] @ h)\" *)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) a = ([x, y], rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "have suffix: \"T_on' (rTS h0) ([x, y], rev a @ h) b = 1\"                                                       \n     and jajajaj: \"config' (rTS h0) ([x, y],rev a @ h) b = ([y,x],rev b @ rev a @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 1 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) b =\n    ([y, x], rev b @ rev a @ h)", "unfolding bb"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) [y, y] = 1 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) [y, y] =\n    ([y, x], rev [y, y] @ rev a @ h)", "using TS_yy' history assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; \\<exists>hs. ?h = [?x, ?y] @ hs\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS ?h0.0) ([?x, ?y], ?h)\n                     [?y, ?y] =\n                    1\n  \\<lbrakk>?x \\<noteq> ?y; \\<exists>hs. ?h = [?x, ?y] @ hs\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.config' (rTS ?h0.0) ([?x, ?y], ?h)\n                     [?y, ?y] =\n                    ([?y, ?x], rev [?y, ?y] @ ?h)\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) [y, y] = 1 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) [y, y] =\n    ([y, x], rev [y, y] @ rev a @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 1\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) b =\n  ([y, x], rev b @ rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from stars suffix"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 1", "have \"T_on' (rTS h0) ([x, y], h) (a @ b) = length a\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a", "using lena"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 1\n  0 < length a\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a", "have whatineed: \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2", "using vab bb"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a\n  v = a @ b\n  b = [y, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "have grgr:\"config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "unfolding vab"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) (a @ b) =\n    ([y, x], rev (a @ b) @ h)", "apply(simp only: config'_append2 state jajajaj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([y, x], rev b @ rev a @ h) = ([y, x], rev (a @ b) @ h)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "from history"], ["proof (chain)\npicking this:\n  \\<exists>hs. rev a @ h = [x, y] @ hs", "obtain hs' where \"rev a @ h = [x, y] @ hs'\""], ["proof (prove)\nusing this:\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. (\\<And>hs'.\n        rev a @ h = [x, y] @ hs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rev a @ h = [x, y] @ hs'\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "then"], ["proof (chain)\npicking this:\n  rev a @ h = [x, y] @ hs'", "obtain hs2 where reva: \"rev a @ h = x # hs2\""], ["proof (prove)\nusing this:\n  rev a @ h = [x, y] @ hs'\n\ngoal (1 subgoal):\n 1. (\\<And>hs2.\n        rev a @ h = x # hs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rev a @ h = x # hs2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "using whatineed grgr"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)", "by(auto simp add: reva vab bb)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n  (\\<exists>hs. rev v @ h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([y, x], rev v @ h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_b'1: assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 2)\n       \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have f: \"qs \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from ts_b'[OF assms(1) f] assms(2)"], ["proof (chain)\npicking this:\n  (\\<exists>hs. ?h = [x, x] @ hs) \\<or>\n  ?h = [x] \\<or> ?h = [] \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], ?h) qs =\n  length qs - 2 \\<and>\n  (\\<exists>hs. rev qs @ ?h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], ?h) qs =\n  ([y, x], rev qs @ ?h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "have\n              T_star: \"T_on' (rTS h0) ([x, y], h) qs = length qs - 2\"\n          and inv1:   \"config' (rTS h0) ([x, y],  h) qs = ([y, x], rev qs @ h)\"\n          and inv2:   \"(\\<exists>hs. rev qs @ h = [y, y] @ hs)\""], ["proof (prove)\nusing this:\n  (\\<exists>hs. ?h = [x, x] @ hs) \\<or>\n  ?h = [x] \\<or> ?h = [] \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], ?h) qs =\n  length qs - 2 \\<and>\n  (\\<exists>hs. rev qs @ ?h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], ?h) qs =\n  ([y, x], rev qs @ ?h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) &&&\n    \\<exists>hs. rev qs @ h = [y, y] @ hs", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n  \\<exists>hs. rev qs @ h = [y, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from T_star"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2", "have TS: \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 2)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2", "by metis"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have lqs: \"last qs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last qs = y", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by force"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from inv1"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)", "have inv: \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x, y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(simp add: lqs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    TS_inv' ([y, x], rev qs @ h) y [x, y]", "apply(subst TS_inv'_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([y, x], rev qs @ h) =\n        (if y = hd [x, y] then [x, y] else rev [x, y], [y, y] @ hs)) \\<or>\n    ([y, x], rev qs @ h) =\n    (if y = hd [x, y] then [x, y] else rev [x, y], [])", "using assms(2) inv2"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  \\<exists>hs. rev qs @ h = [y, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([y, x], rev qs @ h) =\n        (if y = hd [x, y] then [x, y] else rev [x, y], [y, y] @ hs)) \\<or>\n    ([y, x], rev qs @ h) =\n    (if y = hd [x, y] then [x, y] else rev [x, y], [])", "by(simp)"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "unfolding TS"], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs - 2 = length qs - 2 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "by(fact inv)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 2 \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_b1'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "assume A: \"x \\<noteq> y\"\n        and B: \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n        and C: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "have C': \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []", "by blast"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "from B"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = length qs - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "using ts_b'[OF A B C'] A lqs"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 2 \\<and>\n  (\\<exists>hs. rev qs @ h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([y, x], rev qs @ h)\n  x \\<noteq> y\n  last qs = y\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "unfolding TS_inv'_det"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 2 \\<and>\n  (\\<exists>hs. rev qs @ h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([y, x], rev qs @ h)\n  x \\<noteq> y\n  last qs = y\n\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     (if last qs = hd [x, y] then [x, y] else rev [x, y], [])) \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  real (length qs - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?ya2,\n                Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "note b1=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?ya2,\n                Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(rule b1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule b1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n  real (length qs - 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_b2': assumes \"x \\<noteq> y\"\n  \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 3)\n            \\<and>  config' (rTS h0) ([x,y], h) qs = ([y,x],rev qs@h) \\<and> (\\<exists>hs. (rev qs @ h) = [y,y]@hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "obtain v where qs: \"qs = [x]@v\"\n          and V: \"v\\<in>lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>qs = [x] @ v;\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y,\n                        Atom y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs = [x] @ v\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "from assms(3)"], ["proof (chain)\npicking this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []", "have 3: \"(\\<exists>hs. x#h = [x, x] @ hs) \\<or> x#h = [x] \\<or> x#h = []\""], ["proof (prove)\nusing this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. x # h = [x, x] @ hs) \\<or> x # h = [x] \\<or> x # h = []", "by auto"], ["proof (state)\nthis:\n  (\\<exists>hs. x # h = [x, x] @ hs) \\<or> x # h = [x] \\<or> x # h = []\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "from ts_b'[OF assms(1) V 3]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], x # h) v =\n  length v - 2 \\<and>\n  (\\<exists>hs. rev v @ x # h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], x # h) v =\n  ([y, x], rev v @ x # h)", "have T: \"T_on' (rTS h0) ([x, y], x#h) v = length v - 2\"\n    and C: \"config' (rTS h0) ([x, y], x#h) v = ([y, x], rev v @ x#h)\"\n    and H: \"(\\<exists>hs. rev v @ x#h = [y, y] @ hs)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], x # h) v =\n  length v - 2 \\<and>\n  (\\<exists>hs. rev v @ x # h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], x # h) v =\n  ([y, x], rev v @ x # h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # h) v = length v - 2 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], x # h) v =\n    ([y, x], rev v @ x # h) &&&\n    \\<exists>hs. rev v @ x # h = [y, y] @ hs", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # h) v = length v - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], x # h) v =\n  ([y, x], rev v @ x # h)\n  \\<exists>hs. rev v @ x # h = [y, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "have t: \"t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0", "by (simp add: step_def rTS_def TS_step_d_def t\\<^sub>p_def)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "have c: \"Partial_Cost_Model.Step (rTS h0) ([x, y], h) x\n            = ([x,y], x#h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (rTS h0) ([x, y], h) x = ([x, y], x # h)", "by (simp add: Step_def rTS_def TS_step_d_def step_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.Step (rTS h0) ([x, y], h) x = ([x, y], x # h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [y, y] @ hs)", "unfolding qs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([x] @ v) =\n    length ([x] @ v) - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([y, x], rev ([x] @ v) @ h) \\<and>\n    (\\<exists>hs. rev ([x] @ v) @ h = [y, y] @ hs)", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([x] @ v) =\n    length ([x] @ v) - 3\n 2. Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([y, x], rev ([x] @ v) @ h)\n 3. \\<exists>hs. rev ([x] @ v) @ h = [y, y] @ hs", "apply(simp add: T_on'_append T c t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([y, x], rev ([x] @ v) @ h)\n 2. \\<exists>hs. rev ([x] @ v) @ h = [y, y] @ hs", "apply(simp add: config'_rand_append C c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hs. rev ([x] @ v) @ h = [y, y] @ hs", "using H"], ["proof (prove)\nusing this:\n  \\<exists>hs. rev v @ x # h = [y, y] @ hs\n\ngoal (1 subgoal):\n 1. \\<exists>hs. rev ([x] @ v) @ h = [y, y] @ hs", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n  ([y, x], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [y, y] @ hs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_b2'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "assume A: \"x \\<noteq> y\"\n        and B: \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n        and C: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from B"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from C"], ["proof (chain)\npicking this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "have C': \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\""], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []", "by blast"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = length qs - 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "using ts_b2'[OF A B C'] A lqs"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([y, x], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [y, y] @ hs)\n  x \\<noteq> y\n  last qs = y\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "unfolding TS_inv'_det"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([y, x], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [y, y] @ hs)\n  x \\<noteq> y\n  last qs = y\n\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     (if last qs = hd [x, y] then [x, y] else rev [x, y], [])) \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  real (length qs - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Atom ?xa2, Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?ya2,\n                Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "note b2=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Atom ?xa2, Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?ya2,\n                Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(rule b2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule b2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n  real (length qs - 3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_b': assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n   \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "obtain u v where uu: \"u \\<in> lang (Plus (Atom x) One)\"\n        and vv: \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n        and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y, Atom y]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y, Atom y]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (question (Atom x))\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from TS_xr'[OF assms(1) uu assms(2)]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) ?r", "have\n              T_pre: \"T_on' (rTS h0) ([x, y], h) (u @ v) = \n                        T_on' (rTS h0) ([x, y], rev u @ h) v\"\n          and fall': \"(\\<exists>hs. (rev u @ h) = [x, x] @ hs) \\<or> (rev u @ h) = [x] \\<or> (rev u @ h)=[]\"\n          and conf: \"config' (rTS h0) ([x,y],h) (u@v) = config' (rTS h0) ([x,y],rev u @ h) v\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v &&&\n    (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n    rev u @ h = [x] \\<or> rev u @ h = [] &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "with assms uu"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n  u \\<in> lang (question (Atom x))\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v", "have fall: \"(\\<exists>hs. (rev u @ h) = [x, x] @ hs) \\<or> index (rev u @ h) y = length (rev u @ h)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n  u \\<in> lang (question (Atom x))\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n    index (rev u @ h) y = length (rev u @ h)", "by(auto)"], ["proof (state)\nthis:\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  index (rev u @ h) y = length (rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from ts_b'[OF assms(1) vv fall']"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  length v - 2 \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  ([y, x], rev v @ rev u @ h)", "have\n              T_star: \"T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\"\n          and inv1:   \"config' (rTS h0) ([x, y], rev u @ h) v = ([y, x], rev v @ rev u @ h)\"\n          and inv2:   \"(\\<exists>hs. rev v @ rev u @ h = [y, y] @ hs)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  length v - 2 \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [y, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  ([y, x], rev v @ rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v =\n    length v - 2 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([y, x], rev v @ rev u @ h) &&&\n    \\<exists>hs. rev v @ rev u @ h = [y, y] @ hs", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([y, x], rev v @ rev u @ h)\n  \\<exists>hs. rev v @ rev u @ h = [y, y] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from T_pre T_star qsuv"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  qs = u @ v", "have TS: \"T_on' (rTS h0) ([x, y], h) qs = (length v - 2)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2", "by metis"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "(* OPT *)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (question (Atom x))", "have uuu: \"u=[] \\<or> u=[x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. u = [] \\<or> u = [x]", "by auto"], ["proof (state)\nthis:\n  u = [] \\<or> u = [x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have vvv: \"v \\<in> lang (seq\n          [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                   Atom y])", "by(auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                 Atom y])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have OPT: \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "apply(rule OPT2_B)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. qs = ?u @ v\n 3. ?u = [] \\<or> ?u = [x]\n 4. v \\<in> lang\n             (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])", "by(fact)+"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have lqs: \"last qs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last qs = y", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by force"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have \"config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h)", "unfolding qsuv conf inv1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([y, x], rev v @ rev u @ h) = ([y, x], rev (u @ v) @ h)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)", "have inv: \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x, y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(simp add: lqs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    TS_inv' ([y, x], rev qs @ h) y [x, y]", "apply(subst TS_inv'_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([y, x], rev qs @ h) =\n        (if y = hd [x, y] then [x, y] else rev [x, y], [y, y] @ hs)) \\<or>\n    ([y, x], rev qs @ h) =\n    (if y = hd [x, y] then [x, y] else rev [x, y], [])", "using assms(2) inv2 qsuv"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  \\<exists>hs. rev v @ rev u @ h = [y, y] @ hs\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([y, x], rev qs @ h) =\n        (if y = hd [x, y] then [x, y] else rev [x, y], [y, y] @ hs)) \\<or>\n    ([y, x], rev qs @ h) =\n    (if y = hd [x, y] then [x, y] else rev [x, y], [])", "by(simp)"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "unfolding TS OPT"], ["proof (prove)\ngoal (1 subgoal):\n 1. length v - 2 \\<le> 2 * (length v div 2) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length v - 2 \\<le> 2 * (length v div 2)\n 2. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "by(fact inv)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"(x+1)yy\""], ["", "lemma ts_a': assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n   \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  shows \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\n          \\<and> T_on' (rTS h0) ([x, y], h) qs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "obtain u v where uu: \"u \\<in> lang (Plus (Atom x) One)\"\n        and vv: \"v \\<in> lang (seq[Atom y, Atom y])\"\n        and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang (seq [Atom y, Atom y]); qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang (seq [Atom y, Atom y]); qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (question (Atom x))\n  v \\<in> lang (seq [Atom y, Atom y])\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang (seq [Atom y, Atom y])", "have vv2: \"v = [y,y]\""], ["proof (prove)\nusing this:\n  v \\<in> lang (seq [Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v = [y, y]", "by auto"], ["proof (state)\nthis:\n  v = [y, y]\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (question (Atom x))", "have TS_prefix: \" T_on' (rTS h0) ([x, y], h) u = 0\""], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 0", "using assms(1)"], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 0", "by(auto simp add: rTS_def oneTS_steps t\\<^sub>p_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u = 0\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have h_split: \"rev u @ h = [] \\<or> rev u @ h = [x] \\<or> (\\<exists> hs. rev u @ h = [x,x]@hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev u @ h = [] \\<or>\n    rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)", "using assms(3) uu"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. rev u @ h = [] \\<or>\n    rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)", "by(auto)"], ["proof (state)\nthis:\n  rev u @ h = [] \\<or>\n  rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "then"], ["proof (chain)\npicking this:\n  rev u @ h = [] \\<or>\n  rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)", "have e: \"T_on' (rTS h0) ([x,y],rev u @ h) [y,y] = 2\""], ["proof (prove)\nusing this:\n  rev u @ h = [] \\<or>\n  rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] = 2", "using assms(1)"], ["proof (prove)\nusing this:\n  rev u @ h = [] \\<or>\n  rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] = 2", "apply(auto simp add: rTS_def\n              oneTS_steps\n              Step_def step_def t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] = 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have conf: \"config' (rTS h0) ([x, y], h) u = ([x,y], rev u @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], rev u @ h)", "using uu"], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], rev u @ h)", "by(auto simp add: Step_def rTS_def TS_step_d_def step_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) u = ([x, y], rev u @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have \"T_on' (rTS h0) ([x, y], h) qs = T_on' (rTS h0) ([x, y], h) (u @ v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v)", "using qsuv"], ["proof (prove)\nusing this:\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have \"\\<dots>\n      =T_on' (rTS h0) ([x, y], h) u + T_on' (rTS h0) (config' (rTS h0) ([x, y], h) u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v", "by(rule T_on'_append)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have \"\\<dots>\n      = T_on' (rTS h0) ([x, y], h) u + T_on' (rTS h0) ([x,y],rev u @ h) [y,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0)\n     (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y]", "by(simp add: conf vv2)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y]\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0)\n   (Partial_Cost_Model.config' (rTS h0) ([x, y], h) u) v =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y]\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have \"\\<dots> = T_on' (rTS h0) ([x, y], h) u + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + 2", "by (simp only: e)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u +\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) [y, y] =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have \"\\<dots> = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + 2 = 2", "by (simp add: TS_prefix)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) u + 2 = 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have TS: \"T_on' (rTS h0) ([x, y], h) qs= 2\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "."], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "(* dannach *)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have lqs: \"last qs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last qs = y", "using assms(2)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by force"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "from assms(1)"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"config' (rTS h0) ([x, y], h) qs = ([y,x], rev qs @ h)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([y, x], rev qs @ h)", "unfolding qsuv"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    ([y, x], rev (u @ v) @ h)", "apply(simp only: config'_append2 conf vv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) [y, y] =\n    ([y, x], rev (u @ [y, y]) @ h)", "using h_split"], ["proof (prove)\nusing this:\n  rev u @ h = [] \\<or>\n  rev u @ h = [x] \\<or> (\\<exists>hs. rev u @ h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) [y, y] =\n    ([y, x], rev (u @ [y, y]) @ h)", "apply(auto simp add: Step_def rTS_def\n              oneTS_steps\n              step_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; h = []; u = []\\<rbrakk>\n    \\<Longrightarrow> mtf2 (Suc 0) y [x, y] = [y, x]\n 2. \\<lbrakk>x \\<noteq> y; rev u @ h = [x]\\<rbrakk>\n    \\<Longrightarrow> mtf2 (Suc 0) y [x, y] = [y, x]\n 3. \\<And>hs.\n       \\<lbrakk>x \\<noteq> y; rev u @ h = x # x # hs\\<rbrakk>\n       \\<Longrightarrow> mtf2 (Suc 0) y [x, y] = [y, x]", "by(simp_all add: mtf2_def swap_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "with assms(1)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)", "have \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([y, x], rev qs @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(subst TS_inv'_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     ([y, x], rev qs @ h)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>hs.\n                          Partial_Cost_Model.config' (rTS h0) ([x, y], h)\n                           qs =\n                          (if last qs = hd [x, y] then [x, y]\n                           else rev [x, y],\n                           [last qs, last qs] @ hs)) \\<or>\n                      Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n                      (if last qs = hd [x, y] then [x, y] else rev [x, y],\n                       [])", "by(simp add: qsuv vv2 lqs)"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "unfolding TS"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    2 = 2", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "by fact"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y] \\<and>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_a': assumes  \"x \\<noteq> y\"\n    \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  and \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y])\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<and> TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x, y]\n    \\<and> T_on' (rTS h0) ([x, y], h) qs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "have OPT: \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "using OPT2_A[OF assms(1,3)]"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "using OPT ts_a'[OF assms(1,3,2)]"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs) (last qs)\n   [x, y] \\<and>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y] \\<and>\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_a'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n shows  \n    \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T\\<^sub>p_on_rand' (embed (rTS h0)) s qs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "assume A: \"x \\<noteq> y\"\n        \"qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\"\n        \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) = 2", "using ts_a'[OF A]"], ["proof (prove)\nusing this:\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs) (last qs)\n   [x, y] \\<and>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = 2\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) = 2", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  2\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2 \\<in> lang (seq [question (Atom ?xa2), Atom ?ya2, Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    2\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "note b=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2 \\<in> lang (seq [question (Atom ?xa2), Atom ?ya2, Atom ?ya2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    2\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(rule b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    2\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"x+yx(yx)*x\""], ["", "lemma ts_c': assumes \"x \\<noteq> y\"\n  \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\n            \\<and>  config' (rTS h0) ([x,y], h) v = ([x,y],rev v@h) \\<and> (\\<exists>hs. (rev v @ h) = [x,x]@hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []", "have lenvmod: \"length v mod 2 = 1\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "assume \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[x]}\""], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in> {[x]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[x]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}", "have \"p = [y,x]\" \"r=[x]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [x]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]", "have a: \"length v = 3+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length v = 3 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 3 + length q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]};\n     (\\<exists>hs. h = x # x # hs) \\<or> h = [x] \\<or> h = []\\<rbrakk>\n    \\<Longrightarrow> length v mod 2 = Suc 0", "from a b"], ["proof (chain)\npicking this:\n  length v = 3 + length q\n  length q mod 2 = 0", "show \"length v mod 2 = Suc 0\""], ["proof (prove)\nusing this:\n  length v = 3 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = Suc 0", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "with assms(1,3)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n  length v mod 2 = 1", "have fall: \"(\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n  length v mod 2 = 1\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h", "by(auto)"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> index h y = length h\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom x])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                      and \"b \\<in> lang (seq[Atom x])\"\n                      and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom x]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "then"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b", "have bb: \"b=[x]\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. b = [x]", "by auto"], ["proof (state)\nthis:\n  b = [x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from aa"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])", "have lena: \"length a > 0\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. 0 < length a", "by auto"], ["proof (state)\nthis:\n  0 < length a\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from TS_yxyx'[OF assms(1) aa fall]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (a @ ?r) =\n  length a - 1 +\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev a @ h) ?r \\<and>\n  (\\<exists>hs. rev a @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) a = ([x, y], rev a @ h)", "have stars: \"T_on' (rTS h0) ([x, y], h) (a @ b) =\n    length a - 1 + T_on' (rTS h0) ([x, y],rev a @ h) b\"\n    and history: \"(\\<exists>hs. rev a @ h = [x, y] @ hs)\"\n    and state: \"config' (rTS h0) ([x, y], h) a =  ([x, y], rev a @ h)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (a @ ?r) =\n  length a - 1 +\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev a @ h) ?r \\<and>\n  (\\<exists>hs. rev a @ h = [x, y] @ hs) \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) a = ([x, y], rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n    length a - 1 +\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b &&&\n    \\<exists>hs. rev a @ h = [x, y] @ hs &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) a = ([x, y], rev a @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) a = ([x, y], rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "have suffix: \"T_on' (rTS h0) ( [x, y],rev a @ h) b = 0\"\n          and suState: \"config' (rTS h0) ([x, y], rev a @ h) b = ([x,y], rev b @ (rev a @ h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 0 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) b =\n    ([x, y], rev b @ rev a @ h)", "unfolding bb"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) [x] = 0 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) [x] =\n    ([x, y], rev [x] @ rev a @ h)", "using TS_x'"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([?x, ?y], ?h) [?x] = 0 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([?x, ?y], ?h) [?x] =\n  ([?x, ?y], rev [?x] @ ?h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) [x] = 0 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) [x] =\n    ([x, y], rev [x] @ rev a @ h)", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 0\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev a @ h) b =\n  ([x, y], rev b @ rev a @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from stars suffix"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 0", "have \"T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) =\n  length a - 1 + Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev a @ h) b = 0\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1", "have whatineed: \"T_on' (rTS h0) ([x, y], h) v = (length v - 2)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2", "using vab bb"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (a @ b) = length a - 1\n  v = a @ b\n  b = [x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "have conf: \"config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)", "by(simp add: vab config'_append2 state suState)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "from history"], ["proof (chain)\npicking this:\n  \\<exists>hs. rev a @ h = [x, y] @ hs", "obtain hs' where \"rev a @ h = [x, y] @ hs'\""], ["proof (prove)\nusing this:\n  \\<exists>hs. rev a @ h = [x, y] @ hs\n\ngoal (1 subgoal):\n 1. (\\<And>hs'.\n        rev a @ h = [x, y] @ hs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rev a @ h = [x, y] @ hs'\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "then"], ["proof (chain)\npicking this:\n  rev a @ h = [x, y] @ hs'", "obtain hs2 where reva: \"rev a @ h = x # hs2\""], ["proof (prove)\nusing this:\n  rev a @ h = [x, y] @ hs'\n\ngoal (1 subgoal):\n 1. (\\<And>hs2.\n        rev a @ h = x # hs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rev a @ h = x # hs2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "using whatineed"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n    ([x, y], rev v @ h) \\<and>\n    (\\<exists>hs. rev v @ h = [x, x] @ hs)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v =\n    length v - 2 \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)\n 2. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v =\n    length v - 2 \\<Longrightarrow>\n    \\<exists>hs. rev v @ h = x # x # hs", "using conf"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v =\n    length v - 2 \\<Longrightarrow>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) v = ([x, y], rev v @ h)\n 2. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v =\n    length v - 2 \\<Longrightarrow>\n    \\<exists>hs. rev v @ h = x # x # hs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v =\n    length v - 2 \\<Longrightarrow>\n    \\<exists>hs. rev v @ h = x # x # hs", "by(simp add: reva vab bb)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) v = length v - 2 \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) v =\n  ([x, y], rev v @ h) \\<and>\n  (\\<exists>hs. rev v @ h = [x, x] @ hs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_c1'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "assume A: \"x \\<noteq> y\"\n        and B: \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n        and C: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "have C': \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []", "by blast"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = [x] \\<or> h = []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "from B"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom x])\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = length qs - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "using ts_c'[OF A B C'] A lqs"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([x, y], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [x, x] @ hs)\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "unfolding TS_inv'_det"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([x, y], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [x, x] @ hs)\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     (if last qs = hd [x, y] then [x, y] else rev [x, y], [])) \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 2)", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  real (length qs - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "note c1=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 2)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 2)", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(rule c1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 2)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule c1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n  real (length qs - 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_c2': assumes \"x \\<noteq> y\"\n  \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n  \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs = (length qs - 3)\n            \\<and>  config' (rTS h0) ([x,y], h) qs = ([x,y],rev qs@h) \\<and> (\\<exists>hs. (rev qs @ h) = [x,x]@hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])", "obtain v where qs: \"qs = [x]@v\"\n          and V: \"v\\<in>lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>qs = [x] @ v;\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs = [x] @ v\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "from assms(3)"], ["proof (chain)\npicking this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []", "have 3: \"(\\<exists>hs. x#h = [x, x] @ hs) \\<or> x#h = [x] \\<or> x#h = []\""], ["proof (prove)\nusing this:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. x # h = [x, x] @ hs) \\<or> x # h = [x] \\<or> x # h = []", "by auto"], ["proof (state)\nthis:\n  (\\<exists>hs. x # h = [x, x] @ hs) \\<or> x # h = [x] \\<or> x # h = []\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "from ts_c'[OF assms(1) V 3]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], x # h) v =\n  length v - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], x # h) v =\n  ([x, y], rev v @ x # h) \\<and>\n  (\\<exists>hs. rev v @ x # h = [x, x] @ hs)", "have T: \"T_on' (rTS h0) ([x, y], x#h) v = length v - 2\"\n    and C: \"config' (rTS h0) ([x, y], x#h) v = ([x, y], rev v @ x#h)\"\n    and H: \"(\\<exists>hs. rev v @ x#h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], x # h) v =\n  length v - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], x # h) v =\n  ([x, y], rev v @ x # h) \\<and>\n  (\\<exists>hs. rev v @ x # h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # h) v = length v - 2 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], x # h) v =\n    ([x, y], rev v @ x # h) &&&\n    \\<exists>hs. rev v @ x # h = [x, x] @ hs", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], x # h) v = length v - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], x # h) v =\n  ([x, y], rev v @ x # h)\n  \\<exists>hs. rev v @ x # h = [x, x] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "have t: \"t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0", "by (simp add: step_def rTS_def TS_step_d_def t\\<^sub>p_def)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (fst (snd (rTS h0) ([x, y], h) x)) = 0\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "have c: \"Partial_Cost_Model.Step (rTS h0) ([x, y], h) x\n            = ([x,y], x#h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (rTS h0) ([x, y], h) x = ([x, y], x # h)", "by (simp add: Step_def rTS_def TS_step_d_def step_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.Step (rTS h0) ([x, y], h) x = ([x, y], x # h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<and>\n    (\\<exists>hs. rev qs @ h = [x, x] @ hs)", "unfolding qs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([x] @ v) =\n    length ([x] @ v) - 3 \\<and>\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([x, y], rev ([x] @ v) @ h) \\<and>\n    (\\<exists>hs. rev ([x] @ v) @ h = [x, x] @ hs)", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) ([x] @ v) =\n    length ([x] @ v) - 3\n 2. Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([x, y], rev ([x] @ v) @ h)\n 3. \\<exists>hs. rev ([x] @ v) @ h = [x, x] @ hs", "apply(simp add: T_on'_append T c t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) ([x] @ v) =\n    ([x, y], rev ([x] @ v) @ h)\n 2. \\<exists>hs. rev ([x] @ v) @ h = [x, x] @ hs", "apply(simp add: config'_rand_append C c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hs. rev ([x] @ v) @ h = [x, x] @ hs", "using H"], ["proof (prove)\nusing this:\n  \\<exists>hs. rev v @ x # h = [x, x] @ hs\n\ngoal (1 subgoal):\n 1. \\<exists>hs. rev ([x] @ v) @ h = [x, x] @ hs", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n  ([x, y], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [x, x] @ hs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_c2'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = (length qs - 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "assume A: \"x \\<noteq> y\"\n        and B: \"qs \\<in> lang (seq[Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n        and C: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from B"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Times (Atom y) (Atom x),\n                  Star (Times (Atom y) (Atom x)), Atom x])\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "from C"], ["proof (chain)\npicking this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "have C': \"(\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\""], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []", "by blast"], ["proof (state)\nthis:\n  (\\<exists>hs. h = [x, x] @ hs) \\<or> h = []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = length qs - 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "using ts_c2'[OF A B C'] A lqs"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([x, y], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [x, x] @ hs)\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "unfolding TS_inv'_det"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = length qs - 3 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  ([x, y], rev qs @ h) \\<and>\n  (\\<exists>hs. rev qs @ h = [x, x] @ hs)\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     (if last qs = hd [x, y] then [x, y] else rev [x, y], [])) \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) =\n    real (length qs - 3)", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  real (length qs - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Atom ?xa2, Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "note c2=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2\n   \\<in> lang\n          (seq [Atom ?xa2, Times (Atom ?ya2) (Atom ?xa2),\n                Star (Times (Atom ?ya2) (Atom ?xa2)), Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    real (length ?qsa2 - 3)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n    real (length qs - 3)", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(rule c2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    real (length qs - 3)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule c2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [Atom x, Times (Atom y) (Atom x),\n                    Star (Times (Atom y) (Atom x)), Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs =\n  real (length qs - 3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_c': assumes \"x \\<noteq> y\" \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n  \"qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>  TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "obtain u v where uu: \"u \\<in> lang (Plus (Atom x) One)\"\n        and vv: \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n        and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (question (Atom x))\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from TS_xr'[OF assms(1) uu assms(2)]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) ?r", "have\n              T_pre: \"T_on' (rTS h0) ([x, y], h) (u@v) = T_on' (rTS h0) ([x, y], rev u @ h) v\"\n          and fall': \"(\\<exists>hs. (rev u @ h) = [x, x] @ hs) \\<or> (rev u @ h) = [x] \\<or> (rev u @ h)=[]\"\n          and conf': \"config' (rTS h0) ([x, y], h) (u @ v) =\n                config' (rTS h0) ([x, y], rev u @ h) v\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) (u @ ?r) =\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) ?r\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v &&&\n    (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n    rev u @ h = [x] \\<or> rev u @ h = [] &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "with assms uu"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n  u \\<in> lang (question (Atom x))\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v", "have fall: \"(\\<exists>hs. (rev u @ h) = [x, x] @ hs) \\<or> index (rev u @ h) y = length (rev u @ h)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n  u \\<in> lang (question (Atom x))\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  rev u @ h = [x] \\<or> rev u @ h = []\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v\n\ngoal (1 subgoal):\n 1. (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n    index (rev u @ h) y = length (rev u @ h)", "by(auto)"], ["proof (state)\nthis:\n  (\\<exists>hs. rev u @ h = [x, x] @ hs) \\<or>\n  index (rev u @ h) y = length (rev u @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from ts_c'[OF assms(1) vv fall']"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  length v - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h) \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, x] @ hs)", "have\n              T_star: \"T_on' (rTS h0) ([x, y], rev u @ h) v = (length v - 2)\"\n          and inv1:   \"config' (rTS h0) ([x, y], (rev u @ h)) v = ([x, y], rev v @ rev u @ h)\"\n          and inv2:   \"(\\<exists>hs. rev v @ rev u @ h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  length v - 2 \\<and>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h) \\<and>\n  (\\<exists>hs. rev v @ rev u @ h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v =\n    length v - 2 &&&\n    Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n    ([x, y], rev v @ rev u @ h) &&&\n    \\<exists>hs. rev v @ rev u @ h = [x, x] @ hs", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  Partial_Cost_Model.config' (rTS h0) ([x, y], rev u @ h) v =\n  ([x, y], rev v @ rev u @ h)\n  \\<exists>hs. rev v @ rev u @ h = [x, x] @ hs\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from T_pre T_star qsuv"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  qs = u @ v", "have TS: \"T_on' (rTS h0) ([x, y], h) qs = (length v - 2)\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) (u @ v) =\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], rev u @ h) v = length v - 2\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2", "by metis"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "(* OPT *)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = length v - 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (question (Atom x))", "have uuu: \"u=[] \\<or> u=[x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. u = [] \\<or> u = [x]", "by auto"], ["proof (state)\nthis:\n  u = [] \\<or> u = [x]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have vvv: \"v \\<in> lang (seq\n          [Atom y, Atom x,\n           Star (Times (Atom y) (Atom x)),\n           Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "by(auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have OPT: \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "apply(rule OPT2_C)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. qs = ?u @ v\n 3. ?u = [] \\<or> ?u = [x]\n 4. v \\<in> lang\n             (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "by(fact)+"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have lqs: \"last qs = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last qs = x", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by force"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "have conf: \"config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h)", "by(simp add: qsuv conf' inv1)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)", "have conf: \"TS_inv' (config' (rTS h0) ([x, y], h) qs) (last qs) [x,y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], rev qs @ h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "apply(simp add: lqs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<Longrightarrow>\n    TS_inv' ([x, y], rev qs @ h) x [x, y]", "apply( subst TS_inv'_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([x, y], rev qs @ h) =\n        (if x = hd [x, y] then [x, y] else rev [x, y], [x, x] @ hs)) \\<or>\n    ([x, y], rev qs @ h) =\n    (if x = hd [x, y] then [x, y] else rev [x, y], [])", "using inv2 qsuv"], ["proof (prove)\nusing this:\n  \\<exists>hs. rev v @ rev u @ h = [x, x] @ hs\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n    ([x, y], rev qs @ h) \\<Longrightarrow>\n    (\\<exists>hs.\n        ([x, y], rev qs @ h) =\n        (if x = hd [x, y] then [x, y] else rev [x, y], [x, x] @ hs)) \\<or>\n    ([x, y], rev qs @ h) =\n    (if x = hd [x, y] then [x, y] else rev [x, y], [])", "by(simp)"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "unfolding TS OPT"], ["proof (prove)\ngoal (1 subgoal):\n 1. length v - 2 \\<le> 2 * (length v div 2) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "by (auto simp add: conf)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"xx\""], ["", "lemma request_first: \"x\\<noteq>y \\<Longrightarrow> Step (rTS h) ([x, y], is) x = ([x,y],x#is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    Partial_Cost_Model.Step (rTS h) ([x, y], is) x = ([x, y], x # is)", "unfolding rTS_def Step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (let (a, ya) = snd (\\<lambda>s. h, TS_step_d) ([x, y], is) x\n     in (step (fst ([x, y], is)) x a, ya)) =\n    ([x, y], x # is)", "by(simp add: split_def TS_step_d_def step_def)"], ["", "lemma ts_d': \"qs \\<in> Lxx x y \\<Longrightarrow>\n    x \\<noteq> y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs) \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n    T_on' (rTS h0) ([x, y], h) qs = 0 \\<and>\n     TS_inv' (config' (rTS h0) ([x, y], h) qs) x [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "assume xny: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "assume \"qs \\<in> lang (seq [Atom x, Atom x])\""], ["proof (state)\nthis:\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [Atom x, Atom x])", "have xx: \"qs = [x,x]\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. qs = [x, x]", "by auto"], ["proof (state)\nthis:\n  qs = [x, x]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "from xny"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have TS: \"T_on' (rTS h0) ([x, y], h) qs = 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "unfolding xx"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) [x, x] = 0", "by(auto simp add: Step_def step_def oneTS_steps rTS_def  t\\<^sub>p_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "from xny"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"config' (rTS h0) ([x, y], h) qs = ([x, y], x # x # h) \""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], x # x # h)", "by(auto simp add: xx Step_def rTS_def oneTS_steps step_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], x # x # h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], x # x # h)", "have \" TS_inv' (config' (rTS h0) ([x, y], h) qs) x [x, y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs = ([x, y], x # x # h)\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]", "by(simp add: TS_inv'_det)"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y; x \\<noteq> y;\n     h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs);\n     qs \\<in> lang (seq [Atom x, Atom x])\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs =\n                      0 \\<and>\n                      TS_inv'\n                       (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs)\n                       x [x, y]", "with TS"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0 \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0 \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) x [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_d': assumes xny: \"x \\<noteq> y\" and \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\"\n    and qsis: \"qs \\<in> lang (seq [Atom x, Atom x])\"\n    shows \"T_on' (rTS h0) ([x,y],h) qs \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \"\n      and \"TS_inv' (config' (rTS h0) ([x,y],h) qs)  (last qs) [x, y]\"\n      and \"T_on' (rTS h0) ([x,y],h) qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) &&&\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] &&&\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n 2. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]\n 3. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "from qsis"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [Atom x, Atom x])", "have xx: \"qs = [x,x]\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. qs = [x, x]", "by auto"], ["proof (state)\nthis:\n  qs = [x, x]\n\ngoal (3 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n 2. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]\n 3. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "show TS: \"T_on' (rTS h0) ([x,y],h) qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "by (auto simp add: xx t\\<^sub>p_def rTS_def Step_def oneTS_steps step_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n 2. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0", "show \"T_on' (rTS h0) ([x,y],h) qs \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs = 0\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n    \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "show \"TS_inv' (config' (rTS h0) ([x,y],h) qs)  (last qs) [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y]", "unfolding TS_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>hs.\n        return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) =\n        return_pmf\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n    return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) =\n    return_pmf (if last qs = hd [x, y] then [x, y] else rev [x, y], [])", "by(simp add: xx request_first[OF xny])"], ["proof (state)\nthis:\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n   [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_d'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"TS_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\"  \n   \"qs \\<in> lang (seq [Atom x, Atom x])\"\n shows \"TS_inv (config'_rand (embed (rTS h0)) s qs) (last qs) [x0, y0]\n      \\<and> T_on_rand' (embed (rTS h0)) s qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"(x0=x \\<and> y0=y) \\<or> (y0=x \\<and> x0=y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "by(auto)"], ["proof (state)\nthis:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "then"], ["proof (chain)\npicking this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y", "obtain h where S: \"s = return_pmf ([x,y],h)\" and h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>s = return_pmf ([x, y], h);\n         h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  TS_inv s x [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0],\n        [x, x] @ hs)) \\<or>\n  s = return_pmf (if x = hd [x0, y0] then [x0, y0] else rev [x0, y0], [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x0 = x \\<and> y0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h.\n                \\<lbrakk>s = return_pmf ([x, y], h);\n                 h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     y0 = x \\<and> x0 = y\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  s = return_pmf ([x, y], h)\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "have l: \"qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "{"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "fix x y qs h0"], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "fix h:: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "assume A: \"x \\<noteq> y\"\n        and B: \"qs \\<in> lang (seq [Atom x, Atom x])\"\n        and C: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  qs \\<in> lang (seq [Atom x, Atom x])\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "from B"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [Atom x, Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom x, Atom x])\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "have \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) qs) (last qs) [x, y] \\<and>\n            T_on_rand' (embed (rTS h0)) (return_pmf ([x, y], h)) qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp only: T_on'_embed[symmetric] config'_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) = 0", "using TS_d'[OF A C B ] A lqs"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs) (last qs)\n   [x, y]\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = 0\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs) (last qs)\n     [x, y] \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) = 0", "unfolding TS_inv'_det"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs\n  \\<le> 2 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  (\\<exists>hs.\n      Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n      (if last qs = hd [x, y] then [x, y] else rev [x, y],\n       [last qs, last qs] @ hs)) \\<or>\n  Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) qs =\n  (if last qs = hd [x, y] then [x, y] else rev [x, y], [])\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) qs = 0\n  x \\<noteq> y\n  last qs = x\n\ngoal (1 subgoal):\n 1. ((\\<exists>hs.\n         Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n         (if last qs = hd [x, y] then [x, y] else rev [x, y],\n          [last qs, last qs] @ hs)) \\<or>\n     Partial_Cost_Model.config' (rTS h0) ([x, y], h) qs =\n     (if last qs = hd [x, y] then [x, y] else rev [x, y], [])) \\<and>\n    real (Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) qs) = 0", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) qs =\n  0\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2 \\<in> lang (seq [Atom ?xa2, Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    0\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "note d=this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2;\n   ?qsa2 \\<in> lang (seq [Atom ?xa2, Atom ?xa2]);\n   ?ha2 = [] \\<or> (\\<exists>hs. ?ha2 = [?xa2, ?xa2] @ hs)\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0a2))\n                       (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2)\n                     (last ?qsa2) [?xa2, ?ya2] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0a2))\n                     (return_pmf ([?xa2, ?ya2], ?ha2)) ?qsa2 =\n                    0\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n       qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "using kas"], ["proof (prove)\nusing this:\n  x0 = x \\<and> y0 = y \\<or> y0 = x \\<and> x0 = y\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(rule d)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (4 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow> x \\<noteq> y\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 3. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (3 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 2. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. x0 = x \\<and> y0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [y, x] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(subst TS_inv_sym[of y x x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> y \\<noteq> x\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> {y, x} = {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "apply(blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) qs)\n     (last qs) [x, y] \\<and>\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) qs =\n    0\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(rule d)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (4 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> x \\<noteq> y\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 4. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  TS_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (3 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    qs \\<in> lang (seq [Atom x, Atom x])\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 3. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using h"], ["proof (prove)\nusing this:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (2 subgoals):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow>\n    h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n 2. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "using last_in_set l assms(4)"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n  qs \\<noteq> []\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. y0 = x \\<and> x0 = y \\<Longrightarrow> last qs \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0)) s\n     qs)\n   (last qs) [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS h0)) s qs = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Phase Partitioning\""], ["", "lemma D': assumes \"\\<sigma>' \\<in> Lxx x y\" and \"x \\<noteq> y\" and \"TS_inv' ([x, y], h) x [x, y]\"\n  shows  \"T_on' (rTS h0) ([x, y], h) \\<sigma>' \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \n      \\<and>  TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) \\<sigma>') (last \\<sigma>') [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "from config'_embed"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed ?A)\n   (return_pmf ?s0.0) ?qs =\n  return_pmf (Partial_Cost_Model.config' ?A ?s0.0 ?qs)", "have \" config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) \\<sigma>' \n      = return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed ?A)\n   (return_pmf ?s0.0) ?qs =\n  return_pmf (Partial_Cost_Model.config' ?A ?s0.0 ?qs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) \\<sigma>' =\n    return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) \\<sigma>' =\n  return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) \\<sigma>' =\n  return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')", "have L: \"TS_inv (config'_rand (embed (rTS h0)) (return_pmf ([x, y], h)) \\<sigma>') (last \\<sigma>') [x, y]\n      = TS_inv' (config' (rTS h0) ([x, y], h) \\<sigma>')  (last \\<sigma>') [x, y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n   (return_pmf ([x, y], h)) \\<sigma>' =\n  return_pmf (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y] =\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) \\<sigma>')\n   (last \\<sigma>') [x, y] =\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "from assms(3)"], ["proof (chain)\npicking this:\n  TS_inv' ([x, y], h) x [x, y]", "have \n      h: \"h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\""], ["proof (prove)\nusing this:\n  TS_inv' ([x, y], h) x [x, y]\n\ngoal (1 subgoal):\n 1. h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)", "by(auto simp add: TS_inv'_det)"], ["proof (state)\nthis:\n  h = [] \\<or> (\\<exists>hs. h = [x, x] @ hs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "have \"T_on' (rTS h0) ([x, y], h) \\<sigma>' \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \n      \\<and>  TS_inv' (config' (rTS h0) ([x, y], h) \\<sigma>')  (last \\<sigma>') [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply(rule LxxE[OF assms(1)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<sigma>' \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom y,\n                 Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 3. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 4. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using TS_d'[OF assms(2) h, of \"\\<sigma>'\"]"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n  \\<sigma>' \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n  \\<sigma>' \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) \\<sigma>' = 0\n\ngoal (4 subgoals):\n 1. \\<sigma>' \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom y,\n                 Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 3. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 4. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom y,\n                 Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 3. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using TS_b'[OF assms(2) h]"], ["proof (prove)\nusing this:\n  ?qs\n  \\<in> lang\n         (seq [question (Atom x), Atom y, Atom x,\n               Star (Times (Atom y) (Atom x)), Atom y,\n               Atom y]) \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) ?qs\n  \\<le> 2 * T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) ?qs)\n   (last ?qs) [x, y]\n\ngoal (3 subgoals):\n 1. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom y,\n                 Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 3. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using TS_c'[OF assms(2) h]"], ["proof (prove)\nusing this:\n  ?qs\n  \\<in> lang\n         (seq [question (Atom x), Atom y, Atom x,\n               Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) ?qs\n  \\<le> 2 * T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) ?qs)\n   (last ?qs) [x, y]\n\ngoal (2 subgoals):\n 1. \\<sigma>'\n    \\<in> lang\n           (seq [question (Atom x), Atom y, Atom x,\n                 Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]\n 2. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using TS_a'[OF assms(2) h]"], ["proof (prove)\nusing this:\n  ?qs \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) ?qs\n  \\<le> 2 * T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS ?h0.0) ([x, y], h) ?qs)\n   (last ?qs) [x, y] \\<and>\n  Partial_Cost_Model.T_on' (rTS ?h0.0) ([x, y], h) ?qs = 2\n\ngoal (1 subgoal):\n 1. \\<sigma>'\n    \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using L"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) \\<sigma>')\n   (last \\<sigma>') [x, y] =\n  TS_inv' (Partial_Cost_Model.config' (rTS h0) ([x, y], h) \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n    \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n       (return_pmf ([x, y], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on' (rTS h0) ([x, y], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y]) \\<and>\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h0))\n     (return_pmf ([x, y], h)) \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem TS_OPT2':  \"(x::nat) \\<noteq> y \\<Longrightarrow> set \\<sigma> \\<subseteq> {x,y}\n     \\<Longrightarrow> T\\<^sub>p_on (rTS []) [x,y] \\<sigma>  \\<le> 2 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p_on (rTS []) [x, y] \\<sigma>)\n                      \\<le> 2 * real (T\\<^sub>p_opt [x, y] \\<sigma>) + 2", "apply(subst T_on_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n                       (fst (Partial_Cost_Model.embed (rTS []))\n                         [x, y] \\<bind>\n                        (\\<lambda>is. return_pmf ([x, y], is)))\n                       \\<sigma>\n                      \\<le> 2 * real (T\\<^sub>p_opt [x, y] \\<sigma>) + 2", "apply(rule Phase_partitioning_general[where P=TS_inv])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 2\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (map_pmf (Pair [x, y])\n                         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n                       x [x, y]\n 5. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 2\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (map_pmf (Pair [x, y])\n                         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n                       x [x, y]\n 4. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (map_pmf (Pair [x, y])\n                         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n                       x [x, y]\n 3. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (map_pmf (Pair [x, y])\n                         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n                       x [x, y]\n 2. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "apply(simp add: TS_inv_def rTS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "case (1 a b \\<sigma>' s)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma>' \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  TS_inv s a [x, y]\n  set \\<sigma>' \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "from 1(6)"], ["proof (chain)\npicking this:\n  TS_inv s a [x, y]", "obtain h hist' where s: \"s = return_pmf ([a, b], h)\" \n            and \"h = [] \\<or> h = [a,a]@hist'\""], ["proof (prove)\nusing this:\n  TS_inv s a [x, y]\n\ngoal (1 subgoal):\n 1. (\\<And>h hist'.\n        \\<lbrakk>s = return_pmf ([a, b], h);\n         h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding TS_inv_def"], ["proof (prove)\nusing this:\n  (\\<exists>hs.\n      s =\n      return_pmf\n       (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n  s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], [])\n\ngoal (1 subgoal):\n 1. (\\<And>h hist'.\n        \\<lbrakk>s = return_pmf ([a, b], h);\n         h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"a=hd [x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs.\n         s =\n         return_pmf\n          (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n     s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], []);\n     a = hd [x, y]\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs.\n         s =\n         return_pmf\n          (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n     s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], []);\n     a \\<noteq> hd [x, y]\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([x, b], h);\n                 h = [] \\<or> h = x # x # hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs. s = return_pmf ([x, y], x # x # hs)) \\<or>\n     s = return_pmf ([x, y], []);\n     a = x\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs.\n         s =\n         return_pmf\n          (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n     s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], []);\n     a \\<noteq> hd [x, y]\\<rbrakk>\n    \\<Longrightarrow> thesis", "using 1"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma>' \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  TS_inv s a [x, y]\n  set \\<sigma>' \\<subseteq> {a, b}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([x, b], h);\n                 h = [] \\<or> h = x # x # hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs. s = return_pmf ([x, y], x # x # hs)) \\<or>\n     s = return_pmf ([x, y], []);\n     a = x\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs.\n         s =\n         return_pmf\n          (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n     s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], []);\n     a \\<noteq> hd [x, y]\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = [a, a] @ hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs.\n         s =\n         return_pmf\n          (if a = hd [x, y] then [x, y] else rev [x, y], [a, a] @ hs)) \\<or>\n     s = return_pmf (if a = hd [x, y] then [x, y] else rev [x, y], []);\n     a \\<noteq> hd [x, y]\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = a # a # hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs. s = return_pmf ([y, x], a # a # hs)) \\<or>\n     s = return_pmf ([y, x], []);\n     a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> thesis", "using 1"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma>' \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  TS_inv s a [x, y]\n  set \\<sigma>' \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h hist'.\n                \\<lbrakk>s = return_pmf ([a, b], h);\n                 h = [] \\<or> h = a # a # hist'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (\\<exists>hs. s = return_pmf ([y, x], a # a # hs)) \\<or>\n     s = return_pmf ([y, x], []);\n     a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  s = return_pmf ([a, b], h)\n  h = [] \\<or> h = [a, a] @ hist'\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "from 1"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma>' \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  TS_inv s a [x, y]\n  set \\<sigma>' \\<subseteq> {a, b}", "have xyab: \"TS_inv' ([a, b], h) a [x, y]\n          = TS_inv' ([a, b], h) a [a, b]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma>' \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  TS_inv s a [x, y]\n  set \\<sigma>' \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. TS_inv' ([a, b], h) a [x, y] = TS_inv' ([a, b], h) a [a, b]", "by(auto simp add: TS_inv'_det)"], ["proof (state)\nthis:\n  TS_inv' ([a, b], h) a [x, y] = TS_inv' ([a, b], h) a [a, b]\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "with 1(6) s"], ["proof (chain)\npicking this:\n  TS_inv s a [x, y]\n  s = return_pmf ([a, b], h)\n  TS_inv' ([a, b], h) a [x, y] = TS_inv' ([a, b], h) a [a, b]", "have inv: \"TS_inv' ([a, b], h) a [a, b]\""], ["proof (prove)\nusing this:\n  TS_inv s a [x, y]\n  s = return_pmf ([a, b], h)\n  TS_inv' ([a, b], h) a [x, y] = TS_inv' ([a, b], h) a [a, b]\n\ngoal (1 subgoal):\n 1. TS_inv' ([a, b], h) a [a, b]", "by simp"], ["proof (state)\nthis:\n  TS_inv' ([a, b], h) a [a, b]\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "from \\<open>\\<sigma>' \\<in> Lxx a b\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma>' \\<in> Lxx a b", "have \"\\<sigma>' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> Lxx a b\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<noteq> []", "using Lxx1"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> Lxx a b\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> 2 \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  \\<sigma>' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "then"], ["proof (chain)\npicking this:\n  \\<sigma>' \\<noteq> []", "have l: \"last \\<sigma>' \\<in> {x,y}\""], ["proof (prove)\nusing this:\n  \\<sigma>' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last \\<sigma>' \\<in> {x, y}", "using 1(5,7) last_in_set"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<noteq> []\n  {a, b} = {x, y}\n  set \\<sigma>' \\<subseteq> {a, b}\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. last \\<sigma>' \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  last \\<sigma>' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        TS_inv s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS [])) s \\<sigma>')\n                          (last \\<sigma>') [x, y]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n    \\<le> 2 *\n          real (T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b])) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) s\n       \\<sigma>')\n     (last \\<sigma>') [x, y]", "unfolding s T_on'_embed[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>')\n    \\<le> 2 *\n          real (T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b])) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n       (return_pmf ([a, b], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "using D'[OF 1(3,4) inv, of \"[]\"]"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>'\n  \\<le> 2 * T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b]) \\<and>\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n     (return_pmf ([a, b], h)) \\<sigma>')\n   (last \\<sigma>') [a, b]\n\ngoal (1 subgoal):\n 1. real (Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>')\n    \\<le> 2 *\n          real (T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b])) \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n       (return_pmf ([a, b], h)) \\<sigma>')\n     (last \\<sigma>') [x, y]", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>'\n             \\<le> 2 * T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b]);\n     TS_inv\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        (return_pmf ([a, b], h)) \\<sigma>')\n      (last \\<sigma>') [a, b]\\<rbrakk>\n    \\<Longrightarrow> real\n                       (Partial_Cost_Model.T_on' (rTS []) ([a, b], h)\n                         \\<sigma>')\n                      \\<le> 2 *\n                            real\n                             (T\\<^sub>p [a, b] \\<sigma>'\n                               (OPT2 \\<sigma>' [a, b]))\n 2. \\<lbrakk>Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>'\n             \\<le> 2 * T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b]);\n     TS_inv\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        (return_pmf ([a, b], h)) \\<sigma>')\n      (last \\<sigma>') [a, b]\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (Partial_Cost_Model.config'_rand\n                         (Partial_Cost_Model.embed (rTS []))\n                         (return_pmf ([a, b], h)) \\<sigma>')\n                       (last \\<sigma>') [x, y]", "apply linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>'\n             \\<le> 2 * T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b]);\n     TS_inv\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        (return_pmf ([a, b], h)) \\<sigma>')\n      (last \\<sigma>') [a, b]\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (Partial_Cost_Model.config'_rand\n                         (Partial_Cost_Model.embed (rTS []))\n                         (return_pmf ([a, b], h)) \\<sigma>')\n                       (last \\<sigma>') [x, y]", "using TS_inv_sym[OF 1(4,5)] l"], ["proof (prove)\nusing this:\n  ?z \\<in> {x, y} \\<Longrightarrow>\n  TS_inv ?c ?z [a, b] = TS_inv ?c ?z [x, y]\n  last \\<sigma>' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_Cost_Model.T_on' (rTS []) ([a, b], h) \\<sigma>'\n             \\<le> 2 * T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b]);\n     TS_inv\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        (return_pmf ([a, b], h)) \\<sigma>')\n      (last \\<sigma>') [a, b]\\<rbrakk>\n    \\<Longrightarrow> TS_inv\n                       (Partial_Cost_Model.config'_rand\n                         (Partial_Cost_Model.embed (rTS []))\n                         (return_pmf ([a, b], h)) \\<sigma>')\n                       (last \\<sigma>') [x, y]", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) s \\<sigma>'\n  \\<le> 2 * real (T\\<^sub>p [a, b] \\<sigma>' (OPT2 \\<sigma>' [a, b])) \\<and>\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) s\n     \\<sigma>')\n   (last \\<sigma>') [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"TS is pairwise\""], ["", "lemma config'_distinct[simp]: \n  shows \"distinct (fst (config' A S qs)) = distinct (fst S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (Partial_Cost_Model.config' A S qs)) = distinct (fst S)", "apply (induct qs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (fst (Partial_Cost_Model.config' A S [])) = distinct (fst S)\n 2. \\<And>x xs.\n       distinct (fst (Partial_Cost_Model.config' A S xs)) =\n       distinct (fst S) \\<Longrightarrow>\n       distinct (fst (Partial_Cost_Model.config' A S (xs @ [x]))) =\n       distinct (fst S)", "by(simp_all add: config'_snoc Step_def split_def distinct_step)"], ["", "lemma config'_set[simp]: \n  shows \"set (fst (config' A S qs)) = set (fst S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (Partial_Cost_Model.config' A S qs)) = set (fst S)", "apply (induct qs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (fst (Partial_Cost_Model.config' A S [])) = set (fst S)\n 2. \\<And>x xs.\n       set (fst (Partial_Cost_Model.config' A S xs)) =\n       set (fst S) \\<Longrightarrow>\n       set (fst (Partial_Cost_Model.config' A S (xs @ [x]))) = set (fst S)", "by(simp_all add: config'_snoc Step_def split_def set_step)"], ["", "lemma s_TS_append: \"i\\<le>length as \\<Longrightarrow>s_TS init h (as@bs) i = s_TS init h as i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length as \\<Longrightarrow>\n    s_TS init h (as @ bs) i = s_TS init h as i", "by (simp add: s_TS_def)"], ["", "lemma s_TS_distinct: \"distinct init \\<Longrightarrow> i<length qs \\<Longrightarrow> distinct (fst (TSdet init h qs i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct init; i < length qs\\<rbrakk>\n    \\<Longrightarrow> distinct (fst (TSdet init h qs i))", "by(simp_all add: config_config_distinct)"], ["", "lemma othersdontinterfere: \"distinct init \\<Longrightarrow> i < length qs \\<Longrightarrow> a\\<in>set init \\<Longrightarrow> b\\<in>set init\n     \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> qs!i\\<notin>{a,b} \\<Longrightarrow> a < b in s_TS init h qs i \\<Longrightarrow> a < b in s_TS init h qs (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init; qs ! i \\<notin> {a, b};\n     a < b in s_TS init h qs i\\<rbrakk>\n    \\<Longrightarrow> a < b in s_TS init h qs (Suc i)", "apply(simp add: s_TS_def split_def take_Suc_conv_app_nth config_append Step_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> a < b\n                      in mtf2\n                          (fst (fst (snd (rTS h) (TSdet init h qs i)\n(qs ! i))))\n                          (qs ! i)\n                          (swaps\n                            (snd (fst (snd (rTS h) (TSdet init h qs i)\n  (qs ! i))))\n                            (fst (TSdet init h qs i)))", "apply(subst x_stays_before_y_if_y_not_moved_to_front)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> qs ! i\n                      \\<in> set (swaps\n                                  (snd (fst\n   (snd (rTS h) (TSdet init h qs i) (qs ! i))))\n                                  (fst (TSdet init h qs i)))\n 2. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (swaps\n                         (snd (fst (snd (rTS h) (TSdet init h qs i)\n                                     (qs ! i))))\n                         (fst (TSdet init h qs i)))\n 3. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (swaps\n                                    (snd\n(fst (snd (rTS h) (TSdet init h qs i) (qs ! i))))\n                                    (fst (TSdet init h qs i)))\n 4. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set (swaps\n                                    (snd\n(fst (snd (rTS h) (TSdet init h qs i) (qs ! i))))\n                                    (fst (TSdet init h qs i)))\n 5. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> qs ! i\n 6. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> a < b\n                      in swaps\n                          (snd (fst (snd (rTS h) (TSdet init h qs i)\n(qs ! i))))\n                          (fst (TSdet init h qs i))\n 7. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> True", "apply(simp_all add: config_config_distinct config_config_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> qs ! i \\<in> set init\n 2. \\<lbrakk>distinct init; i < length qs; a \\<in> set init;\n     b \\<in> set init; set qs \\<subseteq> set init;\n     qs ! i \\<noteq> a \\<and> qs ! i \\<noteq> b;\n     a < b in fst (TSdet init h qs i)\\<rbrakk>\n    \\<Longrightarrow> a < b\n                      in swaps\n                          (snd (fst (snd (rTS h) (TSdet init h qs i)\n(qs ! i))))\n                          (fst (TSdet init h qs i))", "by(auto simp: rTS_def TS_step_d_def)"], ["", "lemma  TS_mono:\n    fixes l::nat\n    assumes 1: \"x < y in s_TS init h xs (length xs)\"\n     and l_in_cs: \"l \\<le> length cs\"\n     and firstocc: \"\\<forall>j<l. cs ! j \\<noteq> y\"\n     and \"x \\<notin> set cs\" \n     and di: \"distinct init\"  \n     and inin: \"set (xs @ cs) \\<subseteq> set init\"\n    shows \"x < y in s_TS init h (xs@cs) (length (xs)+l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "from before_in_setD2[OF 1]"], ["proof (chain)\npicking this:\n  y \\<in> set (s_TS init h xs (length xs))", "have y: \"y : set init\""], ["proof (prove)\nusing this:\n  y \\<in> set (s_TS init h xs (length xs))\n\ngoal (1 subgoal):\n 1. y \\<in> set init", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  y \\<in> set (fst (TSdet init h xs (length xs)))\n\ngoal (1 subgoal):\n 1. y \\<in> set init", "by(simp add: config_config_set)"], ["proof (state)\nthis:\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "from before_in_setD1[OF 1]"], ["proof (chain)\npicking this:\n  x \\<in> set (s_TS init h xs (length xs))", "have x: \"x : set init\""], ["proof (prove)\nusing this:\n  x \\<in> set (s_TS init h xs (length xs))\n\ngoal (1 subgoal):\n 1. x \\<in> set init", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  x \\<in> set (fst (TSdet init h xs (length xs)))\n\ngoal (1 subgoal):\n 1. x \\<in> set init", "by(simp add: config_config_set)"], ["proof (state)\nthis:\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "{"], ["proof (state)\nthis:\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "assume \"n\\<le>l\""], ["proof (state)\nthis:\n  n \\<le> l\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "then"], ["proof (chain)\npicking this:\n  n \\<le> l", "have \"x < y in s_TS init h ((xs)@cs) (length (xs)+n)\""], ["proof (prove)\nusing this:\n  n \\<le> l\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + n)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> l \\<Longrightarrow>\n    x < y in s_TS init h (xs @ cs) (length xs + 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> l\n\ngoal (2 subgoals):\n 1. 0 \\<le> l \\<Longrightarrow>\n    x < y in s_TS init h (xs @ cs) (length xs + 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + 0)", "apply (simp only: s_TS_append )"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h xs (length xs + 0)", "using 1"], ["proof (prove)\nusing this:\n  x < y in s_TS init h xs (length xs)\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h xs (length xs + 0)", "by(simp)"], ["proof (state)\nthis:\n  x < y in s_TS init h (xs @ cs) (length xs + 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> l \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + n)\n  Suc n \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "then"], ["proof (chain)\npicking this:\n  n \\<le> l \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + n)\n  Suc n \\<le> l", "have n_lt_l: \"n<l\""], ["proof (prove)\nusing this:\n  n \\<le> l \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + n)\n  Suc n \\<le> l\n\ngoal (1 subgoal):\n 1. n < l", "by auto"], ["proof (state)\nthis:\n  n < l\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> l \\<Longrightarrow>\n                x < y in s_TS init h (xs @ cs) (length xs + n);\n        Suc n \\<le> l\\<rbrakk>\n       \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + Suc n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (Suc (length xs + n))", "apply(rule othersdontinterfere)"], ["proof (prove)\ngoal (7 subgoals):\n 1. distinct init\n 2. length xs + n < length (xs @ cs)\n 3. x \\<in> set init\n 4. y \\<in> set init\n 5. set (xs @ cs) \\<subseteq> set init\n 6. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 7. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(rule di)"], ["proof (prove)\ngoal (6 subgoals):\n 1. length xs + n < length (xs @ cs)\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set (xs @ cs) \\<subseteq> set init\n 5. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 6. x < y in s_TS init h (xs @ cs) (length xs + n)", "using n_lt_l l_in_cs"], ["proof (prove)\nusing this:\n  n < l\n  l \\<le> length cs\n\ngoal (6 subgoals):\n 1. length xs + n < length (xs @ cs)\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set (xs @ cs) \\<subseteq> set init\n 5. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 6. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<in> set init\n 2. y \\<in> set init\n 3. set (xs @ cs) \\<subseteq> set init\n 4. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 5. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(fact x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y \\<in> set init\n 2. set (xs @ cs) \\<subseteq> set init\n 3. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 4. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(fact y)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (xs @ cs) \\<subseteq> set init\n 2. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 3. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(fact inin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (xs @ cs) ! (length xs + n) \\<notin> {x, y}\n 2. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(simp add: nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cs ! n \\<noteq> x \\<and> cs ! n \\<noteq> y\n 2. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x = cs ! n \\<Longrightarrow> False\n 2. y = cs ! n \\<Longrightarrow> False\n 3. x < y in s_TS init h (xs @ cs) (length xs + n)", "using assms(4) n_lt_l l_in_cs"], ["proof (prove)\nusing this:\n  x \\<notin> set cs\n  n < l\n  l \\<le> length cs\n\ngoal (3 subgoals):\n 1. x = cs ! n \\<Longrightarrow> False\n 2. y = cs ! n \\<Longrightarrow> False\n 3. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. y = cs ! n \\<Longrightarrow> False\n 2. x < y in s_TS init h (xs @ cs) (length xs + n)", "using firstocc n_lt_l"], ["proof (prove)\nusing this:\n  \\<forall>j<l. cs ! j \\<noteq> y\n  n < l\n\ngoal (2 subgoals):\n 1. y = cs ! n \\<Longrightarrow> False\n 2. x < y in s_TS init h (xs @ cs) (length xs + n)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + n)", "using Suc(1) n_lt_l"], ["proof (prove)\nusing this:\n  n \\<le> l \\<Longrightarrow> x < y in s_TS init h (xs @ cs) (length xs + n)\n  n < l\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + n)", "by(simp)"], ["proof (state)\nthis:\n  x < y in s_TS init h (xs @ cs) (length xs + Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in s_TS init h (xs @ cs) (length xs + n)\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "}\n    \\<comment> \\<open>before the request to y, x is in front of y\\<close>"], ["proof (state)\nthis:\n  ?n2 \\<le> l \\<Longrightarrow>\n  x < y in s_TS init h (xs @ cs) (length xs + ?n2)\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "then"], ["proof (chain)\npicking this:\n  ?n2 \\<le> l \\<Longrightarrow>\n  x < y in s_TS init h (xs @ cs) (length xs + ?n2)", "show \"x < y in s_TS init h (xs@cs) (length (xs)+l)\""], ["proof (prove)\nusing this:\n  ?n2 \\<le> l \\<Longrightarrow>\n  x < y in s_TS init h (xs @ cs) (length xs + ?n2)\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (xs @ cs) (length xs + l)", "by blast"], ["proof (state)\nthis:\n  x < y in s_TS init h (xs @ cs) (length xs + l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_no_action: \"step s q (0,[]) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s q (0, []) = s", "unfolding step_def mtf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) = (0, [])\n     in if q \\<in> set (swaps sws s)\n        then swaps [index (swaps sws s) q - k..<index (swaps sws s) q]\n              (swaps sws s)\n        else swaps sws s) =\n    s", "by simp"], ["", "lemma s_TS_set: \"i \\<le> length qs \\<Longrightarrow> set (s_TS init h qs i) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length qs \\<Longrightarrow> set (s_TS init h qs i) = set init", "apply(induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> length qs \\<Longrightarrow> set (s_TS init h qs 0) = set init\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> length qs \\<Longrightarrow>\n                set (s_TS init h qs i) = set init;\n        Suc i \\<le> length qs\\<rbrakk>\n       \\<Longrightarrow> set (s_TS init h qs (Suc i)) = set init", "apply(simp add: s_TS_def  )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> length qs \\<Longrightarrow>\n                set (s_TS init h qs i) = set init;\n        Suc i \\<le> length qs\\<rbrakk>\n       \\<Longrightarrow> set (s_TS init h qs (Suc i)) = set init", "apply(simp add: s_TS_def TSdet_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       Suc i \\<le> length qs \\<Longrightarrow>\n       set (fst (Partial_Cost_Model.Step (rTS h) (TSdet init h qs i)\n                  (qs ! i))) =\n       set init", "by(simp add: split_def rTS_def Step_def step_def)"], ["", "lemma count_notin2: \"count_list xs x = 0 \\<Longrightarrow> x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list xs x = 0 \\<Longrightarrow> x \\<notin> set xs", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. count_list [] x = 0 \\<Longrightarrow> x \\<notin> set []\n 2. \\<And>a xs.\n       \\<lbrakk>count_list xs x = 0 \\<Longrightarrow> x \\<notin> set xs;\n        count_list (a # xs) x = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (a # xs)", "apply (auto del: count_notin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>count_list xs x = 0 \\<Longrightarrow> False;\n        (if a = x then count_list xs x + 1 else count_list xs x) = 0;\n        x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"a=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>count_list xs x = 0 \\<Longrightarrow> False;\n        (if a = x then count_list xs x + 1 else count_list xs x) = 0;\n        x \\<in> set xs; a = x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs.\n       \\<lbrakk>count_list xs x = 0 \\<Longrightarrow> False;\n        (if a = x then count_list xs x + 1 else count_list xs x) = 0;\n        x \\<in> set xs; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "by(simp_all)+"], ["", "lemma count_append: \"count_list (xs@ys) x = count_list xs x + count_list ys x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (xs @ ys) x = count_list xs x + count_list ys x", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. count_list ([] @ ys) x = count_list [] x + count_list ys x\n 2. \\<And>a xs.\n       count_list (xs @ ys) x =\n       count_list xs x + count_list ys x \\<Longrightarrow>\n       count_list ((a # xs) @ ys) x =\n       count_list (a # xs) x + count_list ys x", "by(simp_all)"], ["", "lemma count_rev: \"count_list (rev xs) x = count_list xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (rev xs) x = count_list xs x", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. count_list (rev []) x = count_list [] x\n 2. \\<And>a xs.\n       count_list (rev xs) x = count_list xs x \\<Longrightarrow>\n       count_list (rev (a # xs)) x = count_list (a # xs) x", "by(simp_all add: count_append )"], ["", "lemma mtf2_q_passes: assumes \"q \\<in> set xs\" \"distinct xs\" \n  and \"index xs q - n \\<le> index xs x\" \"index xs x < index xs q\"\n  shows \"q < x in (mtf2 n q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "from assms"], ["proof (chain)\npicking this:\n  q \\<in> set xs\n  distinct xs\n  index xs q - n \\<le> index xs x\n  index xs x < index xs q", "have \"index xs q < length xs\""], ["proof (prove)\nusing this:\n  q \\<in> set xs\n  distinct xs\n  index xs q - n \\<le> index xs x\n  index xs x < index xs q\n\ngoal (1 subgoal):\n 1. index xs q < length xs", "by auto"], ["proof (state)\nthis:\n  index xs q < length xs\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "with assms(4)"], ["proof (chain)\npicking this:\n  index xs x < index xs q\n  index xs q < length xs", "have ind_x: \"index xs x < length xs\""], ["proof (prove)\nusing this:\n  index xs x < index xs q\n  index xs q < length xs\n\ngoal (1 subgoal):\n 1. index xs x < length xs", "by auto"], ["proof (state)\nthis:\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "then"], ["proof (chain)\npicking this:\n  index xs x < length xs", "have xinxs: \"x\\<in>set xs\""], ["proof (prove)\nusing this:\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  index xs x < length xs\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by metis"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "have B: \"index (mtf2 n q xs) q = index xs q - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 n q xs) q = index xs q - n", "apply(rule mtf2_q_after)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs\n 2. q \\<in> set xs", "by(fact)+"], ["proof (state)\nthis:\n  index (mtf2 n q xs) q = index xs q - n\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "also"], ["proof (state)\nthis:\n  index (mtf2 n q xs) q = index xs q - n\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "from ind_x mtf2_forward_effect3'[OF assms]"], ["proof (chain)\npicking this:\n  index xs x < length xs\n  index (mtf2 n q xs) (xs ! index xs x) =\n  Suc (index xs (xs ! index xs x)) \\<and>\n  index xs q - n < index (mtf2 n q xs) (xs ! index xs x) \\<and>\n  index (mtf2 n q xs) (xs ! index xs x) \\<le> index xs q", "have A: \"\\<dots> < index (mtf2 n q xs) x\""], ["proof (prove)\nusing this:\n  index xs x < length xs\n  index (mtf2 n q xs) (xs ! index xs x) =\n  Suc (index xs (xs ! index xs x)) \\<and>\n  index xs q - n < index (mtf2 n q xs) (xs ! index xs x) \\<and>\n  index (mtf2 n q xs) (xs ! index xs x) \\<le> index xs q\n\ngoal (1 subgoal):\n 1. index xs q - n < index (mtf2 n q xs) x", "by auto"], ["proof (state)\nthis:\n  index xs q - n < index (mtf2 n q xs) x\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "finally"], ["proof (chain)\npicking this:\n  index (mtf2 n q xs) q < index (mtf2 n q xs) x", "show ?thesis"], ["proof (prove)\nusing this:\n  index (mtf2 n q xs) q < index (mtf2 n q xs) x\n\ngoal (1 subgoal):\n 1. q < x in mtf2 n q xs", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index (mtf2 n q xs) q < index (mtf2 n q xs) x\n\ngoal (1 subgoal):\n 1. index (mtf2 n q xs) q < index (mtf2 n q xs) x \\<and>\n    x \\<in> set (mtf2 n q xs)", "using xinxs"], ["proof (prove)\nusing this:\n  index (mtf2 n q xs) q < index (mtf2 n q xs) x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. index (mtf2 n q xs) q < index (mtf2 n q xs) x \\<and>\n    x \\<in> set (mtf2 n q xs)", "by force"], ["proof (state)\nthis:\n  q < x in mtf2 n q xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma twotox:\n    assumes \"count_list bs y \\<le> 1\"\n      and \"distinct init\"\n      and \"x \\<in> set init\"\n      and \"y : set init\" \n      and \"x \\<notin> set bs\"\n      and \"x\\<noteq>y\"\n    shows \"x < y in s_TS init h (as@[x]@bs@[x]) (length (as@[x]@bs@[x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have aa: \"snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs)))\n        = rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))) =\n    rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h", "apply(rule sndTSdet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length as + length bs) \\<le> length ((as @ x # bs) @ [x])", "by(simp)"], ["proof (state)\nthis:\n  snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))) =\n  rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "then"], ["proof (chain)\npicking this:\n  snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))) =\n  rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h", "have aa': \"snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n        = rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\""], ["proof (prove)\nusing this:\n  snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))) =\n  rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\n\ngoal (1 subgoal):\n 1. snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))) =\n    rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h", "by auto"], ["proof (state)\nthis:\n  snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))) =\n  rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have lasocc_x: \"index (snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs)))) x = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h ((as @ x # bs) @ [x])\n            (Suc (length as + length bs))))\n     x =\n    length bs", "unfolding aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h)\n     x =\n    length bs", "apply(simp add:  del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (rev bs @ x # rev as @ h) x = length bs", "using assms(5)"], ["proof (prove)\nusing this:\n  x \\<notin> set bs\n\ngoal (1 subgoal):\n 1. index (rev bs @ x # rev as @ h) x = length bs", "by(simp add: index_append)"], ["proof (state)\nthis:\n  index\n   (snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))))\n   x =\n  length bs\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "then"], ["proof (chain)\npicking this:\n  index\n   (snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))))\n   x =\n  length bs", "have lasocc_x': \"(index (snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x) = length bs\""], ["proof (prove)\nusing this:\n  index\n   (snd (TSdet init h ((as @ x # bs) @ [x]) (Suc (length as + length bs))))\n   x =\n  length bs\n\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x =\n    length bs", "by auto"], ["proof (state)\nthis:\n  index\n   (snd (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n   x =\n  length bs\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "let ?sincelast = \"take (length bs)\n                          (snd (TSdet init h ((as @ x # bs) @ [x])\n                                 (Suc (length as + length bs))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have sl: \"?sincelast  = rev bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length bs)\n     (snd (TSdet init h ((as @ x # bs) @ [x])\n            (Suc (length as + length bs)))) =\n    rev bs", "unfolding aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length bs)\n     (rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h) =\n    rev bs", "by(simp)"], ["proof (state)\nthis:\n  take (length bs)\n   (snd (TSdet init h ((as @ x # bs) @ [x])\n          (Suc (length as + length bs)))) =\n  rev bs\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "let ?S = \"{xa. xa < x in fst (TSdet init h (as @ x # bs @ [x])\n                                      (Suc (length as + length bs))) \\<and>\n                             count_list ?sincelast xa \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have y: \"y \\<in> ?S \\<or> ~  y < x  in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {xa.\n             xa < x\n             in fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs))) \\<and>\n             count_list\n              (take (length bs)\n                (snd (TSdet init h ((as @ x # bs) @ [x])\n                       (Suc (length as + length bs)))))\n              xa\n             \\<le> 1} \\<or>\n    \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "unfolding sl"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {xa.\n             xa < x\n             in fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs))) \\<and>\n             count_list (rev bs) xa \\<le> 1} \\<or>\n    \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "unfolding s_TS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {xa.\n             xa < x\n             in fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs))) \\<and>\n             count_list (rev bs) xa \\<le> 1} \\<or>\n    \\<not> y < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs)))", "using assms(1)"], ["proof (prove)\nusing this:\n  count_list bs y \\<le> 1\n\ngoal (1 subgoal):\n 1. y \\<in> {xa.\n             xa < x\n             in fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs))) \\<and>\n             count_list (rev bs) xa \\<le> 1} \\<or>\n    \\<not> y < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs)))", "by(simp add: count_rev del: config'.simps)"], ["proof (state)\nthis:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1} \\<or>\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have eklr: \"length (as@[x]@bs@[x]) = Suc (length (as@[x]@bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) = Suc (length (as @ [x] @ bs))", "by simp"], ["proof (state)\nthis:\n  length (as @ [x] @ bs @ [x]) = Suc (length (as @ [x] @ bs))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have 1: \"s_TS init h (as@[x]@bs@[x]) (length (as@[x]@bs@[x]))\n     = fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x])\n            (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x])) =\n    fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))", "unfolding s_TS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ [x] @ bs @ [x])\n          (length (as @ [x] @ bs @ [x]))) =\n    fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))", "unfolding eklr"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ [x] @ bs @ [x])\n          (Suc (length (as @ [x] @ bs)))) =\n    fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))", "apply(subst TSdet_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (length (as @ [x] @ bs)) \\<le> length (as @ [x] @ bs @ [x])\n 2. fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs))) =\n    fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))", "by(simp_all add: split_def)"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x])) =\n  fst (Partial_Cost_Model.Step (rTS h)\n        (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n        ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have brrr: \"x\\<in> set (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))", "apply(subst s_TS_set[unfolded s_TS_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (length as + length bs) \\<le> length (as @ x # bs @ [x])\n 2. x \\<in> set init", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set init", "by fact"], ["proof (state)\nthis:\n  x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have ydrin: \"y\\<in>set (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))", "apply(subst s_TS_set[unfolded s_TS_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (length as + length bs) \\<le> length (as @ x # bs @ [x])\n 2. y \\<in> set init", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set init", "by fact"], ["proof (state)\nthis:\n  y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have dbrrr: \"distinct (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))", "apply(subst s_TS_distinct[unfolded s_TS_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct init\n 2. Suc (length as + length bs) < length (as @ x # bs @ [x])\n 3. True", "using assms(2)"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (3 subgoals):\n 1. distinct init\n 2. Suc (length as + length bs) < length (as @ x # bs @ [x])\n 3. True", "by(simp_all)"], ["proof (state)\nthis:\n  distinct\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "proof (cases \"y < x  in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "case True"], ["proof (state)\nthis:\n  y < x in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "with y"], ["proof (chain)\npicking this:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1} \\<or>\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n  y < x in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "have yS: \"y\\<in>?S\""], ["proof (prove)\nusing this:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1} \\<or>\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n  y < x in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. y \\<in> {xa.\n             xa < x\n             in fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs))) \\<and>\n             count_list\n              (take (length bs)\n                (snd (TSdet init h ((as @ x # bs) @ [x])\n                       (Suc (length as + length bs)))))\n              xa\n             \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "then"], ["proof (chain)\npicking this:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}", "have minsteps: \"Min (index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) ` ?S)\n              \\<le> index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\""], ["proof (prove)\nusing this:\n  y \\<in> {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}\n\ngoal (1 subgoal):\n 1. Min (index\n          (fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs)))) `\n         {xa.\n          xa < x\n          in fst (TSdet init h (as @ x # bs @ [x])\n                   (Suc (length as + length bs))) \\<and>\n          count_list\n           (take (length bs)\n             (snd (TSdet init h ((as @ x # bs) @ [x])\n                    (Suc (length as + length bs)))))\n           xa\n          \\<le> 1})\n    \\<le> index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))))\n           y", "by auto"], ["proof (state)\nthis:\n  Min (index\n        (fst (TSdet init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)))) `\n       {xa.\n        xa < x\n        in fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs))) \\<and>\n        count_list\n         (take (length bs)\n           (snd (TSdet init h ((as @ x # bs) @ [x])\n                  (Suc (length as + length bs)))))\n         xa\n        \\<le> 1})\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "let ?entf = \"index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x -\n                           Min (index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) ` ?S)\""], ["proof (state)\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "from minsteps"], ["proof (chain)\npicking this:\n  Min (index\n        (fst (TSdet init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)))) `\n       {xa.\n        xa < x\n        in fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs))) \\<and>\n        count_list\n         (take (length bs)\n           (snd (TSdet init h ((as @ x # bs) @ [x])\n                  (Suc (length as + length bs)))))\n         xa\n        \\<le> 1})\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y", "have br: \" index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x - (?entf)\n          \\<le> index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\""], ["proof (prove)\nusing this:\n  Min (index\n        (fst (TSdet init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)))) `\n       {xa.\n        xa < x\n        in fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs))) \\<and>\n        count_list\n         (take (length bs)\n           (snd (TSdet init h ((as @ x # bs) @ [x])\n                  (Suc (length as + length bs)))))\n         xa\n        \\<le> 1})\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x -\n    (index\n      (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n      x -\n     Min (index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))) `\n          {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}))\n    \\<le> index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))))\n           y", "by presburger"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n   x -\n  (index\n    (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n    x -\n   Min (index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs)))) `\n        {xa.\n         xa < x\n         in fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))) \\<and>\n         count_list\n          (take (length bs)\n            (snd (TSdet init h ((as @ x # bs) @ [x])\n                   (Suc (length as + length bs)))))\n          xa\n         \\<le> 1}))\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have brr: \"index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n        < index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     y\n    < index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x", "using True"], ["proof (prove)\nusing this:\n  y < x in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     y\n    < index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x", "unfolding before_in_def s_TS_def"], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n  < index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x \\<and>\n  x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     y\n    < index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x", "by auto"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n  < index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "from br brr"], ["proof (chain)\npicking this:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n   x -\n  (index\n    (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n    x -\n   Min (index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs)))) `\n        {xa.\n         xa < x\n         in fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))) \\<and>\n         count_list\n          (take (length bs)\n            (snd (TSdet init h ((as @ x # bs) @ [x])\n                   (Suc (length as + length bs)))))\n          xa\n         \\<le> 1}))\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n  < index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x", "have klo: \" index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x - (?entf)\n          \\<le> index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n        \\<and> index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n        < index (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) x\""], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n   x -\n  (index\n    (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n    x -\n   Min (index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs)))) `\n        {xa.\n         xa < x\n         in fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))) \\<and>\n         count_list\n          (take (length bs)\n            (snd (TSdet init h ((as @ x # bs) @ [x])\n                   (Suc (length as + length bs)))))\n          xa\n         \\<le> 1}))\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n  < index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x -\n    (index\n      (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n      x -\n     Min (index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))) `\n          {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}))\n    \\<le> index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))))\n           y \\<and>\n    index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     y\n    < index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x", "by metis"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n   x -\n  (index\n    (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n    x -\n   Min (index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs)))) `\n        {xa.\n         xa < x\n         in fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))) \\<and>\n         count_list\n          (take (length bs)\n            (snd (TSdet init h ((as @ x # bs) @ [x])\n                   (Suc (length as + length bs)))))\n          xa\n         \\<le> 1}))\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ [x])\n                (Suc (length as + length bs))))\n         y \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))) y\n  < index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "let ?result =\"(mtf2 ?entf x (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))))\""], ["proof (state)\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have whatsthat: \"s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n        = ?result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x])) =\n    mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x -\n      Min (index\n            (fst (TSdet init h (as @ x # bs @ [x])\n                   (Suc (length as + length bs)))) `\n           {xa.\n            xa < x\n            in fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))) \\<and>\n            count_list\n             (take (length bs)\n               (snd (TSdet init h ((as @ x # bs) @ [x])\n                      (Suc (length as + length bs)))))\n             xa\n            \\<le> 1}))\n     x (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.Step (rTS h)\n          (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n          ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs))) =\n    mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x -\n      Min (index\n            (fst (TSdet init h (as @ x # bs @ [x])\n                   (Suc (length as + length bs)))) `\n           {xa.\n            xa < x\n            in fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))) \\<and>\n            count_list\n             (take (length bs)\n               (snd (TSdet init h ((as @ x # bs) @ [x])\n                      (Suc (length as + length bs)))))\n             xa\n            \\<le> 1}))\n     x (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))", "apply(simp add: split_def step_def rTS_def Step_def TS_step_d_def del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>xa.\n         xa < (as @ x # bs @ [x]) ! Suc (length as + length bs)\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<longrightarrow>\n         \\<not> count_list\n                 (take\n                   (index\n                     (snd (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs)))\n                     ((as @ x # bs @ [x]) ! Suc (length as + length bs)))\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs))))\n                 xa\n                \\<le> Suc 0) \\<longrightarrow>\n     fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs)) =\n     mtf2\n      (index\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))\n        x -\n       Min (index\n             (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                    (init, h) (as @ x # bs))) `\n            {xa.\n             xa < x\n             in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs)) \\<and>\n             count_list\n              (take (length bs)\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs))))\n              xa\n             \\<le> Suc 0}))\n      x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))) \\<and>\n    ((\\<exists>xa.\n         xa < (as @ x # bs @ [x]) ! Suc (length as + length bs)\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs)))\n              ((as @ x # bs @ [x]) ! Suc (length as + length bs)))\n            (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs))))\n          xa\n         \\<le> Suc 0) \\<longrightarrow>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       ((as @ x # bs @ [x]) ! Suc (length as + length bs)) =\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs)) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))) \\<and>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       ((as @ x # bs @ [x]) ! Suc (length as + length bs)) \\<noteq>\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         ((as @ x # bs @ [x]) ! Suc (length as + length bs)) -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < (as @ x # bs @ [x]) ! Suc (length as + length bs)\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take\n                 (index\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs)))\n                   ((as @ x # bs @ [x]) ! Suc (length as + length bs)))\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       ((as @ x # bs @ [x]) ! Suc (length as + length bs))\n       (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))))", "apply(simp add: nth_append del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>xa.\n         xa < x\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<longrightarrow>\n         \\<not> count_list\n                 (take\n                   (index\n                     (snd (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs)))\n                     x)\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs))))\n                 xa\n                \\<le> Suc 0) \\<longrightarrow>\n     fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs)) =\n     mtf2\n      (index\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))\n        x -\n       Min (index\n             (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                    (init, h) (as @ x # bs))) `\n            {xa.\n             xa < x\n             in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs)) \\<and>\n             count_list\n              (take (length bs)\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs))))\n              xa\n             \\<le> Suc 0}))\n      x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))) \\<and>\n    ((\\<exists>xa.\n         xa < x\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs)))\n              x)\n            (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs))))\n          xa\n         \\<le> Suc 0) \\<longrightarrow>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       x =\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs)) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))) \\<and>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       x \\<noteq>\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take\n                 (index\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs)))\n                   x)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs))) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))))", "using lasocc_x'[unfolded rTS_def] aa'[unfolded rTS_def]"], ["proof (prove)\nusing this:\n  index\n   (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n          (take (Suc (length as + length bs)) (as @ x # bs @ [x]))))\n   x =\n  length bs\n  snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n        (take (Suc (length as + length bs)) (as @ x # bs @ [x]))) =\n  rev (take (Suc (length as + length bs)) ((as @ x # bs) @ [x])) @ h\n\ngoal (1 subgoal):\n 1. ((\\<forall>xa.\n         xa < x\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<longrightarrow>\n         \\<not> count_list\n                 (take\n                   (index\n                     (snd (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs)))\n                     x)\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs))))\n                 xa\n                \\<le> Suc 0) \\<longrightarrow>\n     fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs)) =\n     mtf2\n      (index\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))\n        x -\n       Min (index\n             (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                    (init, h) (as @ x # bs))) `\n            {xa.\n             xa < x\n             in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs)) \\<and>\n             count_list\n              (take (length bs)\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs))))\n              xa\n             \\<le> Suc 0}))\n      x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs)))) \\<and>\n    ((\\<exists>xa.\n         xa < x\n         in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs)))\n              x)\n            (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs))))\n          xa\n         \\<le> Suc 0) \\<longrightarrow>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       x =\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs)) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))) \\<and>\n     (index\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs)))\n       x \\<noteq>\n      length\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs))) \\<longrightarrow>\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take\n                 (index\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs)))\n                   x)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs))) =\n      mtf2\n       (index\n         (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))\n         x -\n        Min (index\n              (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs))) `\n             {xa.\n              xa < x\n              in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs)) \\<and>\n              count_list\n               (take (length bs)\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs))))\n               xa\n              \\<le> Suc 0}))\n       x (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs)))))", "apply(simp add:  del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index (rev bs @ x # rev as @ h) x = length bs;\n     snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs)) =\n     rev bs @ x # rev as @ h\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          xa < x\n                          in fst (Partial_Cost_Model.config'\n                                   (\\<lambda>s. h, TS_step_d) (init, h)\n                                   (as @ x # bs)) \\<longrightarrow>\n                          \\<not> count_list (rev bs) xa\n                                 \\<le> Suc 0) \\<longrightarrow>\n                      fst (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs)) =\n                      mtf2\n                       (index\n                         (fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs)))\n                         x -\n                        Min (index\n                              (fst (Partial_Cost_Model.config'\n                                     (\\<lambda>s. h, TS_step_d) (init, h)\n                                     (as @ x # bs))) `\n                             {xa.\n                              xa < x\n                              in fst (Partial_Cost_Model.config'\n (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs)) \\<and>\n                              count_list (rev bs) xa \\<le> Suc 0}))\n                       x (fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs)))", "using yS[unfolded sl rTS_def]"], ["proof (prove)\nusing this:\n  y \\<in> {xa.\n           xa < x\n           in fst (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n                    (take (Suc (length as + length bs))\n                      (as @ x # bs @ [x]))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n                     (take (Suc (length as + length bs))\n                       ((as @ x # bs) @ [x])))))\n            xa\n           \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>index (rev bs @ x # rev as @ h) x = length bs;\n     snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs)) =\n     rev bs @ x # rev as @ h\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          xa < x\n                          in fst (Partial_Cost_Model.config'\n                                   (\\<lambda>s. h, TS_step_d) (init, h)\n                                   (as @ x # bs)) \\<longrightarrow>\n                          \\<not> count_list (rev bs) xa\n                                 \\<le> Suc 0) \\<longrightarrow>\n                      fst (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs)) =\n                      mtf2\n                       (index\n                         (fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs)))\n                         x -\n                        Min (index\n                              (fst (Partial_Cost_Model.config'\n                                     (\\<lambda>s. h, TS_step_d) (init, h)\n                                     (as @ x # bs))) `\n                             {xa.\n                              xa < x\n                              in fst (Partial_Cost_Model.config'\n (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs)) \\<and>\n                              count_list (rev bs) xa \\<le> Suc 0}))\n                       x (fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs)))", "by auto"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x])) =\n  mtf2\n   (index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x -\n    Min (index\n          (fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs)))) `\n         {xa.\n          xa < x\n          in fst (TSdet init h (as @ x # bs @ [x])\n                   (Suc (length as + length bs))) \\<and>\n          count_list\n           (take (length bs)\n             (snd (TSdet init h ((as @ x # bs) @ [x])\n                    (Suc (length as + length bs)))))\n           xa\n          \\<le> 1}))\n   x (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have ydrinee: \"  y \\<in> set (mtf2 ?entf x (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (mtf2\n                  (index\n                    (fst (TSdet init h (as @ x # bs @ [x])\n                           (Suc (length as + length bs))))\n                    x -\n                   Min (index\n                         (fst (TSdet init h (as @ x # bs @ [x])\n                                (Suc (length as + length bs)))) `\n                        {xa.\n                         xa < x\n                         in fst (TSdet init h (as @ x # bs @ [x])\n                                  (Suc (length as + length bs))) \\<and>\n                         count_list\n                          (take (length bs)\n                            (snd (TSdet init h ((as @ x # bs) @ [x])\n                                   (Suc (length as + length bs)))))\n                          xa\n                         \\<le> 1}))\n                  x (fst (TSdet init h (as @ x # bs @ [x])\n                           (Suc (length as + length bs)))))", "apply(subst set_mtf2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))", "apply(subst s_TS_set[unfolded s_TS_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (length as + length bs) \\<le> length (as @ x # bs @ [x])\n 2. y \\<in> set init", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set init", "by fact"], ["proof (state)\nthis:\n  y \\<in> set (mtf2\n                (index\n                  (fst (TSdet init h (as @ x # bs @ [x])\n                         (Suc (length as + length bs))))\n                  x -\n                 Min (index\n                       (fst (TSdet init h (as @ x # bs @ [x])\n                              (Suc (length as + length bs)))) `\n                      {xa.\n                       xa < x\n                       in fst (TSdet init h (as @ x # bs @ [x])\n                                (Suc (length as + length bs))) \\<and>\n                       count_list\n                        (take (length bs)\n                          (snd (TSdet init h ((as @ x # bs) @ [x])\n                                 (Suc (length as + length bs)))))\n                        xa\n                       \\<le> 1}))\n                x (fst (TSdet init h (as @ x # bs @ [x])\n                         (Suc (length as + length bs)))))\n\ngoal (2 subgoals):\n 1. y < x\n    in s_TS init h (as @ x # bs @ [x])\n        (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "unfolding whatsthat"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in mtf2\n        (index\n          (fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs))))\n          x -\n         Min (index\n               (fst (TSdet init h (as @ x # bs @ [x])\n                      (Suc (length as + length bs)))) `\n              {xa.\n               xa < x\n               in fst (TSdet init h (as @ x # bs @ [x])\n                        (Suc (length as + length bs))) \\<and>\n               count_list\n                (take (length bs)\n                  (snd (TSdet init h ((as @ x # bs) @ [x])\n                         (Suc (length as + length bs)))))\n                xa\n               \\<le> 1}))\n        x (fst (TSdet init h (as @ x # bs @ [x])\n                 (Suc (length as + length bs))))", "apply(rule mtf2_q_passes)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))\n 2. distinct\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n 3. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     x -\n    (index\n      (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n      x -\n     Min (index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))) `\n          {xa.\n           xa < x\n           in fst (TSdet init h (as @ x # bs @ [x])\n                    (Suc (length as + length bs))) \\<and>\n           count_list\n            (take (length bs)\n              (snd (TSdet init h ((as @ x # bs) @ [x])\n                     (Suc (length as + length bs)))))\n            xa\n           \\<le> 1}))\n    \\<le> index\n           (fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs))))\n           y\n 4. index\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n     y\n    < index\n       (fst (TSdet init h (as @ x # bs @ [x])\n              (Suc (length as + length bs))))\n       x", "by(fact)+"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "then"], ["proof (chain)\npicking this:\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "have 2: \"x < y  in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\""], ["proof (prove)\nusing this:\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "using brrr ydrin not_before_in assms(6)"], ["proof (prove)\nusing this:\n  \\<not> y < x\n         in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n  x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n  y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  \\<not> y < x\n         in fst (TSdet init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))\n  x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n  y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                     (Suc (length as + length bs))))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "by metis"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "{"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "have \"x < y in mtf2 e x (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in mtf2 e x\n        (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "apply(rule x_stays_before_y_if_y_not_moved_to_front)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x \\<in> set (s_TS init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))\n 2. distinct (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n 3. x \\<in> set (s_TS init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))\n 4. y \\<in> set (s_TS init h (as @ x # bs @ [x])\n                  (Suc (length as + length bs)))\n 5. y \\<noteq> x\n 6. x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))", "unfolding s_TS_def"], ["proof (prove)\ngoal (6 subgoals):\n 1. x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))\n 2. distinct\n     (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n 3. x \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))\n 4. y \\<in> set (fst (TSdet init h (as @ x # bs @ [x])\n                       (Suc (length as + length bs))))\n 5. y \\<noteq> x\n 6. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "apply(fact)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<noteq> x\n 2. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "using assms(6)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. y \\<noteq> x\n 2. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "using 2"], ["proof (prove)\nusing this:\n  x < y in s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs))\n\ngoal (1 subgoal):\n 1. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  x < y\n  in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n\ngoal (1 subgoal):\n 1. x < y\n    in fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs)))", "by simp"], ["proof (state)\nthis:\n  x < y\n  in mtf2 e x\n      (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "}"], ["proof (state)\nthis:\n  x < y\n  in mtf2 ?e2 x\n      (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "note bratz=this"], ["proof (state)\nthis:\n  x < y\n  in mtf2 ?e2 x\n      (s_TS init h (as @ x # bs @ [x]) (Suc (length as + length bs)))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in s_TS init h (as @ x # bs @ [x])\n               (Suc (length as + length bs)) \\<Longrightarrow>\n    x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.Step (rTS h)\n             (TSdet init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs)))\n             ((as @ [x] @ bs @ [x]) ! length (as @ [x] @ bs)))", "apply(simp add: TSnopaid split_def Step_def s_TS_def TS_step_d_def step_def nth_append  del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in mtf2\n        (fst (fst (snd (rTS h) (config\\<^sub>p (rTS h) init (as @ x # bs))\n                    x)))\n        x (fst (config\\<^sub>p (rTS h) init (as @ x # bs)))", "using bratz[unfolded s_TS_def]"], ["proof (prove)\nusing this:\n  x < y\n  in mtf2 ?e2 x\n      (fst (TSdet init h (as @ x # bs @ [x]) (Suc (length as + length bs))))\n\ngoal (1 subgoal):\n 1. x < y\n    in mtf2\n        (fst (fst (snd (rTS h) (config\\<^sub>p (rTS h) init (as @ x # bs))\n                    x)))\n        x (fst (config\\<^sub>p (rTS h) init (as @ x # bs)))", "by simp"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_drop: \"count_list (drop n cs) x \\<le> count_list cs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "have \"count_list cs x = count_list (take n cs @ drop n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list cs x = count_list (take n cs @ drop n cs) x", "by auto"], ["proof (state)\nthis:\n  count_list cs x = count_list (take n cs @ drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "also"], ["proof (state)\nthis:\n  count_list cs x = count_list (take n cs @ drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "have \"\\<dots> = count_list (take n cs) x + count_list (drop n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n cs @ drop n cs) x =\n    count_list (take n cs) x + count_list (drop n cs) x", "by (rule count_append)"], ["proof (state)\nthis:\n  count_list (take n cs @ drop n cs) x =\n  count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "also"], ["proof (state)\nthis:\n  count_list (take n cs @ drop n cs) x =\n  count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "have \"\\<dots> \\<ge> count_list (drop n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (drop n cs) x\n    \\<le> count_list (take n cs) x + count_list (drop n cs) x", "by auto"], ["proof (state)\nthis:\n  count_list (drop n cs) x\n  \\<le> count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "finally"], ["proof (chain)\npicking this:\n  count_list (drop n cs) x \\<le> count_list cs x", "show ?thesis"], ["proof (prove)\nusing this:\n  count_list (drop n cs) x \\<le> count_list cs x\n\ngoal (1 subgoal):\n 1. count_list (drop n cs) x \\<le> count_list cs x", "."], ["proof (state)\nthis:\n  count_list (drop n cs) x \\<le> count_list cs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_take_less: assumes \"n\\<le>m\" \n  shows \"count_list (take n cs) x \\<le> count_list (take m cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "from assms"], ["proof (chain)\npicking this:\n  n \\<le> m", "have \"count_list (take n cs) x = count_list (take n (take m cs)) x\""], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x = count_list (take n (take m cs)) x", "by auto"], ["proof (state)\nthis:\n  count_list (take n cs) x = count_list (take n (take m cs)) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "also"], ["proof (state)\nthis:\n  count_list (take n cs) x = count_list (take n (take m cs)) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "have \"\\<dots> \\<le> count_list (take n (take m cs) @ drop n (take m cs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n (take m cs)) x\n    \\<le> count_list (take n (take m cs) @ drop n (take m cs)) x", "by (simp only: count_append)"], ["proof (state)\nthis:\n  count_list (take n (take m cs)) x\n  \\<le> count_list (take n (take m cs) @ drop n (take m cs)) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "also"], ["proof (state)\nthis:\n  count_list (take n (take m cs)) x\n  \\<le> count_list (take n (take m cs) @ drop n (take m cs)) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "have \"\\<dots> = count_list (take m cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n (take m cs) @ drop n (take m cs)) x =\n    count_list (take m cs) x", "by(simp only: append_take_drop_id)"], ["proof (state)\nthis:\n  count_list (take n (take m cs) @ drop n (take m cs)) x =\n  count_list (take m cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "finally"], ["proof (chain)\npicking this:\n  count_list (take n cs) x \\<le> count_list (take m cs) x", "show ?thesis"], ["proof (prove)\nusing this:\n  count_list (take n cs) x \\<le> count_list (take m cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list (take m cs) x", "."], ["proof (state)\nthis:\n  count_list (take n cs) x \\<le> count_list (take m cs) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_take: \"count_list (take n cs) x \\<le> count_list cs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "have \"count_list cs x = count_list (take n cs @ drop n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list cs x = count_list (take n cs @ drop n cs) x", "by auto"], ["proof (state)\nthis:\n  count_list cs x = count_list (take n cs @ drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "also"], ["proof (state)\nthis:\n  count_list cs x = count_list (take n cs @ drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "have \"\\<dots> = count_list (take n cs) x + count_list (drop n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n cs @ drop n cs) x =\n    count_list (take n cs) x + count_list (drop n cs) x", "by (rule count_append)"], ["proof (state)\nthis:\n  count_list (take n cs @ drop n cs) x =\n  count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "also"], ["proof (state)\nthis:\n  count_list (take n cs @ drop n cs) x =\n  count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "have \"\\<dots> \\<ge> count_list (take n cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take n cs) x\n    \\<le> count_list (take n cs) x + count_list (drop n cs) x", "by auto"], ["proof (state)\nthis:\n  count_list (take n cs) x\n  \\<le> count_list (take n cs) x + count_list (drop n cs) x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "finally"], ["proof (chain)\npicking this:\n  count_list (take n cs) x \\<le> count_list cs x", "show ?thesis"], ["proof (prove)\nusing this:\n  count_list (take n cs) x \\<le> count_list cs x\n\ngoal (1 subgoal):\n 1. count_list (take n cs) x \\<le> count_list cs x", "."], ["proof (state)\nthis:\n  count_list (take n cs) x \\<le> count_list cs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma casexxy: assumes \"\\<sigma>=as@[x]@bs@[x]@cs\"\n    and \"x \\<notin> set cs\"\n    and \"set cs \\<subseteq> set init\"\n    and \"x \\<in> set init\"\n    and \"distinct init\"\n    and \"x \\<notin> set bs\"\n    and \"set as \\<subseteq> set init\"\n    and \"set bs \\<subseteq> set init\"\n  shows \"(%i. i<length cs \\<longrightarrow> (\\<forall>j<i. cs!j\\<noteq>cs!i) \\<longrightarrow> cs!i\\<noteq>x\n      \\<longrightarrow> (cs!i) \\<notin> set bs\n      \\<longrightarrow> x < (cs!i) in  (s_TS init h \\<sigma> (length (as@[x]@bs@[x]) + i+1))) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<longrightarrow>\n    (\\<forall>j<i. cs ! j \\<noteq> cs ! i) \\<longrightarrow>\n    cs ! i \\<noteq> x \\<longrightarrow>\n    cs ! i \\<notin> set bs \\<longrightarrow>\n    x < cs ! i\n    in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)", "proof (rule infinite_descent[where P=\"(%i. i<length cs \\<longrightarrow> (\\<forall>j<i. cs!j\\<noteq>cs!i) \\<longrightarrow> cs!i\\<noteq>x\n      \\<longrightarrow> (cs!i) \\<notin> set bs\n      \\<longrightarrow> x < (cs!i) in  (s_TS init h \\<sigma> (length (as@[x]@bs@[x]) + i+1)))\"], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "case (1 i)"], ["proof (state)\nthis:\n  \\<not> (i < length cs \\<longrightarrow>\n          (\\<forall>j<i. cs ! j \\<noteq> cs ! i) \\<longrightarrow>\n          cs ! i \\<noteq> x \\<longrightarrow>\n          cs ! i \\<notin> set bs \\<longrightarrow>\n          x < cs ! i\n          in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?y = \"cs!i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from 1"], ["proof (chain)\npicking this:\n  \\<not> (i < length cs \\<longrightarrow>\n          (\\<forall>j<i. cs ! j \\<noteq> cs ! i) \\<longrightarrow>\n          cs ! i \\<noteq> x \\<longrightarrow>\n          cs ! i \\<notin> set bs \\<longrightarrow>\n          x < cs ! i\n          in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))", "have i_in_cs: \"i < length cs\" and\n      firstocc: \"(\\<forall>j<i. cs ! j \\<noteq> cs ! i)\"\n      and ynx: \"cs ! i \\<noteq> x\"\n      and ynotinbs: \"cs ! i \\<notin> set bs\"\n      and y_before_x': \"~x < cs ! i in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1)\""], ["proof (prove)\nusing this:\n  \\<not> (i < length cs \\<longrightarrow>\n          (\\<forall>j<i. cs ! j \\<noteq> cs ! i) \\<longrightarrow>\n          cs ! i \\<noteq> x \\<longrightarrow>\n          cs ! i \\<notin> set bs \\<longrightarrow>\n          x < cs ! i\n          in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. (i < length cs &&& \\<forall>j<i. cs ! j \\<noteq> cs ! i) &&&\n    cs ! i \\<noteq> x &&&\n    cs ! i \\<notin> set bs &&&\n    \\<not> x < cs ! i\n           in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)", "by auto"], ["proof (state)\nthis:\n  i < length cs\n  \\<forall>j<i. cs ! j \\<noteq> cs ! i\n  cs ! i \\<noteq> x\n  cs ! i \\<notin> set bs\n  \\<not> x < cs ! i\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have ss: \"set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1)) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)) =\n    set init", "using assms(1) i_in_cs"], ["proof (prove)\nusing this:\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n  i < length cs\n\ngoal (1 subgoal):\n 1. set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)) =\n    set init", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)) =\n  set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)) =\n  set init", "have \"cs ! i \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1))\""], ["proof (prove)\nusing this:\n  set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)) =\n  set init\n\ngoal (1 subgoal):\n 1. cs ! i\n    \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))", "unfolding ss"], ["proof (prove)\nusing this:\n  set init = set init\n\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "using assms(3) i_in_cs"], ["proof (prove)\nusing this:\n  set init = set init\n  set cs \\<subseteq> set init\n  i < length cs\n\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "by fastforce"], ["proof (state)\nthis:\n  cs ! i\n  \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "moreover"], ["proof (state)\nthis:\n  cs ! i\n  \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"x : set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h \\<sigma>\n                  (length (as @ [x] @ bs @ [x]) + i + 1))", "unfolding ss"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set init", "using assms(4)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x \\<in> set init", "by fastforce\n\n  \\<comment> \\<open>after the request to y, y is in front of x\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "ultimately"], ["proof (chain)\npicking this:\n  cs ! i\n  \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n  x \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))", "have y_before_x_Suct3: \"?y < x in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1)\""], ["proof (prove)\nusing this:\n  cs ! i\n  \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n  x \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. cs ! i < x\n    in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)", "using  y_before_x' ynx not_before_in"], ["proof (prove)\nusing this:\n  cs ! i\n  \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n  x \\<in> set (s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1))\n  \\<not> x < cs ! i\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n  cs ! i \\<noteq> x\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. cs ! i < x\n    in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)", "by metis"], ["proof (state)\nthis:\n  cs ! i < x in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from ynotinbs"], ["proof (chain)\npicking this:\n  cs ! i \\<notin> set bs", "have yatmostonceinbs: \"count_list bs (cs!i) \\<le> 1\""], ["proof (prove)\nusing this:\n  cs ! i \\<notin> set bs\n\ngoal (1 subgoal):\n 1. count_list bs (cs ! i) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  count_list bs (cs ! i) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?y = \"cs!i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have yininit: \"?y \\<in> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "using assms(3) i_in_cs"], ["proof (prove)\nusing this:\n  set cs \\<subseteq> set init\n  i < length cs\n\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "by fastforce"], ["proof (state)\nthis:\n  cs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "{"], ["proof (state)\nthis:\n  cs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "assume \"y \\<in> set init\""], ["proof (state)\nthis:\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "assume \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "assume \"count_list bs y \\<le> 1\""], ["proof (state)\nthis:\n  count_list bs y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  count_list bs y \\<le> 1", "have \"x < y in s_TS init h (as@[x]@bs@[x]) (length (as@[x]@bs@[x]))\""], ["proof (prove)\nusing this:\n  count_list bs y \\<le> 1\n\ngoal (1 subgoal):\n 1. x < y\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "apply(rule twotox)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. x \\<notin> set bs\n 5. x \\<noteq> y", "by(fact)+"], ["proof (state)\nthis:\n  x < y in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y2 \\<in> set init; x \\<noteq> ?y2;\n   count_list bs ?y2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> x < ?y2\n                    in s_TS init h (as @ [x] @ bs @ [x])\n                        (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "note xgoestofront=this"], ["proof (state)\nthis:\n  \\<lbrakk>?y2 \\<in> set init; x \\<noteq> ?y2;\n   count_list bs ?y2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> x < ?y2\n                    in s_TS init h (as @ [x] @ bs @ [x])\n                        (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with yatmostonceinbs ynx yininit"], ["proof (chain)\npicking this:\n  count_list bs (cs ! i) \\<le> 1\n  cs ! i \\<noteq> x\n  cs ! i \\<in> set init\n  \\<lbrakk>?y2 \\<in> set init; x \\<noteq> ?y2;\n   count_list bs ?y2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> x < ?y2\n                    in s_TS init h (as @ [x] @ bs @ [x])\n                        (length (as @ [x] @ bs @ [x]))", "have zeitpunktt2: \"x < ?y in s_TS init h (as@[x]@bs@[x]) (length (as@[x]@bs@[x]))\""], ["proof (prove)\nusing this:\n  count_list bs (cs ! i) \\<le> 1\n  cs ! i \\<noteq> x\n  cs ! i \\<in> set init\n  \\<lbrakk>?y2 \\<in> set init; x \\<noteq> ?y2;\n   count_list bs ?y2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> x < ?y2\n                    in s_TS init h (as @ [x] @ bs @ [x])\n                        (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. x < cs ! i\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "by blast"], ["proof (state)\nthis:\n  x < cs ! i\n  in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"i \\<le> length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length cs", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. i \\<le> length cs", "by auto"], ["proof (state)\nthis:\n  i \\<le> length cs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have x_before_y_t3: \"x < ?y in s_TS init h ((as@[x]@bs@[x])@cs) (length (as@[x]@bs@[x])+i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < cs ! i\n    in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)", "apply(rule TS_mono)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < cs ! i\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. i \\<le> length cs\n 3. \\<forall>j<i. cs ! j \\<noteq> cs ! i\n 4. x \\<notin> set cs\n 5. distinct init\n 6. set ((as @ [x] @ bs @ [x]) @ cs) \\<subseteq> set init", "apply(fact)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((as @ [x] @ bs @ [x]) @ cs) \\<subseteq> set init", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n  x \\<notin> set cs\n  set cs \\<subseteq> set init\n  x \\<in> set init\n  distinct init\n  x \\<notin> set bs\n  set as \\<subseteq> set init\n  set bs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. set ((as @ [x] @ bs @ [x]) @ cs) \\<subseteq> set init", "by simp\n  \\<comment> \\<open>so x and y swap positions when y is requested, that means that y was inserted infront of\n      some elment z (which cannot be x, has only been requested at most once since last request of y\n          but is in front of x)\\<close>\n\n  \\<comment> \\<open>first show that y must have been requested in as\\<close>"], ["proof (state)\nthis:\n  x < cs ! i\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"snd (TSdet init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i)) =\n          rev (take (length (as @ [x] @ bs @ [x]) + i) (as @ [x] @ bs @ [x] @ cs)) @ h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)) =\n    rev (take (length (as @ [x] @ bs @ [x]) + i)\n          (as @ [x] @ bs @ [x] @ cs)) @\n    h", "apply(rule sndTSdet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + i \\<le> length (as @ [x] @ bs @ [x] @ cs)", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + i \\<le> length (as @ [x] @ bs @ [x] @ cs)", "by simp"], ["proof (state)\nthis:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take (length (as @ [x] @ bs @ [x]) + i) (as @ [x] @ bs @ [x] @ cs)) @\n  h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "also"], ["proof (state)\nthis:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take (length (as @ [x] @ bs @ [x]) + i) (as @ [x] @ bs @ [x] @ cs)) @\n  h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"\\<dots>  = (rev (take i cs)) @ [x] @ (rev bs) @ [x] @ (rev as) @ h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (take (length (as @ [x] @ bs @ [x]) + i)\n          (as @ [x] @ bs @ [x] @ cs)) @\n    h =\n    rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "by simp"], ["proof (state)\nthis:\n  rev (take (length (as @ [x] @ bs @ [x]) + i) (as @ [x] @ bs @ [x] @ cs)) @\n  h =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "finally"], ["proof (chain)\npicking this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "have fstTS_t3: \"snd (TSdet init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i)) = \n                (rev (take i cs)) @ [x] @ (rev bs) @ [x] @ (rev as) @ h\""], ["proof (prove)\nusing this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)) =\n    rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "."], ["proof (state)\nthis:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "have fstTS_t3': \"(snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i))))) = \n                (rev (take i cs)) @ [x] @ (rev bs) @ [x] @ (rev as) @ h\""], ["proof (prove)\nusing this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i)))) =\n    rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "using assms(1)"], ["proof (prove)\nusing this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n\ngoal (1 subgoal):\n 1. snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i)))) =\n    rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "by auto"], ["proof (state)\nthis:\n  snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i)))) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?is = \"snd (TSdet init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?is' = \"snd (config (rTS h) init (as @ [x] @ bs @ [x] @ (take i cs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?s = \"fst (TSdet init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?s' = \"fst (config (rTS h) init (as @ [x] @ bs @ [x] @ (take i cs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?s_Suct3=\"s_TS init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?S = \"{xa. (xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i) in ?s \\<and>\n            count_list (take (index ?is ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i))) ?is) xa \\<le> 1) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?S' = \"{xa. (xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i) in ?s' \\<and>\n            count_list (take (index ?is' ((cs!i))) ?is') xa \\<le> 1) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have isis': \"?is = ?is'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)) =\n    snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))", "by(simp)"], ["proof (state)\nthis:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have ss': \"?s = ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)) =\n    fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))", "by(simp)"], ["proof (state)\nthis:\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))", "have SS': \"?S = ?S'\""], ["proof (prove)\nusing this:\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n\ngoal (1 subgoal):\n 1. {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} =\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1}", "using i_in_cs"], ["proof (prove)\nusing this:\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n  i < length cs\n\ngoal (1 subgoal):\n 1. {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} =\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1}", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "(* unfold TSdet once *)"], ["proof (state)\nthis:\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have once: \"TSdet init h (as @ x # bs @ x # cs) (Suc (Suc (Suc (length as + length bs + i))))\n        = Step (rTS h) (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TSdet init h (as @ x # bs @ x # cs)\n     (Suc (Suc (Suc (length as + length bs + i)))) =\n    Partial_Cost_Model.Step (rTS h)\n     (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)", "apply(subst TSdet_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (Suc (Suc (length as + length bs + i)))\n    \\<le> length (as @ x # bs @ x # cs)\n 2. Partial_Cost_Model.Step (rTS h)\n     (TSdet init h (as @ x # bs @ x # cs)\n       (Suc (Suc (length as + length bs + i))))\n     ((as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))) =\n    Partial_Cost_Model.Step (rTS h)\n     (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (2 subgoals):\n 1. Suc (Suc (Suc (length as + length bs + i)))\n    \\<le> length (as @ x # bs @ x # cs)\n 2. Partial_Cost_Model.Step (rTS h)\n     (TSdet init h (as @ x # bs @ x # cs)\n       (Suc (Suc (length as + length bs + i))))\n     ((as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))) =\n    Partial_Cost_Model.Step (rTS h)\n     (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.Step (rTS h)\n     (TSdet init h (as @ x # bs @ x # cs)\n       (Suc (Suc (length as + length bs + i))))\n     ((as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))) =\n    Partial_Cost_Model.Step (rTS h)\n     (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  TSdet init h (as @ x # bs @ x # cs)\n   (Suc (Suc (Suc (length as + length bs + i)))) =\n  Partial_Cost_Model.Step (rTS h)\n   (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have aha: \"(index ?is (cs ! i) \\<noteq> length ?is) \n        \\<and> ?S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} \\<noteq>\n    {}", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> (index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i) \\<noteq>\n          length\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n          {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1} \\<noteq>\n          {})\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i) \\<noteq>\n          length\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n          {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1} \\<noteq>\n          {})", "have \"(index ?is (cs ! i) = length ?is) \\<or> ?S = {}\""], ["proof (prove)\nusing this:\n  \\<not> (index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i) \\<noteq>\n          length\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n          {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1} \\<noteq>\n          {})\n\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) =\n    length\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))) \\<or>\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} =\n    {}", "by(simp)"], ["proof (state)\nthis:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) =\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) =\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {}", "have alters: \"(index ?is' (cs ! i) = length ?is') \\<or> ?S' = {}\""], ["proof (prove)\nusing this:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) =\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) =\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<or>\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1} =\n    {}", "apply(simp only: SS')"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) =\n    length\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))) \\<or>\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1} =\n    {} \\<Longrightarrow>\n    index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) =\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<or>\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1} =\n    {}", "by(simp only: isis')\n    \\<comment> \\<open>wenn (cs ! i) noch nie requested wurde, dann kann es gar nicht nach vorne gebracht werden!\n        also widerspruch mit @{text y_before_x'}\\<close>"], ["proof (state)\nthis:\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) =\n  length\n   (snd (config\\<^sub>p (rTS h) init\n          (as @ [x] @ bs @ [x] @ take i cs))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "have \"?s_Suct3 = fst (config (rTS h) init ((as @ [x] @ bs @ [x]) @ (take (i+1) cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "unfolding s_TS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i + 1)) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "apply(simp only: length_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length as + (length [x] + (length bs + length [x])) + i + 1)) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "apply(subst take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (take\n            (length as + (length [x] + (length bs + length [x])) + i + 1)\n            as @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as)\n            ([x] @ bs @ [x] @ cs))) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "apply(subst take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (take\n            (length as + (length [x] + (length bs + length [x])) + i + 1)\n            as @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as)\n            [x] @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x])\n            (bs @ [x] @ cs))) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "apply(subst take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (take\n            (length as + (length [x] + (length bs + length [x])) + i + 1)\n            as @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as)\n            [x] @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x])\n            bs @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x] -\n             length bs)\n            ([x] @ cs))) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "apply(subst take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (take\n            (length as + (length [x] + (length bs + length [x])) + i + 1)\n            as @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as)\n            [x] @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x])\n            bs @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x] -\n             length bs)\n            [x] @\n           take\n            (length as + (length [x] + (length bs + length [x])) + i + 1 -\n             length as -\n             length [x] -\n             length bs -\n             length [x])\n            cs)) =\n    fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))", "by(simp)"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  fst (config\\<^sub>p (rTS h) init\n        ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  fst (config\\<^sub>p (rTS h) init\n        ((as @ [x] @ bs @ [x]) @ take (i + 1) cs))\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "have \"\\<dots> =  fst (config (rTS h) init (((as @ [x] @ bs @ [x]) @ (take i cs)) @ [cs!i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)) =\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i]))", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)) =\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i]))", "by(simp add: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS h) init\n        ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)) =\n  fst (config\\<^sub>p (rTS h) init\n        (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i]))\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS h) init\n        ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)) =\n  fst (config\\<^sub>p (rTS h) init\n        (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i]))\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "have \"\\<dots> = step ?s' ?y (0, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "proof (cases \"index ?is' (cs ! i) = length ?is'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) =\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])\n 2. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "case True"], ["proof (state)\nthis:\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) =\n  length\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n\ngoal (2 subgoals):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) =\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])\n 2. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (rTS h)\n          (config\\<^sub>p (rTS h) init ((as @ [x] @ bs @ [x]) @ take i cs))\n          [cs ! i]) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (rTS h)\n          (config\\<^sub>p (rTS h) init ((as @ [x] @ bs @ [x]) @ take i cs))\n          [cs ! i]) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "apply(simp add: rTS_def Step_def split_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst (TS_step_d\n            (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs))\n            (cs ! i))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "apply(subst TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((let li = index\n                      (snd (Partial_Cost_Model.config'\n                             (\\<lambda>s. h, TS_step_d) (init, h)\n                             (as @ x # bs @ x # take i cs)))\n                      (cs ! i)\n            in if li =\n                  length\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs @ x # take i cs)))\n               then 0\n               else let sincelast =\n                          take li\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. h, TS_step_d) (init, h)\n                                  (as @ x # bs @ x # take i cs)));\n                        S = {xa.\n                             xa < cs ! i\n                             in fst (Partial_Cost_Model.config'\n(\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n                             count_list sincelast xa \\<le> 1}\n                    in if S = {} then 0\n                       else index\n                             (fst (Partial_Cost_Model.config'\n                                    (\\<lambda>s. h, TS_step_d) (init, h)\n                                    (as @ x # bs @ x # take i cs)))\n                             (cs ! i) -\n                            Min (index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) `\n                                 S),\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "apply(simp only: True[unfolded rTS_def,simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((let li = length\n                      (snd (Partial_Cost_Model.config'\n                             (\\<lambda>s. h, TS_step_d) (init, h)\n                             (as @ x # bs @ x # take i cs)))\n            in if li =\n                  length\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs @ x # take i cs)))\n               then 0\n               else let sincelast =\n                          take li\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. h, TS_step_d) (init, h)\n                                  (as @ x # bs @ x # take i cs)));\n                        S = {xa.\n                             xa < cs ! i\n                             in fst (Partial_Cost_Model.config'\n(\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n                             count_list sincelast xa \\<le> 1}\n                    in if S = {} then 0\n                       else index\n                             (fst (Partial_Cost_Model.config'\n                                    (\\<lambda>s. h, TS_step_d) (init, h)\n                                    (as @ x # bs @ x # take i cs)))\n                             (cs ! i) -\n                            Min (index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) `\n                                 S),\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "by(simp)"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS h) init\n        (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])\n\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "case False"], ["proof (state)\nthis:\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "with alters"], ["proof (chain)\npicking this:\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) =\n  length\n   (snd (config\\<^sub>p (rTS h) init\n          (as @ [x] @ bs @ [x] @ take i cs))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))", "have S': \"?S' = {}\""], ["proof (prove)\nusing this:\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) =\n  length\n   (snd (config\\<^sub>p (rTS h) init\n          (as @ [x] @ bs @ [x] @ take i cs))) \\<or>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n  index\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n\ngoal (1 subgoal):\n 1. {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (config\\<^sub>p (rTS h) init\n              (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (config\\<^sub>p (rTS h) init\n                 (as @ [x] @ bs @ [x] @ take i cs)))\n          (cs ! i))\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs))))\n      xa\n     \\<le> 1} =\n    {}", "by simp"], ["proof (state)\nthis:\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "have 1 : \"{xa. xa < cs ! i\n                                 in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n                                          (as @ x # bs @ x # take i cs)) \\<and>\n                                 count_list (take (index\n                (snd\n                  (Partial_Cost_Model.config'\n                    (\\<lambda>s. h, TS_step_d) (init, h)\n                    (as @ x # bs @ x # take i cs)))\n                (cs ! i))\n                        (snd\n                          (Partial_Cost_Model.config'\n(\\<lambda>s. h, TS_step_d) (init, h)\n(as @ x # bs @ x # take i cs)))) xa \\<le> 1} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa.\n     xa < cs ! i\n     in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))\n          (cs ! i))\n        (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs @ x # take i cs))))\n      xa\n     \\<le> 1} =\n    {}", "using S'"], ["proof (prove)\nusing this:\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. {xa.\n     xa < cs ! i\n     in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))\n          (cs ! i))\n        (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs @ x # take i cs))))\n      xa\n     \\<le> 1} =\n    {}", "by(simp add: rTS_def nth_append)"], ["proof (state)\nthis:\n  {xa.\n   xa < cs ! i\n   in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs @ x # take i cs)))\n        (cs ! i))\n      (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs))))\n    xa\n   \\<le> 1} =\n  {}\n\ngoal (1 subgoal):\n 1. index\n     (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) \\<noteq>\n    length\n     (snd (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs))) \\<Longrightarrow>\n    fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS h) init\n          (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (rTS h)\n          (config\\<^sub>p (rTS h) init ((as @ [x] @ bs @ [x]) @ take i cs))\n          [cs ! i]) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (rTS h)\n          (config\\<^sub>p (rTS h) init ((as @ [x] @ bs @ [x]) @ take i cs))\n          [cs ! i]) =\n    step\n     (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n     (cs ! i) (0, [])", "apply(simp add: rTS_def Step_def split_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst (TS_step_d\n            (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs))\n            (cs ! i))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "apply(subst TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((let li = index\n                      (snd (Partial_Cost_Model.config'\n                             (\\<lambda>s. h, TS_step_d) (init, h)\n                             (as @ x # bs @ x # take i cs)))\n                      (cs ! i)\n            in if li =\n                  length\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs @ x # take i cs)))\n               then 0\n               else let sincelast =\n                          take li\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. h, TS_step_d) (init, h)\n                                  (as @ x # bs @ x # take i cs)));\n                        S = {xa.\n                             xa < cs ! i\n                             in fst (Partial_Cost_Model.config'\n(\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n                             count_list sincelast xa \\<le> 1}\n                    in if S = {} then 0\n                       else index\n                             (fst (Partial_Cost_Model.config'\n                                    (\\<lambda>s. h, TS_step_d) (init, h)\n                                    (as @ x # bs @ x # take i cs)))\n                             (cs ! i) -\n                            Min (index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) `\n                                 S),\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "apply(simp only: 1 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((if index\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs @ x # take i cs)))\n                (cs ! i) =\n               length\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs @ x # take i cs)))\n            then 0\n            else if {} = {} then 0\n                 else index\n                       (fst (Partial_Cost_Model.config'\n                              (\\<lambda>s. h, TS_step_d) (init, h)\n                              (as @ x # bs @ x # take i cs)))\n                       (cs ! i) -\n                      Min (index\n                            (fst (Partial_Cost_Model.config'\n                                   (\\<lambda>s. h, TS_step_d) (init, h)\n                                   (as @ x # bs @ x # take i cs))) `\n                           {}),\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i) (0, [])", "by(simp)"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS h) init\n        (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS h) init\n        (((as @ [x] @ bs @ [x]) @ take i cs) @ [cs ! i])) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])", "have \"?s_Suct3 = step ?s ?y (0, [])\""], ["proof (prove)\nusing this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])\n\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) (0, [])", "using ss'"], ["proof (prove)\nusing this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step (fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs)))\n   (cs ! i) (0, [])\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) (0, [])", "by simp"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) (0, [])\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) (0, [])", "have e: \"?s_Suct3 = ?s\""], ["proof (prove)\nusing this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) (0, [])\n\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))", "by(simp only: step_no_action)"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "from x_before_y_t3"], ["proof (chain)\npicking this:\n  x < cs ! i\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)", "have \"x < cs ! i in ?s_Suct3\""], ["proof (prove)\nusing this:\n  x < cs ! i\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)\n\ngoal (1 subgoal):\n 1. x < cs ! i\n    in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i + 1)", "unfolding e"], ["proof (prove)\nusing this:\n  x < cs ! i\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)\n\ngoal (1 subgoal):\n 1. x < cs ! i\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  x < cs ! i\n  in fst (TSdet init h ((as @ [x] @ bs @ [x]) @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. x < cs ! i\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "by simp"], ["proof (state)\nthis:\n  x < cs ! i\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i) \\<noteq>\n            length\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n            {xa.\n             xa <\n             (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n             in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n             count_list\n              (take\n                (index\n                  (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  ((as @ [x] @ bs @ [x] @ cs) !\n                   (length (as @ [x] @ bs @ [x]) + i)))\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i))))\n              xa\n             \\<le> 1} \\<noteq>\n            {}) \\<Longrightarrow>\n    False", "with y_before_x'"], ["proof (chain)\npicking this:\n  \\<not> x < cs ! i\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n  x < cs ! i\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> x < cs ! i\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n  x < cs ! i\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. False", "unfolding assms(1)"], ["proof (prove)\nusing this:\n  \\<not> x < cs ! i\n         in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i + 1)\n  x < cs ! i\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}", "have aha': \"index (snd (TSdet init h (as @ x # bs @ x # cs)  (Suc (Suc (length as + length bs + i)))))\n (cs ! i) \\<noteq>\nlength (snd (TSdet init h (as @ x # bs @ x # cs) (Suc (Suc (length as + length bs + i)))))\" \n      and\n      aha2: \"?S \\<noteq> {}\""], ["proof (prove)\nusing this:\n  index\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i) \\<noteq>\n  length\n   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i))) \\<and>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. index\n     (snd (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) \\<noteq>\n    length\n     (snd (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))) &&&\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  index\n   (snd (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) \\<noteq>\n  length\n   (snd (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from fstTS_t3' assms(1)"], ["proof (chain)\npicking this:\n  snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i)))) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs", "have is_: \"?is = (rev (take i cs)) @ [x] @ (rev bs) @ [x] @ (rev as) @ h\""], ["proof (prove)\nusing this:\n  snd (TSdet init h \\<sigma> (Suc (Suc (length as + length bs + i)))) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n\ngoal (1 subgoal):\n 1. snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)) =\n    rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h", "by auto"], ["proof (state)\nthis:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have minlencsi: \" min (length cs) i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length cs) i = i", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. min (length cs) i = i", "by linarith"], ["proof (state)\nthis:\n  min (length cs) i = i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "let ?lastoccy=\"(index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"?y \\<notin> set (rev (take i cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i \\<notin> set (rev (take i cs))", "using firstocc"], ["proof (prove)\nusing this:\n  \\<forall>j<i. cs ! j \\<noteq> cs ! i\n\ngoal (1 subgoal):\n 1. cs ! i \\<notin> set (rev (take i cs))", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  cs ! i \\<notin> set (rev (take i cs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  cs ! i \\<notin> set (rev (take i cs))", "have lastoccy: \"?lastoccy \\<ge>\n            i + 1 + length bs + 1\""], ["proof (prove)\nusing this:\n  cs ! i \\<notin> set (rev (take i cs))\n\ngoal (1 subgoal):\n 1. i + 1 + length bs + 1\n    \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)", "using ynx ynotinbs minlencsi"], ["proof (prove)\nusing this:\n  cs ! i \\<notin> set (rev (take i cs))\n  cs ! i \\<noteq> x\n  cs ! i \\<notin> set bs\n  min (length cs) i = i\n\ngoal (1 subgoal):\n 1. i + 1 + length bs + 1\n    \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)", "by(simp add: index_append)"], ["proof (state)\nthis:\n  i + 1 + length bs + 1\n  \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "(* x is not in S, because it is requested at least twice since the last request to y*)"], ["proof (state)\nthis:\n  i + 1 + length bs + 1\n  \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have x_nin_S: \"x\\<notin>?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> {xa.\n                xa <\n                (as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)\n                in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n                count_list\n                 (take\n                   (index\n                     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                            (length (as @ [x] @ bs @ [x]) + i)))\n                     ((as @ [x] @ bs @ [x] @ cs) !\n                      (length (as @ [x] @ bs @ [x]) + i)))\n                   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                          (length (as @ [x] @ bs @ [x]) + i))))\n                 xa\n                \\<le> 1}", "using is_"], ["proof (prove)\nusing this:\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. x \\<notin> {xa.\n                xa <\n                (as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)\n                in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n                count_list\n                 (take\n                   (index\n                     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                            (length (as @ [x] @ bs @ [x]) + i)))\n                     ((as @ [x] @ bs @ [x] @ cs) !\n                      (length (as @ [x] @ bs @ [x]) + i)))\n                   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                          (length (as @ [x] @ bs @ [x]) + i))))\n                 xa\n                \\<le> 1}", "apply(simp add: split_def nth_append del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "case 1"], ["proof (state)\nthis:\n  snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n  rev (take i cs) @ x # rev bs @ x # rev as @ h\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \" count_list (take ?lastoccy (rev (take i cs))) x \\<le>\n          count_list (drop (length cs - i) (rev cs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list\n     (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n       (rev (take i cs)))\n     x\n    \\<le> count_list (drop (length cs - i) (rev cs)) x", "by (simp add: count_take rev_take)"], ["proof (state)\nthis:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x\n  \\<le> count_list (drop (length cs - i) (rev cs)) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x\n  \\<le> count_list (drop (length cs - i) (rev cs)) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \"\\<dots> \\<le> count_list (rev cs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (drop (length cs - i) (rev cs)) x \\<le> count_list (rev cs) x", "by(simp add: count_drop )"], ["proof (state)\nthis:\n  count_list (drop (length cs - i) (rev cs)) x \\<le> count_list (rev cs) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  count_list (drop (length cs - i) (rev cs)) x \\<le> count_list (rev cs) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (rev cs) x = 0", "using assms(2)"], ["proof (prove)\nusing this:\n  x \\<notin> set cs\n\ngoal (1 subgoal):\n 1. count_list (rev cs) x = 0", "by(simp add: count_rev)"], ["proof (state)\nthis:\n  count_list (rev cs) x = 0\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "finally"], ["proof (chain)\npicking this:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x\n  \\<le> 0", "have \" count_list (take ?lastoccy (rev (take i cs))) x = 0\""], ["proof (prove)\nusing this:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. count_list\n     (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n       (rev (take i cs)))\n     x =\n    0", "by auto"], ["proof (state)\nthis:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x =\n  0\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have\"\n        2 \\<le>\n        count_list ([x] @ rev bs @ [x]) x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> count_list ([x] @ rev bs @ [x]) x", "apply(simp only: count_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> count_list [x] x + (count_list (rev bs) x + count_list [x] x)", "by(simp)"], ["proof (state)\nthis:\n  2 \\<le> count_list ([x] @ rev bs @ [x]) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  2 \\<le> count_list ([x] @ rev bs @ [x]) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \"\\<dots> = count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list ([x] @ rev bs @ [x]) x =\n    count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x", "by auto"], ["proof (state)\nthis:\n  count_list ([x] @ rev bs @ [x]) x =\n  count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  count_list ([x] @ rev bs @ [x]) x =\n  count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \"\\<dots> \\<le> count_list (take (?lastoccy - i) (x # rev bs @ x # rev as @ h)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\n    \\<le> count_list\n           (take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i) -\n              i)\n             (x # rev bs @ x # rev as @ h))\n           x", "apply(rule count_take_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length bs + 1\n    \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i", "using lastoccy"], ["proof (prove)\nusing this:\n  i + 1 + length bs + 1\n  \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)\n\ngoal (1 subgoal):\n 1. 1 + length bs + 1\n    \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i", "by linarith"], ["proof (state)\nthis:\n  count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\n  \\<le> count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n            i)\n           (x # rev bs @ x # rev as @ h))\n         x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  count_list (take (1 + length bs + 1) (x # rev bs @ x # rev as @ h)) x\n  \\<le> count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n            i)\n           (x # rev bs @ x # rev as @ h))\n         x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have   \"\\<dots> \\<le>  count_list (take ?lastoccy (rev (take i cs))) x\n                      + count_list (take (?lastoccy - i) (x # rev bs @ x # rev as @ h)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list\n     (take\n       (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i)\n       (x # rev bs @ x # rev as @ h))\n     x\n    \\<le> count_list\n           (take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i))\n             (rev (take i cs)))\n           x +\n          count_list\n           (take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i) -\n              i)\n             (x # rev bs @ x # rev as @ h))\n           x", "by auto"], ["proof (state)\nthis:\n  count_list\n   (take\n     (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i)\n     (x # rev bs @ x # rev as @ h))\n   x\n  \\<le> count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n           (rev (take i cs)))\n         x +\n        count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n            i)\n           (x # rev bs @ x # rev as @ h))\n         x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "also"], ["proof (state)\nthis:\n  count_list\n   (take\n     (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i)\n     (x # rev bs @ x # rev as @ h))\n   x\n  \\<le> count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n           (rev (take i cs)))\n         x +\n        count_list\n         (take\n           (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n            i)\n           (x # rev bs @ x # rev as @ h))\n         x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "have \"\\<dots> = count_list (take ?lastoccy (rev (take i cs))\n                            @ take (?lastoccy - min (length cs) i)\n                            (x # rev bs @ x # rev as @ h)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list\n     (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n       (rev (take i cs)))\n     x +\n    count_list\n     (take\n       (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i)\n       (x # rev bs @ x # rev as @ h))\n     x =\n    count_list\n     (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n       (rev (take i cs)) @\n      take\n       (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n        min (length cs) i)\n       (x # rev bs @ x # rev as @ h))\n     x", "by(simp add: minlencsi count_append)"], ["proof (state)\nthis:\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)))\n   x +\n  count_list\n   (take\n     (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) - i)\n     (x # rev bs @ x # rev as @ h))\n   x =\n  count_list\n   (take (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n     (rev (take i cs)) @\n    take\n     (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i) -\n      min (length cs) i)\n     (x # rev bs @ x # rev as @ h))\n   x\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)) =\n    rev (take i cs) @ x # rev bs @ x # rev as @ h \\<Longrightarrow>\n    x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "finally"], ["proof (chain)\npicking this:\n  2 \\<le> count_list\n           (take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i))\n             (rev (take i cs)) @\n            take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i) -\n              min (length cs) i)\n             (x # rev bs @ x # rev as @ h))\n           x", "show ?case"], ["proof (prove)\nusing this:\n  2 \\<le> count_list\n           (take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i))\n             (rev (take i cs)) @\n            take\n             (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n               (cs ! i) -\n              min (length cs) i)\n             (x # rev bs @ x # rev as @ h))\n           x\n\ngoal (1 subgoal):\n 1. x < cs ! i\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n    \\<not> count_list\n            (take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i))\n              (rev (take i cs)) @\n             take\n              (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n                (cs ! i) -\n               min (length cs) i)\n              (x # rev bs @ x # rev as @ h))\n            x\n           \\<le> Suc 0", "by presburger"], ["proof (state)\nthis:\n  x < cs ! i\n  in fst (config\\<^sub>p (rTS h) init\n           (as @ x # bs @ x # take i cs)) \\<longrightarrow>\n  \\<not> count_list\n          (take\n            (index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i))\n            (rev (take i cs)) @\n           take\n            (index (rev (take i cs) @ x # rev bs @ x # rev as @ h)\n              (cs ! i) -\n             min (length cs) i)\n            (x # rev bs @ x # rev as @ h))\n          x\n         \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> {xa.\n              xa <\n              (as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)\n              in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n              count_list\n               (take\n                 (index\n                   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                          (length (as @ [x] @ bs @ [x]) + i)))\n                   ((as @ [x] @ bs @ [x] @ cs) !\n                    (length (as @ [x] @ bs @ [x]) + i)))\n                 (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                        (length (as @ [x] @ bs @ [x]) + i))))\n               xa\n              \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"Min (index ?s ` ?S) \\<in> (index ?s ` ?S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1})\n    \\<in> index\n           (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))) `\n          {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1}", "apply(rule Min_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))) `\n      {xa.\n       xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n       in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n       count_list\n        (take\n          (index\n            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n            ((as @ [x] @ bs @ [x] @ cs) !\n             (length (as @ [x] @ bs @ [x]) + i)))\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))))\n        xa\n       \\<le> 1})\n 2. index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))) `\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} \\<noteq>\n    {}", "using aha2"], ["proof (prove)\nusing this:\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. finite\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))) `\n      {xa.\n       xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n       in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n       count_list\n        (take\n          (index\n            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n            ((as @ [x] @ bs @ [x] @ cs) !\n             (length (as @ [x] @ bs @ [x]) + i)))\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))))\n        xa\n       \\<le> 1})\n 2. index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))) `\n    {xa.\n     xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n     in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n     count_list\n      (take\n        (index\n          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))))\n      xa\n     \\<le> 1} \\<noteq>\n    {}", "by (simp_all)"], ["proof (state)\nthis:\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  \\<in> index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))) `\n        {xa.\n         xa <\n         (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n              ((as @ [x] @ bs @ [x] @ cs) !\n               (length (as @ [x] @ bs @ [x]) + i)))\n            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))))\n          xa\n         \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  \\<in> index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))) `\n        {xa.\n         xa <\n         (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n              ((as @ [x] @ bs @ [x] @ cs) !\n               (length (as @ [x] @ bs @ [x]) + i)))\n            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))))\n          xa\n         \\<le> 1}", "obtain z where zminimal: \"index ?s z = Min (index ?s ` ?S)\"and z_in_S: \"z \\<in> ?S\""], ["proof (prove)\nusing this:\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  \\<in> index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))) `\n        {xa.\n         xa <\n         (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n         count_list\n          (take\n            (index\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n              ((as @ [x] @ bs @ [x] @ cs) !\n               (length (as @ [x] @ bs @ [x]) + i)))\n            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))))\n          xa\n         \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>index\n                  (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                         (length (as @ [x] @ bs @ [x]) + i)))\n                  z =\n                 Min (index\n                       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                              (length (as @ [x] @ bs @ [x]) + i))) `\n                      {xa.\n                       xa <\n                       (as @ [x] @ bs @ [x] @ cs) !\n                       (length (as @ [x] @ bs @ [x]) + i)\n                       in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                                (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n                       count_list\n                        (take\n                          (index\n                            (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                                   (length (as @ [x] @ bs @ [x]) + i)))\n                            ((as @ [x] @ bs @ [x] @ cs) !\n                             (length (as @ [x] @ bs @ [x]) + i)))\n                          (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                                 (length (as @ [x] @ bs @ [x]) + i))))\n                        xa\n                       \\<le> 1});\n         z \\<in> {xa.\n                  xa <\n                  (as @ [x] @ bs @ [x] @ cs) !\n                  (length (as @ [x] @ bs @ [x]) + i)\n                  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                           (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n                  count_list\n                   (take\n                     (index\n                       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                              (length (as @ [x] @ bs @ [x]) + i)))\n                       ((as @ [x] @ bs @ [x] @ cs) !\n                        (length (as @ [x] @ bs @ [x]) + i)))\n                     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                            (length (as @ [x] @ bs @ [x]) + i))))\n                   xa\n                  \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  z \\<in> {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  z \\<in> {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1}", "have bef: \"z < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i) in ?s\"\n          and \"count_list (take (index ?is ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i))) ?is) z \\<le> 1\""], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  z \\<in> {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1}\n\ngoal (1 subgoal):\n 1. z < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i)) &&&\n    count_list\n     (take\n       (index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z\n    \\<le> 1", "by(blast)+"], ["proof (state)\nthis:\n  z < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with zminimal"], ["proof (chain)\npicking this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  z < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1", "have zbeforey: \"z < cs ! i in ?s\"\n    and zatmostonce: \"count_list (take (index ?is (cs ! i)) ?is) z \\<le> 1\"\n    and isminimal: \"index ?s z = Min (index ?s ` ?S)\""], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  z < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. z < cs ! i\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i)) &&&\n    count_list\n     (take\n       (index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i))\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z\n    \\<le> 1 &&&\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z =\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1})", "by(simp_all add: nth_append)"], ["proof (state)\nthis:\n  z < cs ! i\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have elemins: \"z \\<in> set ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))", "by (meson zbeforey before_in_setD1)"], ["proof (state)\nthis:\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))", "have zininit: \"z \\<in> set init\""], ["proof (prove)\nusing this:\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. z \\<in> set init", "using i_in_cs"], ["proof (prove)\nusing this:\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n  i < length cs\n\ngoal (1 subgoal):\n 1. z \\<in> set init", "by(simp add: s_TS_set[unfolded s_TS_def] del: config'.simps)"], ["proof (state)\nthis:\n  z \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from zbeforey"], ["proof (chain)\npicking this:\n  z < cs ! i\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))", "have zbeforey_ind: \"index ?s z < index ?s ?y\""], ["proof (prove)\nusing this:\n  z < cs ! i\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n    < index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i)", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) \\<and>\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n    < index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i)", "by auto"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)", "have el_n_y: \"z \\<noteq> ?y\""], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n\ngoal (1 subgoal):\n 1. z \\<noteq> cs ! i", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> cs ! i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have el_n_x: \"z \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> x", "using x_nin_S  z_in_S"], ["proof (prove)\nusing this:\n  x \\<notin> {xa.\n              xa <\n              (as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)\n              in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n              count_list\n               (take\n                 (index\n                   (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                          (length (as @ [x] @ bs @ [x]) + i)))\n                   ((as @ [x] @ bs @ [x] @ cs) !\n                    (length (as @ [x] @ bs @ [x]) + i)))\n                 (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                        (length (as @ [x] @ bs @ [x]) + i))))\n               xa\n              \\<le> 1}\n  z \\<in> {xa.\n           xa <\n           (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n           count_list\n            (take\n              (index\n                (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                ((as @ [x] @ bs @ [x] @ cs) !\n                 (length (as @ [x] @ bs @ [x]) + i)))\n              (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i))))\n            xa\n           \\<le> 1}\n\ngoal (1 subgoal):\n 1. z \\<noteq> x", "by blast"], ["proof (state)\nthis:\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "(* and because it is JUST before that element, z must be before x *)"], ["proof (state)\nthis:\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "{"], ["proof (state)\nthis:\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "fix s q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have TS_step_d2: \"TS_step_d s q =\n      (let V\\<^sub>r={x. x < q in fst s \\<and> count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n       in ((if index (snd s) q \\<noteq> length (snd s) \\<and> V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min ( (index (fst s)) ` V\\<^sub>r)\n          else 0,[]),q#(snd s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_step_d s q =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "unfolding TS_step_d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "apply(cases \"index (snd s) q < length (snd s)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))\n 2. \\<not> index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "using index_le_size"], ["proof (prove)\nusing this:\n  index ?xs ?x \\<le> length ?xs\n\ngoal (2 subgoals):\n 1. index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))\n 2. \\<not> index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "apply(simp split: prod.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>index (snd s) q < length (snd s);\n     \\<And>xs x. index xs x \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x < q in fst s \\<longrightarrow>\n                          \\<not> count_list (take (index (snd s) q) (snd s))\n                                  x\n                                 \\<le> Suc 0) \\<longrightarrow>\n                      (\\<exists>x.\n                          x < q in fst s \\<and>\n                          count_list (take (index (snd s) q) (snd s)) x\n                          \\<le> Suc 0) \\<longrightarrow>\n                      index (fst s) q\n                      \\<le> Min (index (fst s) `\n                                 {x. x < q in fst s \\<and>\n                                     count_list\n(take (index (snd s) q) (snd s)) x\n                                     \\<le> Suc 0})\n 2. \\<not> index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index (snd s) q < length (snd s) \\<Longrightarrow>\n    ((let li = index (snd s) q\n      in if li = length (snd s) then 0\n         else let sincelast = take li (snd s);\n                  S = {x. x < q in fst s \\<and>\n                          count_list sincelast x \\<le> 1}\n              in if S = {} then 0\n                 else index (fst s) q - Min (index (fst s) ` S),\n      []),\n     q # snd s) =\n    (let V\\<^sub>r =\n           {x. x < q in fst s \\<and>\n               count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n     in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n             V\\<^sub>r \\<noteq> {}\n          then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n          []),\n         q # snd s))", "by(auto simp add: index_less_size_conv split: prod.split)"], ["proof (state)\nthis:\n  TS_step_d s q =\n  (let V\\<^sub>r =\n         {x. x < q in fst s \\<and>\n             count_list (take (index (snd s) q) (snd s)) x \\<le> 1}\n   in ((if index (snd s) q \\<noteq> length (snd s) \\<and>\n           V\\<^sub>r \\<noteq> {}\n        then index (fst s) q - Min (index (fst s) ` V\\<^sub>r) else 0,\n        []),\n       q # snd s))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "}"], ["proof (state)\nthis:\n  TS_step_d ?s4 ?q4 =\n  (let V\\<^sub>r =\n         {x. x < ?q4 in fst ?s4 \\<and>\n             count_list (take (index (snd ?s4) ?q4) (snd ?s4)) x \\<le> 1}\n   in ((if index (snd ?s4) ?q4 \\<noteq> length (snd ?s4) \\<and>\n           V\\<^sub>r \\<noteq> {}\n        then index (fst ?s4) ?q4 - Min (index (fst ?s4) ` V\\<^sub>r) else 0,\n        []),\n       ?q4 # snd ?s4))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "note alt_chara=this"], ["proof (state)\nthis:\n  TS_step_d ?s4 ?q4 =\n  (let V\\<^sub>r =\n         {x. x < ?q4 in fst ?s4 \\<and>\n             count_list (take (index (snd ?s4) ?q4) (snd ?s4)) x \\<le> 1}\n   in ((if index (snd ?s4) ?q4 \\<noteq> length (snd ?s4) \\<and>\n           V\\<^sub>r \\<noteq> {}\n        then index (fst ?s4) ?q4 - Min (index (fst ?s4) ` V\\<^sub>r) else 0,\n        []),\n       ?q4 # snd ?s4))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have iF: \"(index (snd (config' (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) (cs ! i)\n               \\<noteq> length (snd (config' (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) \\<and>\n               {xa. xa < cs ! i in fst (config' (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n                    count_list\n                     (take (index (snd (config' (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))) (cs ! i))\n                       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h) (as @ x # bs @ x # take i cs))))\n                     xa\n                    \\<le> 1} \\<noteq>\n               {}) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index\n      (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs)))\n      (cs ! i) \\<noteq>\n     length\n      (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs))) \\<and>\n     {xa.\n      xa < cs ! i\n      in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n      count_list\n       (take\n         (index\n           (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs @ x # take i cs)))\n           (cs ! i))\n         (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs @ x # take i cs))))\n       xa\n      \\<le> 1} \\<noteq>\n     {}) =\n    True", "using aha[unfolded rTS_def] ss' SS'"], ["proof (prove)\nusing this:\n  index\n   (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n          (take (length (as @ [x] @ bs @ [x]) + i)\n            (as @ [x] @ bs @ [x] @ cs))))\n   (cs ! i) \\<noteq>\n  length\n   (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n          (take (length (as @ [x] @ bs @ [x]) + i)\n            (as @ [x] @ bs @ [x] @ cs)))) \\<and>\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n            (take (length (as @ [x] @ bs @ [x]) + i)\n              (as @ [x] @ bs @ [x] @ cs))) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n               (take (length (as @ [x] @ bs @ [x]) + i)\n                 (as @ [x] @ bs @ [x] @ cs))))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (config\\<^sub>p (\\<lambda>s. h, TS_step_d) init\n             (take (length (as @ [x] @ bs @ [x]) + i)\n               (as @ [x] @ bs @ [x] @ cs)))))\n    xa\n   \\<le> 1} \\<noteq>\n  {}\n  fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i)) =\n  fst (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        ((as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)))\n      (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))))\n    xa\n   \\<le> 1} =\n  {xa.\n   xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n   in fst (config\\<^sub>p (rTS h) init\n            (as @ [x] @ bs @ [x] @ take i cs)) \\<and>\n   count_list\n    (take\n      (index\n        (snd (config\\<^sub>p (rTS h) init\n               (as @ [x] @ bs @ [x] @ take i cs)))\n        (cs ! i))\n      (snd (config\\<^sub>p (rTS h) init (as @ [x] @ bs @ [x] @ take i cs))))\n    xa\n   \\<le> 1}\n\ngoal (1 subgoal):\n 1. (index\n      (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs)))\n      (cs ! i) \\<noteq>\n     length\n      (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs))) \\<and>\n     {xa.\n      xa < cs ! i\n      in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n               (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n      count_list\n       (take\n         (index\n           (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                  (init, h) (as @ x # bs @ x # take i cs)))\n           (cs ! i))\n         (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs @ x # take i cs))))\n       xa\n      \\<le> 1} \\<noteq>\n     {}) =\n    True", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  (index\n    (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs @ x # take i cs)))\n    (cs ! i) \\<noteq>\n   length\n    (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n           (as @ x # bs @ x # take i cs))) \\<and>\n   {xa.\n    xa < cs ! i\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n             (as @ x # bs @ x # take i cs)) \\<and>\n    count_list\n     (take\n       (index\n         (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                (init, h) (as @ x # bs @ x # take i cs)))\n         (cs ! i))\n       (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs))))\n     xa\n    \\<le> 1} \\<noteq>\n   {}) =\n  True\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"?s_Suct3 = fst (TSdet init h (as @ x # bs @ x # cs) (Suc (Suc (Suc (length as + length bs + i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (Suc (length as + length bs + i)))))", "by(auto simp add: s_TS_def)"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  fst (TSdet init h (as @ x # bs @ x # cs)\n        (Suc (Suc (Suc (length as + length bs + i)))))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "also"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  fst (TSdet init h (as @ x # bs @ x # cs)\n        (Suc (Suc (Suc (length as + length bs + i)))))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"\\<dots> = step ?s ?y (index ?s ?y - Min (index ?s ` ?S), [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (Suc (length as + length bs + i))))) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i) -\n      Min (index\n            (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))) `\n           {xa.\n            xa <\n            (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n            in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                        (length (as @ [x] @ bs @ [x]) + i)))\n                 ((as @ [x] @ bs @ [x] @ cs) !\n                  (length (as @ [x] @ bs @ [x]) + i)))\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i))))\n             xa\n            \\<le> 1}),\n      [])", "apply(simp only: once[unfolded assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.Step (rTS h)\n          (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))\n          (cs ! i)) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i) -\n      Min (index\n            (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))) `\n           {xa.\n            xa <\n            (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n            in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                        (length (as @ [x] @ bs @ [x]) + i)))\n                 ((as @ [x] @ bs @ [x] @ cs) !\n                  (length (as @ [x] @ bs @ [x]) + i)))\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i))))\n             xa\n            \\<le> 1}),\n      [])", "apply(simp add: Step_def split_def rTS_def del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst (TS_step_d\n            (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs))\n            (cs ! i))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (index\n       (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)))\n       (cs ! i) -\n      Min (index\n            (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs @ x # take i cs))) `\n           {xa.\n            xa <\n            (as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))\n            in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs @ x # take i cs)))\n                 ((as @ x # bs @ x # cs) !\n                  Suc (Suc (length as + length bs + i))))\n               (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs @ x # take i cs))))\n             xa\n            \\<le> Suc 0}),\n      [])", "apply(subst alt_chara)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst (let V\\<^sub>r =\n                 {xa.\n                  xa < cs ! i\n                  in fst (Partial_Cost_Model.config'\n                           (\\<lambda>s. h, TS_step_d) (init, h)\n                           (as @ x # bs @ x # take i cs)) \\<and>\n                  count_list\n                   (take\n                     (index\n                       (snd (Partial_Cost_Model.config'\n                              (\\<lambda>s. h, TS_step_d) (init, h)\n                              (as @ x # bs @ x # take i cs)))\n                       (cs ! i))\n                     (snd (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs @ x # take i cs))))\n                   xa\n                  \\<le> 1}\n           in ((if index\n                    (snd (Partial_Cost_Model.config'\n                           (\\<lambda>s. h, TS_step_d) (init, h)\n                           (as @ x # bs @ x # take i cs)))\n                    (cs ! i) \\<noteq>\n                   length\n                    (snd (Partial_Cost_Model.config'\n                           (\\<lambda>s. h, TS_step_d) (init, h)\n                           (as @ x # bs @ x # take i cs))) \\<and>\n                   V\\<^sub>r \\<noteq> {}\n                then index\n                      (fst (Partial_Cost_Model.config'\n                             (\\<lambda>s. h, TS_step_d) (init, h)\n                             (as @ x # bs @ x # take i cs)))\n                      (cs ! i) -\n                     Min (index\n                           (fst (Partial_Cost_Model.config'\n                                  (\\<lambda>s. h, TS_step_d) (init, h)\n                                  (as @ x # bs @ x # take i cs))) `\n                          V\\<^sub>r)\n                else 0,\n                []),\n               cs ! i #\n               snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs @ x # take i cs))))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (index\n       (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)))\n       (cs ! i) -\n      Min (index\n            (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs @ x # take i cs))) `\n           {xa.\n            xa <\n            (as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))\n            in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs @ x # take i cs)))\n                 ((as @ x # bs @ x # cs) !\n                  Suc (Suc (length as + length bs + i))))\n               (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs @ x # take i cs))))\n             xa\n            \\<le> Suc 0}),\n      [])", "apply(simp only: Let_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((if index\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs @ x # take i cs)))\n                (cs ! i) \\<noteq>\n               length\n                (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                       (init, h) (as @ x # bs @ x # take i cs))) \\<and>\n               {xa.\n                xa < cs ! i\n                in fst (Partial_Cost_Model.config'\n                         (\\<lambda>s. h, TS_step_d) (init, h)\n                         (as @ x # bs @ x # take i cs)) \\<and>\n                count_list\n                 (take\n                   (index\n                     (snd (Partial_Cost_Model.config'\n                            (\\<lambda>s. h, TS_step_d) (init, h)\n                            (as @ x # bs @ x # take i cs)))\n                     (cs ! i))\n                   (snd (Partial_Cost_Model.config'\n                          (\\<lambda>s. h, TS_step_d) (init, h)\n                          (as @ x # bs @ x # take i cs))))\n                 xa\n                \\<le> 1} \\<noteq>\n               {}\n            then index\n                  (fst (Partial_Cost_Model.config'\n                         (\\<lambda>s. h, TS_step_d) (init, h)\n                         (as @ x # bs @ x # take i cs)))\n                  (cs ! i) -\n                 Min (index\n                       (fst (Partial_Cost_Model.config'\n                              (\\<lambda>s. h, TS_step_d) (init, h)\n                              (as @ x # bs @ x # take i cs))) `\n                      {xa.\n                       xa < cs ! i\n                       in fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs @ x # take i cs)) \\<and>\n                       count_list\n                        (take\n                          (index\n                            (snd (Partial_Cost_Model.config'\n                                   (\\<lambda>s. h, TS_step_d) (init, h)\n                                   (as @ x # bs @ x # take i cs)))\n                            (cs ! i))\n                          (snd (Partial_Cost_Model.config'\n                                 (\\<lambda>s. h, TS_step_d) (init, h)\n                                 (as @ x # bs @ x # take i cs))))\n                        xa\n                       \\<le> 1})\n            else 0,\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (index\n       (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)))\n       (cs ! i) -\n      Min (index\n            (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs @ x # take i cs))) `\n           {xa.\n            xa <\n            (as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))\n            in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs @ x # take i cs)))\n                 ((as @ x # bs @ x # cs) !\n                  Suc (Suc (length as + length bs + i))))\n               (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs @ x # take i cs))))\n             xa\n            \\<le> Suc 0}),\n      [])", "apply(simp only: iF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (fst ((if True\n            then index\n                  (fst (Partial_Cost_Model.config'\n                         (\\<lambda>s. h, TS_step_d) (init, h)\n                         (as @ x # bs @ x # take i cs)))\n                  (cs ! i) -\n                 Min (index\n                       (fst (Partial_Cost_Model.config'\n                              (\\<lambda>s. h, TS_step_d) (init, h)\n                              (as @ x # bs @ x # take i cs))) `\n                      {xa.\n                       xa < cs ! i\n                       in fst (Partial_Cost_Model.config'\n                                (\\<lambda>s. h, TS_step_d) (init, h)\n                                (as @ x # bs @ x # take i cs)) \\<and>\n                       count_list\n                        (take\n                          (index\n                            (snd (Partial_Cost_Model.config'\n                                   (\\<lambda>s. h, TS_step_d) (init, h)\n                                   (as @ x # bs @ x # take i cs)))\n                            (cs ! i))\n                          (snd (Partial_Cost_Model.config'\n                                 (\\<lambda>s. h, TS_step_d) (init, h)\n                                 (as @ x # bs @ x # take i cs))))\n                        xa\n                       \\<le> 1})\n            else 0,\n            []),\n           cs ! i #\n           snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                 (init, h) (as @ x # bs @ x # take i cs)))) =\n    step\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n            (as @ x # bs @ x # take i cs)))\n     (cs ! i)\n     (index\n       (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d) (init, h)\n              (as @ x # bs @ x # take i cs)))\n       (cs ! i) -\n      Min (index\n            (fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                   (init, h) (as @ x # bs @ x # take i cs))) `\n           {xa.\n            xa <\n            (as @ x # bs @ x # cs) ! Suc (Suc (length as + length bs + i))\n            in fst (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                     (init, h) (as @ x # bs @ x # take i cs)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                        (init, h) (as @ x # bs @ x # take i cs)))\n                 ((as @ x # bs @ x # cs) !\n                  Suc (Suc (length as + length bs + i))))\n               (snd (Partial_Cost_Model.config' (\\<lambda>s. h, TS_step_d)\n                      (init, h) (as @ x # bs @ x # take i cs))))\n             xa\n            \\<le> Suc 0}),\n      [])", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  fst (TSdet init h (as @ x # bs @ x # cs)\n        (Suc (Suc (Suc (length as + length bs + i))))) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "finally"], ["proof (chain)\npicking this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])", "have \"?s_Suct3 = step ?s ?y (index ?s ?y - Min (index ?s ` ?S), [])\""], ["proof (prove)\nusing this:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])\n\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i) -\n      Min (index\n            (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))) `\n           {xa.\n            xa <\n            (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n            in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n            count_list\n             (take\n               (index\n                 (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                        (length (as @ [x] @ bs @ [x]) + i)))\n                 ((as @ [x] @ bs @ [x] @ cs) !\n                  (length (as @ [x] @ bs @ [x]) + i)))\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i))))\n             xa\n            \\<le> 1}),\n      [])", "."], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with isminimal"], ["proof (chain)\npicking this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])", "have state_dannach: \"?s_Suct3 = step ?s ?y (index ?s ?y - index ?s z, [])\""], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z =\n  Min (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i))) `\n       {xa.\n        xa < (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n        in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n        count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             ((as @ [x] @ bs @ [x] @ cs) !\n              (length (as @ [x] @ bs @ [x]) + i)))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         xa\n        \\<le> 1})\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    Min (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i))) `\n         {xa.\n          xa <\n          (as @ [x] @ bs @ [x] @ cs) ! (length (as @ [x] @ bs @ [x]) + i)\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)) \\<and>\n          count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               ((as @ [x] @ bs @ [x] @ cs) !\n                (length (as @ [x] @ bs @ [x]) + i)))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           xa\n          \\<le> 1}),\n    [])\n\ngoal (1 subgoal):\n 1. s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1) =\n    step\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n     (index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       z,\n      [])", "by presburger\n    \n\n  \\<comment> \\<open>so y is moved in front of z, that means:\\<close>"], ["proof (state)\nthis:\n  s_TS init h (as @ [x] @ bs @ [x] @ cs)\n   (length (as @ [x] @ bs @ [x]) + i + 1) =\n  step\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   (cs ! i)\n   (index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i) -\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z,\n    [])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have yinfrontofz: \"?y < z in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i < z\n    in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)", "unfolding   assms(1) state_dannach"], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i < z\n    in step\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        (cs ! i)\n        (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          (cs ! i) -\n         index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z,\n         [])", "apply(simp add: step_def del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i < z\n    in mtf2\n        (index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          (cs ! i) -\n         index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          z)\n        (cs ! i)\n        (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))", "apply(rule mtf2_q_passes)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cs ! i\n    \\<in> set (fst (config\\<^sub>p (rTS h) init\n                     (as @ x # bs @ x # take i cs)))\n 2. distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 3. index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     (cs ! i) -\n    (index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n      (cs ! i) -\n     index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n      z)\n    \\<le> index\n           (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n           z\n 4. index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     z\n    < index\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n       (cs ! i)", "using i_in_cs assms(5)"], ["proof (prove)\nusing this:\n  i < length cs\n  distinct init\n\ngoal (4 subgoals):\n 1. cs ! i\n    \\<in> set (fst (config\\<^sub>p (rTS h) init\n                     (as @ x # bs @ x # take i cs)))\n 2. distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 3. index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     (cs ! i) -\n    (index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n      (cs ! i) -\n     index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n      z)\n    \\<le> index\n           (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n           z\n 4. index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     z\n    < index\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n       (cs ! i)", "apply(simp_all add: s_TS_distinct[unfolded s_TS_def] s_TS_set[unfolded s_TS_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> cs ! i \\<in> set init\n 2. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> index\n                       (fst (config\\<^sub>p (rTS h) init\n                              (as @ x # bs @ x # take i cs)))\n                       z\n                      < index\n                         (fst (config\\<^sub>p (rTS h) init\n                                (as @ x # bs @ x # take i cs)))\n                         (cs ! i)", "using yininit"], ["proof (prove)\nusing this:\n  cs ! i \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> cs ! i \\<in> set init\n 2. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> index\n                       (fst (config\\<^sub>p (rTS h) init\n                              (as @ x # bs @ x # take i cs)))\n                       z\n                      < index\n                         (fst (config\\<^sub>p (rTS h) init\n                                (as @ x # bs @ x # take i cs)))\n                         (cs ! i)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> index\n                       (fst (config\\<^sub>p (rTS h) init\n                              (as @ x # bs @ x # take i cs)))\n                       z\n                      < index\n                         (fst (config\\<^sub>p (rTS h) init\n                                (as @ x # bs @ x # take i cs)))\n                         (cs ! i)", "using zbeforey_ind"], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cs; distinct init\\<rbrakk>\n    \\<Longrightarrow> index\n                       (fst (config\\<^sub>p (rTS h) init\n                              (as @ x # bs @ x # take i cs)))\n                       z\n                      < index\n                         (fst (config\\<^sub>p (rTS h) init\n                                (as @ x # bs @ x # take i cs)))\n                         (cs ! i)", "by simp"], ["proof (state)\nthis:\n  cs ! i < z in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have yins: \"?y \\<in> set ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i\n    \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))", "using i_in_cs assms(3,5)"], ["proof (prove)\nusing this:\n  i < length cs\n  set cs \\<subseteq> set init\n  distinct init\n\ngoal (1 subgoal):\n 1. cs ! i\n    \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))", "apply(simp_all add:   s_TS_set[unfolded s_TS_def] del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cs; set cs \\<subseteq> set init;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> cs ! i \\<in> set init", "by fastforce"], ["proof (state)\nthis:\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"index ?s_Suct3 ?y = index ?s z\" \n    and \"index ?s_Suct3 z = Suc (index ?s z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z &&&\n    index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "let ?xs = \"(fst (TSdet init h (as @ x # bs @ x # cs) (Suc (Suc (length as + length bs + i)))))\""], ["proof (state)\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "have setxs: \"set ?xs = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i))))) =\n    set init", "apply(rule  s_TS_set[unfolded s_TS_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc (length as + length bs + i))\n    \\<le> length (as @ x # bs @ x # cs)", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. Suc (Suc (length as + length bs + i))\n    \\<le> length (as @ x # bs @ x # cs)", "by auto"], ["proof (state)\nthis:\n  set (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i))))) =\n  set init\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "then"], ["proof (chain)\npicking this:\n  set (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i))))) =\n  set init", "have yinxs: \"cs ! i \\<in> set  ?xs\""], ["proof (prove)\nusing this:\n  set (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i))))) =\n  set init\n\ngoal (1 subgoal):\n 1. cs ! i\n    \\<in> set (fst (TSdet init h (as @ x # bs @ x # cs)\n                     (Suc (Suc (length as + length bs + i)))))", "apply(simp  add: setxs del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "using assms(3) i_in_cs"], ["proof (prove)\nusing this:\n  set cs \\<subseteq> set init\n  i < length cs\n\ngoal (1 subgoal):\n 1. cs ! i \\<in> set init", "by fastforce"], ["proof (state)\nthis:\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ x # bs @ x # cs)\n                   (Suc (Suc (length as + length bs + i)))))\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "have distinctxs: \"distinct ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))", "apply(rule  s_TS_distinct[unfolded s_TS_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct init\n 2. Suc (Suc (length as + length bs + i)) < length (as @ x # bs @ x # cs)", "using i_in_cs assms(5)"], ["proof (prove)\nusing this:\n  i < length cs\n  distinct init\n\ngoal (2 subgoals):\n 1. distinct init\n 2. Suc (Suc (length as + length bs + i)) < length (as @ x # bs @ x # cs)", "by auto"], ["proof (state)\nthis:\n  distinct\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "let ?n = \"(index\n             (fst (TSdet init h (as @ x # bs @ x # cs)\n                    (Suc (Suc (length as + length bs + i)))))\n             (cs ! i) -\n            index\n             (fst (TSdet init h (as @ x # bs @ x # cs)\n                    (Suc (Suc (length as + length bs + i)))))\n             z)\""], ["proof (state)\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "have \"index (mtf2 ?n ?y ?xs) (?xs ! index ?xs ?y) = index ?xs ?y - ?n\\<and>\n            index ?xs ?y - ?n = index (mtf2 ?n ?y ?xs) (?xs !  index ?xs ?y )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)) =\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z) \\<and>\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z) =\n    index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i))", "apply(rule mtf2_forward_effect2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cs ! i\n    \\<in> set (fst (TSdet init h (as @ x # bs @ x # cs)\n                     (Suc (Suc (length as + length bs + i)))))\n 2. distinct\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n 3. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)", "apply(fact)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n 2. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)", "apply(fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)", "by simp"], ["proof (state)\nthis:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) =\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i))\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "then"], ["proof (chain)\npicking this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) =\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i))", "have  \"index (mtf2 ?n ?y ?xs) (?xs ! index ?xs ?y) = index ?xs ?y - ?n\""], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) =\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i))\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)) =\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z)", "by metis"], ["proof (state)\nthis:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "also"], ["proof (state)\nthis:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "have \"\\<dots> = index ?s z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z", "using zbeforey_ind"], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z", "by force"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "finally"], ["proof (chain)\npicking this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z", "have A: \"index (mtf2 ?n ?y ?xs) (?xs ! index ?xs ?y) = index ?s z\""], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z", "."], ["proof (state)\nthis:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "have aa: \"index ?xs ?y - ?n \\<le> index ?xs z\" \"index ?xs z < index ?xs ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i) -\n    (index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      (cs ! i) -\n     index\n      (fst (TSdet init h (as @ x # bs @ x # cs)\n             (Suc (Suc (length as + length bs + i)))))\n      z)\n    \\<le> index\n           (fst (TSdet init h (as @ x # bs @ x # cs)\n                  (Suc (Suc (length as + length bs + i)))))\n           z &&&\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z\n    < index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z\n    < index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)", "using zbeforey_ind"], ["proof (prove)\nusing this:\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  < index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     (cs ! i)\n\ngoal (1 subgoal):\n 1. index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z\n    < index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i)", "by fastforce"], ["proof (state)\nthis:\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   z\n  < index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "from mtf2_forward_effect3'[OF yinxs distinctxs aa]"], ["proof (chain)\npicking this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z) =\n  Suc (index\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))))\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))) !\n         index\n          (fst (TSdet init h (as @ x # bs @ x # cs)\n                 (Suc (Suc (length as + length bs + i)))))\n          z)) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n  < index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z) \\<and>\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z)\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i)", "have B: \"index (mtf2 ?n ?y ?xs) z = Suc (index ?xs z)\""], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z) =\n  Suc (index\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))))\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))) !\n         index\n          (fst (TSdet init h (as @ x # bs @ x # cs)\n                 (Suc (Suc (length as + length bs + i)))))\n          z)) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n  < index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z) \\<and>\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z)\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i)\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ x # bs @ x # cs)\n                 (Suc (Suc (length as + length bs + i)))))\n          z)", "using elemins yins"], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z) =\n  Suc (index\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))))\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))) !\n         index\n          (fst (TSdet init h (as @ x # bs @ x # cs)\n                 (Suc (Suc (length as + length bs + i)))))\n          z)) \\<and>\n  index\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))))\n   (cs ! i) -\n  (index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    (cs ! i) -\n   index\n    (fst (TSdet init h (as @ x # bs @ x # cs)\n           (Suc (Suc (length as + length bs + i)))))\n    z)\n  < index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))) !\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z) \\<and>\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     z)\n  \\<le> index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i)\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ x # bs @ x # cs)\n                (Suc (Suc (length as + length bs + i)))))\n         z)\n       (cs ! i)\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i))))))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ x # bs @ x # cs)\n                 (Suc (Suc (length as + length bs + i)))))\n          z)", "by(simp add: nth_append split_def del: config'.simps)"], ["proof (state)\nthis:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))))\n        z)\n\ngoal (2 subgoals):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z\n 2. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "show \"index ?s_Suct3 ?y = index ?s z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z", "unfolding state_dannach"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (step\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i)\n       (index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         z,\n        []))\n     (cs ! i) =\n    index\n     (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)))\n     z", "apply(simp add: step_def nth_append del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         (cs ! i) -\n        index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         z)\n       (cs ! i)\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))))\n     (cs ! i) =\n    index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     z", "using A yins"], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   (fst (TSdet init h (as @ x # bs @ x # cs)\n          (Suc (Suc (length as + length bs + i)))) !\n    index\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i)))))\n     (cs ! i)) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         (cs ! i) -\n        index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         z)\n       (cs ! i)\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))))\n     (cs ! i) =\n    index (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n     z", "by(simp add: nth_append  del: config'.simps)"], ["proof (state)\nthis:\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   (cs ! i) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n\ngoal (1 subgoal):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "show \"index ?s_Suct3 z = Suc (index ?s z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "unfolding state_dannach"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (step\n       (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i)\n       (index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i) -\n        index\n         (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         z,\n        []))\n     z =\n    Suc (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z)", "apply(simp add: step_def nth_append del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         (cs ! i) -\n        index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         z)\n       (cs ! i)\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))))\n     z =\n    Suc (index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          z)", "using B yins"], ["proof (prove)\nusing this:\n  index\n   (mtf2\n     (index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       (cs ! i) -\n      index\n       (fst (TSdet init h (as @ x # bs @ x # cs)\n              (Suc (Suc (length as + length bs + i)))))\n       z)\n     (cs ! i)\n     (fst (TSdet init h (as @ x # bs @ x # cs)\n            (Suc (Suc (length as + length bs + i))))))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ x # bs @ x # cs)\n               (Suc (Suc (length as + length bs + i)))))\n        z)\n  cs ! i\n  \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. index\n     (mtf2\n       (index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         (cs ! i) -\n        index\n         (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n         z)\n       (cs ! i)\n       (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))))\n     z =\n    Suc (index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          z)", "by(simp add: nth_append  del: config'.simps)"], ["proof (state)\nthis:\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   (cs ! i) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        z)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   (cs ! i) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        z)", "have are: \"Suc (index ?s_Suct3 ?y) = index ?s_Suct3 z\""], ["proof (prove)\nusing this:\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   (cs ! i) =\n  index\n   (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i)))\n   z\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z =\n  Suc (index\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        z)\n\ngoal (1 subgoal):\n 1. Suc (index\n          (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i + 1))\n          (cs ! i)) =\n    index\n     (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1))\n     z", "by presburger"], ["proof (state)\nthis:\n  Suc (index\n        (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i + 1))\n        (cs ! i)) =\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from are before_in_def y_before_x_Suct3 el_n_x  assms(1)"], ["proof (chain)\npicking this:\n  Suc (index\n        (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i + 1))\n        (cs ! i)) =\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z\n  ?x < ?y in ?xs = (index ?xs ?x < index ?xs ?y \\<and> ?y \\<in> set ?xs)\n  cs ! i < x in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n  z \\<noteq> x\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs", "have z_before_x: \"z < x in ?s_Suct3\""], ["proof (prove)\nusing this:\n  Suc (index\n        (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n          (length (as @ [x] @ bs @ [x]) + i + 1))\n        (cs ! i)) =\n  index\n   (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i + 1))\n   z\n  ?x < ?y in ?xs = (index ?xs ?x < index ?xs ?y \\<and> ?y \\<in> set ?xs)\n  cs ! i < x in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + i + 1)\n  z \\<noteq> x\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n\ngoal (1 subgoal):\n 1. z < x\n    in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i + 1)", "by (metis Suc_lessI not_before_in yinfrontofz)"], ["proof (state)\nthis:\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have xSuct3: \"x\\<in>set ?s_Suct3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i + 1))", "using assms(4) i_in_cs"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  i < length cs\n\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i + 1))", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  x \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have elSuct3: \"z\\<in>set ?s_Suct3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i + 1))", "using zininit i_in_cs"], ["proof (prove)\nusing this:\n  z \\<in> set init\n  i < length cs\n\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i + 1))", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  z \\<in> set (s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have xt3: \"x\\<in>set ?s \""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))", "apply(subst config_config_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set init", "by fact"], ["proof (state)\nthis:\n  x \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "note elt3=elemins"], ["proof (state)\nthis:\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have z_s: \"z < x in ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z < x\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "proof(rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> z < x\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> z < x\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))", "have \"x < z in ?s\""], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. x < z\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "using not_before_in[OF xt3 elt3] el_n_x"], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))\n  (\\<not> x < z\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))) =\n  (z < x\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<or>\n   x = z)\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < z\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))\n  (\\<not> x < z\n          in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                   (length (as @ [x] @ bs @ [x]) + i))) =\n  (z < x\n   in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i)) \\<or>\n   x = z)\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < z\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "by blast"], ["proof (state)\nthis:\n  x < z\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x < z\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))", "have \"x < z in ?s_Suct3\""], ["proof (prove)\nusing this:\n  x < z\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n        (length (as @ [x] @ bs @ [x]) + i + 1)", "apply (simp only: state_dannach)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    x < z\n    in step\n        (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n               (length (as @ [x] @ bs @ [x]) + i)))\n        (cs ! i)\n        (index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          (cs ! i) -\n         index\n          (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                 (length (as @ [x] @ bs @ [x]) + i)))\n          z,\n         [])", "apply (simp only: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    x < z\n    in (let (k, sws) =\n              (index\n                (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                (cs ! i) -\n               index\n                (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                       (length (as @ [x] @ bs @ [x]) + i)))\n                z,\n               [])\n        in mtf2 k (cs ! i)\n            (swaps sws\n              (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))))", "apply(simp add: nth_append del: config'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z\n    in mtf2\n        (index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          (cs ! i) -\n         index\n          (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n          z)\n        (cs ! i)\n        (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))", "apply(rule x_stays_before_y_if_y_not_moved_to_front)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    cs ! i\n    \\<in> set (fst (config\\<^sub>p (rTS h) init\n                     (as @ x # bs @ x # take i cs)))\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 6. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply(subst config_config_set)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    cs ! i \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 6. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "using i_in_cs assms(3)"], ["proof (prove)\nusing this:\n  i < length cs\n  set cs \\<subseteq> set init\n\ngoal (6 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    cs ! i \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 6. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct\n     (fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs)))\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply(subst config_config_distinct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "using assms(5)"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (5 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    distinct init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 5. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply(subst config_config_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "using assms(4)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n\ngoal (4 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 4. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set (fst (config\\<^sub>p (rTS h) init\n                       (as @ x # bs @ x # take i cs)))\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply(subst config_config_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "using zininit"], ["proof (prove)\nusing this:\n  z \\<in> set init\n\ngoal (3 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<in> set init\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 3. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "using el_n_y"], ["proof (prove)\nusing this:\n  z \\<noteq> cs ! i\n\ngoal (2 subgoals):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    z \\<noteq> cs ! i\n 2. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in fst (config\\<^sub>p (rTS h) init\n             (as @ x # bs @ x # take i cs)) \\<Longrightarrow>\n    x < z in fst (config\\<^sub>p (rTS h) init (as @ x # bs @ x # take i cs))", "by(simp)"], ["proof (state)\nthis:\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)", "show \"False\""], ["proof (prove)\nusing this:\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. False", "using z_before_x not_before_in[OF xSuct3 elSuct3]"], ["proof (prove)\nusing this:\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n  (\\<not> x < z\n          in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i + 1)) =\n  (z < x\n   in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n       (length (as @ [x] @ bs @ [x]) + i + 1) \\<or>\n   x = z)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z < x\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have mind: \"(index ?is (cs ! i)) \\<ge> i + 1 + length bs + 1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 + length bs + 1\n    \\<le> index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i)", "using lastoccy"], ["proof (prove)\nusing this:\n  i + 1 + length bs + 1\n  \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)\n\ngoal (1 subgoal):\n 1. i + 1 + length bs + 1\n    \\<le> index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i)", "using i_in_cs fstTS_t3'[unfolded assms(1)]"], ["proof (prove)\nusing this:\n  i + 1 + length bs + 1\n  \\<le> index (rev (take i cs) @ x # rev bs @ x # rev as @ h) (cs ! i)\n  i < length cs\n  snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n        (Suc (Suc (length as + length bs + i)))) =\n  rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h\n\ngoal (1 subgoal):\n 1. i + 1 + length bs + 1\n    \\<le> index\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i)))\n           (cs ! i)", "by(simp add: split_def nth_append del: config'.simps)"], ["proof (state)\nthis:\n  i + 1 + length bs + 1\n  \\<le> index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z=\n      count_list (take (i + 1 + length bs + 1) ?is) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z =\n    count_list\n     (take (i + 1 + length bs + 1)\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z", "unfolding is_"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z =\n    count_list\n     (take (i + 1 + length bs + 1)\n       (rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h))\n     z", "using el_n_x"], ["proof (prove)\nusing this:\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z =\n    count_list\n     (take (i + 1 + length bs + 1)\n       (rev (take i cs) @ [x] @ rev bs @ [x] @ rev as @ h))\n     z", "by(simp add: minlencsi count_append )"], ["proof (state)\nthis:\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z =\n  count_list\n   (take (i + 1 + length bs + 1)\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "also"], ["proof (state)\nthis:\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z =\n  count_list\n   (take (i + 1 + length bs + 1)\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from mind"], ["proof (chain)\npicking this:\n  i + 1 + length bs + 1\n  \\<le> index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i)", "have \"\\<dots> \n          \\<le> count_list (take (index ?is (cs ! i)) ?is) z\""], ["proof (prove)\nusing this:\n  i + 1 + length bs + 1\n  \\<le> index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i)\n\ngoal (1 subgoal):\n 1. count_list\n     (take (i + 1 + length bs + 1)\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z\n    \\<le> count_list\n           (take\n             (index\n               (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                      (length (as @ [x] @ bs @ [x]) + i)))\n               (cs ! i))\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i))))\n           z", "by(rule count_take_less)"], ["proof (state)\nthis:\n  count_list\n   (take (i + 1 + length bs + 1)\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "also"], ["proof (state)\nthis:\n  count_list\n   (take (i + 1 + length bs + 1)\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> count_list\n         (take\n           (index\n             (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + i)))\n             (cs ! i))\n           (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))))\n         z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list\n     (take\n       (index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i))\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z\n    \\<le> 1", "using zatmostonce"], ["proof (prove)\nusing this:\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. count_list\n     (take\n       (index\n         (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                (length (as @ [x] @ bs @ [x]) + i)))\n         (cs ! i))\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i))))\n     z\n    \\<le> 1", "by metis"], ["proof (state)\nthis:\n  count_list\n   (take\n     (index\n       (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n              (length (as @ [x] @ bs @ [x]) + i)))\n       (cs ! i))\n     (snd (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n            (length (as @ [x] @ bs @ [x]) + i))))\n   z\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "finally"], ["proof (chain)\npicking this:\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1", "have aaa: \"count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1\""], ["proof (prove)\nusing this:\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1\n\ngoal (1 subgoal):\n 1. count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1", "."], ["proof (state)\nthis:\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with el_n_x"], ["proof (chain)\npicking this:\n  z \\<noteq> x\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1", "have \"count_list bs z + count_list (take i cs) z \\<le> 1\""], ["proof (prove)\nusing this:\n  z \\<noteq> x\n  count_list (rev (take i cs) @ [x] @ rev bs @ [x]) z \\<le> 1\n\ngoal (1 subgoal):\n 1. count_list bs z + count_list (take i cs) z \\<le> 1", "by(simp add: count_append count_rev)"], ["proof (state)\nthis:\n  count_list bs z + count_list (take i cs) z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "moreover"], ["proof (state)\nthis:\n  count_list bs z + count_list (take i cs) z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"count_list (take (Suc i) cs) z = count_list (take i cs) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z = count_list (take i cs) z", "using i_in_cs  el_n_y"], ["proof (prove)\nusing this:\n  i < length cs\n  z \\<noteq> cs ! i\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z = count_list (take i cs) z", "by(simp add: take_Suc_conv_app_nth count_append)"], ["proof (state)\nthis:\n  count_list (take (Suc i) cs) z = count_list (take i cs) z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "ultimately"], ["proof (chain)\npicking this:\n  count_list bs z + count_list (take i cs) z \\<le> 1\n  count_list (take (Suc i) cs) z = count_list (take i cs) z", "have aaaa: \"count_list bs z + count_list (take  (Suc i) cs) z \\<le> 1\""], ["proof (prove)\nusing this:\n  count_list bs z + count_list (take i cs) z \\<le> 1\n  count_list (take (Suc i) cs) z = count_list (take i cs) z\n\ngoal (1 subgoal):\n 1. count_list bs z + count_list (take (Suc i) cs) z \\<le> 1", "by simp"], ["proof (state)\nthis:\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have z_occurs_once_in_cs: \"count_list (take (Suc i) cs) z = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z = 1", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  count_list (take (Suc i) cs) z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "with aaaa"], ["proof (chain)\npicking this:\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1\n  count_list (take (Suc i) cs) z \\<noteq> 1", "have atmost1: \"count_list bs z \\<le> 1\" and \"count_list (take (Suc i) cs) z = 0\""], ["proof (prove)\nusing this:\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1\n  count_list (take (Suc i) cs) z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. count_list bs z \\<le> 1 &&& count_list (take (Suc i) cs) z = 0", "by force+"], ["proof (state)\nthis:\n  count_list bs z \\<le> 1\n  count_list (take (Suc i) cs) z = 0\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have yeah: \"z \\<notin> set (take (Suc i) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> set (take (Suc i) cs)", "apply(rule count_notin2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z = 0", "by fact\n \n    \\<comment> \\<open>now we know that x is in front of z after 2nd request to x, and that z is not requested any more,\n        that means it stays behind x, which leads to a contradiction with @{text z_before_x}\\<close>"], ["proof (state)\nthis:\n  z \\<notin> set (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have xin123: \"x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                  (length (as @ [x] @ bs @ [x]) + (i + 1)))", "using i_in_cs assms(4)"], ["proof (prove)\nusing this:\n  i < length cs\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                  (length (as @ [x] @ bs @ [x]) + (i + 1)))", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                (length (as @ [x] @ bs @ [x]) + (i + 1)))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have zin123: \"z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                  (length (as @ [x] @ bs @ [x]) + (i + 1)))", "using i_in_cs elemins"], ["proof (prove)\nusing this:\n  i < length cs\n  z \\<in> set (fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                  (length (as @ [x] @ bs @ [x]) + (i + 1)))", "by(simp add: s_TS_set  del: config'.simps)"], ["proof (state)\nthis:\n  z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n                (length (as @ [x] @ bs @ [x]) + (i + 1)))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have \"x < z in s_TS init h ((as @ [x] @ bs @ [x]) @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n        (length (as @ [x] @ bs @ [x]) + (i + 1))", "apply(rule TS_mono)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < z\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n 2. i + 1 \\<le> length (take (i + 1) cs)\n 3. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 4. x \\<notin> set (take (i + 1) cs)\n 5. distinct init\n 6. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(rule xgoestofront)"], ["proof (prove)\ngoal (8 subgoals):\n 1. z \\<in> set init\n 2. x \\<noteq> z\n 3. count_list bs z \\<le> 1\n 4. i + 1 \\<le> length (take (i + 1) cs)\n 5. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 6. x \\<notin> set (take (i + 1) cs)\n 7. distinct init\n 8. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(fact)"], ["proof (prove)\ngoal (7 subgoals):\n 1. x \\<noteq> z\n 2. count_list bs z \\<le> 1\n 3. i + 1 \\<le> length (take (i + 1) cs)\n 4. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 5. x \\<notin> set (take (i + 1) cs)\n 6. distinct init\n 7. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "using el_n_x"], ["proof (prove)\nusing this:\n  z \\<noteq> x\n\ngoal (7 subgoals):\n 1. x \\<noteq> z\n 2. count_list bs z \\<le> 1\n 3. i + 1 \\<le> length (take (i + 1) cs)\n 4. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 5. x \\<notin> set (take (i + 1) cs)\n 6. distinct init\n 7. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. count_list bs z \\<le> 1\n 2. i + 1 \\<le> length (take (i + 1) cs)\n 3. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 4. x \\<notin> set (take (i + 1) cs)\n 5. distinct init\n 6. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(fact)"], ["proof (prove)\ngoal (5 subgoals):\n 1. i + 1 \\<le> length (take (i + 1) cs)\n 2. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 3. x \\<notin> set (take (i + 1) cs)\n 4. distinct init\n 5. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (5 subgoals):\n 1. i + 1 \\<le> length (take (i + 1) cs)\n 2. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 3. x \\<notin> set (take (i + 1) cs)\n 4. distinct init\n 5. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 2. x \\<notin> set (take (i + 1) cs)\n 3. distinct init\n 4. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "using yeah i_in_cs length_take  nth_mem"], ["proof (prove)\nusing this:\n  z \\<notin> set (take (Suc i) cs)\n  i < length cs\n  length (take ?n ?xs) = min (length ?xs) ?n\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (4 subgoals):\n 1. \\<forall>j<i + 1. take (i + 1) cs ! j \\<noteq> z\n 2. x \\<notin> set (take (i + 1) cs)\n 3. distinct init\n 4. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply (metis Suc_eq_plus1 Suc_leI min_absorb2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<notin> set (take (i + 1) cs)\n 2. distinct init\n 3. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "using set_take_subset assms(2)"], ["proof (prove)\nusing this:\n  set (take ?n ?xs) \\<subseteq> set ?xs\n  x \\<notin> set cs\n\ngoal (3 subgoals):\n 1. x \\<notin> set (take (i + 1) cs)\n 2. distinct init\n 3. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct init\n 2. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "using assms i_in_cs"], ["proof (prove)\nusing this:\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n  x \\<notin> set cs\n  set cs \\<subseteq> set init\n  x \\<in> set init\n  distinct init\n  x \\<notin> set bs\n  set as \\<subseteq> set init\n  set bs \\<subseteq> set init\n  i < length cs\n\ngoal (2 subgoals):\n 1. distinct init\n 2. set ((as @ [x] @ bs @ [x]) @ take (i + 1) cs) \\<subseteq> set init", "apply(simp_all )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> = as @ x # bs @ x # cs; x \\<notin> set cs;\n     set cs \\<subseteq> set init; x \\<in> set init; distinct init;\n     x \\<notin> set bs; set as \\<subseteq> set init;\n     set bs \\<subseteq> set init; i < length cs\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) cs) \\<subseteq> set init", "using set_take_subset"], ["proof (prove)\nusing this:\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> = as @ x # bs @ x # cs; x \\<notin> set cs;\n     set cs \\<subseteq> set init; x \\<in> set init; distinct init;\n     x \\<notin> set bs; set as \\<subseteq> set init;\n     set bs \\<subseteq> set init; i < length cs\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) cs) \\<subseteq> set init", "by fast"], ["proof (state)\nthis:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n      (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n      (length (as @ [x] @ bs @ [x]) + (i + 1))", "have ge: \"\\<not> z < x in s_TS init h ((as @ [x] @ bs @ [x]) @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1))\""], ["proof (prove)\nusing this:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n      (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n               (length (as @ [x] @ bs @ [x]) + (i + 1))", "using not_before_in[OF zin123 xin123] el_n_x"], ["proof (prove)\nusing this:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n      (length (as @ [x] @ bs @ [x]) + (i + 1))\n  (\\<not> z < x\n          in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n              (length (as @ [x] @ bs @ [x]) + (i + 1))) =\n  (x < z\n   in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n       (length (as @ [x] @ bs @ [x]) + (i + 1)) \\<or>\n   z = x)\n  z \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> z < x\n           in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n               (length (as @ [x] @ bs @ [x]) + (i + 1))", "by blast"], ["proof (state)\nthis:\n  \\<not> z < x\n         in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n             (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have \" s_TS init h ((as @ [x] @ bs @ [x]) @ cs) (length (as @ [x] @ bs @ [x]) + (i+1))\n          = s_TS init h ((as @ [x] @ bs @ [x] @ (take (i+1) cs)) @ (drop (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n    s_TS init h ((as @ [x] @ bs @ [x] @ take (i + 1) cs) @ drop (i + 1) cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1))", "by auto"], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h ((as @ [x] @ bs @ [x] @ take (i + 1) cs) @ drop (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h ((as @ [x] @ bs @ [x] @ take (i + 1) cs) @ drop (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "have \"\\<dots>\n              = s_TS init h (as @ [x] @ bs @ [x] @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x] @ take (i + 1) cs) @ drop (i + 1) cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n    s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1))", "apply(rule s_TS_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + (i + 1)\n    \\<le> length (as @ [x] @ bs @ [x] @ take (i + 1) cs)", "using i_in_cs"], ["proof (prove)\nusing this:\n  i < length cs\n\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + (i + 1)\n    \\<le> length (as @ [x] @ bs @ [x] @ take (i + 1) cs)", "by(simp)"], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x] @ take (i + 1) cs) @ drop (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))", "have aaa: \" s_TS init h ((as @ [x] @ bs @ [x]) @ cs) (length (as @ [x] @ bs @ [x]) + (i+1))\n              = s_TS init h (as @ [x] @ bs @ [x] @ (take (i+1) cs)) (length (as @ [x] @ bs @ [x]) + (i+1))\""], ["proof (prove)\nusing this:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n    s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n     (length (as @ [x] @ bs @ [x]) + (i + 1))", "."], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. count_list (take (Suc i) cs) z \\<noteq> 1 \\<Longrightarrow> False", "from ge z_before_x"], ["proof (chain)\npicking this:\n  \\<not> z < x\n         in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n             (length (as @ [x] @ bs @ [x]) + (i + 1))\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n             (length (as @ [x] @ bs @ [x]) + (i + 1))\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. False", "unfolding assms(1)"], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n             (length (as @ [x] @ bs @ [x]) + (i + 1))\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n\ngoal (1 subgoal):\n 1. False", "using aaa"], ["proof (prove)\nusing this:\n  \\<not> z < x\n         in s_TS init h ((as @ [x] @ bs @ [x]) @ take (i + 1) cs)\n             (length (as @ [x] @ bs @ [x]) + (i + 1))\n  z < x\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i + 1)\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ take (i + 1) cs)\n   (length (as @ [x] @ bs @ [x]) + (i + 1))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_list (take (Suc i) cs) z = 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from z_occurs_once_in_cs"], ["proof (chain)\npicking this:\n  count_list (take (Suc i) cs) z = 1", "have kinSuci: \"z \\<in> set (take (Suc i) cs)\""], ["proof (prove)\nusing this:\n  count_list (take (Suc i) cs) z = 1\n\ngoal (1 subgoal):\n 1. z \\<in> set (take (Suc i) cs)", "by (metis One_nat_def count_notin n_not_Suc_n)"], ["proof (state)\nthis:\n  z \\<in> set (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  z \\<in> set (take (Suc i) cs)", "have zincs: \"z\\<in>set cs\""], ["proof (prove)\nusing this:\n  z \\<in> set (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. z \\<in> set cs", "using set_take_subset"], ["proof (prove)\nusing this:\n  z \\<in> set (take (Suc i) cs)\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. z \\<in> set cs", "by fast"], ["proof (state)\nthis:\n  z \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from z_occurs_once_in_cs"], ["proof (chain)\npicking this:\n  count_list (take (Suc i) cs) z = 1", "obtain k where k_def: \"k=index (take (Suc i) cs) z\""], ["proof (prove)\nusing this:\n  count_list (take (Suc i) cs) z = 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k = index (take (Suc i) cs) z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = index (take (Suc i) cs) z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  k = index (take (Suc i) cs) z", "have \"k=index cs z\""], ["proof (prove)\nusing this:\n  k = index (take (Suc i) cs) z\n\ngoal (1 subgoal):\n 1. k = index cs z", "using kinSuci"], ["proof (prove)\nusing this:\n  k = index (take (Suc i) cs) z\n  z \\<in> set (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. k = index cs z", "by (simp add: index_take_if_set)"], ["proof (state)\nthis:\n  k = index cs z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  k = index cs z", "have zcsk: \"z = cs!k\""], ["proof (prove)\nusing this:\n  k = index cs z\n\ngoal (1 subgoal):\n 1. z = cs ! k", "using zincs"], ["proof (prove)\nusing this:\n  k = index cs z\n  z \\<in> set cs\n\ngoal (1 subgoal):\n 1. z = cs ! k", "by simp"], ["proof (state)\nthis:\n  z = cs ! k\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have era: \" cs ! index (take (Suc i) cs) z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! index (take (Suc i) cs) z = z", "using kinSuci in_set_takeD index_take_if_set"], ["proof (prove)\nusing this:\n  z \\<in> set (take (Suc i) cs)\n  ?x \\<in> set (take ?n ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n  ?x \\<in> set (take ?n ?xs) \\<Longrightarrow>\n  index (take ?n ?xs) ?x = index ?xs ?x\n\ngoal (1 subgoal):\n 1. cs ! index (take (Suc i) cs) z = z", "by fastforce"], ["proof (state)\nthis:\n  cs ! index (take (Suc i) cs) z = z\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have ki: \"k<i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < i", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (take (Suc i) cs) z < i", "using kinSuci el_n_y"], ["proof (prove)\nusing this:\n  z \\<in> set (take (Suc i) cs)\n  z \\<noteq> cs ! i\n\ngoal (1 subgoal):\n 1. index (take (Suc i) cs) z < i", "by (metis i_in_cs index_take index_take_if_set le_neq_implies_less not_less_eq_eq yes)"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have zmustbebeforex: \"cs!k < x in ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! k < x\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "unfolding k_def era"], ["proof (prove)\ngoal (1 subgoal):\n 1. z < x\n    in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n             (length (as @ [x] @ bs @ [x]) + i))", "by (fact z_s)\n \n  \\<comment> \\<open>before the request to z, x is in front of z, analog zu oben, vllt generell machen?\\<close>\n\n\n   \\<comment> \\<open>element z does not occur between t1 and position k\\<close>"], ["proof (state)\nthis:\n  cs ! k < x\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have  z_notinbs: \"cs ! k \\<notin> set bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! k \\<notin> set bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cs ! k \\<notin> set bs", "from z_occurs_once_in_cs aaaa"], ["proof (chain)\npicking this:\n  count_list (take (Suc i) cs) z = 1\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1", "have \"count_list bs z = 0\""], ["proof (prove)\nusing this:\n  count_list (take (Suc i) cs) z = 1\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1\n\ngoal (1 subgoal):\n 1. count_list bs z = 0", "by auto"], ["proof (state)\nthis:\n  count_list bs z = 0\n\ngoal (1 subgoal):\n 1. cs ! k \\<notin> set bs", "then"], ["proof (chain)\npicking this:\n  count_list bs z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  count_list bs z = 0\n\ngoal (1 subgoal):\n 1. cs ! k \\<notin> set bs", "using zcsk count_notin2"], ["proof (prove)\nusing this:\n  count_list bs z = 0\n  z = cs ! k\n  count_list ?xs ?x = 0 \\<Longrightarrow> ?x \\<notin> set ?xs\n\ngoal (1 subgoal):\n 1. cs ! k \\<notin> set bs", "by metis"], ["proof (state)\nthis:\n  cs ! k \\<notin> set bs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cs ! k \\<notin> set bs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"count_list bs z \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list bs z \\<le> 1", "using aaaa"], ["proof (prove)\nusing this:\n  count_list bs z + count_list (take (Suc i) cs) z \\<le> 1\n\ngoal (1 subgoal):\n 1. count_list bs z \\<le> 1", "by linarith"], ["proof (state)\nthis:\n  count_list bs z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with xgoestofront[OF zininit el_n_x[symmetric]]"], ["proof (chain)\npicking this:\n  count_list bs z \\<le> 1 \\<Longrightarrow>\n  x < z in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n  count_list bs z \\<le> 1", "have xbeforez: \"x < z in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\""], ["proof (prove)\nusing this:\n  count_list bs z \\<le> 1 \\<Longrightarrow>\n  x < z in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n  count_list bs z \\<le> 1\n\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))", "by auto"], ["proof (state)\nthis:\n  x < z in s_TS init h (as @ [x] @ bs @ [x]) (length (as @ [x] @ bs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "obtain cs1 cs2 where v: \"cs1 @ cs2 = cs\" and cs1: \"cs1 = take (Suc k) cs\" and cs2: \"cs2 = drop (Suc k) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>cs1 @ cs2 = cs; cs1 = take (Suc k) cs;\n         cs2 = drop (Suc k) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cs1 @ cs2 = cs\n  cs1 = take (Suc k) cs\n  cs2 = drop (Suc k) cs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have z_firstocc:  \"\\<forall>j<k.  cs ! j \\<noteq> cs ! k\"\n      and z_lastocc:  \"\\<forall>j<i-k-1.  cs2 ! j \\<noteq> cs ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<k. cs ! j \\<noteq> cs ! k &&&\n    \\<forall>j<i - k - 1. cs2 ! j \\<noteq> cs ! k", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 j)"], ["proof (state)\nthis:\n  j < k\n  cs ! j = cs ! k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with ki i_in_cs"], ["proof (chain)\npicking this:\n  k < i\n  i < length cs\n  j < k\n  cs ! j = cs ! k", "have 2: \"j < length (take k cs)\""], ["proof (prove)\nusing this:\n  k < i\n  i < length cs\n  j < k\n  cs ! j = cs ! k\n\ngoal (1 subgoal):\n 1. j < length (take k cs)", "by auto"], ["proof (state)\nthis:\n  j < length (take k cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have un1: \"(take (Suc i) cs)!k = cs!k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i) cs ! k = cs ! k", "apply(rule nth_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < Suc i", "using ki"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. k < Suc i", "by auto"], ["proof (state)\nthis:\n  take (Suc i) cs ! k = cs ! k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have un2: \"(take k cs)!j = cs!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k cs ! j = cs ! j", "apply(rule nth_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < k", "using 1(1) ki"], ["proof (prove)\nusing this:\n  j < k\n  k < i\n\ngoal (1 subgoal):\n 1. j < k", "by auto"], ["proof (state)\nthis:\n  take k cs ! j = cs ! j\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "from i_in_cs ki"], ["proof (chain)\npicking this:\n  i < length cs\n  k < i", "have f1: \"k < length (take (Suc i) cs)\""], ["proof (prove)\nusing this:\n  i < length cs\n  k < i\n\ngoal (1 subgoal):\n 1. k < length (take (Suc i) cs)", "by auto"], ["proof (state)\nthis:\n  k < length (take (Suc i) cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k < length (take (Suc i) cs)", "have \"(take (Suc i) cs) = (take k (take (Suc i) cs)) @ (take (Suc i) cs)!k # (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  k < length (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take k (take (Suc i) cs) @\n    take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)", "by(rule id_take_nth_drop)"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(take k (take (Suc i) cs)) = take k cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (take (Suc i) cs) = take k cs", "using i_in_cs ki"], ["proof (prove)\nusing this:\n  i < length cs\n  k < i\n\ngoal (1 subgoal):\n 1. take k (take (Suc i) cs) = take k cs", "by (simp add: min_def)"], ["proof (state)\nthis:\n  take k (take (Suc i) cs) = take k cs\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  take k (take (Suc i) cs) = take k cs\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = (take j (take k cs)) @ (take k cs)!j # (drop (Suc j) (take k cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k cs =\n    take j (take k cs) @ take k cs ! j # drop (Suc j) (take k cs)", "using 2"], ["proof (prove)\nusing this:\n  j < length (take k cs)\n\ngoal (1 subgoal):\n 1. take k cs =\n    take j (take k cs) @ take k cs ! j # drop (Suc j) (take k cs)", "by(rule id_take_nth_drop)"], ["proof (state)\nthis:\n  take k cs = take j (take k cs) @ take k cs ! j # drop (Suc j) (take k cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  take (Suc i) cs =\n  (take j (take k cs) @ take k cs ! j # drop (Suc j) (take k cs)) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)", "have \"take (Suc i) cs\n            =  (take j (take k cs)) @ [(take k cs)!j] @ (drop (Suc j) (take k cs)) \n                        @ [(take (Suc i) cs)!k] @ (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  take (Suc i) cs =\n  (take j (take k cs) @ take k cs ! j # drop (Suc j) (take k cs)) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take j (take k cs) @\n    [take k cs ! j] @\n    drop (Suc j) (take k cs) @\n    [take (Suc i) cs ! k] @ drop (Suc k) (take (Suc i) cs)", "by(simp)"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [take k cs ! j] @\n  drop (Suc j) (take k cs) @\n  [take (Suc i) cs ! k] @ drop (Suc k) (take (Suc i) cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [take k cs ! j] @\n  drop (Suc j) (take k cs) @\n  [take (Suc i) cs ! k] @ drop (Suc k) (take (Suc i) cs)", "have A: \"take (Suc i) cs\n            =  (take j (take k cs)) @ [cs!j] @ (drop (Suc j) (take k cs)) \n                        @ [cs!k] @ (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [take k cs ! j] @\n  drop (Suc j) (take k cs) @\n  [take (Suc i) cs ! k] @ drop (Suc k) (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take j (take k cs) @\n    [cs ! j] @\n    drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)", "unfolding un1 un2"], ["proof (prove)\nusing this:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [cs ! j] @\n  drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take j (take k cs) @\n    [cs ! j] @\n    drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)", "by simp"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [cs ! j] @\n  drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"count_list ((take j (take k cs)) @ [cs!j] @ (drop (Suc j) (take k cs)) \n                        @ [cs!k] @ (drop (Suc k) (take (Suc i) cs))) z \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> count_list\n             (take j (take k cs) @\n              [cs ! j] @\n              drop (Suc j) (take k cs) @\n              [cs ! k] @ drop (Suc k) (take (Suc i) cs))\n             z", "apply(simp add: count_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cs ! k = z \\<longrightarrow>\n     cs ! j \\<noteq> z \\<longrightarrow>\n     Suc 0\n     \\<le> count_list (take (min j k) cs) z +\n           (count_list (drop (Suc j) (take k cs)) z +\n            count_list (drop (Suc k) (take (Suc i) cs)) z)) \\<and>\n    (cs ! k \\<noteq> z \\<longrightarrow>\n     (cs ! j = z \\<longrightarrow>\n      Suc 0\n      \\<le> count_list (take (min j k) cs) z +\n            (count_list (drop (Suc j) (take k cs)) z +\n             count_list (drop (Suc k) (take (Suc i) cs)) z)) \\<and>\n     (cs ! j \\<noteq> z \\<longrightarrow>\n      2 \\<le> count_list (take (min j k) cs) z +\n              (count_list (drop (Suc j) (take k cs)) z +\n               count_list (drop (Suc k) (take (Suc i) cs)) z)))", "using zcsk 1(2)"], ["proof (prove)\nusing this:\n  z = cs ! k\n  cs ! j = cs ! k\n\ngoal (1 subgoal):\n 1. (cs ! k = z \\<longrightarrow>\n     cs ! j \\<noteq> z \\<longrightarrow>\n     Suc 0\n     \\<le> count_list (take (min j k) cs) z +\n           (count_list (drop (Suc j) (take k cs)) z +\n            count_list (drop (Suc k) (take (Suc i) cs)) z)) \\<and>\n    (cs ! k \\<noteq> z \\<longrightarrow>\n     (cs ! j = z \\<longrightarrow>\n      Suc 0\n      \\<le> count_list (take (min j k) cs) z +\n            (count_list (drop (Suc j) (take k cs)) z +\n             count_list (drop (Suc k) (take (Suc i) cs)) z)) \\<and>\n     (cs ! j \\<noteq> z \\<longrightarrow>\n      2 \\<le> count_list (take (min j k) cs) z +\n              (count_list (drop (Suc j) (take k cs)) z +\n               count_list (drop (Suc k) (take (Suc i) cs)) z)))", "by(simp)"], ["proof (state)\nthis:\n  2 \\<le> count_list\n           (take j (take k cs) @\n            [cs ! j] @\n            drop (Suc j) (take k cs) @\n            [cs ! k] @ drop (Suc k) (take (Suc i) cs))\n           z\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [cs ! j] @\n  drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)\n  2 \\<le> count_list\n           (take j (take k cs) @\n            [cs ! j] @\n            drop (Suc j) (take k cs) @\n            [cs ! k] @ drop (Suc k) (take (Suc i) cs))\n           z", "have \"count_list (take (Suc i) cs) z \\<ge> 2\""], ["proof (prove)\nusing this:\n  take (Suc i) cs =\n  take j (take k cs) @\n  [cs ! j] @\n  drop (Suc j) (take k cs) @ [cs ! k] @ drop (Suc k) (take (Suc i) cs)\n  2 \\<le> count_list\n           (take j (take k cs) @\n            [cs ! j] @\n            drop (Suc j) (take k cs) @\n            [cs ! k] @ drop (Suc k) (take (Suc i) cs))\n           z\n\ngoal (1 subgoal):\n 1. 2 \\<le> count_list (take (Suc i) cs) z", "by auto"], ["proof (state)\nthis:\n  2 \\<le> count_list (take (Suc i) cs) z\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with z_occurs_once_in_cs"], ["proof (chain)\npicking this:\n  count_list (take (Suc i) cs) z = 1\n  2 \\<le> count_list (take (Suc i) cs) z", "show \"False\""], ["proof (prove)\nusing this:\n  count_list (take (Suc i) cs) z = 1\n  2 \\<le> count_list (take (Suc i) cs) z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "case (2 j)"], ["proof (state)\nthis:\n  j < i - k - 1\n  cs2 ! j = cs ! k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  j < i - k - 1\n  cs2 ! j = cs ! k", "have 1: \"Suc k+j < i\""], ["proof (prove)\nusing this:\n  j < i - k - 1\n  cs2 ! j = cs ! k\n\ngoal (1 subgoal):\n 1. Suc k + j < i", "by auto"], ["proof (state)\nthis:\n  Suc k + j < i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Suc k + j < i", "have f2: \"j < length (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  Suc k + j < i\n\ngoal (1 subgoal):\n 1. j < length (drop (Suc k) (take (Suc i) cs))", "using i_in_cs"], ["proof (prove)\nusing this:\n  Suc k + j < i\n  i < length cs\n\ngoal (1 subgoal):\n 1. j < length (drop (Suc k) (take (Suc i) cs))", "by simp"], ["proof (state)\nthis:\n  j < length (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have 3: \"(drop (Suc k) (take (Suc i) cs)) = take j (drop (Suc k) (take (Suc i) cs))\n                                        @ (drop (Suc k) (take (Suc i) cs))! j\n                                          # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) =\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    drop (Suc k) (take (Suc i) cs) ! j #\n    drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "using f2"], ["proof (prove)\nusing this:\n  j < length (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) =\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    drop (Suc k) (take (Suc i) cs) ! j #\n    drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "by(rule id_take_nth_drop)"], ["proof (state)\nthis:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  drop (Suc k) (take (Suc i) cs) ! j #\n  drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(drop (Suc k) (take (Suc i) cs))! j = (take (Suc i) cs) ! (Suc k+j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) ! j = take (Suc i) cs ! (Suc k + j)", "apply(rule nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k \\<le> length (take (Suc i) cs)", "using i_in_cs 1"], ["proof (prove)\nusing this:\n  i < length cs\n  Suc k + j < i\n\ngoal (1 subgoal):\n 1. Suc k \\<le> length (take (Suc i) cs)", "by auto"], ["proof (state)\nthis:\n  drop (Suc k) (take (Suc i) cs) ! j = take (Suc i) cs ! (Suc k + j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  drop (Suc k) (take (Suc i) cs) ! j = take (Suc i) cs ! (Suc k + j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = cs ! (Suc k+j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i) cs ! (Suc k + j) = cs ! (Suc k + j)", "apply(rule nth_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k + j < Suc i", "using 1"], ["proof (prove)\nusing this:\n  Suc k + j < i\n\ngoal (1 subgoal):\n 1. Suc k + j < Suc i", "by auto"], ["proof (state)\nthis:\n  take (Suc i) cs ! (Suc k + j) = cs ! (Suc k + j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  drop (Suc k) (take (Suc i) cs) ! j = cs ! (Suc k + j)", "have 4: \"(drop (Suc k) (take (Suc i) cs)) = take j (drop (Suc k) (take (Suc i) cs))\n                                        @ cs! (Suc k +j)\n                                          # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  drop (Suc k) (take (Suc i) cs) ! j = cs ! (Suc k + j)\n\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) =\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    cs ! (Suc k + j) # drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "using 3"], ["proof (prove)\nusing this:\n  drop (Suc k) (take (Suc i) cs) ! j = cs ! (Suc k + j)\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  drop (Suc k) (take (Suc i) cs) ! j #\n  drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) =\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    cs ! (Suc k + j) # drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "by auto"], ["proof (state)\nthis:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! (Suc k + j) # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have 5: \"cs2 ! j = cs! (Suc k +j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs2 ! j = cs ! (Suc k + j)", "unfolding cs2"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc k) cs ! j = cs ! (Suc k + j)", "apply(rule nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k \\<le> length cs", "using i_in_cs 1"], ["proof (prove)\nusing this:\n  i < length cs\n  Suc k + j < i\n\ngoal (1 subgoal):\n 1. Suc k \\<le> length cs", "by auto"], ["proof (state)\nthis:\n  cs2 ! j = cs ! (Suc k + j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "from 4 5 2(2)"], ["proof (chain)\npicking this:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! (Suc k + j) # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  cs2 ! j = cs ! (Suc k + j)\n  cs2 ! j = cs ! k", "have 6: \"(drop (Suc k) (take (Suc i) cs)) = take j (drop (Suc k) (take (Suc i) cs))\n                                        @ cs! k\n                                          # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! (Suc k + j) # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  cs2 ! j = cs ! (Suc k + j)\n  cs2 ! j = cs ! k\n\ngoal (1 subgoal):\n 1. drop (Suc k) (take (Suc i) cs) =\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    cs ! k # drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "by auto"], ["proof (state)\nthis:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! k # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "from i_in_cs ki"], ["proof (chain)\npicking this:\n  i < length cs\n  k < i", "have 1: \"k < length (take (Suc i) cs)\""], ["proof (prove)\nusing this:\n  i < length cs\n  k < i\n\ngoal (1 subgoal):\n 1. k < length (take (Suc i) cs)", "by auto"], ["proof (state)\nthis:\n  k < length (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k < length (take (Suc i) cs)", "have 7: \"(take (Suc i) cs) = (take k (take (Suc i) cs)) @ (take (Suc i) cs)!k # (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  k < length (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take k (take (Suc i) cs) @\n    take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)", "by(rule id_take_nth_drop)"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have 9: \"(take (Suc i) cs)!k = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i) cs ! k = z", "unfolding zcsk"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i) cs ! k = cs ! k", "apply(rule nth_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < Suc i", "using ki"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. k < Suc i", "by auto"], ["proof (state)\nthis:\n  take (Suc i) cs ! k = z\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "from 6 7"], ["proof (chain)\npicking this:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! k # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)", "have A: \"(take (Suc i) cs) = (take k (take (Suc i) cs)) @ z # take j (drop (Suc k) (take (Suc i) cs))\n                                        @ z\n                                          # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\""], ["proof (prove)\nusing this:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! k # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take k (take (Suc i) cs) @\n    z #\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    z # drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "using ki 9"], ["proof (prove)\nusing this:\n  drop (Suc k) (take (Suc i) cs) =\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  cs ! k # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  take (Suc i) cs ! k # drop (Suc k) (take (Suc i) cs)\n  k < i\n  take (Suc i) cs ! k = z\n\ngoal (1 subgoal):\n 1. take (Suc i) cs =\n    take k (take (Suc i) cs) @\n    z #\n    take j (drop (Suc k) (take (Suc i) cs)) @\n    z # drop (Suc j) (drop (Suc k) (take (Suc i) cs))", "by auto"], ["proof (state)\nthis:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  z #\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  z # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "have \"count_list ((take k (take (Suc i) cs)) @ z # take j (drop (Suc k) (take (Suc i) cs))\n                                        @ z\n                                          # drop (Suc j) (drop (Suc k) (take (Suc i) cs))) z\n                                            \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> count_list\n             (take k (take (Suc i) cs) @\n              z #\n              take j (drop (Suc k) (take (Suc i) cs)) @\n              z # drop (Suc j) (drop (Suc k) (take (Suc i) cs)))\n             z", "by(simp add: count_append)"], ["proof (state)\nthis:\n  2 \\<le> count_list\n           (take k (take (Suc i) cs) @\n            z #\n            take j (drop (Suc k) (take (Suc i) cs)) @\n            z # drop (Suc j) (drop (Suc k) (take (Suc i) cs)))\n           z\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  z #\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  z # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  2 \\<le> count_list\n           (take k (take (Suc i) cs) @\n            z #\n            take j (drop (Suc k) (take (Suc i) cs)) @\n            z # drop (Suc j) (drop (Suc k) (take (Suc i) cs)))\n           z", "have \"count_list (take (Suc i) cs) z \\<ge> 2\""], ["proof (prove)\nusing this:\n  take (Suc i) cs =\n  take k (take (Suc i) cs) @\n  z #\n  take j (drop (Suc k) (take (Suc i) cs)) @\n  z # drop (Suc j) (drop (Suc k) (take (Suc i) cs))\n  2 \\<le> count_list\n           (take k (take (Suc i) cs) @\n            z #\n            take j (drop (Suc k) (take (Suc i) cs)) @\n            z # drop (Suc j) (drop (Suc k) (take (Suc i) cs)))\n           z\n\ngoal (1 subgoal):\n 1. 2 \\<le> count_list (take (Suc i) cs) z", "by auto"], ["proof (state)\nthis:\n  2 \\<le> count_list (take (Suc i) cs) z\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < i - k - 1; cs2 ! j = cs ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with z_occurs_once_in_cs"], ["proof (chain)\npicking this:\n  count_list (take (Suc i) cs) z = 1\n  2 \\<le> count_list (take (Suc i) cs) z", "show \"False\""], ["proof (prove)\nusing this:\n  count_list (take (Suc i) cs) z = 1\n  2 \\<le> count_list (take (Suc i) cs) z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<k. cs ! j \\<noteq> cs ! k\n  \\<forall>j<i - k - 1. cs2 ! j \\<noteq> cs ! k\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have k_in_cs: \"k < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length cs", "using ki i_in_cs"], ["proof (prove)\nusing this:\n  k < i\n  i < length cs\n\ngoal (1 subgoal):\n 1. k < length cs", "by auto"], ["proof (state)\nthis:\n  k < length cs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "with cs1"], ["proof (chain)\npicking this:\n  cs1 = take (Suc k) cs\n  k < length cs", "have lenkk: \"length cs1 = k+1\""], ["proof (prove)\nusing this:\n  cs1 = take (Suc k) cs\n  k < length cs\n\ngoal (1 subgoal):\n 1. length cs1 = k + 1", "by auto"], ["proof (state)\nthis:\n  length cs1 = k + 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from k_in_cs"], ["proof (chain)\npicking this:\n  k < length cs", "have mincsk: \"min (length cs) (Suc k) = Suc k\""], ["proof (prove)\nusing this:\n  k < length cs\n\ngoal (1 subgoal):\n 1. min (length cs) (Suc k) = Suc k", "by auto"], ["proof (state)\nthis:\n  min (length cs) (Suc k) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have \"s_TS init h (((as@[x]@bs@[x])@cs1) @ cs2) (length (as@[x]@bs@[x])+k+1)\n        = s_TS init h ((as@[x]@bs@[x])@(cs1)) (length (as@[x]@bs@[x])+k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h (((as @ [x] @ bs @ [x]) @ cs1) @ cs2)\n     (length (as @ [x] @ bs @ [x]) + k + 1) =\n    s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n     (length (as @ [x] @ bs @ [x]) + k + 1)", "apply(rule s_TS_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + k + 1\n    \\<le> length ((as @ [x] @ bs @ [x]) @ cs1)", "using cs1 cs2 k_in_cs"], ["proof (prove)\nusing this:\n  cs1 = take (Suc k) cs\n  cs2 = drop (Suc k) cs\n  k < length cs\n\ngoal (1 subgoal):\n 1. length (as @ [x] @ bs @ [x]) + k + 1\n    \\<le> length ((as @ [x] @ bs @ [x]) @ cs1)", "by(simp)"], ["proof (state)\nthis:\n  s_TS init h (((as @ [x] @ bs @ [x]) @ cs1) @ cs2)\n   (length (as @ [x] @ bs @ [x]) + k + 1) =\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n   (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "then"], ["proof (chain)\npicking this:\n  s_TS init h (((as @ [x] @ bs @ [x]) @ cs1) @ cs2)\n   (length (as @ [x] @ bs @ [x]) + k + 1) =\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n   (length (as @ [x] @ bs @ [x]) + k + 1)", "have spliter: \"s_TS init h ((as@[x]@bs@[x])@(cs1)) (length (as@[x]@bs@[x]@(cs1)))\n        = s_TS init h ((as@[x]@bs@[x])@cs) (length (as@[x]@bs@[x])+k+1) \""], ["proof (prove)\nusing this:\n  s_TS init h (((as @ [x] @ bs @ [x]) @ cs1) @ cs2)\n   (length (as @ [x] @ bs @ [x]) + k + 1) =\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n   (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n     (length (as @ [x] @ bs @ [x] @ cs1)) =\n    s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n     (length (as @ [x] @ bs @ [x]) + k + 1)", "using lenkk v cs1"], ["proof (prove)\nusing this:\n  s_TS init h (((as @ [x] @ bs @ [x]) @ cs1) @ cs2)\n   (length (as @ [x] @ bs @ [x]) + k + 1) =\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n   (length (as @ [x] @ bs @ [x]) + k + 1)\n  length cs1 = k + 1\n  cs1 @ cs2 = cs\n  cs1 = take (Suc k) cs\n\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n     (length (as @ [x] @ bs @ [x] @ cs1)) =\n    s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n     (length (as @ [x] @ bs @ [x]) + k + 1)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_TS init h (as @ x # bs @ x # cs)\n              (Suc (Suc (Suc (length as + length bs + k)))) =\n             s_TS init h (as @ x # bs @ x # take (Suc k) cs)\n              (Suc (Suc (Suc (length as + length bs + k))));\n     min (length cs) (Suc k) = Suc k; take (Suc k) cs @ cs2 = cs;\n     cs1 = take (Suc k) cs\\<rbrakk>\n    \\<Longrightarrow> s_TS init h (as @ x # bs @ x # take (Suc k) cs)\n                       (Suc (Suc (Suc (length as + (length bs + k))))) =\n                      s_TS init h (as @ x # bs @ x # take (Suc k) cs)\n                       (Suc (Suc (Suc (length as + length bs + k))))", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n   (length (as @ [x] @ bs @ [x] @ cs1)) =\n  s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n   (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "from cs2"], ["proof (chain)\npicking this:\n  cs2 = drop (Suc k) cs", "have \"length cs2 = length cs - (Suc k)\""], ["proof (prove)\nusing this:\n  cs2 = drop (Suc k) cs\n\ngoal (1 subgoal):\n 1. length cs2 = length cs - Suc k", "by auto"], ["proof (state)\nthis:\n  length cs2 = length cs - Suc k\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have notxbeforez: \"~ x < z in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < z\n           in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> \\<not> x < z\n                in s_TS init h \\<sigma>\n                    (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> x < z\n                in s_TS init h \\<sigma>\n                    (length (as @ [x] @ bs @ [x]) + k + 1)", "have a: \"x < z in s_TS init h ((as@[x]@bs@[x])@(cs1)) (length (as@[x]@bs@[x]@(cs1)))\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> x < z\n                in s_TS init h \\<sigma>\n                    (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n        (length (as @ [x] @ bs @ [x] @ cs1))", "unfolding spliter assms(1)"], ["proof (prove)\nusing this:\n  \\<not> \\<not> x < z\n                in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n                    (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n        (length (as @ [x] @ bs @ [x]) + k + 1)", "by auto"], ["proof (state)\nthis:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n      (length (as @ [x] @ bs @ [x] @ cs1))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "have 41: \"x \\<in> set(s_TS init h ((as @ [x] @ bs @ [x]) @ cs) (length (as @ [x] @ bs @ [x]) + i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))", "using i_in_cs assms(4)"], ["proof (prove)\nusing this:\n  i < length cs\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "have 42: \"z \\<in> set(s_TS init h ((as @ [x] @ bs @ [x]) @ cs) (length (as @ [x] @ bs @ [x]) + i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))", "using i_in_cs zininit"], ["proof (prove)\nusing this:\n  i < length cs\n  z \\<in> set init\n\ngoal (1 subgoal):\n 1. z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                  (length (as @ [x] @ bs @ [x]) + i))", "by(simp add: s_TS_set)"], ["proof (state)\nthis:\n  z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "have rewr: \"s_TS init h ((as@[x]@bs@[x]@cs1)@cs2) (length (as@[x]@bs@[x]@cs1)+(i-k-1)) =\n            s_TS init h (as@[x]@bs@[x]@cs) (length (as@[x]@bs@[x])+i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n     (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1)) =\n    s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i)", "using cs1 v ki"], ["proof (prove)\nusing this:\n  cs1 = take (Suc k) cs\n  cs1 @ cs2 = cs\n  k < i\n\ngoal (1 subgoal):\n 1. s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n     (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1)) =\n    s_TS init h (as @ [x] @ bs @ [x] @ cs)\n     (length (as @ [x] @ bs @ [x]) + i)", "apply(simp add: mincsk)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs1 = take (Suc k) cs; take (Suc k) cs @ cs2 = cs;\n     k < i\\<rbrakk>\n    \\<Longrightarrow> s_TS init h (as @ x # bs @ x # cs)\n                       (Suc (Suc (length as + (length bs + i)))) =\n                      s_TS init h (as @ x # bs @ x # cs)\n                       (Suc (Suc (length as + length bs + i)))", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n   (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1)) =\n  s_TS init h (as @ [x] @ bs @ [x] @ cs) (length (as @ [x] @ bs @ [x]) + i)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "have \"x < z in s_TS init h ((as@[x]@bs@[x]@cs1)@cs2) (length (as@[x]@bs@[x]@cs1)+(i-k-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n        (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1))", "apply(rule TS_mono)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < z\n    in s_TS init h (as @ [x] @ bs @ [x] @ cs1)\n        (length (as @ [x] @ bs @ [x] @ cs1))\n 2. i - k - 1 \\<le> length cs2\n 3. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 4. x \\<notin> set cs2\n 5. distinct init\n 6. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "using a"], ["proof (prove)\nusing this:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x]) @ cs1)\n      (length (as @ [x] @ bs @ [x] @ cs1))\n\ngoal (6 subgoals):\n 1. x < z\n    in s_TS init h (as @ [x] @ bs @ [x] @ cs1)\n        (length (as @ [x] @ bs @ [x] @ cs1))\n 2. i - k - 1 \\<le> length cs2\n 3. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 4. x \\<notin> set cs2\n 5. distinct init\n 6. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. i - k - 1 \\<le> length cs2\n 2. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 3. x \\<notin> set cs2\n 4. distinct init\n 5. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "using cs2 i_in_cs ki v cs1"], ["proof (prove)\nusing this:\n  cs2 = drop (Suc k) cs\n  i < length cs\n  k < i\n  cs1 @ cs2 = cs\n  cs1 = take (Suc k) cs\n\ngoal (5 subgoals):\n 1. i - k - 1 \\<le> length cs2\n 2. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 3. x \\<notin> set cs2\n 4. distinct init\n 5. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 2. x \\<notin> set cs2\n 3. distinct init\n 4. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "using z_lastocc zcsk"], ["proof (prove)\nusing this:\n  \\<forall>j<i - k - 1. cs2 ! j \\<noteq> cs ! k\n  z = cs ! k\n\ngoal (4 subgoals):\n 1. \\<forall>j<i - k - 1. cs2 ! j \\<noteq> z\n 2. x \\<notin> set cs2\n 3. distinct init\n 4. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<notin> set cs2\n 2. distinct init\n 3. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "using v assms(2)"], ["proof (prove)\nusing this:\n  cs1 @ cs2 = cs\n  x \\<notin> set cs\n\ngoal (3 subgoals):\n 1. x \\<notin> set cs2\n 2. distinct init\n 3. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct init\n 2. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> = as @ [x] @ bs @ [x] @ cs\n  x \\<notin> set cs\n  set cs \\<subseteq> set init\n  x \\<in> set init\n  distinct init\n  x \\<notin> set bs\n  set as \\<subseteq> set init\n  set bs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. distinct init\n 2. set ((as @ [x] @ bs @ [x] @ cs1) @ cs2) \\<subseteq> set init", "by(simp_all add: cs1 cs2)"], ["proof (state)\nthis:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n      (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "(* \"contradiction to zmustbebeforex\" *)"], ["proof (state)\nthis:\n  x < z\n  in s_TS init h ((as @ [x] @ bs @ [x] @ cs1) @ cs2)\n      (length (as @ [x] @ bs @ [x] @ cs1) + (i - k - 1))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> x < z\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + k +\n                       1) \\<Longrightarrow>\n    False", "from zmustbebeforex this[unfolded rewr ] el_n_x zcsk 41 42 not_before_in"], ["proof (chain)\npicking this:\n  cs ! k < x\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)\n  z \\<noteq> x\n  z = cs ! k\n  x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n  z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)", "show \"False\""], ["proof (prove)\nusing this:\n  cs ! k < x\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  x < z\n  in s_TS init h (as @ [x] @ bs @ [x] @ cs)\n      (length (as @ [x] @ bs @ [x]) + i)\n  z \\<noteq> x\n  z = cs ! k\n  x \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n  z \\<in> set (s_TS init h ((as @ [x] @ bs @ [x]) @ cs)\n                (length (as @ [x] @ bs @ [x]) + i))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. False", "unfolding s_TS_def"], ["proof (prove)\nusing this:\n  cs ! k < x\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  x < z\n  in fst (TSdet init h (as @ [x] @ bs @ [x] @ cs)\n           (length (as @ [x] @ bs @ [x]) + i))\n  z \\<noteq> x\n  z = cs ! k\n  x \\<in> set (fst (TSdet init h ((as @ [x] @ bs @ [x]) @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n  z \\<in> set (fst (TSdet init h ((as @ [x] @ bs @ [x]) @ cs)\n                     (length (as @ [x] @ bs @ [x]) + i)))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> x < z\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "have 1: \"k < length cs\"\n                   \"(\\<forall>j<k. cs ! j \\<noteq> cs ! k)\"\n                   \"cs ! k \\<noteq> x\" \"cs ! k \\<notin> set bs\" \n              \"~ x < z in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k < length cs &&& \\<forall>j<k. cs ! j \\<noteq> cs ! k) &&&\n    cs ! k \\<noteq> x &&&\n    cs ! k \\<notin> set bs &&&\n    \\<not> x < z\n           in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)", "apply(safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. k < length cs\n 2. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 3. x = cs ! k \\<Longrightarrow> False\n 4. cs ! k \\<in> set bs \\<Longrightarrow> False\n 5. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "using ki i_in_cs"], ["proof (prove)\nusing this:\n  k < i\n  i < length cs\n\ngoal (5 subgoals):\n 1. k < length cs\n 2. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 3. x = cs ! k \\<Longrightarrow> False\n 4. cs ! k \\<in> set bs \\<Longrightarrow> False\n 5. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. x = cs ! k \\<Longrightarrow> False\n 3. cs ! k \\<in> set bs \\<Longrightarrow> False\n 4. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "using z_firstocc"], ["proof (prove)\nusing this:\n  \\<forall>j<k. cs ! j \\<noteq> cs ! k\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < k; cs ! j = cs ! k\\<rbrakk> \\<Longrightarrow> False\n 2. x = cs ! k \\<Longrightarrow> False\n 3. cs ! k \\<in> set bs \\<Longrightarrow> False\n 4. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x = cs ! k \\<Longrightarrow> False\n 2. cs ! k \\<in> set bs \\<Longrightarrow> False\n 3. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "using assms(2) ki i_in_cs"], ["proof (prove)\nusing this:\n  x \\<notin> set cs\n  k < i\n  i < length cs\n\ngoal (3 subgoals):\n 1. x = cs ! k \\<Longrightarrow> False\n 2. cs ! k \\<in> set bs \\<Longrightarrow> False\n 3. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cs ! k \\<in> set bs \\<Longrightarrow> False\n 2. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "using z_notinbs"], ["proof (prove)\nusing this:\n  cs ! k \\<notin> set bs\n\ngoal (2 subgoals):\n 1. cs ! k \\<in> set bs \\<Longrightarrow> False\n 2. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "using notxbeforez"], ["proof (prove)\nusing this:\n  \\<not> x < z\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. x < z\n    in s_TS init h \\<sigma>\n        (length (as @ [x] @ bs @ [x]) + k + 1) \\<Longrightarrow>\n    False", "by auto"], ["proof (state)\nthis:\n  k < length cs\n  \\<forall>j<k. cs ! j \\<noteq> cs ! k\n  cs ! k \\<noteq> x\n  cs ! k \\<notin> set bs\n  \\<not> x < z\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> (n < length cs \\<longrightarrow>\n               (\\<forall>j<n. cs ! j \\<noteq> cs ! n) \\<longrightarrow>\n               cs ! n \\<noteq> x \\<longrightarrow>\n               cs ! n \\<notin> set bs \\<longrightarrow>\n               x < cs ! n\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + n + 1)) \\<Longrightarrow>\n       \\<exists>m<n.\n          \\<not> (m < length cs \\<longrightarrow>\n                  (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n                  cs ! m \\<noteq> x \\<longrightarrow>\n                  cs ! m \\<notin> set bs \\<longrightarrow>\n                  x < cs ! m\n                  in s_TS init h \\<sigma>\n                      (length (as @ [x] @ bs @ [x]) + m + 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m<i.\n       \\<not> (m < length cs \\<longrightarrow>\n               (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n               cs ! m \\<noteq> x \\<longrightarrow>\n               cs ! m \\<notin> set bs \\<longrightarrow>\n               x < cs ! m\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + m + 1))", "apply(simp only: ex_nat_less_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>{0..<i}.\n       \\<not> (m < length cs \\<longrightarrow>\n               (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n               cs ! m \\<noteq> x \\<longrightarrow>\n               cs ! m \\<notin> set bs \\<longrightarrow>\n               x < cs ! m\n               in s_TS init h \\<sigma>\n                   (length (as @ [x] @ bs @ [x]) + m + 1))", "apply(rule bexI[where x=k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> (k < length cs \\<longrightarrow>\n            (\\<forall>j<k. cs ! j \\<noteq> cs ! k) \\<longrightarrow>\n            cs ! k \\<noteq> x \\<longrightarrow>\n            cs ! k \\<notin> set bs \\<longrightarrow>\n            x < cs ! k\n            in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1))\n 2. k \\<in> {0..<i}", "using 1 zcsk"], ["proof (prove)\nusing this:\n  k < length cs\n  \\<forall>j<k. cs ! j \\<noteq> cs ! k\n  cs ! k \\<noteq> x\n  cs ! k \\<notin> set bs\n  \\<not> x < z\n         in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1)\n  z = cs ! k\n\ngoal (2 subgoals):\n 1. \\<not> (k < length cs \\<longrightarrow>\n            (\\<forall>j<k. cs ! j \\<noteq> cs ! k) \\<longrightarrow>\n            cs ! k \\<noteq> x \\<longrightarrow>\n            cs ! k \\<notin> set bs \\<longrightarrow>\n            x < cs ! k\n            in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + k + 1))\n 2. k \\<in> {0..<i}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> {0..<i}", "using ki"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. k \\<in> {0..<i}", "by simp"], ["proof (state)\nthis:\n  \\<exists>m<i.\n     \\<not> (m < length cs \\<longrightarrow>\n             (\\<forall>j<m. cs ! j \\<noteq> cs ! m) \\<longrightarrow>\n             cs ! m \\<noteq> x \\<longrightarrow>\n             cs ! m \\<notin> set bs \\<longrightarrow>\n             x < cs ! m\n             in s_TS init h \\<sigma> (length (as @ [x] @ bs @ [x]) + m + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nopaid: \"snd (fst (TS_step_d s q)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (TS_step_d s q)) = []", "unfolding TS_step_d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst ((let li = index (snd s) q\n               in if li = length (snd s) then 0\n                  else let sincelast = take li (snd s);\n                           S = {x. x < q in fst s \\<and>\n                                   count_list sincelast x \\<le> 1}\n                       in if S = {} then 0\n                          else index (fst s) q - Min (index (fst s) ` S),\n               []),\n              q # snd s)) =\n    []", "by simp"], ["", "lemma staysuntouched:\n   assumes d[simp]: \"distinct (fst S)\"\n    and x: \"x \\<in> set (fst S)\"\n    and y: \"y \\<in> set (fst S)\" \n   shows \"set qs \\<subseteq> set (fst S) \\<Longrightarrow> x \\<notin> set qs \\<Longrightarrow> y \\<notin> set qs\n        \\<Longrightarrow> x < y in fst (config' (rTS []) S qs) =  x < y in fst S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set (fst S); x \\<notin> set qs;\n     y \\<notin> set qs\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S qs) =\n                      x < y in fst S", "proof(induct qs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> set (fst S); x \\<notin> set xs;\n                 y \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> x < y\n                                  in fst\n(Partial_Cost_Model.config' (rTS []) S xs) =\n                                  x < y in fst S;\n        set (xs @ [xa]) \\<subseteq> set (fst S); x \\<notin> set (xs @ [xa]);\n        y \\<notin> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x < y\n                         in fst (Partial_Cost_Model.config' (rTS []) S\n                                  (xs @ [xa])) =\n                         x < y in fst S", "case (snoc q qs)"], ["proof (state)\nthis:\n  \\<lbrakk>set qs \\<subseteq> set (fst S); x \\<notin> set qs;\n   y \\<notin> set qs\\<rbrakk>\n  \\<Longrightarrow> x < y\n                    in fst (Partial_Cost_Model.config' (rTS []) S qs) =\n                    x < y in fst S\n  set (qs @ [q]) \\<subseteq> set (fst S)\n  x \\<notin> set (qs @ [q])\n  y \\<notin> set (qs @ [q])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> set (fst S); x \\<notin> set xs;\n                 y \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> x < y\n                                  in fst\n(Partial_Cost_Model.config' (rTS []) S xs) =\n                                  x < y in fst S;\n        set (xs @ [xa]) \\<subseteq> set (fst S); x \\<notin> set (xs @ [xa]);\n        y \\<notin> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x < y\n                         in fst (Partial_Cost_Model.config' (rTS []) S\n                                  (xs @ [xa])) =\n                         x < y in fst S", "have \"x < y in fst (config' (rTS []) S (qs @ [q])) =\n          x < y in fst (config' (rTS []) S qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n    x < y in fst (Partial_Cost_Model.config' (rTS []) S qs)", "apply(simp add: config'_snoc Step_def split_def step_def rTS_def nopaid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in mtf2\n        (fst (fst (TS_step_d\n                    (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      S qs)\n                    q)))\n        q (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) S\n                 qs)) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) S qs)", "apply(rule xy_relativorder_mtf2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. q \\<noteq> x\n 2. q \\<noteq> y\n 3. distinct\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) S qs))\n 4. x \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))\n 5. y \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))\n 6. q \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>set qs \\<subseteq> set (fst S); x \\<notin> set qs;\n   y \\<notin> set qs\\<rbrakk>\n  \\<Longrightarrow> x < y\n                    in fst (Partial_Cost_Model.config' (rTS []) S qs) =\n                    x < y in fst S\n  set (qs @ [q]) \\<subseteq> set (fst S)\n  x \\<notin> set (qs @ [q])\n  y \\<notin> set (qs @ [q])\n\ngoal (6 subgoals):\n 1. q \\<noteq> x\n 2. q \\<noteq> y\n 3. distinct\n     (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) S qs))\n 4. x \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))\n 5. y \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))\n 6. q \\<in> set (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                       S qs))", "by(simp_all add: x y )"], ["proof (state)\nthis:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S qs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> set (fst S); x \\<notin> set xs;\n                 y \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> x < y\n                                  in fst\n(Partial_Cost_Model.config' (rTS []) S xs) =\n                                  x < y in fst S;\n        set (xs @ [xa]) \\<subseteq> set (fst S); x \\<notin> set (xs @ [xa]);\n        y \\<notin> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x < y\n                         in fst (Partial_Cost_Model.config' (rTS []) S\n                                  (xs @ [xa])) =\n                         x < y in fst S", "also"], ["proof (state)\nthis:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S qs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> set (fst S); x \\<notin> set xs;\n                 y \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> x < y\n                                  in fst\n(Partial_Cost_Model.config' (rTS []) S xs) =\n                                  x < y in fst S;\n        set (xs @ [xa]) \\<subseteq> set (fst S); x \\<notin> set (xs @ [xa]);\n        y \\<notin> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x < y\n                         in fst (Partial_Cost_Model.config' (rTS []) S\n                                  (xs @ [xa])) =\n                         x < y in fst S", "have \"\\<dots> = x < y in fst S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (Partial_Cost_Model.config' (rTS []) S qs) = x < y in fst S", "apply(rule snoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set qs \\<subseteq> set (fst S)\n 2. x \\<notin> set qs\n 3. y \\<notin> set qs", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>set qs \\<subseteq> set (fst S); x \\<notin> set qs;\n   y \\<notin> set qs\\<rbrakk>\n  \\<Longrightarrow> x < y\n                    in fst (Partial_Cost_Model.config' (rTS []) S qs) =\n                    x < y in fst S\n  set (qs @ [q]) \\<subseteq> set (fst S)\n  x \\<notin> set (qs @ [q])\n  y \\<notin> set (qs @ [q])\n\ngoal (3 subgoals):\n 1. set qs \\<subseteq> set (fst S)\n 2. x \\<notin> set qs\n 3. y \\<notin> set qs", "by simp_all"], ["proof (state)\nthis:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S qs) = x < y in fst S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> set (fst S); x \\<notin> set xs;\n                 y \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> x < y\n                                  in fst\n(Partial_Cost_Model.config' (rTS []) S xs) =\n                                  x < y in fst S;\n        set (xs @ [xa]) \\<subseteq> set (fst S); x \\<notin> set (xs @ [xa]);\n        y \\<notin> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x < y\n                         in fst (Partial_Cost_Model.config' (rTS []) S\n                                  (xs @ [xa])) =\n                         x < y in fst S", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n  x < y in fst S", "show ?case"], ["proof (prove)\nusing this:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n  x < y in fst S\n\ngoal (1 subgoal):\n 1. x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n    x < y in fst S", "."], ["proof (state)\nthis:\n  x < y in fst (Partial_Cost_Model.config' (rTS []) S (qs @ [q])) =\n  x < y in fst S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set [] \\<subseteq> set (fst S); x \\<notin> set [];\n     y \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in fst (Partial_Cost_Model.config' (rTS []) S []) =\n                      x < y in fst S", "qed simp"], ["", "lemma staysuntouched':\n   assumes d[simp]: \"distinct init\"\n    and x: \"x \\<in> set init\"\n    and y: \"y \\<in> set init\"\n    and \"set qs \\<subseteq> set init\"\n    and \"x \\<notin> set qs\" and \"y \\<notin> set qs\"\n   shows \"x < y in fst (config (rTS []) init qs) =  x < y in init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "let ?S=\"(init, fst (rTS []) init)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "have \"x < y in fst (config' (rTS []) ?S qs) =  x < y in fst ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (init, fst (rTS []) init)", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct (fst (init, fst (rTS []) init))\n 2. x \\<in> set (fst (init, fst (rTS []) init))\n 3. y \\<in> set (fst (init, fst (rTS []) init))\n 4. set qs \\<subseteq> set (fst (init, fst (rTS []) init))\n 5. x \\<notin> set qs\n 6. y \\<notin> set qs", "using assms"], ["proof (prove)\nusing this:\n  distinct init\n  x \\<in> set init\n  y \\<in> set init\n  set qs \\<subseteq> set init\n  x \\<notin> set qs\n  y \\<notin> set qs\n\ngoal (6 subgoals):\n 1. distinct (fst (init, fst (rTS []) init))\n 2. x \\<in> set (fst (init, fst (rTS []) init))\n 3. y \\<in> set (fst (init, fst (rTS []) init))\n 4. set qs \\<subseteq> set (fst (init, fst (rTS []) init))\n 5. x \\<notin> set qs\n 6. y \\<notin> set qs", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (init, fst (rTS []) init)\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "then"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (init, fst (rTS []) init)", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (init, fst (rTS []) init)\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "by simp"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma projEmpty: \"Lxy qs S = [] \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lxy qs S = []; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set qs", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>z. z \\<in> S) qs = []; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set qs", "by (metis filter_empty_conv)"], ["", "lemma Lxy_index_mono:\n  assumes \"x\\<in>S\" \"y\\<in>S\"\n    and \"index xs x < index xs y\"\n    and \"index xs y < length xs\"\n    and \"x\\<noteq>y\"\n  shows \"index (Lxy xs S) x < index (Lxy xs S) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> S\n  y \\<in> S\n  index xs x < index xs y\n  index xs y < length xs\n  x \\<noteq> y", "have ij: \"index xs x < index xs y\"\n        and xinxs: \"index xs x < length xs\"\n        and yinxs: \"index xs y < length xs\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  y \\<in> S\n  index xs x < index xs y\n  index xs y < length xs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&&\n    index xs x < length xs &&& index xs y < length xs", "by auto"], ["proof (state)\nthis:\n  index xs x < index xs y\n  index xs x < length xs\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "then"], ["proof (chain)\npicking this:\n  index xs x < index xs y\n  index xs x < length xs\n  index xs y < length xs", "have inset: \"x\\<in>set xs\" \"y\\<in>set xs\""], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs x < length xs\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs &&& y \\<in> set xs", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs x < length xs\n  index xs y < length xs\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs &&& y \\<in> set xs", "by fast+"], ["proof (state)\nthis:\n  x \\<in> set xs\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "from xinxs"], ["proof (chain)\npicking this:\n  index xs x < length xs", "obtain a as where dec1: \"a @ [xs!index xs x] @ as = xs\"\n        and a: \"a = take (index xs x) xs\" and \"as = drop (Suc (index xs x)) xs\"\n        and length_a: \"length a = index xs x\" and length_as: \"length as = length xs - index xs x- 1\""], ["proof (prove)\nusing this:\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! index xs x] @ as = xs; a = take (index xs x) xs;\n         as = drop (Suc (index xs x)) xs; length a = index xs x;\n         length as = length xs - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  index xs x < length xs\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! index xs x] @ as = xs; a = take (index xs x) xs;\n         as = drop (Suc (index xs x)) xs; length a = index xs x;\n         length as = length xs - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a @ [xs ! index xs x] @ as = xs\n  a = take (index xs x) xs\n  as = drop (Suc (index xs x)) xs\n  length a = index xs x\n  length as = length xs - index xs x - 1\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"index xs y\\<ge>length (a @ [xs!index xs x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a @ [xs ! index xs x]) \\<le> index xs y", "using length_a ij"], ["proof (prove)\nusing this:\n  length a = index xs x\n  index xs x < index xs y\n\ngoal (1 subgoal):\n 1. length (a @ [xs ! index xs x]) \\<le> index xs y", "by auto"], ["proof (state)\nthis:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "then"], ["proof (chain)\npicking this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y", "have \"((a @ [xs!index xs x]) @ as) ! index xs y = as ! (index xs y-length (a @ [xs ! index xs x]))\""], ["proof (prove)\nusing this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! index xs x]) @ as) ! index xs y =\n    as ! (index xs y - length (a @ [xs ! index xs x]))", "using nth_append[where xs=\"a @ [xs!index xs x]\" and ys=\"as\"]"], ["proof (prove)\nusing this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n  ((a @ [xs ! index xs x]) @ as) ! ?n =\n  (if ?n < length (a @ [xs ! index xs x]) then (a @ [xs ! index xs x]) ! ?n\n   else as ! (?n - length (a @ [xs ! index xs x])))\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! index xs x]) @ as) ! index xs y =\n    as ! (index xs y - length (a @ [xs ! index xs x]))", "by(simp)"], ["proof (state)\nthis:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "then"], ["proof (chain)\npicking this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))", "have xsj: \"xs ! index xs y = as ! (index xs y-index xs x-1)\""], ["proof (prove)\nusing this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n\ngoal (1 subgoal):\n 1. xs ! index xs y = as ! (index xs y - index xs x - 1)", "using dec1 length_a"], ["proof (prove)\nusing this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n  a @ [xs ! index xs x] @ as = xs\n  length a = index xs x\n\ngoal (1 subgoal):\n 1. xs ! index xs y = as ! (index xs y - index xs x - 1)", "by auto"], ["proof (state)\nthis:\n  xs ! index xs y = as ! (index xs y - index xs x - 1)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have las: \"(index xs y-index xs x-1) < length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs y - index xs x - 1 < length as", "using length_as yinxs ij"], ["proof (prove)\nusing this:\n  length as = length xs - index xs x - 1\n  index xs y < length xs\n  index xs x < index xs y\n\ngoal (1 subgoal):\n 1. index xs y - index xs x - 1 < length as", "by simp"], ["proof (state)\nthis:\n  index xs y - index xs x - 1 < length as\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "obtain b c where dec2: \"b @ [xs!index xs y] @ c = as\"\n            and \"b = take (index xs y-index xs x-1) as\" \"c=drop (Suc (index xs y-index xs x-1)) as\"\n            and length_b: \"length b = index xs y-index xs x-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! index xs y] @ c = as;\n         b = take (index xs y - index xs x - 1) as;\n         c = drop (Suc (index xs y - index xs x - 1)) as;\n         length b = index xs y - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop[OF las] xsj"], ["proof (prove)\nusing this:\n  as =\n  take (index xs y - index xs x - 1) as @\n  as ! (index xs y - index xs x - 1) #\n  drop (Suc (index xs y - index xs x - 1)) as\n  xs ! index xs y = as ! (index xs y - index xs x - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! index xs y] @ c = as;\n         b = take (index xs y - index xs x - 1) as;\n         c = drop (Suc (index xs y - index xs x - 1)) as;\n         length b = index xs y - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  b @ [xs ! index xs y] @ c = as\n  b = take (index xs y - index xs x - 1) as\n  c = drop (Suc (index xs y - index xs x - 1)) as\n  length b = index xs y - index xs x - 1\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have xs_dec: \"a @ [xs!index xs x] @ b @ [xs!index xs y] @ c = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs", "using dec1 dec2"], ["proof (prove)\nusing this:\n  a @ [xs ! index xs x] @ as = xs\n  b @ [xs ! index xs y] @ c = as\n\ngoal (1 subgoal):\n 1. a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs", "by auto"], ["proof (state)\nthis:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "then"], ["proof (chain)\npicking this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs", "have \"Lxy xs S = Lxy (a @ [xs!index xs x] @ b @ [xs!index xs y] @ c) S\""], ["proof (prove)\nusing this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n\ngoal (1 subgoal):\n 1. Lxy xs S = Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) S", "by(simp add: xs_dec)"], ["proof (state)\nthis:\n  Lxy xs S = Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) S\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "also"], ["proof (state)\nthis:\n  Lxy xs S = Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) S\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"\\<dots> = Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) S =\n    Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S", "by(simp add: Lxy_append Lxy_def assms inset)"], ["proof (state)\nthis:\n  Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) S =\n  Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "finally"], ["proof (chain)\npicking this:\n  Lxy xs S = Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S", "have gr: \"Lxy xs S = Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S\""], ["proof (prove)\nusing this:\n  Lxy xs S = Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S\n\ngoal (1 subgoal):\n 1. Lxy xs S = Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S", "using assms"], ["proof (prove)\nusing this:\n  Lxy xs S = Lxy a S @ Lxy [x] S @ Lxy b S @ Lxy [y] S @ Lxy c S\n  x \\<in> S\n  y \\<in> S\n  index xs x < index xs y\n  index xs y < length xs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Lxy xs S = Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S", "by(simp add: Lxy_def)"], ["proof (state)\nthis:\n  Lxy xs S = Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"y \\<notin> set (take (index xs x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> set (take (index xs x) xs)", "apply(rule index_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> S\n  y \\<in> S\n  index xs x < index xs y\n  index xs y < length xs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "by simp"], ["proof (state)\nthis:\n  y \\<notin> set (take (index xs x) xs)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "then"], ["proof (chain)\npicking this:\n  y \\<notin> set (take (index xs x) xs)", "have \"y \\<notin>  set (Lxy (take (index xs x) xs) S )\""], ["proof (prove)\nusing this:\n  y \\<notin> set (take (index xs x) xs)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (Lxy (take (index xs x) xs) S)", "apply(subst Lxy_set_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> set (take (index xs x) xs) \\<Longrightarrow>\n    y \\<notin> S \\<inter> set (take (index xs x) xs)", "by blast"], ["proof (state)\nthis:\n  y \\<notin> set (Lxy (take (index xs x) xs) S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "with a"], ["proof (chain)\npicking this:\n  a = take (index xs x) xs\n  y \\<notin> set (Lxy (take (index xs x) xs) S)", "have ynot: \"y \\<notin> set (Lxy a S)\""], ["proof (prove)\nusing this:\n  a = take (index xs x) xs\n  y \\<notin> set (Lxy (take (index xs x) xs) S)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (Lxy a S)", "by simp"], ["proof (state)\nthis:\n  y \\<notin> set (Lxy a S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"index (Lxy xs S) y =\n          index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy xs S) y = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y", "by(simp add: gr)"], ["proof (state)\nthis:\n  index (Lxy xs S) y = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "also"], ["proof (state)\nthis:\n  index (Lxy xs S) y = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"\\<dots> \\<ge> length (Lxy a S) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy a S) + 1\n    \\<le> index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y", "using assms(5) ynot"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  y \\<notin> set (Lxy a S)\n\ngoal (1 subgoal):\n 1. length (Lxy a S) + 1\n    \\<le> index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y", "by(simp add: index_append)"], ["proof (state)\nthis:\n  length (Lxy a S) + 1\n  \\<le> index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) y\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "finally"], ["proof (chain)\npicking this:\n  length (Lxy a S) + 1 \\<le> index (Lxy xs S) y", "have 1: \"index (Lxy xs S) y \\<ge> length (Lxy a S) + 1\""], ["proof (prove)\nusing this:\n  length (Lxy a S) + 1 \\<le> index (Lxy xs S) y\n\ngoal (1 subgoal):\n 1. length (Lxy a S) + 1 \\<le> index (Lxy xs S) y", "."], ["proof (state)\nthis:\n  length (Lxy a S) + 1 \\<le> index (Lxy xs S) y\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"index (Lxy xs S) x = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy xs S) x = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x", "by (simp add: gr)"], ["proof (state)\nthis:\n  index (Lxy xs S) x = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "also"], ["proof (state)\nthis:\n  index (Lxy xs S) x = index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "have \"\\<dots> \\<le>  length (Lxy a S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x \\<le> length (Lxy a S)", "apply(simp add: index_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (Lxy a S) \\<longrightarrow>\n    index (Lxy a S) x \\<le> length (Lxy a S)", "apply(subst index_less_size_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy a S) x < length (Lxy a S) \\<longrightarrow>\n    index (Lxy a S) x \\<le> length (Lxy a S)", "by simp"], ["proof (state)\nthis:\n  index (Lxy a S @ [x] @ Lxy b S @ [y] @ Lxy c S) x \\<le> length (Lxy a S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "finally"], ["proof (chain)\npicking this:\n  index (Lxy xs S) x \\<le> length (Lxy a S)", "have 2: \"index (Lxy xs S) x \\<le> length (Lxy a S)\""], ["proof (prove)\nusing this:\n  index (Lxy xs S) x \\<le> length (Lxy a S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x \\<le> length (Lxy a S)", "."], ["proof (state)\nthis:\n  index (Lxy xs S) x \\<le> length (Lxy a S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "from 1 2"], ["proof (chain)\npicking this:\n  length (Lxy a S) + 1 \\<le> index (Lxy xs S) y\n  index (Lxy xs S) x \\<le> length (Lxy a S)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (Lxy a S) + 1 \\<le> index (Lxy xs S) y\n  index (Lxy xs S) x \\<le> length (Lxy a S)\n\ngoal (1 subgoal):\n 1. index (Lxy xs S) x < index (Lxy xs S) y", "by linarith"], ["proof (state)\nthis:\n  index (Lxy xs S) x < index (Lxy xs S) y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_Cons: \n  assumes filterd_cons: \"Lxy qs S = a#as\"\n    and a_filter: \"a\\<in>S\"\n  obtains pre suf where \"qs = pre @ [a] @ suf\" and \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre\"\n                  and \"Lxy suf S = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set (Lxy qs S) \\<subseteq> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs S) \\<subseteq> set qs", "using Lxy_set_filter"], ["proof (prove)\nusing this:\n  set (Lxy ?xs ?S) = ?S \\<inter> set ?xs\n\ngoal (1 subgoal):\n 1. set (Lxy qs S) \\<subseteq> set qs", "by fast"], ["proof (state)\nthis:\n  set (Lxy qs S) \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with filterd_cons"], ["proof (chain)\npicking this:\n  Lxy qs S = a # as\n  set (Lxy qs S) \\<subseteq> set qs", "have a_inq: \"a \\<in> set qs\""], ["proof (prove)\nusing this:\n  Lxy qs S = a # as\n  set (Lxy qs S) \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. a \\<in> set qs", "by simp"], ["proof (state)\nthis:\n  a \\<in> set qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  a \\<in> set qs", "have \"index qs a < length qs\""], ["proof (prove)\nusing this:\n  a \\<in> set qs\n\ngoal (1 subgoal):\n 1. index qs a < length qs", "by(simp)"], ["proof (state)\nthis:\n  index qs a < length qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  index qs a < length qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume eS:\"e\\<in>S\""], ["proof (state)\nthis:\n  e \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"e\\<noteq>a\""], ["proof (state)\nthis:\n  e \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"index qs a \\<le> index qs e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index qs a \\<le> index qs e", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> index qs a \\<le> index qs e \\<Longrightarrow> False", "assume \"\\<not> index qs a \\<le> index qs e\""], ["proof (state)\nthis:\n  \\<not> index qs a \\<le> index qs e\n\ngoal (1 subgoal):\n 1. \\<not> index qs a \\<le> index qs e \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> index qs a \\<le> index qs e", "have 1: \"index qs e < index qs a\""], ["proof (prove)\nusing this:\n  \\<not> index qs a \\<le> index qs e\n\ngoal (1 subgoal):\n 1. index qs e < index qs a", "by simp"], ["proof (state)\nthis:\n  index qs e < index qs a\n\ngoal (1 subgoal):\n 1. \\<not> index qs a \\<le> index qs e \\<Longrightarrow> False", "have 0: \"index (Lxy qs S) a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy qs S) a = 0", "unfolding filterd_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (a # as) a = 0", "by simp"], ["proof (state)\nthis:\n  index (Lxy qs S) a = 0\n\ngoal (1 subgoal):\n 1. \\<not> index qs a \\<le> index qs e \\<Longrightarrow> False", "have 2: \"index (Lxy qs S) e < index (Lxy qs S) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy qs S) e < index (Lxy qs S) a", "apply(rule Lxy_index_mono)"], ["proof (prove)\ngoal (5 subgoals):\n 1. e \\<in> S\n 2. a \\<in> S\n 3. index qs e < index qs a\n 4. index qs a < length qs\n 5. e \\<noteq> a", "by(fact)+"], ["proof (state)\nthis:\n  index (Lxy qs S) e < index (Lxy qs S) a\n\ngoal (1 subgoal):\n 1. \\<not> index qs a \\<le> index qs e \\<Longrightarrow> False", "from 0 2"], ["proof (chain)\npicking this:\n  index (Lxy qs S) a = 0\n  index (Lxy qs S) e < index (Lxy qs S) a", "show \"False\""], ["proof (prove)\nusing this:\n  index (Lxy qs S) a = 0\n  index (Lxy qs S) e < index (Lxy qs S) a\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index qs a \\<le> index qs e\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?e2 \\<in> S; ?e2 \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> index qs a \\<le> index qs ?e2\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note atfront=this"], ["proof (state)\nthis:\n  \\<lbrakk>?e2 \\<in> S; ?e2 \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> index qs a \\<le> index qs ?e2\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?lastInd=\"index qs a\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"qs = take ?lastInd qs @ qs!?lastInd # drop (Suc ?lastInd) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs = take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index qs a < length qs", "using a_inq"], ["proof (prove)\nusing this:\n  a \\<in> set qs\n\ngoal (1 subgoal):\n 1. index qs a < length qs", "by simp"], ["proof (state)\nthis:\n  qs = take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  qs = take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = take ?lastInd qs @ [a] @ drop (Suc ?lastInd) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs =\n    take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs", "using a_inq"], ["proof (prove)\nusing this:\n  a \\<in> set qs\n\ngoal (1 subgoal):\n 1. take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs =\n    take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs", "by simp"], ["proof (state)\nthis:\n  take (index qs a) qs @ qs ! index qs a # drop (Suc (index qs a)) qs =\n  take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs", "have split: \"qs = take ?lastInd qs @ [a] @ drop (Suc ?lastInd) qs\""], ["proof (prove)\nusing this:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs", "."], ["proof (state)\nthis:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have nothingin: \"\\<And>s. s\\<in>S \\<Longrightarrow> s \\<notin> set (take ?lastInd qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow> s \\<notin> set (take (index qs a) qs)", "apply(rule index_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> index qs a \\<le> index qs s", "apply(case_tac \"a=s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; a = s\\<rbrakk>\n       \\<Longrightarrow> index qs a \\<le> index qs s\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; a \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> index qs a \\<le> index qs s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; a \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> index qs a \\<le> index qs s", "by (rule atfront) simp_all"], ["proof (state)\nthis:\n  ?s \\<in> S \\<Longrightarrow> ?s \\<notin> set (take (index qs a) qs)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?s \\<in> S \\<Longrightarrow> ?s \\<notin> set (take (index qs a) qs)", "have \"set (Lxy (take ?lastInd qs) S) = {}\""], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> ?s \\<notin> set (take (index qs a) qs)\n\ngoal (1 subgoal):\n 1. set (Lxy (take (index qs a) qs) S) = {}", "apply(subst Lxy_set_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> S \\<Longrightarrow>\n        s \\<notin> set (take (index qs a) qs)) \\<Longrightarrow>\n    S \\<inter> set (take (index qs a) qs) = {}", "by blast"], ["proof (state)\nthis:\n  set (Lxy (take (index qs a) qs) S) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  set (Lxy (take (index qs a) qs) S) = {}", "have emptyPre: \"Lxy (take ?lastInd qs) S = []\""], ["proof (prove)\nusing this:\n  set (Lxy (take (index qs a) qs) S) = {}\n\ngoal (1 subgoal):\n 1. Lxy (take (index qs a) qs) S = []", "by blast"], ["proof (state)\nthis:\n  Lxy (take (index qs a) qs) S = []\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a#as = Lxy qs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # as = Lxy qs S", "using filterd_cons"], ["proof (prove)\nusing this:\n  Lxy qs S = a # as\n\ngoal (1 subgoal):\n 1. a # as = Lxy qs S", "by simp"], ["proof (state)\nthis:\n  a # as = Lxy qs S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  a # as = Lxy qs S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = Lxy (take ?lastInd qs @ [a] @ drop (Suc ?lastInd) qs) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy qs S =\n    Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S", "using split"], ["proof (prove)\nusing this:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n\ngoal (1 subgoal):\n 1. Lxy qs S =\n    Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S", "by simp"], ["proof (state)\nthis:\n  Lxy qs S = Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  Lxy qs S = Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = Lxy (take ?lastInd qs) S @ (Lxy [a] S) @ Lxy (drop (Suc ?lastInd) qs) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S =\n    Lxy (take (index qs a) qs) S @\n    Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S", "by(simp add: Lxy_append Lxy_def)"], ["proof (state)\nthis:\n  Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S =\n  Lxy (take (index qs a) qs) S @\n  Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  Lxy (take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs) S =\n  Lxy (take (index qs a) qs) S @\n  Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = a#Lxy (drop (Suc ?lastInd) qs) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (take (index qs a) qs) S @\n    Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S =\n    a # Lxy (drop (Suc (index qs a)) qs) S", "unfolding emptyPre"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] @ Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S =\n    a # Lxy (drop (Suc (index qs a)) qs) S", "by(simp add: Lxy_def a_filter)"], ["proof (state)\nthis:\n  Lxy (take (index qs a) qs) S @\n  Lxy [a] S @ Lxy (drop (Suc (index qs a)) qs) S =\n  a # Lxy (drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  a # as = a # Lxy (drop (Suc (index qs a)) qs) S", "have suf: \"Lxy (drop (Suc ?lastInd) qs) S = as\""], ["proof (prove)\nusing this:\n  a # as = a # Lxy (drop (Suc (index qs a)) qs) S\n\ngoal (1 subgoal):\n 1. Lxy (drop (Suc (index qs a)) qs) S = as", "by simp"], ["proof (state)\nthis:\n  Lxy (drop (Suc (index qs a)) qs) S = as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre;\n         Lxy suf S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from split nothingin suf"], ["proof (chain)\npicking this:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n  ?s \\<in> S \\<Longrightarrow> ?s \\<notin> set (take (index qs a) qs)\n  Lxy (drop (Suc (index qs a)) qs) S = as", "show ?thesis"], ["proof (prove)\nusing this:\n  qs = take (index qs a) qs @ [a] @ drop (Suc (index qs a)) qs\n  ?s \\<in> S \\<Longrightarrow> ?s \\<notin> set (take (index qs a) qs)\n  Lxy (drop (Suc (index qs a)) qs) S = as\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lxy_rev: \"rev (Lxy qs S) = Lxy (rev qs) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (Lxy qs S) = Lxy (rev qs) S", "apply(induct qs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rev (Lxy [] S) = Lxy (rev []) S\n 2. \\<And>a qs.\n       rev (Lxy qs S) = Lxy (rev qs) S \\<Longrightarrow>\n       rev (Lxy (a # qs) S) = Lxy (rev (a # qs)) S", "by(simp_all add: Lxy_def)"], ["", "lemma proj_Snoc: \n  assumes filterd_cons: \"Lxy qs S = as@[a]\"\n    and a_filter: \"a\\<in>S\"\n  obtains pre suf where \"qs = pre @ [a] @ suf\" and \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf\"\n                  and \"Lxy pre S = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Lxy (rev qs) S = rev (Lxy qs S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (rev qs) S = rev (Lxy qs S)", "by(simp add: Lxy_rev)"], ["proof (state)\nthis:\n  Lxy (rev qs) S = rev (Lxy qs S)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  Lxy (rev qs) S = rev (Lxy qs S)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = a#(rev as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (Lxy qs S) = a # rev as", "unfolding filterd_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (as @ [a]) = a # rev as", "by simp"], ["proof (state)\nthis:\n  rev (Lxy qs S) = a # rev as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  Lxy (rev qs) S = a # rev as", "have \"Lxy (rev qs) S = a # (rev as)\""], ["proof (prove)\nusing this:\n  Lxy (rev qs) S = a # rev as\n\ngoal (1 subgoal):\n 1. Lxy (rev qs) S = a # rev as", "."], ["proof (state)\nthis:\n  Lxy (rev qs) S = a # rev as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with a_filter"], ["proof (chain)\npicking this:\n  a \\<in> S\n  Lxy (rev qs) S = a # rev as", "obtain pre' suf' where 1: \"rev qs = pre' @[a] @ suf'\"\n          and 2: \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre'\"\n          and 3: \"Lxy suf' S = rev as\""], ["proof (prove)\nusing this:\n  a \\<in> S\n  Lxy (rev qs) S = a # rev as\n\ngoal (1 subgoal):\n 1. (\\<And>pre' suf'.\n        \\<lbrakk>rev qs = pre' @ [a] @ suf';\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre';\n         Lxy suf' S = rev as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using proj_Cons"], ["proof (prove)\nusing this:\n  a \\<in> S\n  Lxy (rev qs) S = a # rev as\n  \\<lbrakk>Lxy ?qs ?S = ?a # ?as; ?a \\<in> ?S;\n   \\<And>pre suf.\n      \\<lbrakk>?qs = pre @ [?a] @ suf;\n       \\<And>x. x \\<in> ?S \\<Longrightarrow> x \\<notin> set pre;\n       Lxy suf ?S = ?as\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pre' suf'.\n        \\<lbrakk>rev qs = pre' @ [a] @ suf';\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set pre';\n         Lxy suf' S = rev as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  rev qs = pre' @ [a] @ suf'\n  ?x \\<in> S \\<Longrightarrow> ?x \\<notin> set pre'\n  Lxy suf' S = rev as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"qs = rev (rev qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs = rev (rev qs)", "by simp"], ["proof (state)\nthis:\n  qs = rev (rev qs)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  qs = rev (rev qs)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = rev suf' @ [a] @ rev pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (rev qs) = rev suf' @ [a] @ rev pre'", "using 1"], ["proof (prove)\nusing this:\n  rev qs = pre' @ [a] @ suf'\n\ngoal (1 subgoal):\n 1. rev (rev qs) = rev suf' @ [a] @ rev pre'", "by simp"], ["proof (state)\nthis:\n  rev (rev qs) = rev suf' @ [a] @ rev pre'\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  qs = rev suf' @ [a] @ rev pre'", "have a1: \"qs = rev suf' @ [a] @ rev pre'\""], ["proof (prove)\nusing this:\n  qs = rev suf' @ [a] @ rev pre'\n\ngoal (1 subgoal):\n 1. qs = rev suf' @ [a] @ rev pre'", "."], ["proof (state)\nthis:\n  qs = rev suf' @ [a] @ rev pre'\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Lxy (rev suf') S = rev (Lxy suf' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (rev suf') S = rev (Lxy suf' S)", "by(simp add: Lxy_rev)"], ["proof (state)\nthis:\n  Lxy (rev suf') S = rev (Lxy suf' S)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  Lxy (rev suf') S = rev (Lxy suf' S)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (Lxy suf' S) = as", "using 3"], ["proof (prove)\nusing this:\n  Lxy suf' S = rev as\n\ngoal (1 subgoal):\n 1. rev (Lxy suf' S) = as", "by simp"], ["proof (state)\nthis:\n  rev (Lxy suf' S) = as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  Lxy (rev suf') S = as", "have a3: \"Lxy (rev suf') S = as\""], ["proof (prove)\nusing this:\n  Lxy (rev suf') S = as\n\ngoal (1 subgoal):\n 1. Lxy (rev suf') S = as", "."], ["proof (state)\nthis:\n  Lxy (rev suf') S = as\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have a2: \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set (rev pre')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set (rev pre')", "using 2"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> ?x \\<notin> set pre'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set (rev pre')", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> ?x \\<notin> set (rev pre')\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>x. x \\<in> S \\<Longrightarrow> x \\<notin> set suf;\n         Lxy pre S = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from a1 a2 a3"], ["proof (chain)\npicking this:\n  qs = rev suf' @ [a] @ rev pre'\n  ?x \\<in> S \\<Longrightarrow> ?x \\<notin> set (rev pre')\n  Lxy (rev suf') S = as", "show ?thesis"], ["proof (prove)\nusing this:\n  qs = rev suf' @ [a] @ rev pre'\n  ?x \\<in> S \\<Longrightarrow> ?x \\<notin> set (rev pre')\n  Lxy (rev suf') S = as\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sndTSconfig': \"snd (config' (rTS initH) (init,[]) qs) = rev qs @ []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Partial_Cost_Model.config' (rTS initH) (init, []) qs) = rev qs @ []", "apply(induct qs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (Partial_Cost_Model.config' (rTS initH) (init, []) []) = rev [] @ []\n 2. \\<And>x xs.\n       snd (Partial_Cost_Model.config' (rTS initH) (init, []) xs) =\n       rev xs @ [] \\<Longrightarrow>\n       snd (Partial_Cost_Model.config' (rTS initH) (init, []) (xs @ [x])) =\n       rev (xs @ [x]) @ []", "apply(simp add: rTS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       snd (Partial_Cost_Model.config' (rTS initH) (init, []) xs) =\n       rev xs @ [] \\<Longrightarrow>\n       snd (Partial_Cost_Model.config' (rTS initH) (init, []) (xs @ [x])) =\n       rev (xs @ [x]) @ []", "by(simp add: split_def TS_step_d_def config'_snoc Step_def rTS_def)"], ["", "lemma projxx: \n  fixes e a bs\n  assumes axy: \"a\\<in>{x,y}\"\n  assumes ane: \"a\\<noteq>e\"\n  assumes exy: \"e\\<in>{x,y}\"\n  assumes add: \"f\\<in>{[],[e]}\" \n  assumes bsaxy: \"set (bs @ [a] @ f) \\<subseteq> {x,y}\"\n  assumes Lxyinitxy: \"Lxy init {x, y} \\<in> {[x,y],[y,x]}\"\n  shows \"a < e in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ f) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "have aexy: \"{a,e}={x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, e} = {x, y}", "using exy axy ane"], ["proof (prove)\nusing this:\n  e \\<in> {x, y}\n  a \\<in> {x, y}\n  a \\<noteq> e\n\ngoal (1 subgoal):\n 1. {a, e} = {x, y}", "by blast"], ["proof (state)\nthis:\n  {a, e} = {x, y}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "let ?h=\"snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                          (Lxy init {x, y}, []) (bs @ a # f))\""], ["proof (state)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "have history: \"?h = (rev f)@a#(rev bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n          (Lxy init {x, y}, []) (bs @ a # f)) =\n    rev f @ a # rev bs", "using sndTSdet[of \"length (bs@a#f)\" \"bs@a#f\", unfolded rTS_def]"], ["proof (prove)\nusing this:\n  length (bs @ a # f) \\<le> length (bs @ a # f) \\<Longrightarrow>\n  snd (config\\<^sub>p (\\<lambda>s. ?initH, TS_step_d) ?init\n        (take (length (bs @ a # f)) (bs @ a # f))) =\n  rev (take (length (bs @ a # f)) (bs @ a # f)) @ ?initH\n\ngoal (1 subgoal):\n 1. snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n          (Lxy init {x, y}, []) (bs @ a # f)) =\n    rev f @ a # rev bs", "by(simp)"], ["proof (state)\nthis:\n  snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ a # f)) =\n  rev f @ a # rev bs\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "{"], ["proof (state)\nthis:\n  snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ a # f)) =\n  rev f @ a # rev bs\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "fix xs s"], ["proof (state)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "assume sinit: \"s:{[a,e],[e,a]}\""], ["proof (state)\nthis:\n  s \\<in> {[a, e], [e, a]}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "assume \"set xs \\<subseteq> {a,e}\""], ["proof (state)\nthis:\n  set xs \\<subseteq> {a, e}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "then"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> {a, e}", "have \"fst (config' (\\<lambda>s. [], TS_step_d) (s, []) xs) \\<in> {[a,e], [e,a]}\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {a, e}\n\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (s, []) xs)\n    \\<in> {[a, e], [e, a]}", "apply (induct xs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> {a, e} \\<Longrightarrow>\n    fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (s, []) [])\n    \\<in> {[a, e], [e, a]}\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (s, [])\n                               (xs @ [x]))\n                         \\<in> {[a, e], [e, a]}", "using sinit"], ["proof (prove)\nusing this:\n  s \\<in> {[a, e], [e, a]}\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> {a, e} \\<Longrightarrow>\n    fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (s, []) [])\n    \\<in> {[a, e], [e, a]}\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (s, [])\n                               (xs @ [x]))\n                         \\<in> {[a, e], [e, a]}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (s, [])\n                               (xs @ [x]))\n                         \\<in> {[a, e], [e, a]}", "apply(subst config'_append2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d)\n                               (Partial_Cost_Model.config'\n                                 (\\<lambda>s. [], TS_step_d) (s, []) xs)\n                               [x])\n                         \\<in> {[a, e], [e, a]}", "apply(simp only: Step_def config'.simps Let_def split_def fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> step\n                          (fst (Partial_Cost_Model.config'\n                                 (\\<lambda>s. [], TS_step_d) (s, []) xs))\n                          x (fst (snd (\\<lambda>s. [], TS_step_d)\n                                   (Partial_Cost_Model.config'\n                                     (\\<lambda>s. [], TS_step_d) (s, []) xs)\n                                   x))\n                         \\<in> {[a, e], [e, a]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {a, e}\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> {a, e} \\<Longrightarrow>\n                fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (s, []) xs)\n                \\<in> {[a, e], [e, a]};\n        set (xs @ [x]) \\<subseteq> {a, e}\\<rbrakk>\n       \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (s, []) xs)\n                         \\<in> {[a, e], [e, a]}", "by simp_all"], ["proof (state)\nthis:\n  fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (s, []) xs)\n  \\<in> {[a, e], [e, a]}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<in> {[a, e], [e, a]}; set ?xs2 \\<subseteq> {a, e}\\<rbrakk>\n  \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                          (\\<lambda>s. [], TS_step_d) (?s2, []) ?xs2)\n                    \\<in> {[a, e], [e, a]}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "note staysae=this"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<in> {[a, e], [e, a]}; set ?xs2 \\<subseteq> {a, e}\\<rbrakk>\n  \\<Longrightarrow> fst (Partial_Cost_Model.config'\n                          (\\<lambda>s. [], TS_step_d) (?s2, []) ?xs2)\n                    \\<in> {[a, e], [e, a]}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "have opt: \"fst (config' (\\<lambda>s. [], TS_step_d)\n                                       (Lxy init {x, y}, []) (bs @ [a] @ f)) \\<in> {[a,e], [e,a]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n          (Lxy init {x, y}, []) (bs @ [a] @ f))\n    \\<in> {[a, e], [e, a]}", "apply(rule staysae)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Lxy init {x, y} \\<in> {[a, e], [e, a]}\n 2. set (bs @ [a] @ f) \\<subseteq> {a, e}", "using Lxyinitxy exy axy ane"], ["proof (prove)\nusing this:\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n  e \\<in> {x, y}\n  a \\<in> {x, y}\n  a \\<noteq> e\n\ngoal (2 subgoals):\n 1. Lxy init {x, y} \\<in> {[a, e], [e, a]}\n 2. set (bs @ [a] @ f) \\<subseteq> {a, e}", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bs @ [a] @ f) \\<subseteq> {a, e}", "unfolding aexy"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bs @ [a] @ f) \\<subseteq> {x, y}", "by(fact bsaxy)"], ["proof (state)\nthis:\n  fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ [a] @ f))\n  \\<in> {[a, e], [e, a]}\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "have contr: \" (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) = False", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq>\n    False \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq> False\n\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq>\n    False \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq> False", "have \"\\<And>x. 0 < (if e = x then 0 else index [a] x + 1)\""], ["proof (prove)\nusing this:\n  (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq> False\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < (if e = x then 0 else index [a] x + 1)", "by simp"], ["proof (state)\nthis:\n  0 < (if e = ?x then 0 else index [a] ?x + 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq>\n    False \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 < (if e = ?x then 0 else index [a] ?x + 1)", "have \"0 < (if e = e then 0 else index [a] e + 1)\""], ["proof (prove)\nusing this:\n  0 < (if e = ?x then 0 else index [a] ?x + 1)\n\ngoal (1 subgoal):\n 1. 0 < (if e = e then 0 else index [a] e + 1)", "by blast"], ["proof (state)\nthis:\n  0 < (if e = e then 0 else index [a] e + 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq>\n    False \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 < (if e = e then 0 else index [a] e + 1)", "have \"0<0\""], ["proof (prove)\nusing this:\n  0 < (if e = e then 0 else index [a] e + 1)\n\ngoal (1 subgoal):\n 1. (0::'a) < (0::'a)", "by simp"], ["proof (state)\nthis:\n  (0::?'a1) < (0::?'a1)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) \\<noteq>\n    False \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (0::?'a1) < (0::?'a1)", "show \"False\""], ["proof (prove)\nusing this:\n  (0::?'a1) < (0::?'a1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x. 0 < (if e = x then 0 else index [a] x + 1)) = False\n\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "show \"a < e in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ f) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ f) @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) (Lxy init {x, y}) (bs @ [a] @ f)) [a])", "apply(simp add: rTS_def Step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (Lxy init {x, y}, []) (bs @ a # f)))\n        a (fst (TS_step_d\n                 (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                   (Lxy init {x, y}, []) (bs @ a # f))\n                 a))", "apply(subst TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (Lxy init {x, y}, []) (bs @ a # f)))\n        a (fst ((let li = index\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. [], TS_step_d)\n                                  (Lxy init {x, y}, []) (bs @ a # f)))\n                           a\n                 in if li =\n                       length\n                        (snd (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d)\n                               (Lxy init {x, y}, []) (bs @ a # f)))\n                    then 0\n                    else let sincelast =\n                               take li\n                                (snd (Partial_Cost_Model.config'\n (\\<lambda>s. [], TS_step_d) (Lxy init {x, y}, []) (bs @ a # f)));\n                             S = {xa.\n                                  xa < a\n                                  in fst\n(Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n  (Lxy init {x, y}, []) (bs @ a # f)) \\<and>\n                                  count_list sincelast xa \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (Lxy init {x, y}, []) (bs @ a # f)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ a # f))) `\nS),\n                 []),\n                a #\n                snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (Lxy init {x, y}, []) (bs @ a # f))))", "apply(simp only: history)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (Lxy init {x, y}, []) (bs @ a # f)))\n        a (fst ((let li = index (rev f @ a # rev bs) a\n                 in if li = length (rev f @ a # rev bs) then 0\n                    else let sincelast = take li (rev f @ a # rev bs);\n                             S = {xa.\n                                  xa < a\n                                  in fst\n(Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n  (Lxy init {x, y}, []) (bs @ a # f)) \\<and>\n                                  count_list sincelast xa \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (Lxy init {x, y}, []) (bs @ a # f)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ a # f))) `\nS),\n                 []),\n                a # rev f @ a # rev bs))", "using opt ane add"], ["proof (prove)\nusing this:\n  fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ [a] @ f))\n  \\<in> {[a, e], [e, a]}\n  a \\<noteq> e\n  f \\<in> {[], [e]}\n\ngoal (1 subgoal):\n 1. a < e\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (Lxy init {x, y}, []) (bs @ a # f)))\n        a (fst ((let li = index (rev f @ a # rev bs) a\n                 in if li = length (rev f @ a # rev bs) then 0\n                    else let sincelast = take li (rev f @ a # rev bs);\n                             S = {xa.\n                                  xa < a\n                                  in fst\n(Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n  (Lxy init {x, y}, []) (bs @ a # f)) \\<and>\n                                  count_list sincelast xa \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (Lxy init {x, y}, []) (bs @ a # f)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (bs @ a # f))) `\nS),\n                 []),\n                a # rev f @ a # rev bs))", "apply(auto simp: step_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a])) =\n     [a, e];\n     f = []\\<rbrakk>\n    \\<Longrightarrow> a < e in [a, e]\n 2. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [a, e];\n     f = [e]\\<rbrakk>\n    \\<Longrightarrow> a < e in [a, e]\n 3. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a])) =\n     [e, a];\n     f = []; \\<forall>x. \\<not> x < a in [e, a]\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a])) =\n        [e, a];\n        f = []; xa < a in [e, a]\\<rbrakk>\n       \\<Longrightarrow> a < e in mtf2 (Suc 0) a [e, a]\n 5. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        x < a in [e, a] \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; xa < a in [e, a];\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> a < e\n                         in mtf2\n                             (Suc 0 -\n                              Min ((\\<lambda>a. 0) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {e}) \\<union>\n                                   (\\<lambda>x.\n Suc (if a = x then 0 else index [] x + 1)) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {x. e \\<noteq> x})))\n                             a [e, a]", "apply(simp add: before_in_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [a, e];\n     f = [e]\\<rbrakk>\n    \\<Longrightarrow> a < e in [a, e]\n 2. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a])) =\n     [e, a];\n     f = []; \\<forall>x. \\<not> x < a in [e, a]\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a])) =\n        [e, a];\n        f = []; xa < a in [e, a]\\<rbrakk>\n       \\<Longrightarrow> a < e in mtf2 (Suc 0) a [e, a]\n 4. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        x < a in [e, a] \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; xa < a in [e, a];\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> a < e\n                         in mtf2\n                             (Suc 0 -\n                              Min ((\\<lambda>a. 0) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {e}) \\<union>\n                                   (\\<lambda>x.\n Suc (if a = x then 0 else index [] x + 1)) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {x. e \\<noteq> x})))\n                             a [e, a]", "apply(simp add: before_in_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a])) =\n     [e, a];\n     f = []; \\<forall>x. \\<not> x < a in [e, a]\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a])) =\n        [e, a];\n        f = []; xa < a in [e, a]\\<rbrakk>\n       \\<Longrightarrow> a < e in mtf2 (Suc 0) a [e, a]\n 3. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        x < a in [e, a] \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; xa < a in [e, a];\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> a < e\n                         in mtf2\n                             (Suc 0 -\n                              Min ((\\<lambda>a. 0) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {e}) \\<union>\n                                   (\\<lambda>x.\n Suc (if a = x then 0 else index [] x + 1)) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {x. e \\<noteq> x})))\n                             a [e, a]", "apply(simp add: before_in_def contr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a])) =\n        [e, a];\n        f = []; xa < a in [e, a]\\<rbrakk>\n       \\<Longrightarrow> a < e in mtf2 (Suc 0) a [e, a]\n 2. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        x < a in [e, a] \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; xa < a in [e, a];\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> a < e\n                         in mtf2\n                             (Suc 0 -\n                              Min ((\\<lambda>a. 0) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {e}) \\<union>\n                                   (\\<lambda>x.\n Suc (if a = x then 0 else index [] x + 1)) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {x. e \\<noteq> x})))\n                             a [e, a]", "apply(simp add: mtf2_def swap_def before_in_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        x < a in [e, a] \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; xa < a in [e, a];\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> a < e\n                         in mtf2\n                             (Suc 0 -\n                              Min ((\\<lambda>a. 0) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {e}) \\<union>\n                                   (\\<lambda>x.\n Suc (if a = x then 0 else index [] x + 1)) `\n                                   ({x. (e = x \\<longrightarrow>\n   x < a in [x, a]) \\<and>\n  (e \\<noteq> x \\<longrightarrow> x < a in [e, a])} \\<inter>\n                                    {x. e \\<noteq> x})))\n                             a [e, a]", "apply(auto simp add: before_in_def contr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> e;\n     fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (bs @ [a, e])) =\n     [e, a];\n     f = [e];\n     \\<forall>x.\n        (if e = x then 0 else index [a] x + 1) = 0 \\<longrightarrow>\n        \\<not> (if e = x then count_list [] x + 1 else count_list [] x)\n               \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; (if e = xa then 0 else index [a] xa + 1) = 0;\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> index (mtf2 (Suc 0) a [e, a]) a\n                         < index (mtf2 (Suc 0) a [e, a]) e", "apply (metis One_nat_def add_is_1 count_list.simps(1) le_Suc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>a \\<noteq> e;\n        fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n              (Lxy init {x, y}, []) (bs @ [a, e])) =\n        [e, a];\n        f = [e]; (if e = xa then 0 else index [a] xa + 1) = 0;\n        (if e = xa then count_list [] xa + 1 else count_list [] xa)\n        \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> index (mtf2 (Suc 0) a [e, a]) a\n                         < index (mtf2 (Suc 0) a [e, a]) e", "by(simp add: mtf2_def swap_def)"], ["proof (state)\nthis:\n  a < e\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ f) @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oneposs: \n   assumes \"set xs = {x,y}\"\n      assumes \"x\\<noteq>y\"\n      assumes \"distinct xs\"\n      assumes True: \"x<y in xs\"\n      shows \"xs = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = [x, y]", "from assms"], ["proof (chain)\npicking this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  x < y in xs", "have len2: \"length xs = 2\""], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  x < y in xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "using distinct_card[OF assms(3)]"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  x < y in xs\n  card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "by fastforce"], ["proof (state)\nthis:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "from True"], ["proof (chain)\npicking this:\n  x < y in xs", "have \"index xs x < index xs y\" \"index xs y < length xs\""], ["proof (prove)\nusing this:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs x < index xs y \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "using assms"], ["proof (prove)\nusing this:\n  index xs x < index xs y \\<and> y \\<in> set xs\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  x < y in xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "by simp_all"], ["proof (state)\nthis:\n  index xs x < index xs y\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "then"], ["proof (chain)\npicking this:\n  index xs x < index xs y\n  index xs y < length xs", "have f: \"index xs x = 0 \\<and> index xs y = 1\""], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. index xs x = 0 \\<and> index xs y = 1", "using len2"], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs y < length xs\n  length xs = 2\n\ngoal (1 subgoal):\n 1. index xs x = 0 \\<and> index xs y = 1", "by linarith"], ["proof (state)\nthis:\n  index xs x = 0 \\<and> index xs y = 1\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"xs = take 1 xs @ xs!1 # drop (Suc 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 1 < length xs", "by simp"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "also"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"\\<dots> = take 1 xs @ [xs!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "by simp"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "also"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"take 1 xs = take 0 (take 1 xs) @ (take 1 xs)!0 # drop (Suc 0) (take 1 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs =\n    take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "by simp"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "also"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"\\<dots> = [xs!0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]", "by(simp)"], ["proof (state)\nthis:\n  take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "finally"], ["proof (chain)\npicking this:\n  xs = [xs ! 0] @ [xs ! 1]", "have \"xs = [xs!0, xs!1]\""], ["proof (prove)\nusing this:\n  xs = [xs ! 0] @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [xs ! 0, xs ! 1]", "by simp"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "also"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"\\<dots> = [xs!(index xs x), xs!index xs y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]", "using f"], ["proof (prove)\nusing this:\n  index xs x = 0 \\<and> index xs y = 1\n\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]", "by simp"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "also"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "have \"\\<dots> = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! index xs x, xs ! index xs y] = [x, y]", "using assms"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  x < y in xs\n\ngoal (1 subgoal):\n 1. [xs ! index xs x, xs ! index xs y] = [x, y]", "by(simp)"], ["proof (state)\nthis:\n  [xs ! index xs x, xs ! index xs y] = [x, y]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "finally"], ["proof (chain)\npicking this:\n  xs = [x, y]", "show \"xs = [x,y]\""], ["proof (prove)\nusing this:\n  xs = [x, y]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "."], ["proof (state)\nthis:\n  xs = [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma twoposs: \n   assumes \"set xs = {x,y}\"\n      assumes \"x\\<noteq>y\"\n      assumes \"distinct xs\"\n      shows \"xs \\<in> {[x,y], [y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> {[x, y], [y, x]}", "proof (cases \"x<y in xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "case True"], ["proof (state)\nthis:\n  x < y in xs\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "from assms"], ["proof (chain)\npicking this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs", "have len2: \"length xs = 2\""], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "using distinct_card[OF assms(3)]"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "by fastforce"], ["proof (state)\nthis:\n  length xs = 2\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "from True"], ["proof (chain)\npicking this:\n  x < y in xs", "have \"index xs x < index xs y\" \"index xs y < length xs\""], ["proof (prove)\nusing this:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs x < index xs y \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "using assms"], ["proof (prove)\nusing this:\n  index xs x < index xs y \\<and> y \\<in> set xs\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&& index xs y < length xs", "by simp_all"], ["proof (state)\nthis:\n  index xs x < index xs y\n  index xs y < length xs\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "then"], ["proof (chain)\npicking this:\n  index xs x < index xs y\n  index xs y < length xs", "have f: \"index xs x = 0 \\<and> index xs y = 1\""], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. index xs x = 0 \\<and> index xs y = 1", "using len2"], ["proof (prove)\nusing this:\n  index xs x < index xs y\n  index xs y < length xs\n  length xs = 2\n\ngoal (1 subgoal):\n 1. index xs x = 0 \\<and> index xs y = 1", "by linarith"], ["proof (state)\nthis:\n  index xs x = 0 \\<and> index xs y = 1\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"xs = take 1 xs @ xs!1 # drop (Suc 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 1 < length xs", "by simp"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = take 1 xs @ [xs!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "by simp"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"take 1 xs = take 0 (take 1 xs) @ (take 1 xs)!0 # drop (Suc 0) (take 1 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs =\n    take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "by simp"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [xs!0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]", "by(simp)"], ["proof (state)\nthis:\n  take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "finally"], ["proof (chain)\npicking this:\n  xs = [xs ! 0] @ [xs ! 1]", "have \"xs = [xs!0, xs!1]\""], ["proof (prove)\nusing this:\n  xs = [xs ! 0] @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [xs ! 0, xs ! 1]", "by simp"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [xs!(index xs x), xs!index xs y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]", "using f"], ["proof (prove)\nusing this:\n  index xs x = 0 \\<and> index xs y = 1\n\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]", "by simp"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs x, xs ! index xs y]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! index xs x, xs ! index xs y] = [x, y]", "using assms"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. [xs ! index xs x, xs ! index xs y] = [x, y]", "by(simp)"], ["proof (state)\nthis:\n  [xs ! index xs x, xs ! index xs y] = [x, y]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "finally"], ["proof (chain)\npicking this:\n  xs = [x, y]", "have \"xs = [x,y]\""], ["proof (prove)\nusing this:\n  xs = [x, y]\n\ngoal (1 subgoal):\n 1. xs = [x, y]", "."], ["proof (state)\nthis:\n  xs = [x, y]\n\ngoal (2 subgoals):\n 1. x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}\n 2. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "then"], ["proof (chain)\npicking this:\n  xs = [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = [x, y]\n\ngoal (1 subgoal):\n 1. xs \\<in> {[x, y], [y, x]}", "by simp"], ["proof (state)\nthis:\n  xs \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "case False"], ["proof (state)\nthis:\n  \\<not> x < y in xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "from assms"], ["proof (chain)\npicking this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs", "have len2: \"length xs = 2\""], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "using distinct_card[OF assms(3)]"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n  card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "by fastforce"], ["proof (state)\nthis:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "from False"], ["proof (chain)\npicking this:\n  \\<not> x < y in xs", "have \"y<x in xs\""], ["proof (prove)\nusing this:\n  \\<not> x < y in xs\n\ngoal (1 subgoal):\n 1. y < x in xs", "using not_before_in assms(1,2)"], ["proof (prove)\nusing this:\n  \\<not> x < y in xs\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  set xs = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y < x in xs", "by fastforce"], ["proof (state)\nthis:\n  y < x in xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "then"], ["proof (chain)\npicking this:\n  y < x in xs", "have \"index xs y < index xs x\" \"index xs x < length xs\""], ["proof (prove)\nusing this:\n  y < x in xs\n\ngoal (1 subgoal):\n 1. index xs y < index xs x &&& index xs x < length xs", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs y < index xs x \\<and> x \\<in> set xs\n\ngoal (1 subgoal):\n 1. index xs y < index xs x &&& index xs x < length xs", "using assms"], ["proof (prove)\nusing this:\n  index xs y < index xs x \\<and> x \\<in> set xs\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. index xs y < index xs x &&& index xs x < length xs", "by simp_all"], ["proof (state)\nthis:\n  index xs y < index xs x\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "then"], ["proof (chain)\npicking this:\n  index xs y < index xs x\n  index xs x < length xs", "have f: \"index xs y = 0 \\<and> index xs x = 1\""], ["proof (prove)\nusing this:\n  index xs y < index xs x\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. index xs y = 0 \\<and> index xs x = 1", "using len2"], ["proof (prove)\nusing this:\n  index xs y < index xs x\n  index xs x < length xs\n  length xs = 2\n\ngoal (1 subgoal):\n 1. index xs y = 0 \\<and> index xs x = 1", "by linarith"], ["proof (state)\nthis:\n  index xs y = 0 \\<and> index xs x = 1\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"xs = take 1 xs @ xs!1 # drop (Suc 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 1 < length xs", "by simp"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  xs = take 1 xs @ xs ! 1 # drop (Suc 1) xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = take 1 xs @ [xs!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]", "by simp"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  take 1 xs @ xs ! 1 # drop (Suc 1) xs = take 1 xs @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"take 1 xs = take 0 (take 1 xs) @ (take 1 xs)!0 # drop (Suc 0) (take 1 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 xs =\n    take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "using len2"], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. 0 < length (take 1 xs)", "by simp"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  take 1 xs = take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [xs!0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]", "by(simp)"], ["proof (state)\nthis:\n  take 0 (take 1 xs) @ take 1 xs ! 0 # drop (Suc 0) (take 1 xs) = [xs ! 0]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "finally"], ["proof (chain)\npicking this:\n  xs = [xs ! 0] @ [xs ! 1]", "have \"xs = [xs!0, xs!1]\""], ["proof (prove)\nusing this:\n  xs = [xs ! 0] @ [xs ! 1]\n\ngoal (1 subgoal):\n 1. xs = [xs ! 0, xs ! 1]", "by simp"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  xs = [xs ! 0, xs ! 1]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [xs!(index xs y), xs!index xs x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs y, xs ! index xs x]", "using f"], ["proof (prove)\nusing this:\n  index xs y = 0 \\<and> index xs x = 1\n\ngoal (1 subgoal):\n 1. [xs ! 0, xs ! 1] = [xs ! index xs y, xs ! index xs x]", "by simp"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs y, xs ! index xs x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "also"], ["proof (state)\nthis:\n  [xs ! 0, xs ! 1] = [xs ! index xs y, xs ! index xs x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "have \"\\<dots> = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs ! index xs y, xs ! index xs x] = [y, x]", "using assms"], ["proof (prove)\nusing this:\n  set xs = {x, y}\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. [xs ! index xs y, xs ! index xs x] = [y, x]", "by(simp)"], ["proof (state)\nthis:\n  [xs ! index xs y, xs ! index xs x] = [y, x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "finally"], ["proof (chain)\npicking this:\n  xs = [y, x]", "have \"xs = [y,x]\""], ["proof (prove)\nusing this:\n  xs = [y, x]\n\ngoal (1 subgoal):\n 1. xs = [y, x]", "."], ["proof (state)\nthis:\n  xs = [y, x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> xs \\<in> {[x, y], [y, x]}", "then"], ["proof (chain)\npicking this:\n  xs = [y, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = [y, x]\n\ngoal (1 subgoal):\n 1. xs \\<in> {[x, y], [y, x]}", "by simp"], ["proof (state)\nthis:\n  xs \\<in> {[x, y], [y, x]}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_pairwise': assumes \"qs \\<in> {xs. set xs \\<subseteq> set init}\"\n       \"(x, y) \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\"\n       \"x \\<noteq> y\" \"distinct init\"\n   shows \"Pbefore_in x y (embed (rTS [])) qs init =\n       Pbefore_in x y (embed (rTS [])) (Lxy qs {x, y}) (Lxy init {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "from assms"], ["proof (chain)\npicking this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init", "have xyininit: \"{x, y} \\<subseteq> set init\" \n        and qsininit: \"set qs \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> set init &&& set qs \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "note dinit=assms(4)"], ["proof (state)\nthis:\n  distinct init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "from assms"], ["proof (chain)\npicking this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init", "have xny: \"x\\<noteq>y\""], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "have Lxyinitxy: \"Lxy init {x, y} \\<in> {[x, y], [y, x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "apply(rule twoposs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (Lxy init {x, y}) = {x, y}\n 2. x \\<noteq> y\n 3. distinct (Lxy init {x, y})", "apply(subst Lxy_set_filter)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x, y} \\<inter> set init = {x, y}\n 2. x \\<noteq> y\n 3. distinct (Lxy init {x, y})", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. {x, y} \\<inter> set init = {x, y}\n 2. x \\<noteq> y\n 3. distinct (Lxy init {x, y})", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<noteq> y\n 2. distinct (Lxy init {x, y})", "using xny Lxy_distinct[OF dinit]"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  distinct (Lxy init ?S)\n\ngoal (2 subgoals):\n 1. x \\<noteq> y\n 2. distinct (Lxy init {x, y})", "by simp_all"], ["proof (state)\nthis:\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "have lq_s: \"set (Lxy qs {x, y}) \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {x, y}) \\<subseteq> {x, y}", "by (simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "(* projected history *)"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "let ?pH = \"snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "have \"?pH =snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y}) (length (Lxy qs {x, y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y})\n          (length (Lxy qs {x, y})))", "by(simp)"], ["proof (state)\nthis:\n  snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y}) (length (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "also"], ["proof (state)\nthis:\n  snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y}) (length (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "have \"\\<dots> = rev (take (length (Lxy qs {x, y})) (Lxy qs {x, y})) @ []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y})\n          (length (Lxy qs {x, y}))) =\n    rev (take (length (Lxy qs {x, y})) (Lxy qs {x, y})) @ []", "apply(rule sndTSdet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy qs {x, y}) \\<le> length (Lxy qs {x, y})", "by simp"], ["proof (state)\nthis:\n  snd (TSdet (Lxy init {x, y}) [] (Lxy qs {x, y})\n        (length (Lxy qs {x, y}))) =\n  rev (take (length (Lxy qs {x, y})) (Lxy qs {x, y})) @ []\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "finally"], ["proof (chain)\npicking this:\n  snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  rev (take (length (Lxy qs {x, y})) (Lxy qs {x, y})) @ []", "have pH: \"?pH = rev (Lxy qs {x, y})\""], ["proof (prove)\nusing this:\n  snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  rev (take (length (Lxy qs {x, y})) (Lxy qs {x, y})) @ []\n\ngoal (1 subgoal):\n 1. snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    rev (Lxy qs {x, y})", "by simp"], ["proof (state)\nthis:\n  snd (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  rev (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "let ?pQs = \"(Lxy qs {x, y})\""], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "have A: \" x < y in fst (config\\<^sub>p (rTS []) init qs)\n      =   x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof(cases \"?pQs\" rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case Nil"], ["proof (state)\nthis:\n  Lxy qs {x, y} = []\n\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = []", "have xqs: \"x \\<notin> set qs\" and yqs: \"y \\<notin> set qs\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = []\n\ngoal (1 subgoal):\n 1. x \\<notin> set qs &&& y \\<notin> set qs", "by(simp_all add: projEmpty)"], ["proof (state)\nthis:\n  x \\<notin> set qs\n  y \\<notin> set qs\n\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \" x < y in fst (config\\<^sub>p (rTS []) init qs)\n          =  x < y in init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init", "apply(rule staysuntouched')"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set qs \\<subseteq> set init\n 5. x \\<notin> set qs\n 6. y \\<notin> set qs", "using assms xqs yqs"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set qs\n  y \\<notin> set qs\n\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set qs \\<subseteq> set init\n 5. x \\<notin> set qs\n 6. y \\<notin> set qs", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init\n\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) = x < y in init\n\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) [])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init = x < y in Lxy init {x, y}", "apply(rule Lxy_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set init\n 2. distinct init", "using xyininit dinit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  distinct init\n\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set init\n 2. distinct init", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in init =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (2 subgoals):\n 1. Lxy qs {x, y} = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case (snoc as a)"], ["proof (state)\nthis:\n  Lxy qs {x, y} = as @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = as @ [a]", "have \"a\\<in>set (Lxy qs {x, y})\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n\ngoal (1 subgoal):\n 1. a \\<in> set (Lxy qs {x, y})", "by (simp)"], ["proof (state)\nthis:\n  a \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  a \\<in> set (Lxy qs {x, y})", "have axy: \"a\\<in>{x,y}\""], ["proof (prove)\nusing this:\n  a \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xyininit"], ["proof (chain)\npicking this:\n  {x, y} \\<subseteq> set init\n  a \\<in> {x, y}", "have ainit: \"a\\<in>set init\""], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. a \\<in> set init", "by auto"], ["proof (state)\nthis:\n  a \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note a=snoc"], ["proof (state)\nthis:\n  Lxy qs {x, y} = as @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from a axy"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = as @ [a]\n  a \\<in> {x, y}", "obtain pre suf  where qs: \"qs = pre @ [a] @ suf\"\n                  and nosuf: \"\\<And>e. e \\<in> {x,y} \\<Longrightarrow> e \\<notin> set suf\" \n                  and pre: \"Lxy pre {x,y} = as\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf;\n         Lxy pre {x, y} = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using proj_Snoc"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  a \\<in> {x, y}\n  \\<lbrakk>Lxy ?qs ?S = ?as @ [?a]; ?a \\<in> ?S;\n   \\<And>pre suf.\n      \\<lbrakk>?qs = pre @ [?a] @ suf;\n       \\<And>x. x \\<in> ?S \\<Longrightarrow> x \\<notin> set suf;\n       Lxy pre ?S = ?as\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>qs = pre @ [a] @ suf;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf;\n         Lxy pre {x, y} = as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n  Lxy pre {x, y} = as\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       Lxy qs {x, y} = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof (cases \"as\" rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from pre Nil"], ["proof (chain)\npicking this:\n  Lxy pre {x, y} = as\n  as = []", "have xqs: \"x \\<notin> set pre\" and yqs: \"y \\<notin> set pre\""], ["proof (prove)\nusing this:\n  Lxy pre {x, y} = as\n  as = []\n\ngoal (1 subgoal):\n 1. x \\<notin> set pre &&& y \\<notin> set pre", "by(simp_all add: projEmpty)"], ["proof (state)\nthis:\n  x \\<notin> set pre\n  y \\<notin> set pre\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from xqs yqs axy"], ["proof (chain)\npicking this:\n  x \\<notin> set pre\n  y \\<notin> set pre\n  a \\<in> {x, y}", "have \"a \\<notin> set pre\""], ["proof (prove)\nusing this:\n  x \\<notin> set pre\n  y \\<notin> set pre\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. a \\<notin> set pre", "by blast"], ["proof (state)\nthis:\n  a \\<notin> set pre\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  a \\<notin> set pre", "have noocc: \"index (rev pre) a = length (rev pre)\""], ["proof (prove)\nusing this:\n  a \\<notin> set pre\n\ngoal (1 subgoal):\n 1. index (rev pre) a = length (rev pre)", "by simp"], ["proof (state)\nthis:\n  index (rev pre) a = length (rev pre)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \" x < y in fst (config\\<^sub>p (rTS []) init qs)\n            =  x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf))", "by(simp add: qs)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf)) =\n    x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init (pre @ [a])) suf) =\n    x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a]))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 4. set suf \\<subseteq> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 5. x \\<notin> set suf\n 6. y \\<notin> set suf", "using assms xqs yqs qs nosuf"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set pre\n  y \\<notin> set pre\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 4. set suf \\<subseteq> set (fst (config\\<^sub>p (rTS []) init (pre @ [a])))\n 5. x \\<notin> set suf\n 6. y \\<notin> set suf", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a]))\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre @ [a]) @ suf)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a]))\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a])) =\n    x < y in fst (config\\<^sub>p (rTS []) init pre)", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init pre) [a]) =\n    x < y in fst (config\\<^sub>p (rTS []) init pre)", "apply(simp add: rTS_def Step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre))\n        a (fst (TS_step_d\n                 (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                   (init, []) pre)\n                 a)) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre)", "apply(simp only: TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre))\n        a (fst ((let li = index\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. [], TS_step_d) (init, [])\n                                  pre))\n                           a\n                 in if li =\n                       length\n                        (snd (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (init, []) pre))\n                    then 0\n                    else let sincelast =\n                               take li\n                                (snd (Partial_Cost_Model.config'\n (\\<lambda>s. [], TS_step_d) (init, []) pre));\n                             S = {x. x < a\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     pre) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) pre))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        pre)) `\nS),\n                 []),\n                a #\n                snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (init, []) pre))) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre)", "apply(simp only: sndTSconfig'[unfolded rTS_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre))\n        a (fst ((let li = index (rev pre @ []) a\n                 in if li = length (rev pre @ []) then 0\n                    else let sincelast = take li (rev pre @ []);\n                             S = {x. x < a\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     pre) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) pre))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        pre)) `\nS),\n                 []),\n                a # rev pre @ [])) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre)", "by(simp add: noocc step_def)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a])) =\n  x < y in fst (config\\<^sub>p (rTS []) init pre)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init (pre @ [a])) =\n  x < y in fst (config\\<^sub>p (rTS []) init pre)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init pre) = x < y in init", "apply(rule staysuntouched')"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set pre \\<subseteq> set init\n 5. x \\<notin> set pre\n 6. y \\<notin> set pre", "using assms xqs yqs qs"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set pre\n  y \\<notin> set pre\n  qs = pre @ [a] @ suf\n\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set pre \\<subseteq> set init\n 5. x \\<notin> set pre\n 6. y \\<notin> set pre", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init pre) = x < y in init\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init pre) = x < y in init\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "unfolding a Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ([] @ [a]))", "apply(simp add: Step_def split_def rTS_def TS_step_d_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init = x < y in Lxy init {x, y}", "apply(rule Lxy_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set init\n 2. distinct init", "using xyininit dinit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  distinct init\n\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set init\n 2. distinct init", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in init =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case (snoc bs b)"], ["proof (state)\nthis:\n  as = bs @ [b]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note b=this"], ["proof (state)\nthis:\n  as = bs @ [b]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with a"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]", "have \"b\\<in>set (Lxy qs {x, y})\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n\ngoal (1 subgoal):\n 1. b \\<in> set (Lxy qs {x, y})", "by (simp)"], ["proof (state)\nthis:\n  b \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  b \\<in> set (Lxy qs {x, y})", "have bxy: \"b\\<in>{x,y}\""], ["proof (prove)\nusing this:\n  b \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. b \\<in> {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  b \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xyininit"], ["proof (chain)\npicking this:\n  {x, y} \\<subseteq> set init\n  b \\<in> {x, y}", "have binit: \"b\\<in>set init\""], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  b \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. b \\<in> set init", "by auto"], ["proof (state)\nthis:\n  b \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from b pre"], ["proof (chain)\npicking this:\n  as = bs @ [b]\n  Lxy pre {x, y} = as", "have \"Lxy pre {x,y} = bs @ [b]\""], ["proof (prove)\nusing this:\n  as = bs @ [b]\n  Lxy pre {x, y} = as\n\ngoal (1 subgoal):\n 1. Lxy pre {x, y} = bs @ [b]", "by simp"], ["proof (state)\nthis:\n  Lxy pre {x, y} = bs @ [b]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with bxy"], ["proof (chain)\npicking this:\n  b \\<in> {x, y}\n  Lxy pre {x, y} = bs @ [b]", "obtain pre2 suf2  where bs: \"pre = pre2 @ [b] @ suf2\"\n                    and nosuf2: \"\\<And>e. e \\<in> {x,y} \\<Longrightarrow> e \\<notin> set suf2\" \n                    and pre2: \"Lxy pre2 {x,y} = bs\""], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  Lxy pre {x, y} = bs @ [b]\n\ngoal (1 subgoal):\n 1. (\\<And>pre2 suf2.\n        \\<lbrakk>pre = pre2 @ [b] @ suf2;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf2;\n         Lxy pre2 {x, y} = bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using proj_Snoc"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  Lxy pre {x, y} = bs @ [b]\n  \\<lbrakk>Lxy ?qs ?S = ?as @ [?a]; ?a \\<in> ?S;\n   \\<And>pre suf.\n      \\<lbrakk>?qs = pre @ [?a] @ suf;\n       \\<And>x. x \\<in> ?S \\<Longrightarrow> x \\<notin> set suf;\n       Lxy pre ?S = ?as\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pre2 suf2.\n        \\<lbrakk>pre = pre2 @ [b] @ suf2;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf2;\n         Lxy pre2 {x, y} = bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pre = pre2 @ [b] @ suf2\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  Lxy pre2 {x, y} = bs\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from bs qs"], ["proof (chain)\npicking this:\n  pre = pre2 @ [b] @ suf2\n  qs = pre @ [a] @ suf", "have qs2: \"qs = pre2 @ [b] @ suf2 @ [a] @ suf\""], ["proof (prove)\nusing this:\n  pre = pre2 @ [b] @ suf2\n  qs = pre @ [a] @ suf\n\ngoal (1 subgoal):\n 1. qs = pre2 @ [b] @ suf2 @ [a] @ suf", "by simp"], ["proof (state)\nthis:\n  qs = pre2 @ [b] @ suf2 @ [a] @ suf\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       as = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof (cases \"a=b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case True"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note ab=this"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?qs =\"(pre2 @ [a] @ suf2 @ [a]) @ suf\""], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "assume ane: \"a\\<noteq>e\""], ["proof (state)\nthis:\n  a \\<noteq> e\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "assume exy: \"e\\<in>{x,y}\""], ["proof (state)\nthis:\n  e \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"a < e in fst (config\\<^sub>p (rTS []) init qs)\n              = a < e in fst (config\\<^sub>p (rTS []) init ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e in fst (config\\<^sub>p (rTS []) init qs) =\n    a < e\n    in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf))", "using True qs2"], ["proof (prove)\nusing this:\n  a = b\n  qs = pre2 @ [b] @ suf2 @ [a] @ suf\n\ngoal (1 subgoal):\n 1. a < e in fst (config\\<^sub>p (rTS []) init qs) =\n    a < e\n    in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf))", "by(simp)"], ["proof (state)\nthis:\n  a < e in fst (config\\<^sub>p (rTS []) init qs) =\n  a < e\n  in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < e in fst (config\\<^sub>p (rTS []) init qs) =\n  a < e\n  in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = a < e in fst  (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in fst (config\\<^sub>p (rTS []) init\n             ((pre2 @ [a] @ suf2 @ [a]) @ suf)) =\n    a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a])) suf) =\n    a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a])))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre2 @ [a] @ suf2 @ [a])))\n 3. e \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre2 @ [a] @ suf2 @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (pre2 @ [a] @ suf2 @ [a])))\n 5. a \\<notin> set suf\n 6. e \\<notin> set suf", "using assms qs nosuf"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a])))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre2 @ [a] @ suf2 @ [a])))\n 3. e \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre2 @ [a] @ suf2 @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (pre2 @ [a] @ suf2 @ [a])))\n 5. a \\<notin> set suf\n 6. e \\<notin> set suf", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 3. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "using  exy xyininit"], ["proof (prove)\nusing this:\n  e \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 3. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "using nosuf axy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n  a \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "using nosuf exy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n  e \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> e \\<notin> set suf", "by simp"], ["proof (state)\nthis:\n  a < e\n  in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf)) =\n  a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < e\n  in fst (config\\<^sub>p (rTS []) init ((pre2 @ [a] @ suf2 @ [a]) @ suf)) =\n  a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ a # suf2 @ [a]))", "apply(rule twotox[unfolded s_TS_def, simplified])"], ["proof (prove)\ngoal (6 subgoals):\n 1. count_list suf2 e \\<le> Suc 0\n 2. distinct init\n 3. a \\<in> set init\n 4. e \\<in> set init\n 5. a \\<notin> set suf2\n 6. a \\<noteq> e", "using nosuf2 exy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  e \\<in> {x, y}\n\ngoal (6 subgoals):\n 1. count_list suf2 e \\<le> Suc 0\n 2. distinct init\n 3. a \\<in> set init\n 4. e \\<in> set init\n 5. a \\<notin> set suf2\n 6. a \\<noteq> e", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct init\n 2. a \\<in> set init\n 3. e \\<in> set init\n 4. a \\<notin> set suf2\n 5. a \\<noteq> e", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (5 subgoals):\n 1. distinct init\n 2. a \\<in> set init\n 3. e \\<in> set init\n 4. a \\<notin> set suf2\n 5. a \\<noteq> e", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 4. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "using axy xyininit"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (4 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 4. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "apply fast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "using exy xyininit"], ["proof (prove)\nusing this:\n  e \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "using nosuf2 axy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  a \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf2\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "using ane"], ["proof (prove)\nusing this:\n  a \\<noteq> e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> e", "by simp"], ["proof (state)\nthis:\n  a < e in fst (config\\<^sub>p (rTS []) init (pre2 @ [a] @ suf2 @ [a]))\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < e in fst (config\\<^sub>p (rTS []) init qs)", "have \"a < e in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\nusing this:\n  a < e in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. a < e in fst (config\\<^sub>p (rTS []) init qs)", "by simp"], ["proof (state)\nthis:\n  a < e in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> ?e2; ?e2 \\<in> {x, y}\\<rbrakk>\n  \\<Longrightarrow> a < ?e2 in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note full=this"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> ?e2; ?e2 \\<in> {x, y}\\<rbrakk>\n  \\<Longrightarrow> a < ?e2 in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"set (bs @ [a]) \\<subseteq> set (Lxy qs {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bs @ [a]) \\<subseteq> set (Lxy qs {x, y})", "using a b"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n\ngoal (1 subgoal):\n 1. set (bs @ [a]) \\<subseteq> set (Lxy qs {x, y})", "by auto"], ["proof (state)\nthis:\n  set (bs @ [a]) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (bs @ [a]) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = {x,y} \\<inter> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {x, y}) = {x, y} \\<inter> set qs", "by (rule Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set qs \\<subseteq> {x, y}", "by simp"], ["proof (state)\nthis:\n  {x, y} \\<inter> set qs \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  set (bs @ [a]) \\<subseteq> {x, y}", "have bsaxy: \"set (bs @ [a]) \\<subseteq> {x,y}\""], ["proof (prove)\nusing this:\n  set (bs @ [a]) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set (bs @ [a]) \\<subseteq> {x, y}", "."], ["proof (state)\nthis:\n  set (bs @ [a]) \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xny"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  set (bs @ [a]) \\<subseteq> {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (bs @ [a]) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof(cases \"x=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have 1: \"a < y in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y in fst (config\\<^sub>p (rTS []) init qs)", "apply(rule full)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}", "using True xny"], ["proof (prove)\nusing this:\n  x = a\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {x, y}", "by simp"], ["proof (state)\nthis:\n  a < y in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n              = a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "using a b ab"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  a = b\n\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "by simp"], ["proof (state)\nthis:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "apply(rule projxx[where bs=bs and f=\"[]\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> y\n 3. y \\<in> {x, y}\n 4. [] \\<in> {[], [y]}\n 5. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using True"], ["proof (prove)\nusing this:\n  x = a\n\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> y\n 3. y \\<in> {x, y}\n 4. [] \\<in> {[], [y]}\n 5. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}\n 3. [] \\<in> {[], [y]}\n 4. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using a b True ab xny Lxyinitxy bsaxy"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  x = a\n  a = b\n  x \\<noteq> y\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n  set (bs @ [a]) \\<subseteq> {x, y}\n\ngoal (5 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}\n 3. [] \\<in> {[], [y]}\n 4. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "by(simp_all)"], ["proof (state)\nthis:\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using True 1"], ["proof (prove)\nusing this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  x = a\n  a < y in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by simp"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with axy"], ["proof (chain)\npicking this:\n  a \\<in> {x, y}\n  x \\<noteq> a", "have ay: \"a=y\""], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. a = y", "by blast"], ["proof (state)\nthis:\n  a = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have 1: \"a < x in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < x in fst (config\\<^sub>p (rTS []) init qs)", "apply(rule full)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> x\n 2. x \\<in> {x, y}", "using False xny"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. a \\<noteq> x\n 2. x \\<in> {x, y}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x, y}", "by simp"], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n              = a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "using a b ab"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  a = b\n\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "by simp"], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((bs @ [a] @ []) @ [a]))", "apply(rule projxx[where bs=bs and f=\"[]\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> x\n 3. x \\<in> {x, y}\n 4. [] \\<in> {[], [x]}\n 5. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using True axy"], ["proof (prove)\nusing this:\n  a = b\n  a \\<in> {x, y}\n\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> x\n 3. x \\<in> {x, y}\n 4. [] \\<in> {[], [x]}\n 5. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. a \\<noteq> x\n 2. x \\<in> {x, y}\n 3. [] \\<in> {[], [x]}\n 4. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using a b True ab xny Lxyinitxy ay bsaxy"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  a = b\n  a = b\n  x \\<noteq> y\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n  a = y\n  set (bs @ [a]) \\<subseteq> {x, y}\n\ngoal (5 subgoals):\n 1. a \\<noteq> x\n 2. x \\<in> {x, y}\n 3. [] \\<in> {[], [x]}\n 4. set (bs @ [a] @ []) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "by(simp_all)"], ["proof (state)\nthis:\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((bs @ [a] @ []) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have 2: \"a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\nusing this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"x < y in fst (config\\<^sub>p (rTS []) init qs) = \n             (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (x < y in fst (config\\<^sub>p (rTS []) init qs) \\<or> y = x)", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (x < y in fst (config\\<^sub>p (rTS []) init qs) \\<or> y = x)", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False", "using  1 ay"], ["proof (prove)\nusing this:\n  a < x in fst (config\\<^sub>p (rTS []) init qs)\n  a = y\n\ngoal (1 subgoal):\n 1. (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False", "by simp"], ["proof (state)\nthis:\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = (\\<not> y < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False =\n    (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "using 2 ay"], ["proof (prove)\nusing this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  a = y\n\ngoal (1 subgoal):\n 1. False =\n    (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "by simp"], ["proof (state)\nthis:\n  False =\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  False =\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y}))) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (x < y\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     y = x) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (x < y\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     y = x) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by(simp_all add: Lxy_set_filter)"], ["proof (state)\nthis:\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y}))) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (bs @ [a]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note ab=this"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof (cases \"bs\" rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with a b"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = []", "have \"Lxy qs {x, y} = [b,a]\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = []\n\ngoal (1 subgoal):\n 1. Lxy qs {x, y} = [b, a]", "by simp"], ["proof (state)\nthis:\n  Lxy qs {x, y} = [b, a]\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from pre2 Nil"], ["proof (chain)\npicking this:\n  Lxy pre2 {x, y} = bs\n  bs = []", "have xqs: \"x \\<notin> set pre2\" and yqs: \"y \\<notin> set pre2\""], ["proof (prove)\nusing this:\n  Lxy pre2 {x, y} = bs\n  bs = []\n\ngoal (1 subgoal):\n 1. x \\<notin> set pre2 &&& y \\<notin> set pre2", "by(simp_all add: projEmpty)"], ["proof (state)\nthis:\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from xqs yqs bxy"], ["proof (chain)\npicking this:\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  b \\<in> {x, y}", "have \"b \\<notin> set pre2\""], ["proof (prove)\nusing this:\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  b \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. b \\<notin> set pre2", "by blast"], ["proof (state)\nthis:\n  b \\<notin> set pre2\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  b \\<notin> set pre2", "have noocc2: \"index (rev pre2) b = length (rev pre2)\""], ["proof (prove)\nusing this:\n  b \\<notin> set pre2\n\ngoal (1 subgoal):\n 1. index (rev pre2) b = length (rev pre2)", "by simp"], ["proof (state)\nthis:\n  index (rev pre2) b = length (rev pre2)\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from axy nosuf2"], ["proof (chain)\npicking this:\n  a \\<in> {x, y}\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2", "have \"a \\<notin> set suf2\""], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n\ngoal (1 subgoal):\n 1. a \\<notin> set suf2", "by blast"], ["proof (state)\nthis:\n  a \\<notin> set suf2\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xqs yqs axy False"], ["proof (chain)\npicking this:\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  a \\<in> {x, y}\n  a \\<noteq> b\n  a \\<notin> set suf2", "have \"a \\<notin> set ((pre2 @ b # suf2))\""], ["proof (prove)\nusing this:\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  a \\<in> {x, y}\n  a \\<noteq> b\n  a \\<notin> set suf2\n\ngoal (1 subgoal):\n 1. a \\<notin> set (pre2 @ b # suf2)", "by(auto)"], ["proof (state)\nthis:\n  a \\<notin> set (pre2 @ b # suf2)\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  a \\<notin> set (pre2 @ b # suf2)", "have noocc: \"index (rev (pre2 @ b # suf2) @ []) a = length (rev (pre2 @ b # suf2))\""], ["proof (prove)\nusing this:\n  a \\<notin> set (pre2 @ b # suf2)\n\ngoal (1 subgoal):\n 1. index (rev (pre2 @ b # suf2) @ []) a = length (rev (pre2 @ b # suf2))", "by simp"], ["proof (state)\nthis:\n  index (rev (pre2 @ b # suf2) @ []) a = length (rev (pre2 @ b # suf2))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \" x < y in fst (config\\<^sub>p (rTS []) init qs)\n                =  x < y in fst (config\\<^sub>p (rTS []) init ((((pre2 @ [b]) @ suf2) @ [a]) @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y\n    in fst (config\\<^sub>p (rTS []) init\n             ((((pre2 @ [b]) @ suf2) @ [a]) @ suf))", "by(simp add: qs2)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y\n  in fst (config\\<^sub>p (rTS []) init\n           ((((pre2 @ [b]) @ suf2) @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y\n  in fst (config\\<^sub>p (rTS []) init\n           ((((pre2 @ [b]) @ suf2) @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (config\\<^sub>p (rTS []) init\n             ((((pre2 @ [b]) @ suf2) @ [a]) @ suf)) =\n    x < y\n    in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))\n             suf) =\n    x < y\n    in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct\n     (fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (((pre2 @ [b]) @ suf2) @ [a])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (((pre2 @ [b]) @ suf2) @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (((pre2 @ [b]) @ suf2) @ [a])))\n 5. x \\<notin> set suf\n 6. y \\<notin> set suf", "using assms xqs yqs qs nosuf"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (6 subgoals):\n 1. distinct\n     (fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (((pre2 @ [b]) @ suf2) @ [a])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (((pre2 @ [b]) @ suf2) @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (((pre2 @ [b]) @ suf2) @ [a])))\n 5. x \\<notin> set suf\n 6. y \\<notin> set suf", "by(simp_all)"], ["proof (state)\nthis:\n  x < y\n  in fst (config\\<^sub>p (rTS []) init\n           ((((pre2 @ [b]) @ suf2) @ [a]) @ suf)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y\n  in fst (config\\<^sub>p (rTS []) init\n           ((((pre2 @ [b]) @ suf2) @ [a]) @ suf)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a]))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a])) =\n    x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2)) [a]) =\n    x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2))", "apply(simp add: rTS_def Step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) (pre2 @ b # suf2)))\n        a (fst (TS_step_d\n                 (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                   (init, []) (pre2 @ b # suf2))\n                 a)) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) (pre2 @ b # suf2))", "apply(simp only: TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) (pre2 @ b # suf2)))\n        a (fst ((let li = index\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. [], TS_step_d) (init, [])\n                                  (pre2 @ b # suf2)))\n                           a\n                 in if li =\n                       length\n                        (snd (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (init, [])\n                               (pre2 @ b # suf2)))\n                    then 0\n                    else let sincelast =\n                               take li\n                                (snd (Partial_Cost_Model.config'\n (\\<lambda>s. [], TS_step_d) (init, []) (pre2 @ b # suf2)));\n                             S = {x. x < a\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     (pre2 @ b # suf2)) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) (pre2 @ b # suf2)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        (pre2 @ b # suf2))) `\nS),\n                 []),\n                a #\n                snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (init, []) (pre2 @ b # suf2)))) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) (pre2 @ b # suf2))", "apply(simp only: sndTSconfig'[unfolded rTS_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) (pre2 @ b # suf2)))\n        a (fst ((let li = index (rev (pre2 @ b # suf2) @ []) a\n                 in if li = length (rev (pre2 @ b # suf2) @ []) then 0\n                    else let sincelast =\n                               take li (rev (pre2 @ b # suf2) @ []);\n                             S = {x. x < a\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     (pre2 @ b # suf2)) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) (pre2 @ b # suf2)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        (pre2 @ b # suf2))) `\nS),\n                 []),\n                a # rev (pre2 @ b # suf2) @ [])) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) (pre2 @ b # suf2))", "apply(simp only: noocc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) (pre2 @ b # suf2)))\n        a (fst ((let li = length (rev (pre2 @ b # suf2))\n                 in if li = length (rev (pre2 @ b # suf2) @ []) then 0\n                    else let sincelast =\n                               take li (rev (pre2 @ b # suf2) @ []);\n                             S = {x. x < a\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     (pre2 @ b # suf2)) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) (pre2 @ b # suf2)))\n                                  a -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        (pre2 @ b # suf2))) `\nS),\n                 []),\n                a # rev (pre2 @ b # suf2) @ [])) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) (pre2 @ b # suf2))", "by (simp add: step_def)"], ["proof (state)\nthis:\n  x < y\n  in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a])) =\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y\n  in fst (config\\<^sub>p (rTS []) init (((pre2 @ [b]) @ suf2) @ [a])) =\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2)) =\n    x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init (pre2 @ [b])) suf2) =\n    x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b]))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 4. set suf2\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 5. x \\<notin> set suf2\n 6. y \\<notin> set suf2", "using assms xqs yqs qs2 nosuf2"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  qs = pre2 @ [b] @ suf2 @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n\ngoal (6 subgoals):\n 1. distinct (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 3. y \\<in> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 4. set suf2\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init (pre2 @ [b])))\n 5. x \\<notin> set suf2\n 6. y \\<notin> set suf2", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b]))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init ((pre2 @ [b]) @ suf2)) =\n  x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b]))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) init (pre2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b])) =\n    x < y in fst (config\\<^sub>p (rTS []) init pre2)", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init pre2) [b]) =\n    x < y in fst (config\\<^sub>p (rTS []) init pre2)", "apply(simp add: rTS_def Step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre2))\n        b (fst (TS_step_d\n                 (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                   (init, []) pre2)\n                 b)) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre2)", "apply(simp only: TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre2))\n        b (fst ((let li = index\n                           (snd (Partial_Cost_Model.config'\n                                  (\\<lambda>s. [], TS_step_d) (init, [])\n                                  pre2))\n                           b\n                 in if li =\n                       length\n                        (snd (Partial_Cost_Model.config'\n                               (\\<lambda>s. [], TS_step_d) (init, []) pre2))\n                    then 0\n                    else let sincelast =\n                               take li\n                                (snd (Partial_Cost_Model.config'\n (\\<lambda>s. [], TS_step_d) (init, []) pre2));\n                             S = {x. x < b\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     pre2) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) pre2))\n                                  b -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        pre2)) `\nS),\n                 []),\n                b #\n                snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                      (init, []) pre2))) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre2)", "apply(simp only: sndTSconfig'[unfolded rTS_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step\n        (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n               (init, []) pre2))\n        b (fst ((let li = index (rev pre2 @ []) b\n                 in if li = length (rev pre2 @ []) then 0\n                    else let sincelast = take li (rev pre2 @ []);\n                             S = {x. x < b\n                                     in fst\n   (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n     pre2) \\<and>\n                                     count_list sincelast x \\<le> 1}\n                         in if S = {} then 0\n                            else index\n                                  (fst (Partial_Cost_Model.config'\n   (\\<lambda>s. [], TS_step_d) (init, []) pre2))\n                                  b -\n                                 Min (index\n (fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d) (init, [])\n        pre2)) `\nS),\n                 []),\n                b # rev pre2 @ [])) =\n    x < y\n    in fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n             (init, []) pre2)", "by(simp add: noocc2 step_def)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b])) =\n  x < y in fst (config\\<^sub>p (rTS []) init pre2)\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init (pre2 @ [b])) =\n  x < y in fst (config\\<^sub>p (rTS []) init pre2)\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init pre2) = x < y in init", "apply(rule staysuntouched')"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set pre2 \\<subseteq> set init\n 5. x \\<notin> set pre2\n 6. y \\<notin> set pre2", "using assms xqs yqs qs2"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  x \\<notin> set pre2\n  y \\<notin> set pre2\n  qs = pre2 @ [b] @ suf2 @ [a] @ suf\n\ngoal (6 subgoals):\n 1. distinct init\n 2. x \\<in> set init\n 3. y \\<in> set init\n 4. set pre2 \\<subseteq> set init\n 5. x \\<notin> set pre2\n 6. y \\<notin> set pre2", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init pre2) = x < y in init\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init pre2) = x < y in init\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "unfolding a b Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (([] @ [b]) @ [a]))", "using False"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. x < y in init =\n    x < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (([] @ [b]) @ [a]))", "apply(simp add: Step_def split_def rTS_def TS_step_d_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> x < y in init = x < y in Lxy init {x, y}", "apply(rule Lxy_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> b \\<Longrightarrow> {x, y} \\<subseteq> set init\n 2. a \\<noteq> b \\<Longrightarrow> distinct init", "using xyininit dinit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  distinct init\n\ngoal (2 subgoals):\n 1. a \\<noteq> b \\<Longrightarrow> {x, y} \\<subseteq> set init\n 2. a \\<noteq> b \\<Longrightarrow> distinct init", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in init =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case (snoc cs c)"], ["proof (state)\nthis:\n  bs = cs @ [c]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note c=this"], ["proof (state)\nthis:\n  bs = cs @ [c]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with a b"], ["proof (chain)\npicking this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]", "have \"c\\<in>set (Lxy qs {x, y})\""], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n\ngoal (1 subgoal):\n 1. c \\<in> set (Lxy qs {x, y})", "by (simp)"], ["proof (state)\nthis:\n  c \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  c \\<in> set (Lxy qs {x, y})", "have cxy: \"c\\<in>{x,y}\""], ["proof (prove)\nusing this:\n  c \\<in> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. c \\<in> {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  c \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from c pre2"], ["proof (chain)\npicking this:\n  bs = cs @ [c]\n  Lxy pre2 {x, y} = bs", "have \"Lxy pre2 {x,y} = cs @ [c]\""], ["proof (prove)\nusing this:\n  bs = cs @ [c]\n  Lxy pre2 {x, y} = bs\n\ngoal (1 subgoal):\n 1. Lxy pre2 {x, y} = cs @ [c]", "by simp"], ["proof (state)\nthis:\n  Lxy pre2 {x, y} = cs @ [c]\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with cxy"], ["proof (chain)\npicking this:\n  c \\<in> {x, y}\n  Lxy pre2 {x, y} = cs @ [c]", "obtain pre3 suf3  where cs: \"pre2 = pre3 @ [c] @ suf3\"\n                        and nosuf3: \"\\<And>e. e \\<in> {x,y} \\<Longrightarrow> e \\<notin> set suf3\" \n                        and pre3: \"Lxy pre3 {x,y} = cs\""], ["proof (prove)\nusing this:\n  c \\<in> {x, y}\n  Lxy pre2 {x, y} = cs @ [c]\n\ngoal (1 subgoal):\n 1. (\\<And>pre3 suf3.\n        \\<lbrakk>pre2 = pre3 @ [c] @ suf3;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf3;\n         Lxy pre3 {x, y} = cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using proj_Snoc"], ["proof (prove)\nusing this:\n  c \\<in> {x, y}\n  Lxy pre2 {x, y} = cs @ [c]\n  \\<lbrakk>Lxy ?qs ?S = ?as @ [?a]; ?a \\<in> ?S;\n   \\<And>pre suf.\n      \\<lbrakk>?qs = pre @ [?a] @ suf;\n       \\<And>x. x \\<in> ?S \\<Longrightarrow> x \\<notin> set suf;\n       Lxy pre ?S = ?as\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pre3 suf3.\n        \\<lbrakk>pre2 = pre3 @ [c] @ suf3;\n         \\<And>e. e \\<in> {x, y} \\<Longrightarrow> e \\<notin> set suf3;\n         Lxy pre3 {x, y} = cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  pre2 = pre3 @ [c] @ suf3\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf3\n  Lxy pre3 {x, y} = cs\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?qs=\" pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "from bs cs qs"], ["proof (chain)\npicking this:\n  pre = pre2 @ [b] @ suf2\n  pre2 = pre3 @ [c] @ suf3\n  qs = pre @ [a] @ suf", "have qs2: \"qs = ?qs\""], ["proof (prove)\nusing this:\n  pre = pre2 @ [b] @ suf2\n  pre2 = pre3 @ [c] @ suf3\n  qs = pre @ [a] @ suf\n\ngoal (1 subgoal):\n 1. qs = pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf", "by simp"], ["proof (state)\nthis:\n  qs = pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf\n\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       bs = ys @ [ya] \\<Longrightarrow>\n       x < y in fst (config\\<^sub>p (rTS []) init qs) =\n       x < y\n       in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof(cases \"c=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case True"], ["proof (state)\nthis:\n  c = a\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "(* aba *)"], ["proof (state)\nthis:\n  c = a\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "note ca=this"], ["proof (state)\nthis:\n  c = a\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"a < b in fst (config\\<^sub>p (rTS []) init qs)\n                = a < b in fst (config\\<^sub>p (rTS []) init ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b in fst (config\\<^sub>p (rTS []) init qs) =\n    a < b\n    in fst (config\\<^sub>p (rTS []) init\n             ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf))", "using qs2 True"], ["proof (prove)\nusing this:\n  qs = pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf\n  c = a\n\ngoal (1 subgoal):\n 1. a < b in fst (config\\<^sub>p (rTS []) init qs) =\n    a < b\n    in fst (config\\<^sub>p (rTS []) init\n             ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf))", "by simp"], ["proof (state)\nthis:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf))\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = a < b in fst (config\\<^sub>p (rTS []) init (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b\n    in fst (config\\<^sub>p (rTS []) init\n             ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf)) =\n    a < b\n    in fst (config\\<^sub>p (rTS []) init\n             (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) init\n               (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))\n             suf) =\n    a < b\n    in fst (config\\<^sub>p (rTS []) init\n             (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct\n     (fst (config\\<^sub>p (rTS []) init\n            (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 3. b \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 5. a \\<notin> set suf\n 6. b \\<notin> set suf", "using assms qs nosuf"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (6 subgoals):\n 1. distinct\n     (fst (config\\<^sub>p (rTS []) init\n            (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 3. b \\<in> set (fst (config\\<^sub>p (rTS []) init\n                       (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 4. set suf\n    \\<subseteq> set (fst (config\\<^sub>p (rTS []) init\n                           (pre3 @ a # (suf3 @ [b] @ suf2) @ [a])))\n 5. a \\<notin> set suf\n 6. b \\<notin> set suf", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 3. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> set suf", "using bxy xyininit"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 3. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> set suf", "apply(fast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> set suf", "using nosuf axy bxy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> set suf", "by(simp_all)"], ["proof (state)\nthis:\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf)) =\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           ((pre3 @ a # (suf3 @ [b] @ suf2) @ [a]) @ suf)) =\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b\n    in fst (config\\<^sub>p (rTS []) init\n             (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))", "apply(rule twotox[unfolded s_TS_def, simplified])"], ["proof (prove)\ngoal (6 subgoals):\n 1. count_list (suf3 @ [b] @ suf2) b \\<le> Suc 0\n 2. distinct init\n 3. a \\<in> set init\n 4. b \\<in> set init\n 5. a \\<notin> set (suf3 @ [b] @ suf2)\n 6. a \\<noteq> b", "using nosuf2 nosuf3 bxy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf3\n  b \\<in> {x, y}\n\ngoal (6 subgoals):\n 1. count_list (suf3 @ [b] @ suf2) b \\<le> Suc 0\n 2. distinct init\n 3. a \\<in> set init\n 4. b \\<in> set init\n 5. a \\<notin> set (suf3 @ [b] @ suf2)\n 6. a \\<noteq> b", "apply(simp add: count_append)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct init\n 2. a \\<in> set init\n 3. b \\<in> set init\n 4. a \\<notin> set (suf3 @ [b] @ suf2)\n 5. a \\<noteq> b", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (5 subgoals):\n 1. distinct init\n 2. a \\<in> set init\n 3. b \\<in> set init\n 4. a \\<notin> set (suf3 @ [b] @ suf2)\n 5. a \\<noteq> b", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 4. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "using axy xyininit"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (4 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 4. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "apply(fast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "using bxy xyininit"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 3. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "apply(fast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "using ab nosuf2 nosuf3 axy"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf3\n  a \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b \\<and>\n                      a \\<notin> set suf3 \\<and> a \\<notin> set suf2\n 2. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "using ab"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y;\n     distinct init\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a < b\n  in fst (config\\<^sub>p (rTS []) init\n           (pre3 @ a # (suf3 @ [b] @ suf2) @ [a]))\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs)", "have full: \"a < b in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\nusing this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. a < b in fst (config\\<^sub>p (rTS []) init qs)", "by simp"], ["proof (state)\nthis:\n  a < b in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"set (cs @ [a] @ [b]) \\<subseteq> set (Lxy qs {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cs @ [a] @ [b]) \\<subseteq> set (Lxy qs {x, y})", "using a b c"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n\ngoal (1 subgoal):\n 1. set (cs @ [a] @ [b]) \\<subseteq> set (Lxy qs {x, y})", "by auto"], ["proof (state)\nthis:\n  set (cs @ [a] @ [b]) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (cs @ [a] @ [b]) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = {x,y} \\<inter> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {x, y}) = {x, y} \\<inter> set qs", "by (rule Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set qs \\<subseteq> {x, y}", "by simp"], ["proof (state)\nthis:\n  {x, y} \\<inter> set qs \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}", "have csabxy: \"set (cs @ [a] @ [b]) \\<subseteq> {x,y}\""], ["proof (prove)\nusing this:\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set (cs @ [a] @ [b]) \\<subseteq> {x, y}", "."], ["proof (state)\nthis:\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. c = a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n 2. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xny"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof(cases \"x=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with xny ab bxy"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  a \\<noteq> b\n  b \\<in> {x, y}\n  x = a", "have bisy: \"b=y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  a \\<noteq> b\n  b \\<in> {x, y}\n  x = a\n\ngoal (1 subgoal):\n 1. b = y", "by blast"], ["proof (state)\nthis:\n  b = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have 1: \"x < y in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs)", "using full True bisy"], ["proof (prove)\nusing this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs)\n  x = a\n  b = y\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs)", "by simp"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n                  = a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [a] @ [b]) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "using a b c ca ab"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n  c = a\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "by simp"], ["proof (state)\nthis:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "apply(rule projxx)"], ["proof (prove)\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> y\n 3. y \\<in> {x, y}\n 4. [b] \\<in> {[], [y]}\n 5. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using True"], ["proof (prove)\nusing this:\n  x = a\n\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> y\n 3. y \\<in> {x, y}\n 4. [b] \\<in> {[], [y]}\n 5. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}\n 3. [b] \\<in> {[], [y]}\n 4. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using a b True ab xny Lxyinitxy csabxy"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  x = a\n  a \\<noteq> b\n  x \\<noteq> y\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n\ngoal (5 subgoals):\n 1. a \\<noteq> y\n 2. y \\<in> {x, y}\n 3. [b] \\<in> {[], [y]}\n 4. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 5. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "by(simp_all)"], ["proof (state)\nthis:\n  a < y\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using 1 True"], ["proof (prove)\nusing this:\n  a < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  x < y in fst (config\\<^sub>p (rTS []) init qs)\n  x = a\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by simp"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with axy"], ["proof (chain)\npicking this:\n  a \\<in> {x, y}\n  x \\<noteq> a", "have ay: \"a=y\""], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. a = y", "by blast"], ["proof (state)\nthis:\n  a = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with xny ab bxy"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  a \\<noteq> b\n  b \\<in> {x, y}\n  a = y", "have bisx: \"b=x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  a \\<noteq> b\n  b \\<in> {x, y}\n  a = y\n\ngoal (1 subgoal):\n 1. b = x", "by blast"], ["proof (state)\nthis:\n  b = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have 1: \"y < x in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x in fst (config\\<^sub>p (rTS []) init qs)", "using full ay bisx"], ["proof (prove)\nusing this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs)\n  a = y\n  b = x\n\ngoal (1 subgoal):\n 1. y < x in fst (config\\<^sub>p (rTS []) init qs)", "by simp"], ["proof (state)\nthis:\n  y < x in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n                  = a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [a] @ [b]) @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "using a b c ca ab"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n  c = a\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "by simp"], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < x\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [a] @ [b]) @ [a]))", "apply(rule projxx)"], ["proof (prove)\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> x\n 3. x \\<in> {x, y}\n 4. [b] \\<in> {[], [x]}\n 5. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using a b True ab xny Lxyinitxy csabxy False"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  c = a\n  a \\<noteq> b\n  x \\<noteq> y\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n  set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n  x \\<noteq> a\n\ngoal (6 subgoals):\n 1. a \\<in> {x, y}\n 2. a \\<noteq> x\n 3. x \\<in> {x, y}\n 4. [b] \\<in> {[], [x]}\n 5. set (cs @ [a] @ [b]) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "by(simp_all)"], ["proof (state)\nthis:\n  a < x\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           ((cs @ [a] @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have 2: \"a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\nusing this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"x < y in fst (config\\<^sub>p (rTS []) init qs) = \n                 (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (x < y in fst (config\\<^sub>p (rTS []) init qs) \\<or> y = x)", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    (x < y in fst (config\\<^sub>p (rTS []) init qs) \\<or> y = x)", "by(simp_all)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False", "using  1 ay"], ["proof (prove)\nusing this:\n  y < x in fst (config\\<^sub>p (rTS []) init qs)\n  a = y\n\ngoal (1 subgoal):\n 1. (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False", "by simp"], ["proof (state)\nthis:\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  (\\<not> y < x in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = (\\<not> y < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False =\n    (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "using 2 ay"], ["proof (prove)\nusing this:\n  a < x in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  a = y\n\ngoal (1 subgoal):\n 1. False =\n    (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "by simp"], ["proof (state)\nthis:\n  False =\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  False =\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y < x\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y}))) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (x < y\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     y = x) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using assms"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (3 subgoals):\n 1. y \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. x \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (x < y\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     y = x) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by(simp_all add: Lxy_set_filter)"], ["proof (state)\nthis:\n  (\\<not> y < x\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y}))) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set (cs @ [a] @ [b]) \\<subseteq> {x, y};\n     x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "case False"], ["proof (state)\nthis:\n  c \\<noteq> a\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "(* bba *)"], ["proof (state)\nthis:\n  c \\<noteq> a\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> a", "have cb: \"c=b\""], ["proof (prove)\nusing this:\n  c \\<noteq> a\n\ngoal (1 subgoal):\n 1. c = b", "using bxy cxy axy ab"], ["proof (prove)\nusing this:\n  c \\<noteq> a\n  b \\<in> {x, y}\n  c \\<in> {x, y}\n  a \\<in> {x, y}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. c = b", "by blast"], ["proof (state)\nthis:\n  c = b\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?cs = \"suf2 @ [a] @ suf\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?i = \"index ?cs a\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have aed: \"(\\<forall>j<index (suf2 @ a # suf) a. (suf2 @ a # suf) ! j \\<noteq> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<index (suf2 @ a # suf) a. (suf2 @ a # suf) ! j \\<noteq> a", "by (metis add.right_neutral axy index_Cons index_append nosuf2 nth_append nth_mem)"], ["proof (state)\nthis:\n  \\<forall>j<index (suf2 @ a # suf) a. (suf2 @ a # suf) ! j \\<noteq> a\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"?i < length ?cs      \n              \\<longrightarrow> (\\<forall>j<?i. ?cs ! j \\<noteq> ?cs ! ?i) \\<longrightarrow> ?cs ! ?i \\<noteq> b\n                \\<longrightarrow> ?cs ! ?i \\<notin> set suf3\n                \\<longrightarrow> b < ?cs ! ?i in s_TS init [] qs (length (pre3 @ [b] @ suf3 @ [b]) + ?i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (suf2 @ [a] @ suf) a < length (suf2 @ [a] @ suf) \\<longrightarrow>\n    (\\<forall>j<index (suf2 @ [a] @ suf) a.\n        (suf2 @ [a] @ suf) ! j \\<noteq>\n        (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a) \\<longrightarrow>\n    (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a \\<noteq>\n    b \\<longrightarrow>\n    (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n    \\<notin> set suf3 \\<longrightarrow>\n    b < (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n    in s_TS init [] qs\n        (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)", "apply(rule casexxy)"], ["proof (prove)\ngoal (8 subgoals):\n 1. qs = pre3 @ [b] @ suf3 @ [b] @ suf2 @ [a] @ suf\n 2. b \\<notin> set (suf2 @ [a] @ suf)\n 3. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 4. b \\<in> set init\n 5. distinct init\n 6. b \\<notin> set suf3\n 7. set pre3 \\<subseteq> set init\n 8. set suf3 \\<subseteq> set init", "using cb qs2"], ["proof (prove)\nusing this:\n  c = b\n  qs = pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf\n\ngoal (8 subgoals):\n 1. qs = pre3 @ [b] @ suf3 @ [b] @ suf2 @ [a] @ suf\n 2. b \\<notin> set (suf2 @ [a] @ suf)\n 3. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 4. b \\<in> set init\n 5. distinct init\n 6. b \\<notin> set suf3\n 7. set pre3 \\<subseteq> set init\n 8. set suf3 \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. b \\<notin> set (suf2 @ [a] @ suf)\n 2. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 3. b \\<in> set init\n 4. distinct init\n 5. b \\<notin> set suf3\n 6. set pre3 \\<subseteq> set init\n 7. set suf3 \\<subseteq> set init", "using bxy ab nosuf2 nosuf"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  a \\<noteq> b\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (7 subgoals):\n 1. b \\<notin> set (suf2 @ [a] @ suf)\n 2. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 3. b \\<in> set init\n 4. distinct init\n 5. b \\<notin> set suf3\n 6. set pre3 \\<subseteq> set init\n 7. set suf3 \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 2. b \\<in> set init\n 3. distinct init\n 4. b \\<notin> set suf3\n 5. set pre3 \\<subseteq> set init\n 6. set suf3 \\<subseteq> set init", "using bs qs qsininit"], ["proof (prove)\nusing this:\n  pre = pre2 @ [b] @ suf2\n  qs = pre @ [a] @ suf\n  set qs \\<subseteq> set init\n\ngoal (6 subgoals):\n 1. set (suf2 @ [a] @ suf) \\<subseteq> set init\n 2. b \\<in> set init\n 3. distinct init\n 4. b \\<notin> set suf3\n 5. set pre3 \\<subseteq> set init\n 6. set suf3 \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. b \\<in> set init\n 2. distinct init\n 3. b \\<notin> set suf3\n 4. set pre3 \\<subseteq> set init\n 5. set suf3 \\<subseteq> set init", "using bxy xyininit"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (5 subgoals):\n 1. b \\<in> set init\n 2. distinct init\n 3. b \\<notin> set suf3\n 4. set pre3 \\<subseteq> set init\n 5. set suf3 \\<subseteq> set init", "apply(blast)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct init\n 2. b \\<notin> set suf3\n 3. set pre3 \\<subseteq> set init\n 4. set suf3 \\<subseteq> set init", "apply(fact)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<notin> set suf3\n 2. set pre3 \\<subseteq> set init\n 3. set suf3 \\<subseteq> set init", "using nosuf3 bxy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf3\n  b \\<in> {x, y}\n\ngoal (3 subgoals):\n 1. b \\<notin> set suf3\n 2. set pre3 \\<subseteq> set init\n 3. set suf3 \\<subseteq> set init", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set pre3 \\<subseteq> set init\n 2. set suf3 \\<subseteq> set init", "using cs bs qs qsininit"], ["proof (prove)\nusing this:\n  pre2 = pre3 @ [c] @ suf3\n  pre = pre2 @ [b] @ suf2\n  qs = pre @ [a] @ suf\n  set qs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. set pre3 \\<subseteq> set init\n 2. set suf3 \\<subseteq> set init", "by(simp_all)"], ["proof (state)\nthis:\n  index (suf2 @ [a] @ suf) a < length (suf2 @ [a] @ suf) \\<longrightarrow>\n  (\\<forall>j<index (suf2 @ [a] @ suf) a.\n      (suf2 @ [a] @ suf) ! j \\<noteq>\n      (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a) \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a \\<noteq>\n  b \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  \\<notin> set suf3 \\<longrightarrow>\n  b < (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "then"], ["proof (chain)\npicking this:\n  index (suf2 @ [a] @ suf) a < length (suf2 @ [a] @ suf) \\<longrightarrow>\n  (\\<forall>j<index (suf2 @ [a] @ suf) a.\n      (suf2 @ [a] @ suf) ! j \\<noteq>\n      (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a) \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a \\<noteq>\n  b \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  \\<notin> set suf3 \\<longrightarrow>\n  b < (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)", "have inner: \"b < a in s_TS init [] qs (length (pre3 @ [b] @ suf3 @ [b]) + ?i + 1)\""], ["proof (prove)\nusing this:\n  index (suf2 @ [a] @ suf) a < length (suf2 @ [a] @ suf) \\<longrightarrow>\n  (\\<forall>j<index (suf2 @ [a] @ suf) a.\n      (suf2 @ [a] @ suf) ! j \\<noteq>\n      (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a) \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a \\<noteq>\n  b \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  \\<notin> set suf3 \\<longrightarrow>\n  b < (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)\n\ngoal (1 subgoal):\n 1. b < a\n    in s_TS init [] qs\n        (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)", "using ab nosuf3 axy bxy aed"], ["proof (prove)\nusing this:\n  index (suf2 @ [a] @ suf) a < length (suf2 @ [a] @ suf) \\<longrightarrow>\n  (\\<forall>j<index (suf2 @ [a] @ suf) a.\n      (suf2 @ [a] @ suf) ! j \\<noteq>\n      (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a) \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a \\<noteq>\n  b \\<longrightarrow>\n  (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  \\<notin> set suf3 \\<longrightarrow>\n  b < (suf2 @ [a] @ suf) ! index (suf2 @ [a] @ suf) a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)\n  a \\<noteq> b\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf3\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  \\<forall>j<index (suf2 @ a # suf) a. (suf2 @ a # suf) ! j \\<noteq> a\n\ngoal (1 subgoal):\n 1. b < a\n    in s_TS init [] qs\n        (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)", "by(simp)"], ["proof (state)\nthis:\n  b < a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?n = \"(length (pre3 @ [b] @ suf3 @ [b]) + ?i + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?inner=\"(config\\<^sub>p (rTS []) init (take (length (pre3 @ [b] @ suf3 @ [b]) + ?i + 1) ?qs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"b < a in fst (config\\<^sub>p (rTS []) init qs)\n              = b < a in fst (config\\<^sub>p (rTS []) init (take ?n ?qs @ drop ?n ?qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a in fst (config\\<^sub>p (rTS []) init qs) =\n    b < a\n    in fst (config\\<^sub>p (rTS []) init\n             (take\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)))", "using qs2"], ["proof (prove)\nusing this:\n  qs = pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf\n\ngoal (1 subgoal):\n 1. b < a in fst (config\\<^sub>p (rTS []) init qs) =\n    b < a\n    in fst (config\\<^sub>p (rTS []) init\n             (take\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)))", "by simp"], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) init qs) =\n  b < a\n  in fst (config\\<^sub>p (rTS []) init\n           (take\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n            drop\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) init qs) =\n  b < a\n  in fst (config\\<^sub>p (rTS []) init\n           (take\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n            drop\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = b < a in fst (config' (rTS []) ?inner suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (config\\<^sub>p (rTS []) init\n             (take\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf))) =\n    b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             suf)", "apply(simp only: config_append drop_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             (drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               pre3 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3)\n               [c] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c])\n               suf3 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3)\n               [b] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b])\n               suf2 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b] -\n                length suf2)\n               [a] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b] -\n                length suf2 -\n                length [a])\n               suf)) =\n    b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             suf)", "using nosuf2 axy"], ["proof (prove)\nusing this:\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf2\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             (drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1)\n               pre3 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3)\n               [c] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c])\n               suf3 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3)\n               [b] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b])\n               suf2 @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b] -\n                length suf2)\n               [a] @\n              drop\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1 -\n                length pre3 -\n                length [c] -\n                length suf3 -\n                length [b] -\n                length suf2 -\n                length [a])\n               suf)) =\n    b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             suf)", "by(simp add: index_append config_append)"], ["proof (state)\nthis:\n  b < a\n  in fst (config\\<^sub>p (rTS []) init\n           (take\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n            drop\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf))) =\n  b < a\n  in fst (Partial_Cost_Model.config' (rTS [])\n           (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1))\n           suf)\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  b < a\n  in fst (config\\<^sub>p (rTS []) init\n           (take\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf) @\n            drop\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)\n             (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf))) =\n  b < a\n  in fst (Partial_Cost_Model.config' (rTS [])\n           (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1))\n           suf)\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = b < a in fst ?inner\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n               (length (pre3 @ [b] @ suf3 @ [b]) +\n                index (suf2 @ [a] @ suf) a +\n                1))\n             suf) =\n    b < a\n    in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1))", "apply(rule staysuntouched)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct\n     (fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n            (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a +\n             1)))\n 2. b \\<in> set (fst (TSdet init []\n                       (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                       (length (pre3 @ [b] @ suf3 @ [b]) +\n                        index (suf2 @ [a] @ suf) a +\n                        1)))\n 3. a \\<in> set (fst (TSdet init []\n                       (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                       (length (pre3 @ [b] @ suf3 @ [b]) +\n                        index (suf2 @ [a] @ suf) a +\n                        1)))\n 4. set suf\n    \\<subseteq> set (fst (TSdet init []\n                           (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                           (length (pre3 @ [b] @ suf3 @ [b]) +\n                            index (suf2 @ [a] @ suf) a +\n                            1)))\n 5. b \\<notin> set suf\n 6. a \\<notin> set suf", "using assms bxy xyininit  qs nosuf"], ["proof (prove)\nusing this:\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n  qs = pre @ [a] @ suf\n  ?e \\<in> {x, y} \\<Longrightarrow> ?e \\<notin> set suf\n\ngoal (6 subgoals):\n 1. distinct\n     (fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n            (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a +\n             1)))\n 2. b \\<in> set (fst (TSdet init []\n                       (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                       (length (pre3 @ [b] @ suf3 @ [b]) +\n                        index (suf2 @ [a] @ suf) a +\n                        1)))\n 3. a \\<in> set (fst (TSdet init []\n                       (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                       (length (pre3 @ [b] @ suf3 @ [b]) +\n                        index (suf2 @ [a] @ suf) a +\n                        1)))\n 4. set suf\n    \\<subseteq> set (fst (TSdet init []\n                           (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n                           (length (pre3 @ [b] @ suf3 @ [b]) +\n                            index (suf2 @ [a] @ suf) a +\n                            1)))\n 5. b \\<notin> set suf\n 6. a \\<notin> set suf", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf", "using bxy xyininit"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> b \\<in> set init\n 2. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf", "using axy xyininit"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set init \\<and>\n             set pre \\<subseteq> set init \\<and>\n             set suf \\<subseteq> set init;\n     x \\<in> set init \\<and> y \\<in> set init; x \\<noteq> y; distinct init;\n     b = x \\<or> b = y; qs = pre @ a # suf;\n     \\<And>e.\n        e = x \\<or> e = y \\<Longrightarrow> e \\<notin> set suf\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set suf", "by (blast)"], ["proof (state)\nthis:\n  b < a\n  in fst (Partial_Cost_Model.config' (rTS [])\n           (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1))\n           suf) =\n  b < a\n  in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n           (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a +\n            1))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  b < a\n  in fst (Partial_Cost_Model.config' (rTS [])\n           (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1))\n           suf) =\n  b < a\n  in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n           (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a +\n            1))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)) =\n    True", "using inner"], ["proof (prove)\nusing this:\n  b < a\n  in s_TS init [] qs\n      (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a + 1)\n\ngoal (1 subgoal):\n 1. b < a\n    in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n             (length (pre3 @ [b] @ suf3 @ [b]) +\n              index (suf2 @ [a] @ suf) a +\n              1)) =\n    True", "by(simp add: s_TS_def qs2)"], ["proof (state)\nthis:\n  b < a\n  in fst (TSdet init [] (pre3 @ [c] @ suf3 @ [b] @ suf2 @ [a] @ suf)\n           (length (pre3 @ [b] @ suf3 @ [b]) + index (suf2 @ [a] @ suf) a +\n            1)) =\n  True\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  b < a in fst (config\\<^sub>p (rTS []) init qs) = True", "have full: \"b < a in fst (config\\<^sub>p (rTS []) init qs)\""], ["proof (prove)\nusing this:\n  b < a in fst (config\\<^sub>p (rTS []) init qs) = True\n\ngoal (1 subgoal):\n 1. b < a in fst (config\\<^sub>p (rTS []) init qs)", "by simp"], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"set (cs @ [b] @ []) \\<subseteq> set (Lxy qs {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cs @ [b] @ []) \\<subseteq> set (Lxy qs {x, y})", "using a b c"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n\ngoal (1 subgoal):\n 1. set (cs @ [b] @ []) \\<subseteq> set (Lxy qs {x, y})", "by auto"], ["proof (state)\nthis:\n  set (cs @ [b] @ []) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (cs @ [b] @ []) \\<subseteq> set (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = {x,y} \\<inter> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {x, y}) = {x, y} \\<inter> set qs", "by (rule Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (Lxy qs {x, y}) = {x, y} \\<inter> set qs\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set qs \\<subseteq> {x, y}", "by simp"], ["proof (state)\nthis:\n  {x, y} \\<inter> set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  set (cs @ [b] @ []) \\<subseteq> {x, y}", "have csbxy: \"set (cs @ [b] @ []) \\<subseteq> {x,y}\""], ["proof (prove)\nusing this:\n  set (cs @ [b] @ []) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set (cs @ [b] @ []) \\<subseteq> {x, y}", "."], ["proof (state)\nthis:\n  set (cs @ [b] @ []) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"set (Lxy init {x, y}) = {x,y} \\<inter> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y} \\<inter> set init", "by(rule Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y} \\<inter> set init\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y} \\<inter> set init\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "by fast"], ["proof (state)\nthis:\n  {x, y} \\<inter> set init = {x, y}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  {x, y} \\<inter> set init = {x, y}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots> = {b,a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {b, a}", "using axy bxy ab"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. {x, y} = {b, a}", "by fast"], ["proof (state)\nthis:\n  {x, y} = {b, a}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  set (Lxy init {x, y}) = {b, a}", "have r: \"set (Lxy init {x, y}) = {b, a}\""], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {b, a}\n\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {b, a}", "."], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {b, a}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "let ?confbef=\"(config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [b] @ []) @ [b]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have f1: \"b < a in fst ?confbef\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [b] @ []) @ [b]))", "apply(rule projxx)"], ["proof (prove)\ngoal (6 subgoals):\n 1. b \\<in> {x, y}\n 2. b \\<noteq> a\n 3. a \\<in> {x, y}\n 4. [] \\<in> {[], [a]}\n 5. set (cs @ [b] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "using bxy ab axy a b c csbxy Lxyinitxy"], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  a \\<noteq> b\n  a \\<in> {x, y}\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n  set (cs @ [b] @ []) \\<subseteq> {x, y}\n  Lxy init {x, y} \\<in> {[x, y], [y, x]}\n\ngoal (6 subgoals):\n 1. b \\<in> {x, y}\n 2. b \\<noteq> a\n 3. a \\<in> {x, y}\n 4. [] \\<in> {[], [a]}\n 5. set (cs @ [b] @ []) \\<subseteq> {x, y}\n 6. Lxy init {x, y} \\<in> {[x, y], [y, x]}", "by(simp_all)"], ["proof (state)\nthis:\n  b < a\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [b] @ []) @ [b]))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have 1: \"fst ?confbef = [b,a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n          ((cs @ [b] @ []) @ [b])) =\n    [b, a]", "apply(rule oneposs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n               ((cs @ [b] @ []) @ [b]))) =\n    {b, a}\n 2. b \\<noteq> a\n 3. distinct\n     (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n            ((cs @ [b] @ []) @ [b])))\n 4. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [b] @ []) @ [b]))", "using ab axy bxy xyininit Lxy_distinct[OF dinit] f1 r"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  {x, y} \\<subseteq> set init\n  distinct (Lxy init ?S)\n  b < a\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [b] @ []) @ [b]))\n  set (Lxy init {x, y}) = {b, a}\n\ngoal (4 subgoals):\n 1. set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n               ((cs @ [b] @ []) @ [b]))) =\n    {b, a}\n 2. b \\<noteq> a\n 3. distinct\n     (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n            ((cs @ [b] @ []) @ [b])))\n 4. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             ((cs @ [b] @ []) @ [b]))", "by(simp_all)"], ["proof (state)\nthis:\n  fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [b] @ []) @ [b])) =\n  [b, a]\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have 2: \"snd (Partial_Cost_Model.config'\n                           (\\<lambda>s. [], TS_step_d)\n                           (Lxy init {x, y}, [])\n                           (cs @ [b, b])) = [b,b]@(rev cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n          (Lxy init {x, y}, []) (cs @ [b, b])) =\n    [b, b] @ rev cs", "using sndTSdet[of \"length (cs @ [b, b])\" \"(cs @ [b, b])\", unfolded rTS_def]"], ["proof (prove)\nusing this:\n  length (cs @ [b, b]) \\<le> length (cs @ [b, b]) \\<Longrightarrow>\n  snd (config\\<^sub>p (\\<lambda>s. ?initH, TS_step_d) ?init\n        (take (length (cs @ [b, b])) (cs @ [b, b]))) =\n  rev (take (length (cs @ [b, b])) (cs @ [b, b])) @ ?initH\n\ngoal (1 subgoal):\n 1. snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n          (Lxy init {x, y}, []) (cs @ [b, b])) =\n    [b, b] @ rev cs", "by(simp)"], ["proof (state)\nthis:\n  snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (cs @ [b, b])) =\n  [b, b] @ rev cs\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n              = b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (((cs @ [b] @ []) @ [b])@[a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             (((cs @ [b] @ []) @ [b]) @ [a]))", "using a b c cb"], ["proof (prove)\nusing this:\n  Lxy qs {x, y} = as @ [a]\n  as = bs @ [b]\n  bs = cs @ [c]\n  c = b\n\ngoal (1 subgoal):\n 1. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n    b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             (((cs @ [b] @ []) @ [b]) @ [a]))", "by(simp)"], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  b < a\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           (((cs @ [b] @ []) @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})) =\n  b < a\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           (((cs @ [b] @ []) @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n             (((cs @ [b] @ []) @ [b]) @ [a]))", "apply(subst config_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) (Lxy init {x, y})\n               ((cs @ [b] @ []) @ [b]))\n             [a])", "using 1 2 ab"], ["proof (prove)\nusing this:\n  fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) ((cs @ [b] @ []) @ [b])) =\n  [b, a]\n  snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n        (Lxy init {x, y}, []) (cs @ [b, b])) =\n  [b, b] @ rev cs\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b < a\n    in fst (Partial_Cost_Model.config' (rTS [])\n             (config\\<^sub>p (rTS []) (Lxy init {x, y})\n               ((cs @ [b] @ []) @ [b]))\n             [a])", "apply(simp add: step_def Step_def split_def rTS_def TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n                   (Lxy init {x, y}, []) (cs @ [b, b])) =\n             [b, a];\n     snd (Partial_Cost_Model.config' (\\<lambda>s. [], TS_step_d)\n           (Lxy init {x, y}, []) (cs @ [b, b])) =\n     b # b # rev cs;\n     a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> ((\\<forall>x.\n                           b \\<noteq> x \\<longrightarrow>\n                           x < a in [b, a] \\<longrightarrow>\n                           \\<not> count_list\n                                   (take (index (rev cs) a) (rev cs)) x\n                                  \\<le> Suc 0) \\<longrightarrow>\n                       b < a in [b, a]) \\<and>\n                      ((\\<exists>x.\n                           b \\<noteq> x \\<and>\n                           (b \\<noteq> x \\<longrightarrow>\n                            x < a in [b, a] \\<and>\n                            count_list (take (index (rev cs) a) (rev cs)) x\n                            \\<le> Suc 0)) \\<longrightarrow>\n                       (index (rev cs) a = length cs \\<longrightarrow>\n                        b < a in [b, a]) \\<and>\n                       (index (rev cs) a \\<noteq>\n                        length cs \\<longrightarrow>\n                        b < a\n                        in mtf2\n                            (Suc 0 -\n                             (MIN x\\<in>{x.\n   b \\<noteq> x \\<and>\n   (b \\<noteq> x \\<longrightarrow>\n    x < a in [b, a] \\<and>\n    count_list (take (index (rev cs) a) (rev cs)) x \\<le> Suc 0)} \\<inter>\n  {x. b \\<noteq> x}.\n                                 Suc (if a = x then 0 else index [] x + 1)))\n                            a [b, a]))", "by(simp add: before_in_def)"], ["proof (state)\nthis:\n  b < a\n  in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n           (((cs @ [b] @ []) @ [b]) @ [a]))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have projected: \"b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\nusing this:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "have 1: \"{x,y} = {a,b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {a, b}", "using ab axy bxy"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. {x, y} = {a, b}", "by fast"], ["proof (state)\nthis:\n  {x, y} = {a, b}\n\ngoal (1 subgoal):\n 1. c \\<noteq> a \\<Longrightarrow>\n    x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "with xny"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {a, b}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {a, b}\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "proof(cases \"x=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with 1 xny"], ["proof (chain)\npicking this:\n  {x, y} = {a, b}\n  x \\<noteq> y\n  x = a", "have y: \"y=b\""], ["proof (prove)\nusing this:\n  {x, y} = {a, b}\n  x \\<noteq> y\n  x = a\n\ngoal (1 subgoal):\n 1. y = b", "by fast"], ["proof (state)\nthis:\n  y = b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"a < b in fst (config\\<^sub>p (rTS []) init qs) = \n                 (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b in fst (config\\<^sub>p (rTS []) init qs) =\n    (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. a < b in fst (config\\<^sub>p (rTS []) init qs) =\n    (a < b in fst (config\\<^sub>p (rTS []) init qs) \\<or> b = a)", "using binit ainit ab"], ["proof (prove)\nusing this:\n  b \\<in> set init\n  a \\<in> set init\n  a \\<noteq> b\n\ngoal (3 subgoals):\n 1. b \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) init qs))\n 3. a < b in fst (config\\<^sub>p (rTS []) init qs) =\n    (a < b in fst (config\\<^sub>p (rTS []) init qs) \\<or> b = a)", "by(simp_all)"], ["proof (state)\nthis:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs)) = False", "using  full"], ["proof (prove)\nusing this:\n  b < a in fst (config\\<^sub>p (rTS []) init qs)\n\ngoal (1 subgoal):\n 1. (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs)) = False", "by simp"], ["proof (state)\nthis:\n  (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  (\\<not> b < a in fst (config\\<^sub>p (rTS []) init qs)) = False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = (\\<not> b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False =\n    (\\<not> b < a\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "using projected"], ["proof (prove)\nusing this:\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. False =\n    (\\<not> b < a\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y})))", "by simp"], ["proof (state)\nthis:\n  False =\n  (\\<not> b < a\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  False =\n  (\\<not> b < a\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y})))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "have \"\\<dots> = a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> b < a\n            in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                     (Lxy qs {x, y}))) =\n    a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (a < b\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     b = a) =\n    a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using binit ainit ab axy bxy"], ["proof (prove)\nusing this:\n  b \\<in> set init\n  a \\<in> set init\n  a \\<noteq> b\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n\ngoal (3 subgoals):\n 1. b \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 2. a \\<in> set (fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                       (Lxy qs {x, y})))\n 3. (a < b\n     in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n              (Lxy qs {x, y})) \\<or>\n     b = a) =\n    a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by(simp_all add: Lxy_set_filter)"], ["proof (state)\nthis:\n  (\\<not> b < a\n          in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                   (Lxy qs {x, y}))) =\n  a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x = a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))\n 2. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "using True y"], ["proof (prove)\nusing this:\n  a < b in fst (config\\<^sub>p (rTS []) init qs) =\n  a < b in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  x = a\n  y = b\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by simp"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with 1 xny"], ["proof (chain)\npicking this:\n  {x, y} = {a, b}\n  x \\<noteq> y\n  x \\<noteq> a", "have y: \"y=a\" \"x=b\""], ["proof (prove)\nusing this:\n  {x, y} = {a, b}\n  x \\<noteq> y\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. y = a &&& x = b", "by fast+"], ["proof (state)\nthis:\n  y = a\n  x = b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; {x, y} = {a, b}; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> x < y in fst (config\\<^sub>p (rTS []) init qs) =\n                      x < y\n                      in fst (config\\<^sub>p (rTS []) (Lxy init {x, y})\n                               (Lxy qs {x, y}))", "with full projected"], ["proof (chain)\npicking this:\n  b < a in fst (config\\<^sub>p (rTS []) init qs)\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  y = a\n  x = b", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a in fst (config\\<^sub>p (rTS []) init qs)\n  b < a in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n  y = a\n  x = b\n\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by fast"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "(* end of (c=a) *)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "(* end of snoc cs c *)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "(* end of (a=b) *)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "(* end snoc bs b *)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "(* end snoc as a *)"], ["proof (state)\nthis:\n  x < y in fst (config\\<^sub>p (rTS []) init qs) =\n  x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n    Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n     (Lxy init {x, y})", "unfolding Pbefore_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n       (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n        (\\<lambda>is. return_pmf (init, is)))\n       qs) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n       (fst (Partial_Cost_Model.embed (rTS [])) (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "apply(subst config_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (return_pmf (config\\<^sub>p (rTS []) init qs)) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n       (fst (Partial_Cost_Model.embed (rTS [])) (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "apply(subst config_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (return_pmf (config\\<^sub>p (rTS []) init qs)) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (return_pmf\n       (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y})))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst (config\\<^sub>p (rTS []) init qs) =\n    x < y in fst (config\\<^sub>p (rTS []) (Lxy init {x, y}) (Lxy qs {x, y}))", "by (rule A)"], ["proof (state)\nthis:\n  Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) qs init =\n  Pbefore_in x y (Partial_Cost_Model.embed (rTS [])) (Lxy qs {x, y})\n   (Lxy init {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem TS_pairwise: \"pairwise (embed (rTS []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise (Partial_Cost_Model.embed (rTS []))", "apply(rule pairwise_property_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> Pbefore_in x y (Partial_Cost_Model.embed (rTS []))\n                          qs init =\n                         Pbefore_in x y (Partial_Cost_Model.embed (rTS []))\n                          (Lxy qs {x, y}) (Lxy init {x, y})\n 2. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf\n                       (snd (Partial_Cost_Model.embed (rTS [])) xa r).\n          snd (fst z) = []", "apply(rule TS_pairwise')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> qs \\<in> {xs. set xs \\<subseteq> set init}\n 2. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> {(x, y).\n                                x \\<in> set init \\<and>\n                                y \\<in> set init \\<and> x \\<noteq> y}\n 3. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y\n 4. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> distinct init\n 5. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf\n                       (snd (Partial_Cost_Model.embed (rTS [])) xa r).\n          snd (fst z) = []", "by (simp_all add: rTS_def TS_step_d_def)"], ["", "subsection \"TS is 2-compet\""], ["", "lemma TS_compet':   \"pairwise (embed (rTS [])) \\<Longrightarrow> \n      \\<forall>s0\\<in>{init::(nat list). distinct init \\<and> init\\<noteq>[]}. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. T\\<^sub>p_on_rand (embed (rTS [])) s0 qs \\<le> (2::real) *  T\\<^sub>p_opt s0 qs + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed (rTS [])) \\<Longrightarrow>\n    \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n              (fst (Partial_Cost_Model.embed (rTS [])) s0 \\<bind>\n               (\\<lambda>is. return_pmf (s0, is)))\n              qs\n             \\<le> 2 * real (T\\<^sub>p_opt s0 qs) + b", "unfolding rTS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand'\n              (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n              (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                s0 \\<bind>\n               (\\<lambda>is. return_pmf (s0, is)))\n              qs\n             \\<le> 2 * real (T\\<^sub>p_opt s0 qs) + b", "proof (rule factoringlemma_withconstant, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand'\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                 (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                   (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> 2 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b\n 6. \\<And>is s q.\n       List_Factoring.pairwise\n        (Partial_Cost_Model.embed\n          (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n       \\<forall>((free, paid), uu_)\n                \\<in>set_pmf\n                      (snd (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                        (s, is) q).\n          paid = []\n 7. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case 5"], ["proof (state)\nthis:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n\ngoal (7 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand'\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                 (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                   (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> 2 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b\n 6. \\<And>is s q.\n       List_Factoring.pairwise\n        (Partial_Cost_Model.embed\n          (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n       \\<forall>((free, paid), uu_)\n                \\<in>set_pmf\n                      (snd (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                        (s, is) q).\n          paid = []\n 7. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand'\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                 (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                   (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> 2 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand'\n                                   (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                   (fst (Partial_Cost_Model.embed\n    (\\<lambda>s. [], TS_step_d))\n                                     (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> 2 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "case (1 init)"], ["proof (state)\nthis:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand'\n                                   (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                   (fst (Partial_Cost_Model.embed\n    (\\<lambda>s. [], TS_step_d))\n                                     (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> 2 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "note out=this"], ["proof (state)\nthis:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand'\n                                   (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                   (fst (Partial_Cost_Model.embed\n    (\\<lambda>s. [], TS_step_d))\n                                     (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> 2 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n          \\<forall>(x, y)\n                   \\<in>{(x, y).\n                         x \\<in> set init \\<and>\n                         y \\<in> set init \\<and> x < y}.\n             T\\<^sub>p_on_rand'\n              (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n              (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                (Lxy init {x, y}) \\<bind>\n               (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n              (Lxy qs {x, y})\n             \\<le> 2 *\n                   real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                   b", "apply(rule exI[where x=2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 \\<and>\n    (\\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n        \\<forall>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n           T\\<^sub>p_on_rand'\n            (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n            (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n              (Lxy init {x, y}) \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n            (Lxy qs {x, y})\n           \\<le> 2 *\n                 real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                 2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qs.\n       set qs \\<subseteq> set init \\<longrightarrow>\n       (\\<forall>a b.\n           a \\<in> set init \\<and>\n           b \\<in> set init \\<and> a < b \\<longrightarrow>\n           T\\<^sub>p_on_rand'\n            (\\<lambda>s. return_pmf [],\n             \\<lambda>s r. return_pmf (TS_step_d s r))\n            (return_pmf [] \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n            (Lxy qs {a, b})\n           \\<le> 2 *\n                 real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) +\n                 2)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "case (1 qs a b)"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b", "have a: \"a\\<noteq>b\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have twist: \"{a,b}={b, a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} = {b, a}", "by auto"], ["proof (state)\nthis:\n  {a, b} = {b, a}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have b1: \"set (Lxy qs {a, b}) \\<subseteq> {a, b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {a, b}) \\<subseteq> {a, b}", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>z. z \\<in> {a, b}) qs) \\<subseteq> {a, b}", "by auto"], ["proof (state)\nthis:\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "with this[unfolded twist]"], ["proof (chain)\npicking this:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}", "have b2: \"set (Lxy qs {b, a}) \\<subseteq> {b, a}\""], ["proof (prove)\nusing this:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. set (Lxy qs {b, a}) \\<subseteq> {b, a}", "by(auto)"], ["proof (state)\nthis:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have \"set (Lxy init {a, b}) = {a,b} \\<inter> (set init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {a, b}) = {a, b} \\<inter> set init", "apply(induct init)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (Lxy [] {a, b}) = {a, b} \\<inter> set []\n 2. \\<And>aa init.\n       set (Lxy init {a, b}) = {a, b} \\<inter> set init \\<Longrightarrow>\n       set (Lxy (aa # init) {a, b}) = {a, b} \\<inter> set (aa # init)", "unfolding Lxy_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (filter (\\<lambda>z. z \\<in> {a, b}) []) = {a, b} \\<inter> set []\n 2. \\<And>aa init.\n       set (filter (\\<lambda>z. z \\<in> {a, b}) init) =\n       {a, b} \\<inter> set init \\<Longrightarrow>\n       set (filter (\\<lambda>z. z \\<in> {a, b}) (aa # init)) =\n       {a, b} \\<inter> set (aa # init)", "by(auto)"], ["proof (state)\nthis:\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "with 1"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init", "have A: \"set (Lxy init {a, b}) = {a,b}\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init\n\ngoal (1 subgoal):\n 1. set (Lxy init {a, b}) = {a, b}", "by auto"], ["proof (state)\nthis:\n  set (Lxy init {a, b}) = {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have \"finite {a,b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a, b}", "by auto"], ["proof (state)\nthis:\n  finite {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "from out"], ["proof (chain)\npicking this:\n  distinct init\n  init \\<noteq> []", "have B: \"distinct (Lxy init {a, b})\""], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {a, b})", "unfolding Lxy_def"], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>z. z \\<in> {a, b}) init)", "by auto"], ["proof (state)\nthis:\n  distinct (Lxy init {a, b})\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have C: \"length (Lxy init {a, b}) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "using distinct_card[OF B, unfolded A]"], ["proof (prove)\nusing this:\n  card {a, b} = length (Lxy init {a, b})\n\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "using a"], ["proof (prove)\nusing this:\n  card {a, b} = length (Lxy init {a, b})\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "by auto"], ["proof (state)\nthis:\n  length (Lxy init {a, b}) = 2\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have \"{xs. set xs = {a,b} \\<and> distinct xs \\<and> length xs =(2::nat)} \n                    = { [a,b], [b,a] }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n    {[a, b], [b, a]}", "apply(auto simp: a a[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "case (1 xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [a, b]\n  set xs = {a, b}\n  distinct xs\n  length xs = 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from 1(4)"], ["proof (chain)\npicking this:\n  length xs = 2", "obtain x xs' where r:\"xs=x#xs'\""], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv add_2_eq_Suc' append_Nil length_append)"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "with 1(4)"], ["proof (chain)\npicking this:\n  length xs = 2\n  xs = x # xs'", "have \"length xs' = 1\""], ["proof (prove)\nusing this:\n  length xs = 2\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. length xs' = 1", "by auto"], ["proof (state)\nthis:\n  length xs' = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "then"], ["proof (chain)\npicking this:\n  length xs' = 1", "obtain y where s: \"[y] = xs'\""], ["proof (prove)\nusing this:\n  length xs' = 1\n\ngoal (1 subgoal):\n 1. (\\<And>y. [y] = xs' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis One_nat_def length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  [y] = xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from r s"], ["proof (chain)\npicking this:\n  xs = x # xs'\n  [y] = xs'", "have t: \"[x,y] = xs\""], ["proof (prove)\nusing this:\n  xs = x # xs'\n  [y] = xs'\n\ngoal (1 subgoal):\n 1. [x, y] = xs", "by auto"], ["proof (state)\nthis:\n  [x, y] = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "moreover"], ["proof (state)\nthis:\n  [x, y] = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from t 1(1)"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]", "have \"x=b\""], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n\ngoal (1 subgoal):\n 1. x = b", "using doubleton_eq_iff 1(2)"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n  ({?a, ?b} = {?c, ?d}) =\n  (?a = ?c \\<and> ?b = ?d \\<or> ?a = ?d \\<and> ?b = ?c)\n  set xs = {a, b}\n\ngoal (1 subgoal):\n 1. x = b", "by fastforce"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "moreover"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from t 1(1)"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]", "have \"y=a\""], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n\ngoal (1 subgoal):\n 1. y = a", "using doubleton_eq_iff 1(2)"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n  ({?a, ?b} = {?c, ?d}) =\n  (?a = ?c \\<and> ?b = ?d \\<or> ?a = ?d \\<and> ?b = ?c)\n  set xs = {a, b}\n\ngoal (1 subgoal):\n 1. y = a", "by fastforce"], ["proof (state)\nthis:\n  y = a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "ultimately"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  x = b\n  y = a", "show ?case"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  x = b\n  y = a\n\ngoal (1 subgoal):\n 1. xs = [b, a]", "by auto"], ["proof (state)\nthis:\n  xs = [b, a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "with A B C"], ["proof (chain)\npicking this:\n  set (Lxy init {a, b}) = {a, b}\n  distinct (Lxy init {a, b})\n  length (Lxy init {a, b}) = 2\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}", "have pos: \"(Lxy init {a, b}) = [a,b]\n                  \\<or> (Lxy init {a, b}) = [b,a]\""], ["proof (prove)\nusing this:\n  set (Lxy init {a, b}) = {a, b}\n  distinct (Lxy init {a, b})\n  length (Lxy init {a, b}) = 2\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}\n\ngoal (1 subgoal):\n 1. Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]", "by auto"], ["proof (state)\nthis:\n  Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "{"], ["proof (state)\nthis:\n  Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "fix a::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "fix b::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "fix qs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "assume as: \"a \\<noteq> b\" \"set qs \\<subseteq> {a, b}\""], ["proof (state)\nthis:\n  a \\<noteq> b\n  set qs \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "have \"T_on_rand' (embed (rTS [])) (fst (embed (rTS [])) [a,b] \\<bind> (\\<lambda>is. return_pmf ([a,b], is))) qs\n                    = T\\<^sub>p_on (rTS []) [a, b] qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n     (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n      (\\<lambda>is. return_pmf ([a, b], is)))\n     qs =\n    real (T\\<^sub>p_on (rTS []) [a, b] qs)", "by (rule  T_on_embed[symmetric])"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   qs =\n  real (T\\<^sub>p_on (rTS []) [a, b] qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   qs =\n  real (T\\<^sub>p_on (rTS []) [a, b] qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "from as"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  set qs \\<subseteq> {a, b}", "have \"\\<dots> \\<le> 2 * T\\<^sub>p_opt [a, b] qs + 2\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  set qs \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p_on (rTS []) [a, b] qs)\n    \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)", "using TS_OPT2'"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  set qs \\<subseteq> {a, b}\n  \\<lbrakk>?x \\<noteq> ?y; set ?\\<sigma> \\<subseteq> {?x, ?y}\\<rbrakk>\n  \\<Longrightarrow> real (T\\<^sub>p_on (rTS []) [?x, ?y] ?\\<sigma>)\n                    \\<le> 2 * real (T\\<^sub>p_opt [?x, ?y] ?\\<sigma>) + 2\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p_on (rTS []) [a, b] qs)\n    \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)", "by fastforce"], ["proof (state)\nthis:\n  real (T\\<^sub>p_on (rTS []) [a, b] qs)\n  \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   qs\n  \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)", "have \"T_on_rand' (embed (rTS [])) (fst (embed (rTS [])) [a,b] \\<bind> (\\<lambda>is. return_pmf ([a,b], is))) qs\n                    \\<le> 2 * T\\<^sub>p_opt [a, b] qs + 2\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   qs\n  \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n     (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n      (\\<lambda>is. return_pmf ([a, b], is)))\n     qs\n    \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   qs\n  \\<le> real (2 * T\\<^sub>p_opt [a, b] qs + 2)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 \\<noteq> ?ba2; set ?qsa2 \\<subseteq> {?aa2, ?ba2}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n                     (fst (Partial_Cost_Model.embed (rTS []))\n                       [?aa2, ?ba2] \\<bind>\n                      (\\<lambda>is. return_pmf ([?aa2, ?ba2], is)))\n                     ?qsa2\n                    \\<le> real (2 * T\\<^sub>p_opt [?aa2, ?ba2] ?qsa2 + 2)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "note ye=this"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 \\<noteq> ?ba2; set ?qsa2 \\<subseteq> {?aa2, ?ba2}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n                     (fst (Partial_Cost_Model.embed (rTS []))\n                       [?aa2, ?ba2] \\<bind>\n                      (\\<lambda>is. return_pmf ([?aa2, ?ba2], is)))\n                     ?qsa2\n                    \\<le> real (2 * T\\<^sub>p_opt [?aa2, ?ba2] ?qsa2 + 2)\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand'\n                          (\\<lambda>s. return_pmf [],\n                           \\<lambda>s r. return_pmf (TS_step_d s r))\n                          (return_pmf [] \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 2 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) +\n                               2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2", "apply(cases \"(Lxy init {a, b}) = [a,b]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Lxy init {a, b} = [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2\n 2. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2", "using ye[OF a b1, unfolded rTS_def]"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n   (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n     [a, b] \\<bind>\n    (\\<lambda>is. return_pmf ([a, b], is)))\n   (Lxy qs {a, b})\n  \\<le> real (2 * T\\<^sub>p_opt [a, b] (Lxy qs {a, b}) + 2)\n\ngoal (2 subgoals):\n 1. Lxy init {a, b} = [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2\n 2. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2", "using pos ye[OF a[symmetric] b2, unfolded rTS_def]"], ["proof (prove)\nusing this:\n  Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n   (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n     [b, a] \\<bind>\n    (\\<lambda>is. return_pmf ([b, a], is)))\n   (Lxy qs {b, a})\n  \\<le> real (2 * T\\<^sub>p_opt [b, a] (Lxy qs {b, a}) + 2)\n\ngoal (1 subgoal):\n 1. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand'\n     (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n     (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2", "by(simp add: twist)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand'\n   (\\<lambda>s. return_pmf [], \\<lambda>s r. return_pmf (TS_step_d s r))\n   (return_pmf [] \\<bind> (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n   (Lxy qs {a, b})\n  \\<le> 2 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b\\<ge>0.\n     \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n        \\<forall>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n           T\\<^sub>p_on_rand'\n            (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n            (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n              (Lxy init {x, y}) \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n            (Lxy qs {x, y})\n           \\<le> 2 *\n                 real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                 b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n     \\<exists>b\\<ge>0.\n        \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n           \\<forall>(x, y)\n                    \\<in>{(x, y).\n                          x \\<in> set s0 \\<and>\n                          y \\<in> set s0 \\<and> x < y}.\n              T\\<^sub>p_on_rand'\n               (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n               (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                 (Lxy s0 {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n               (Lxy qs {x, y})\n              \\<le> 2 *\n                    real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                    b\n\ngoal (6 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>is s q.\n       List_Factoring.pairwise\n        (Partial_Cost_Model.embed\n          (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n       \\<forall>((free, paid), uu_)\n                \\<in>set_pmf\n                      (snd (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                        (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>is s q.\n       List_Factoring.pairwise\n        (Partial_Cost_Model.embed\n          (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n       \\<forall>((free, paid), uu_)\n                \\<in>set_pmf\n                      (snd (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                        (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case 6"], ["proof (state)\nthis:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n\ngoal (6 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>is s q.\n       List_Factoring.pairwise\n        (Partial_Cost_Model.embed\n          (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n       \\<forall>((free, paid), uu_)\n                \\<in>set_pmf\n                      (snd (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                        (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((free, paid), uu_)\n             \\<in>set_pmf\n                   (snd (Partial_Cost_Model.embed\n                          (\\<lambda>s. [], TS_step_d))\n                     (s_, is_) q_).\n       paid = []", "unfolding TS_step_d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((free, paid), uu_)\n             \\<in>set_pmf\n                   (snd (Partial_Cost_Model.embed\n                          (\\<lambda>s. [],\n                           \\<lambda>s q.\n                              ((let li = index (snd s) q\n                                in if li = length (snd s) then 0\n                                   else let sincelast = take li (snd s);\n      S = {x. x < q in fst s \\<and> count_list sincelast x \\<le> 1}\n  in if S = {} then 0 else index (fst s) q - Min (index (fst s) ` S),\n                                []),\n                               q # snd s)))\n                     (s_, is_) q_).\n       paid = []", "by (simp add: split_def TS_step_d_def)"], ["proof (state)\nthis:\n  \\<forall>((free, paid), uu_)\n           \\<in>set_pmf\n                 (snd (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n                   (s_, is_) q_).\n     paid = []\n\ngoal (5 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case (7 init qs x)"], ["proof (state)\nthis:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n  distinct init\n  set qs \\<subseteq> set init\n  x < length qs\n\ngoal (5 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n 5. \\<And>init qs x.\n       \\<lbrakk>List_Factoring.pairwise\n                 (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init; x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "then"], ["proof (chain)\npicking this:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n  distinct init\n  set qs \\<subseteq> set init\n  x < length qs", "show ?case"], ["proof (prove)\nusing this:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n  distinct init\n  set qs \\<subseteq> set init\n  x < length qs\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand\n         (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n         (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n           init \\<bind>\n          (\\<lambda>is. return_pmf (init, is)))\n         (take x qs)))", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List_Factoring.pairwise\n              (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n     distinct init; set qs \\<subseteq> set init; 0 < length qs\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (set_pmf\n                         (Partial_Cost_Model.config'_rand\n                           (Partial_Cost_Model.embed\n                             (\\<lambda>s. [], TS_step_d))\n                           (fst (Partial_Cost_Model.embed\n                                  (\\<lambda>s. [], TS_step_d))\n                             init \\<bind>\n                            (\\<lambda>is. return_pmf (init, is)))\n                           (take 0 qs)))\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>List_Factoring.pairwise\n                          (Partial_Cost_Model.embed\n                            (\\<lambda>s. [], TS_step_d));\n                 distinct init; set qs \\<subseteq> set init;\n                 x < length qs\\<rbrakk>\n                \\<Longrightarrow> finite\n                                   (set_pmf\n                                     (Partial_Cost_Model.config'_rand\n (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d)) init \\<bind>\n  (\\<lambda>is. return_pmf (init, is)))\n (take x qs)));\n        List_Factoring.pairwise\n         (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d));\n        distinct init; set qs \\<subseteq> set init;\n        Suc x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed\n                                (\\<lambda>s. [], TS_step_d))\n                              (fst (Partial_Cost_Model.embed\n                                     (\\<lambda>s. [], TS_step_d))\n                                init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take (Suc x) qs)))", "by (simp_all add: rTS_def split_def take_Suc_conv_app_nth config'_rand_snoc )"], ["proof (state)\nthis:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand\n       (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n       (fst (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n         init \\<bind>\n        (\\<lambda>is. return_pmf (init, is)))\n       (take x qs)))\n\ngoal (4 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))", "case 4"], ["proof (state)\nthis:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n\ngoal (4 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e\n 4. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))", "then"], ["proof (chain)\npicking this:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))", "show ?case"], ["proof (prove)\nusing this:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n\ngoal (1 subgoal):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))", "by simp"], ["proof (state)\nthis:\n  List_Factoring.pairwise\n   (Partial_Cost_Model.embed (\\<lambda>s. [], TS_step_d))\n\ngoal (3 subgoals):\n 1. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    1 \\<le> 2\n 2. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}. distinct e\n 3. List_Factoring.pairwise\n     (Partial_Cost_Model.embed\n       (\\<lambda>s. [], TS_step_d)) \\<Longrightarrow>\n    \\<forall>e\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       0 < length e", "qed (simp_all)"], ["", "lemma TS_compet: \"compet_rand (embed (rTS [])) 2 {init. distinct init \\<and> init \\<noteq> []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.compet_rand (Partial_Cost_Model.embed (rTS [])) 2\n     {init. distinct init \\<and> init \\<noteq> []}", "unfolding compet_rand_def static_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n              (fst (Partial_Cost_Model.embed (rTS [])) s \\<bind>\n               (\\<lambda>is. return_pmf (s, is)))\n              rs\n             \\<le> 2 * real (T\\<^sub>p_opt s rs) + b", "using TS_compet'[OF TS_pairwise]"], ["proof (prove)\nusing this:\n  \\<forall>s0\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n     \\<exists>b\\<ge>0.\n        \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n           T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n            (fst (Partial_Cost_Model.embed (rTS [])) s0 \\<bind>\n             (\\<lambda>is. return_pmf (s0, is)))\n            qs\n           \\<le> 2 * real (T\\<^sub>p_opt s0 qs) + b\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{init. distinct init \\<and> init \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n              (fst (Partial_Cost_Model.embed (rTS [])) s \\<bind>\n               (\\<lambda>is. return_pmf (s, is)))\n              rs\n             \\<le> 2 * real (T\\<^sub>p_opt s rs) + b", "by simp"], ["", "end"]]}