{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/BIT_pairwise.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma L_nths: \"S \\<subseteq> {..<length init}\n  \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S) (Prob_Theory.bv (length init))\n      = (Prob_Theory.bv (length (nths init S)))\"", "lemma L_nths_Lxy:\n  assumes \"x\\<in>set init\" \"y\\<in>set init\" \"x\\<noteq>y\" \"distinct init\" \n  shows \"map_pmf (\\<lambda>l. nths l {index init x,index init y}) (Prob_Theory.bv (length init))\n      = (Prob_Theory.bv (length (Lxy init {x,y})))\"", "lemma nths_map: \"map f (nths xs S) = nths (map f xs) S\"", "lemma nths_empty: \"(\\<forall>i\\<in>S. i\\<ge>length xs) \\<Longrightarrow> nths xs S = []\"", "lemma nths_project': \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> i<j\n   \\<Longrightarrow> nths xs {i,j} = [xs!i, xs!j]\"", "lemma nths_project:\n  assumes  \"i < length xs\" \"j < length xs\" \"i<j\"\n   shows \"nths xs {i,j} ! 0 = xs ! i \\<and> nths xs {i,j} ! 1 = xs ! j\"", "lemma BIT_pairwise':\n  assumes \"set qs \\<subseteq> set init\"    \n    \"(x,y)\\<in> {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x\\<noteq>y}\"\n   and  xny:\"x \\<noteq> y\" and dinit: \"distinct init\"\n  shows \"Pbefore_in x y BIT qs init = Pbefore_in x y BIT (Lxy qs {x,y}) (Lxy init {x,y})\"", "theorem BIT_pairwise: \"pairwise BIT\""], "translations": [["", "lemma L_nths: \"S \\<subseteq> {..<length init}\n  \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S) (Prob_Theory.bv (length init))\n      = (Prob_Theory.bv (length (nths init S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {..<length init} \\<Longrightarrow>\n    map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n    bv (length (nths init S))", "proof(induct init arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "case (Cons a as)"], ["proof (state)\nthis:\n  ?S \\<subseteq> {..<length as} \\<Longrightarrow>\n  map_pmf (\\<lambda>l. nths l ?S) (bv (length as)) =\n  bv (length (nths as ?S))\n  S \\<subseteq> {..<length (a # as)}\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "then"], ["proof (chain)\npicking this:\n  ?S \\<subseteq> {..<length as} \\<Longrightarrow>\n  map_pmf (\\<lambda>l. nths l ?S) (bv (length as)) =\n  bv (length (nths as ?S))\n  S \\<subseteq> {..<length (a # as)}", "have passt: \"{j. Suc j \\<in> S} \\<subseteq> {..<length as}\""], ["proof (prove)\nusing this:\n  ?S \\<subseteq> {..<length as} \\<Longrightarrow>\n  map_pmf (\\<lambda>l. nths l ?S) (bv (length as)) =\n  bv (length (nths as ?S))\n  S \\<subseteq> {..<length (a # as)}\n\ngoal (1 subgoal):\n 1. {j. Suc j \\<in> S} \\<subseteq> {..<length as}", "by auto"], ["proof (state)\nthis:\n  {j. Suc j \\<in> S} \\<subseteq> {..<length as}\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "have \" map_pmf (\\<lambda>l. nths l S) (Prob_Theory.bv (length (a # as))) = \n    Prob_Theory.bv (length as) \\<bind>\n    (\\<lambda>x. bernoulli_pmf (1 / 2) \\<bind>\n          (\\<lambda>xa. return_pmf\n                  ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n    bv (length as) \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xa.\n            return_pmf\n             ((if 0 \\<in> S then [xa] else []) @\n              nths x {j. Suc j \\<in> S})))", "by(simp add: map_pmf_def bind_return_pmf bind_assoc_pmf nths_Cons)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n  bv (length as) \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S})))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n  bv (length as) \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S})))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "have \"\\<dots> = (bernoulli_pmf (1 / 2)) \\<bind> \n          (\\<lambda>xa. (Prob_Theory.bv (length as) \\<bind>\n    (\\<lambda>x. return_pmf ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv (length as) \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xa.\n            return_pmf\n             ((if 0 \\<in> S then [xa] else []) @\n              nths x {j. Suc j \\<in> S}))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length as) \\<bind>\n        (\\<lambda>x.\n            return_pmf\n             ((if 0 \\<in> S then [xa] else []) @\n              nths x {j. Suc j \\<in> S})))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bv (length as) \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @\n            nths x {j. Suc j \\<in> S}))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length as) \\<bind>\n      (\\<lambda>x.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S})))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "also"], ["proof (state)\nthis:\n  bv (length as) \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @\n            nths x {j. Suc j \\<in> S}))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length as) \\<bind>\n      (\\<lambda>x.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @ nths x {j. Suc j \\<in> S})))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "have \"\\<dots> = (bernoulli_pmf (1 / 2)) \\<bind> \n          (\\<lambda>xa. (map_pmf (\\<lambda>x. (nths x {j. Suc j \\<in> S})) (Prob_Theory.bv (length as)))\n              \\<bind>  (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length as) \\<bind>\n        (\\<lambda>x.\n            return_pmf\n             ((if 0 \\<in> S then [xa] else []) @\n              nths x {j. Suc j \\<in> S}))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n         (bv (length as)) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))", "by(simp add: bind_return_pmf bind_assoc_pmf map_pmf_def)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length as) \\<bind>\n      (\\<lambda>x.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @\n            nths x {j. Suc j \\<in> S}))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n       (bv (length as)) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length as) \\<bind>\n      (\\<lambda>x.\n          return_pmf\n           ((if 0 \\<in> S then [xa] else []) @\n            nths x {j. Suc j \\<in> S}))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n       (bv (length as)) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "have \"\\<dots> = (bernoulli_pmf (1 / 2)) \\<bind> \n          (\\<lambda>xa. Prob_Theory.bv (length (nths as {j. Suc j \\<in> S}))\n              \\<bind>  (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n         (bv (length as)) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))", "using Cons(1)[OF passt]"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>l. nths l {j. Suc j \\<in> S}) (bv (length as)) =\n  bv (length (nths as {j. Suc j \\<in> S}))\n\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n         (bv (length as)) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))", "by auto"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n       (bv (length as)) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (\\<lambda>x. nths x {j. Suc j \\<in> S})\n       (bv (length as)) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs)))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "have \"\\<dots> = Prob_Theory.bv (length (nths (a # as) S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n        (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n    bv (length (nths (a # as) S))", "apply(auto simp add: nths_Cons bind_return_pmf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n        (\\<lambda>xs. return_pmf (xa # xs))) =\n    bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n    (\\<lambda>xs.\n        bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>x. return_pmf (x # xs)))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv (length (nths as {j. Suc j \\<in> S})) \\<bind>\n      (\\<lambda>xs. return_pmf ((if 0 \\<in> S then [xa] else []) @ xs))) =\n  bv (length (nths (a # as) S))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))\n 2. \\<And>a init S.\n       \\<lbrakk>\\<And>S.\n                   S \\<subseteq> {..<length init} \\<Longrightarrow>\n                   map_pmf (\\<lambda>l. nths l S) (bv (length init)) =\n                   bv (length (nths init S));\n        S \\<subseteq> {..<length (a # init)}\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>l. nths l S)\n                          (bv (length (a # init))) =\n                         bv (length (nths (a # init) S))", "finally"], ["proof (chain)\npicking this:\n  map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n  bv (length (nths (a # as) S))", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n  bv (length (nths (a # as) S))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n    bv (length (nths (a # as) S))", "."], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l S) (bv (length (a # as))) =\n  bv (length (nths (a # as) S))\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       S \\<subseteq> {..<length []} \\<Longrightarrow>\n       map_pmf (\\<lambda>l. nths l S) (bv (length [])) =\n       bv (length (nths [] S))", "qed (simp)"], ["", "lemma L_nths_Lxy:\n  assumes \"x\\<in>set init\" \"y\\<in>set init\" \"x\\<noteq>y\" \"distinct init\" \n  shows \"map_pmf (\\<lambda>l. nths l {index init x,index init y}) (Prob_Theory.bv (length init))\n      = (Prob_Theory.bv (length (Lxy init {x,y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "from assms(4)"], ["proof (chain)\npicking this:\n  distinct init", "have setinit: \"(index init) ` set init = {0..<length init}\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. index init ` set init = {0..<length init}", "proof(induct init)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "case (Cons a as)"], ["proof (state)\nthis:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "with Cons"], ["proof (chain)\npicking this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)", "have iH: \"index as ` set as = {0..<length as}\""], ["proof (prove)\nusing this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. index as ` set as = {0..<length as}", "by auto"], ["proof (state)\nthis:\n  index as ` set as = {0..<length as}\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "from Cons"], ["proof (chain)\npicking this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)", "have 1:\"(set as \\<inter> {x. (a \\<noteq> x)}) = set as\""], ["proof (prove)\nusing this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. set as \\<inter> {x. a \\<noteq> x} = set as", "by fastforce"], ["proof (state)\nthis:\n  set as \\<inter> {x. a \\<noteq> x} = set as\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "have 2: \"(\\<lambda>a. Suc (index as a)) ` set as =\n            (\\<lambda>a. Suc a) ` ((index as) ` set as )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Suc (index as a)) ` set as = Suc ` index as ` set as", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>a. Suc (index as a)) ` set as = Suc ` index as ` set as\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (a # as) ` set (a # as) = {0..<length (a # as)}", "apply(simp add: 1 2 iH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert 0 {Suc 0..<Suc (length as)} = {0..<Suc (length as)}", "by auto"], ["proof (state)\nthis:\n  index (a # as) ` set (a # as) = {0..<length (a # as)}\n\ngoal (1 subgoal):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}", "qed simp"], ["proof (state)\nthis:\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "have xy_le: \"index init x<length init\" \"index init y<length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < length init &&& index init y < length init", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n  x \\<noteq> y\n  distinct init\n\ngoal (1 subgoal):\n 1. index init x < length init &&& index init y < length init", "by auto"], ["proof (state)\nthis:\n  index init x < length init\n  index init y < length init\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "have \"map_pmf (\\<lambda>l. nths l {index init x,index init y}) (Prob_Theory.bv (length init))\n      = (Prob_Theory.bv (length (nths init {index init x,index init y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (nths init {index init x, index init y}))", "apply(rule L_nths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init x, index init y} \\<subseteq> {..<length init}", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. {index init x, index init y} \\<subseteq> {..<length init}", "by auto"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (nths init {index init x, index init y}))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "moreover"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (nths init {index init x, index init y}))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "have \"length (Lxy init {x,y}) = length (nths init {index init x,index init y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"set (Lxy init {x,y}) = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "moreover"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"card {x,y} = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x, y} = 2", "using assms(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card {x, y} = 2", "by auto"], ["proof (state)\nthis:\n  card {x, y} = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "moreover"], ["proof (state)\nthis:\n  card {x, y} = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"distinct (Lxy init {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "using assms(4)"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "by(simp add: Lxy_distinct)"], ["proof (state)\nthis:\n  distinct (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "ultimately"], ["proof (chain)\npicking this:\n  set (Lxy init {x, y}) = {x, y}\n  card {x, y} = 2\n  distinct (Lxy init {x, y})", "have 1: \"length (Lxy init {x,y}) = 2\""], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {x, y}\n  card {x, y} = 2\n  distinct (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "by(simp add: distinct_card[symmetric])"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"set (nths init {index init x,index init y}) = {(init ! i) | i.  i < length init \\<and> i \\<in> {index init x,index init y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nths init {index init x, index init y}) =\n    {init ! i |i.\n     i < length init \\<and> i \\<in> {index init x, index init y}}", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. set (nths init {index init x, index init y}) =\n    {init ! i |i.\n     i < length init \\<and> i \\<in> {index init x, index init y}}", "by(simp add: set_nths)"], ["proof (state)\nthis:\n  set (nths init {index init x, index init y}) =\n  {init ! i |i. i < length init \\<and> i \\<in> {index init x, index init y}}\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "moreover"], ["proof (state)\nthis:\n  set (nths init {index init x, index init y}) =\n  {init ! i |i. i < length init \\<and> i \\<in> {index init x, index init y}}\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"card {(init ! i) | i.  i < length init \\<and> i \\<in> {index init x,index init y}} = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "have 1: \"{(init ! i) | i.  i < length init \\<and> i \\<in> {index init x,index init y}} = {init ! index init x, init ! index init y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {init ! i |i.\n     i < length init \\<and> i \\<in> {index init x, index init y}} =\n    {init ! index init x, init ! index init y}", "using xy_le"], ["proof (prove)\nusing this:\n  index init x < length init\n  index init y < length init\n\ngoal (1 subgoal):\n 1. {init ! i |i.\n     i < length init \\<and> i \\<in> {index init x, index init y}} =\n    {init ! index init x, init ! index init y}", "by blast"], ["proof (state)\nthis:\n  {init ! i |i.\n   i < length init \\<and> i \\<in> {index init x, index init y}} =\n  {init ! index init x, init ! index init y}\n\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "also"], ["proof (state)\nthis:\n  {init ! i |i.\n   i < length init \\<and> i \\<in> {index init x, index init y}} =\n  {init ! index init x, init ! index init y}\n\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "have \"\\<dots> = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {init ! index init x, init ! index init y} = {x, y}", "using nth_index assms(1,2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow> ?xs ! index ?xs ?x = ?x\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. {init ! index init x, init ! index init y} = {x, y}", "by auto"], ["proof (state)\nthis:\n  {init ! index init x, init ! index init y} = {x, y}\n\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "finally"], ["proof (chain)\npicking this:\n  {init ! i |i.\n   i < length init \\<and> i \\<in> {index init x, index init y}} =\n  {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  {init ! i |i.\n   i < length init \\<and> i \\<in> {index init x, index init y}} =\n  {x, y}\n\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "using assms(3)"], ["proof (prove)\nusing this:\n  {init ! i |i.\n   i < length init \\<and> i \\<in> {index init x, index init y}} =\n  {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card\n     {init ! i |i.\n      i < length init \\<and> i \\<in> {index init x, index init y}} =\n    2", "by auto"], ["proof (state)\nthis:\n  card\n   {init ! i |i.\n    i < length init \\<and> i \\<in> {index init x, index init y}} =\n  2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   {init ! i |i.\n    i < length init \\<and> i \\<in> {index init x, index init y}} =\n  2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "moreover"], ["proof (state)\nthis:\n  card\n   {init ! i |i.\n    i < length init \\<and> i \\<in> {index init x, index init y}} =\n  2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "have \"distinct (nths init {index init x,index init y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nths init {index init x, index init y})", "using assms(4)"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (nths init {index init x, index init y})", "by(simp)"], ["proof (state)\nthis:\n  distinct (nths init {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "ultimately"], ["proof (chain)\npicking this:\n  set (nths init {index init x, index init y}) =\n  {init ! i |i. i < length init \\<and> i \\<in> {index init x, index init y}}\n  card\n   {init ! i |i.\n    i < length init \\<and> i \\<in> {index init x, index init y}} =\n  2\n  distinct (nths init {index init x, index init y})", "have 2: \"length (nths init {index init x,index init y}) = 2\""], ["proof (prove)\nusing this:\n  set (nths init {index init x, index init y}) =\n  {init ! i |i. i < length init \\<and> i \\<in> {index init x, index init y}}\n  card\n   {init ! i |i.\n    i < length init \\<and> i \\<in> {index init x, index init y}} =\n  2\n  distinct (nths init {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length (nths init {index init x, index init y}) = 2", "by(simp add: distinct_card[symmetric])"], ["proof (state)\nthis:\n  length (nths init {index init x, index init y}) = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "using 1 2"], ["proof (prove)\nusing this:\n  length (Lxy init {x, y}) = 2\n  length (nths init {index init x, index init y}) = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) =\n    length (nths init {index init x, index init y})", "by simp"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = length (nths init {index init x, index init y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = length (nths init {index init x, index init y})\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "ultimately"], ["proof (chain)\npicking this:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (nths init {index init x, index init y}))\n  length (Lxy init {x, y}) = length (nths init {index init x, index init y})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (nths init {index init x, index init y}))\n  length (Lxy init {x, y}) = length (nths init {index init x, index init y})\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)) =\n    bv (length (Lxy init {x, y}))", "by simp"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (Lxy init {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nths_map: \"map f (nths xs S) = nths (map f xs) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (nths xs S) = nths (map f xs) S", "apply(induct xs arbitrary: S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S. map f (nths [] S) = nths (map f []) S\n 2. \\<And>a xs S.\n       (\\<And>S. map f (nths xs S) = nths (map f xs) S) \\<Longrightarrow>\n       map f (nths (a # xs) S) = nths (map f (a # xs)) S", "by(simp_all  add: nths_Cons)"], ["", "lemma nths_empty: \"(\\<forall>i\\<in>S. i\\<ge>length xs) \\<Longrightarrow> nths xs S = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>S. length xs \\<le> i \\<Longrightarrow> nths xs S = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>S. length xs \\<le> i \\<Longrightarrow> nths xs S = []", "assume \"(\\<forall>i\\<in>S. i\\<ge>length xs)\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>S. length xs \\<le> i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>S. length xs \\<le> i \\<Longrightarrow> nths xs S = []", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>S. length xs \\<le> i", "have \"set (nths xs S) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>S. length xs \\<le> i\n\ngoal (1 subgoal):\n 1. set (nths xs S) = {}", "apply(simp add: set_nths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>S. length xs \\<le> i \\<Longrightarrow>\n    \\<forall>i<length xs. i \\<notin> S", "by force"], ["proof (state)\nthis:\n  set (nths xs S) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>S. length xs \\<le> i \\<Longrightarrow> nths xs S = []", "then"], ["proof (chain)\npicking this:\n  set (nths xs S) = {}", "show \"nths xs S = []\""], ["proof (prove)\nusing this:\n  set (nths xs S) = {}\n\ngoal (1 subgoal):\n 1. nths xs S = []", "by simp"], ["proof (state)\nthis:\n  nths xs S = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nths_project': \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> i<j\n   \\<Longrightarrow> nths xs {i,j} = [xs!i, xs!j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "assume il: \"i < length xs\" and jl: \"j < length xs\" and ij: \"i<j\""], ["proof (state)\nthis:\n  i < length xs\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "from il"], ["proof (chain)\npicking this:\n  i < length xs", "obtain a as where dec1: \"a @ [xs!i] @ as = xs\" \n           and \"a = take i xs\" \"as=drop (Suc i) xs\" \n           and length_a: \"length a = i\" and length_as: \"length as = length xs - i - 1\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! i] @ as = xs; a = take i xs;\n         as = drop (Suc i) xs; length a = i;\n         length as = length xs - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  i < length xs\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! i] @ as = xs; a = take i xs;\n         as = drop (Suc i) xs; length a = i;\n         length as = length xs - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a @ [xs ! i] @ as = xs\n  a = take i xs\n  as = drop (Suc i) xs\n  length a = i\n  length as = length xs - i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have \"j\\<ge>length (a @ [xs!i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a @ [xs ! i]) \\<le> j", "using length_a ij"], ["proof (prove)\nusing this:\n  length a = i\n  i < j\n\ngoal (1 subgoal):\n 1. length (a @ [xs ! i]) \\<le> j", "by auto"], ["proof (state)\nthis:\n  length (a @ [xs ! i]) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "then"], ["proof (chain)\npicking this:\n  length (a @ [xs ! i]) \\<le> j", "have \"((a @ [xs!i]) @ as) ! j = as ! (j-length (a @ [xs ! i]))\""], ["proof (prove)\nusing this:\n  length (a @ [xs ! i]) \\<le> j\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))", "using nth_append[where xs=\"a @ [xs!i]\" and ys=\"as\"]"], ["proof (prove)\nusing this:\n  length (a @ [xs ! i]) \\<le> j\n  ((a @ [xs ! i]) @ as) ! ?n =\n  (if ?n < length (a @ [xs ! i]) then (a @ [xs ! i]) ! ?n\n   else as ! (?n - length (a @ [xs ! i])))\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))", "by(simp)"], ["proof (state)\nthis:\n  ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "then"], ["proof (chain)\npicking this:\n  ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))", "have xsj: \"xs ! j = as ! (j-i-1)\""], ["proof (prove)\nusing this:\n  ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))\n\ngoal (1 subgoal):\n 1. xs ! j = as ! (j - i - 1)", "using dec1 length_a"], ["proof (prove)\nusing this:\n  ((a @ [xs ! i]) @ as) ! j = as ! (j - length (a @ [xs ! i]))\n  a @ [xs ! i] @ as = xs\n  length a = i\n\ngoal (1 subgoal):\n 1. xs ! j = as ! (j - i - 1)", "by auto"], ["proof (state)\nthis:\n  xs ! j = as ! (j - i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have las: \"(j-i-1) < length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - i - 1 < length as", "using length_as jl ij"], ["proof (prove)\nusing this:\n  length as = length xs - i - 1\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. j - i - 1 < length as", "by simp"], ["proof (state)\nthis:\n  j - i - 1 < length as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "obtain b c where dec2: \"b @ [xs!j] @ c = as\"\n            and \"b = take (j-i-1) as\" \"c=drop (Suc (j-i-1)) as\"\n            and length_b: \"length b = j-i-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! j] @ c = as; b = take (j - i - 1) as;\n         c = drop (Suc (j - i - 1)) as; length b = j - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop[OF las] xsj"], ["proof (prove)\nusing this:\n  as = take (j - i - 1) as @ as ! (j - i - 1) # drop (Suc (j - i - 1)) as\n  xs ! j = as ! (j - i - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! j] @ c = as; b = take (j - i - 1) as;\n         c = drop (Suc (j - i - 1)) as; length b = j - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  b @ [xs ! j] @ c = as\n  b = take (j - i - 1) as\n  c = drop (Suc (j - i - 1)) as\n  length b = j - i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have xs_dec: \"a @ [xs!i] @ b @ [xs!j] @ c = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ [xs ! i] @ b @ [xs ! j] @ c = xs", "using dec1 dec2"], ["proof (prove)\nusing this:\n  a @ [xs ! i] @ as = xs\n  b @ [xs ! j] @ c = as\n\ngoal (1 subgoal):\n 1. a @ [xs ! i] @ b @ [xs ! j] @ c = xs", "by auto"], ["proof (state)\nthis:\n  a @ [xs ! i] @ b @ [xs ! j] @ c = xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have s2: \"{k. (k + i \\<in> {i, j})} = {0,j-i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k + i \\<in> {i, j}} = {0, j - i}", "using ij"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. {k. k + i \\<in> {i, j}} = {0, j - i}", "by force"], ["proof (state)\nthis:\n  {k. k + i \\<in> {i, j}} = {0, j - i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have s3: \"{k. (k  + length [xs ! i] \\<in> {0, j-i})} = {j-i-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k + length [xs ! i] \\<in> {0, j - i}} = {j - i - 1}", "using ij"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. {k. k + length [xs ! i] \\<in> {0, j - i}} = {j - i - 1}", "by force"], ["proof (state)\nthis:\n  {k. k + length [xs ! i] \\<in> {0, j - i}} = {j - i - 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have s4: \"{k. (k  + length b \\<in> {j-i-1})} = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k + length b \\<in> {j - i - 1}} = {0}", "using length_b"], ["proof (prove)\nusing this:\n  length b = j - i - 1\n\ngoal (1 subgoal):\n 1. {k. k + length b \\<in> {j - i - 1}} = {0}", "by force"], ["proof (state)\nthis:\n  {k. k + length b \\<in> {j - i - 1}} = {0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have s5: \"{k. (k  + length [xs!j] \\<in> {0})} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k + length [xs ! j] \\<in> {0}} = {}", "by force"], ["proof (state)\nthis:\n  {k. k + length [xs ! j] \\<in> {0}} = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have l1: \"nths a {i,j} = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths a {i, j} = []", "apply(rule nths_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i, j}. length a \\<le> i", "using length_a ij"], ["proof (prove)\nusing this:\n  length a = i\n  i < j\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i, j}. length a \\<le> i", "by fastforce"], ["proof (state)\nthis:\n  nths a {i, j} = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have l2: \"nths b {j - Suc i} = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths b {j - Suc i} = []", "apply(rule nths_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{j - Suc i}. length b \\<le> i", "using length_b ij"], ["proof (prove)\nusing this:\n  length b = j - i - 1\n  i < j\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{j - Suc i}. length b \\<le> i", "by fastforce"], ["proof (state)\nthis:\n  nths b {j - Suc i} = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "have \"nths ( a @ [xs!i] @ b @ [xs!j] @ c) {i,j} = [xs!i, xs!j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (a @ [xs ! i] @ b @ [xs ! j] @ c) {i, j} = [xs ! i, xs ! j]", "apply(simp only: nths_append length_a s2 s3 s4 s5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths a {i, j} @\n    nths [xs ! i] {0, j - i} @\n    nths b {j - i - 1} @ nths [xs ! j] {0} @ nths c {} =\n    [xs ! i, xs ! j]", "by(simp add: l1 l2)"], ["proof (state)\nthis:\n  nths (a @ [xs ! i] @ b @ [xs ! j] @ c) {i, j} = [xs ! i, xs ! j]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; i < j\\<rbrakk>\n    \\<Longrightarrow> nths xs {i, j} = [xs ! i, xs ! j]", "then"], ["proof (chain)\npicking this:\n  nths (a @ [xs ! i] @ b @ [xs ! j] @ c) {i, j} = [xs ! i, xs ! j]", "show \"nths xs {i,j} = [xs!i, xs!j]\""], ["proof (prove)\nusing this:\n  nths (a @ [xs ! i] @ b @ [xs ! j] @ c) {i, j} = [xs ! i, xs ! j]\n\ngoal (1 subgoal):\n 1. nths xs {i, j} = [xs ! i, xs ! j]", "unfolding xs_dec"], ["proof (prove)\nusing this:\n  nths xs {i, j} = [xs ! i, xs ! j]\n\ngoal (1 subgoal):\n 1. nths xs {i, j} = [xs ! i, xs ! j]", "."], ["proof (state)\nthis:\n  nths xs {i, j} = [xs ! i, xs ! j]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nths_project:\n  assumes  \"i < length xs\" \"j < length xs\" \"i<j\"\n   shows \"nths xs {i,j} ! 0 = xs ! i \\<and> nths xs {i,j} ! 1 = xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs {i, j} ! 0 = xs ! i \\<and> nths xs {i, j} ! 1 = xs ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nths xs {i, j} ! 0 = xs ! i \\<and> nths xs {i, j} ! 1 = xs ! j", "from assms"], ["proof (chain)\npicking this:\n  i < length xs\n  j < length xs\n  i < j", "have \"nths xs {i,j} = [xs!i, xs!j]\""], ["proof (prove)\nusing this:\n  i < length xs\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. nths xs {i, j} = [xs ! i, xs ! j]", "by(rule nths_project')"], ["proof (state)\nthis:\n  nths xs {i, j} = [xs ! i, xs ! j]\n\ngoal (1 subgoal):\n 1. nths xs {i, j} ! 0 = xs ! i \\<and> nths xs {i, j} ! 1 = xs ! j", "then"], ["proof (chain)\npicking this:\n  nths xs {i, j} = [xs ! i, xs ! j]", "show ?thesis"], ["proof (prove)\nusing this:\n  nths xs {i, j} = [xs ! i, xs ! j]\n\ngoal (1 subgoal):\n 1. nths xs {i, j} ! 0 = xs ! i \\<and> nths xs {i, j} ! 1 = xs ! j", "by simp"], ["proof (state)\nthis:\n  nths xs {i, j} ! 0 = xs ! i \\<and> nths xs {i, j} ! 1 = xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BIT_pairwise':\n  assumes \"set qs \\<subseteq> set init\"    \n    \"(x,y)\\<in> {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x\\<noteq>y}\"\n   and  xny:\"x \\<noteq> y\" and dinit: \"distinct init\"\n  shows \"Pbefore_in x y BIT qs init = Pbefore_in x y BIT (Lxy qs {x,y}) (Lxy init {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "from assms"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init", "have xyininit: \"{x, y} \\<subseteq> set init\" \n        and qsininit: \"set qs \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> set init &&& set qs \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have xyininit': \"{y,x} \\<subseteq> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y, x} \\<subseteq> set init", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. {y, x} \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  {y, x} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have a: \"x \\<in> set init\" \"y\\<in>set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set init &&& y \\<in> set init", "using assms"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (1 subgoal):\n 1. x \\<in> set init &&& y \\<in> set init", "by auto"], ["proof (state)\nthis:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "{"], ["proof (state)\nthis:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have strong: \"set qs \\<subseteq> set init \\<Longrightarrow>\n      map_pmf (\\<lambda>(l,(w,i)). (Lxy l {x,y},(nths w {index init x,index init y},Lxy init {x,y}))) (config_rand BIT init qs) =\n      config_rand BIT (Lxy init {x, y}) (Lxy qs {x, y}) \" (is \"?inv \\<Longrightarrow> ?L qs = ?R qs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set qs \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y})", "proof (induct qs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "have \" map_pmf (\\<lambda>(l,(w,i)). (Lxy l {x,y},(nths w {index init x,index init y},Lxy init {x,y}))) (config_rand BIT init [])\n          =  map_pmf (\\<lambda>w. (Lxy init {x,y}, (w, Lxy init {x,y}))) (map_pmf (\\<lambda>l. nths l {index init x,index init y}) (Prob_Theory.bv (length init)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n       (bv (length init)))", "by(simp add: bind_return_pmf map_pmf_def bind_assoc_pmf split_def BIT_init_def)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)))\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init)))\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "have \"\\<dots> = map_pmf (\\<lambda>w. (Lxy init {x,y}, (w, Lxy init {x,y}))) (Prob_Theory.bv (length (Lxy init {x, y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n       (bv (length init))) =\n    map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (bv (length (Lxy init {x, y})))", "using L_nths_Lxy[OF a xny dinit]"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>l. nths l {index init x, index init y})\n   (bv (length init)) =\n  bv (length (Lxy init {x, y}))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n       (bv (length init))) =\n    map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (bv (length (Lxy init {x, y})))", "by simp"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init))) =\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (bv (length (Lxy init {x, y})))\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (map_pmf (\\<lambda>l. nths l {index init x, index init y})\n     (bv (length init))) =\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (bv (length (Lxy init {x, y})))\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "have \"\\<dots> = config_rand BIT  (Lxy init {x, y}) (Lxy [] {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n     (bv (length (Lxy init {x, y}))) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})", "by(simp add: BIT_init_def bind_return_pmf bind_assoc_pmf map_pmf_def)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>w. (Lxy init {x, y}, w, Lxy init {x, y}))\n   (bv (length (Lxy init {x, y}))) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy [] {x, y})\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "finally"], ["proof (chain)\npicking this:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy [] {x, y})", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy [] {x, y})\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y})", "."], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) []) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy [] {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "case (snoc q qs)"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n  set (qs @ [q]) \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n  set (qs @ [q]) \\<subseteq> set init", "have qininit: \"q \\<in>  set init\" \n            and qsininit: \"set qs \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n  set (qs @ [q]) \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init &&& set qs \\<subseteq> set init", "using qsininit"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n  set (qs @ [q]) \\<subseteq> set init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init &&& set qs \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  q \\<in> set init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "from  snoc(1)[OF qsininit]"], ["proof (chain)\npicking this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})", "have iH: \"?L qs = ?R qs\""], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y})", "by (simp add: split_def)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                map_pmf\n                 (\\<lambda>(l, w, i).\n                     (Lxy l {x, y}, nths w {index init x, index init y},\n                      Lxy init {x, y}))\n                 (Partial_Cost_Model.config'_rand BIT\n                   (fst BIT init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   xs) =\n                Partial_Cost_Model.config'_rand BIT\n                 (fst BIT (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y});\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> map_pmf\n                          (\\<lambda>(l, w, i).\n                              (Lxy l {x, y},\n                               nths w {index init x, index init y},\n                               Lxy init {x, y}))\n                          (Partial_Cost_Model.config'_rand BIT\n                            (fst BIT init \\<bind>\n                             (\\<lambda>is. return_pmf (init, is)))\n                            (xs @ [xa])) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "proof (cases \"q \\<in> {x,y}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "case True"], ["proof (state)\nthis:\n  q \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "note whatisq=this"], ["proof (state)\nthis:\n  q \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"?L (qs@[q]) =\n         map_pmf (\\<lambda>(l,(w,i)). (Lxy l {x,y},(nths w {index init x,index init y},Lxy init {x,y}))) (config_rand BIT init qs \\<bind>\n              (\\<lambda>s. BIT_step s q \\<bind> (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs \\<bind>\n      (\\<lambda>s.\n          BIT_step s q \\<bind>\n          (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))))", "by(simp add: split_def config'_rand_snoc)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))))\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))))\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"\\<dots> =\n        map_pmf (\\<lambda>(l,(w,i)). (Lxy l {x,y}, (nths w {index init x,index init y},Lxy init {x,y}))) (config_rand BIT init qs) \\<bind>\n        (\\<lambda>s.\n            BIT_step s q \\<bind>\n            (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs \\<bind>\n      (\\<lambda>s.\n          BIT_step s q \\<bind>\n          (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))) =\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))", "apply(simp add: map_pmf_def split_def bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        BIT_step xa q \\<bind>\n        (\\<lambda>xb.\n            return_pmf\n             (Lxy (step (fst xa) q (fst xb)) {x, y},\n              nths (fst (snd xb)) {index init x, index init y},\n              Lxy init {x, y}))) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        BIT_step\n         (Lxy (fst xa) {x, y},\n          nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})\n         q \\<bind>\n        (\\<lambda>p.\n            return_pmf (step (Lxy (fst xa) {x, y}) q (fst p), snd p)))", "apply(simp add: BIT_step_def bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        return_pmf\n         (Lxy (step (fst xa) q\n                (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                 else length (fst xa),\n                 []))\n           {x, y},\n          nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n           {index init x, index init y},\n          Lxy init {x, y})) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        return_pmf\n         (step (Lxy (fst xa) {x, y}) q\n           (if nths (fst (snd xa)) {index init x, index init y} !\n               index (Lxy init {x, y}) q\n            then 0\n            else length\n                  (fst (Lxy (fst xa) {x, y},\n                        nths (fst (snd xa)) {index init x, index init y},\n                        Lxy init {x, y})),\n            []),\n          flip (index (Lxy init {x, y}) q)\n           (nths (fst (snd xa)) {index init x, index init y}),\n          Lxy init {x, y}))", "proof (rule bind_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "let ?s = \"fst z\""], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "let ?b = \"fst (snd z)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have z: \"set (?s) = set init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "using config_rand_set[of BIT, simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "by metis"], ["proof (state)\nthis:\n  set (fst z) = set init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "with True"], ["proof (chain)\npicking this:\n  q \\<in> {x, y}\n  set (fst z) = set init", "have qLxy: \"q \\<in> set (Lxy (?s) {x, y})\""], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n  set (fst z) = set init\n\ngoal (1 subgoal):\n 1. q \\<in> set (Lxy (fst z) {x, y})", "using   xyininit"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set (Lxy (fst z) {x, y})", "by (simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  q \\<in> set (Lxy (fst z) {x, y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have dz: \"distinct (?s)\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "using dinit config_rand_distinct[of BIT, simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  distinct init\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "by metis"], ["proof (state)\nthis:\n  distinct (fst z)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "then"], ["proof (chain)\npicking this:\n  distinct (fst z)", "have dLxy: \"distinct (Lxy (?s) {x, y})\""], ["proof (prove)\nusing this:\n  distinct (fst z)\n\ngoal (1 subgoal):\n 1. distinct (Lxy (fst z) {x, y})", "using Lxy_distinct"], ["proof (prove)\nusing this:\n  distinct (fst z)\n  distinct ?xs \\<Longrightarrow> distinct (Lxy ?xs ?S)\n\ngoal (1 subgoal):\n 1. distinct (Lxy (fst z) {x, y})", "by auto"], ["proof (state)\nthis:\n  distinct (Lxy (fst z) {x, y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have [simp]: \"snd (snd z) = init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "using config_n_init3[simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     snd (snd x) = ?init\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "by metis"], ["proof (state)\nthis:\n  snd (snd z) = init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have [simp]: \"length (fst (snd z)) = length init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. length (fst (snd z)) = length init", "using config_n_fst_init_length2[simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?s0.0 \\<bind>\n                     (\\<lambda>is. return_pmf (?s0.0, is)))\n                    ?qs).\n     length (fst (snd x)) = length ?s0.0\n\ngoal (1 subgoal):\n 1. length (fst (snd z)) = length init", "by metis"], ["proof (state)\nthis:\n  length (fst (snd z)) = length init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have indexinbounds: \"index init x < length init\" \"index init y < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < length init &&& index init y < length init", "using a"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. index init x < length init &&& index init y < length init", "by auto"], ["proof (state)\nthis:\n  index init x < length init\n  index init y < length init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from a xny"], ["proof (chain)\npicking this:\n  x \\<in> set init\n  y \\<in> set init\n  x \\<noteq> y", "have indnot: \"index init x \\<noteq> index init y\""], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index init x \\<noteq> index init y", "by auto"], ["proof (state)\nthis:\n  index init x \\<noteq> index init y\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have f1: \"index init x < length (fst (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < length (fst (snd z))", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init x < length (fst (snd z))", "by auto"], ["proof (state)\nthis:\n  index init x < length (fst (snd z))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have f2: \"index init y < length (fst (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init y < length (fst (snd z))", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init y < length (fst (snd z))", "by auto"], ["proof (state)\nthis:\n  index init y < length (fst (snd z))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have 3: \"index init x \\<noteq> index init y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x \\<noteq> index init y", "using xny xyininit"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init x \\<noteq> index init y", "by auto"], ["proof (state)\nthis:\n  index init x \\<noteq> index init y\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "from dinit"], ["proof (chain)\npicking this:\n  distinct init", "have dfil: \"distinct (Lxy init {x,y})\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "by(rule Lxy_distinct)"], ["proof (state)\nthis:\n  distinct (Lxy init {x, y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have Lxy_set: \"set (Lxy init {x, y}) = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "apply(simp add: Lxy_set_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "by fast"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "then"], ["proof (chain)\npicking this:\n  set (Lxy init {x, y}) = {x, y}", "have xLxy: \"x\\<in>set (Lxy init {x, y})\""], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set (Lxy init {x, y})", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (Lxy init {x, y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have Lxy_length: \"length (Lxy init {x, y}) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "using dfil Lxy_set xny distinct_card"], ["proof (prove)\nusing this:\n  distinct (Lxy init {x, y})\n  set (Lxy init {x, y}) = {x, y}\n  x \\<noteq> y\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "by fastforce"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = 2\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have 31:  \"index (Lxy init {x, y}) x < 2\" \n              and  32:  \"index (Lxy init {x, y}) y < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x < 2 &&& index (Lxy init {x, y}) y < 2", "using Lxy_set xyininit Lxy_length"], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {x, y}\n  {x, y} \\<subseteq> set init\n  length (Lxy init {x, y}) = 2\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x < 2 &&& index (Lxy init {x, y}) y < 2", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have 33: \"index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x,y}) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x, y}) y", "using xny xLxy"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> set (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x, y}) y", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x, y}) y\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have a1: \"nths (flip (index init (q)) (fst (snd z))) {index init x,index init y}\n                = flip (index (Lxy init {x,y}) (q)) (nths (fst (snd z)) {index init x,index init y})\" (is \"?A=?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y})", "proof (simp only: list_eq_iff_nth_eq, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "{"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "assume ass: \"index init x < index init y\""], ["proof (state)\nthis:\n  index init x < index init y\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "then"], ["proof (chain)\npicking this:\n  index init x < index init y", "have \"index (Lxy init {x,y}) x < index (Lxy init {x,y}) y\""], ["proof (prove)\nusing this:\n  index init x < index init y\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x < index (Lxy init {x, y}) y", "using Lxy_mono[OF xyininit dinit] before_in_def a(2)"], ["proof (prove)\nusing this:\n  index init x < index init y\n  x < y in init = x < y in Lxy init {x, y}\n  ?x < ?y in ?xs = (index ?xs ?x < index ?xs ?y \\<and> ?y \\<in> set ?xs)\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x < index (Lxy init {x, y}) y", "by force"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "with 31 32"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y", "have ix: \"index (Lxy init {x,y}) x = 0\"\n                      and iy: \"index (Lxy init {x,y}) y = 1\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x = 0 &&& index (Lxy init {x, y}) y = 1", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x = 0\n  index (Lxy init {x, y}) y = 1\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have g1: \"(nths (fst (snd z)) {index init x,index init y}) \n                        = [(fst (snd z)) ! index init x, (fst (snd z)) ! index init y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} =\n    [fst (snd z) ! index init x, fst (snd z) ! index init y]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init x < length (fst (snd z))\n 2. index init y < length (fst (snd z))\n 3. index init x < index init y", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. index init x < length (fst (snd z))\n 2. index init y < length (fst (snd z))\n 3. index init x < index init y", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init y < length (fst (snd z))\n 2. index init x < index init y", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. index init y < length (fst (snd z))\n 2. index init x < index init y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < index init y", "by fact"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} =\n  [fst (snd z) ! index init x, fst (snd z) ! index init y]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have \"nths (flip (index init (q)) (fst (snd z))) {index init x,index init y}\n                  = [flip (index init (q)) (fst (snd z))!index init x,\n                        flip (index init (q)) (fst (snd z))!index init y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init x < length (flip (index init q) (fst (snd z)))\n 2. index init y < length (flip (index init q) (fst (snd z)))\n 3. index init x < index init y", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. index init x < length (flip (index init q) (fst (snd z)))\n 2. index init y < length (flip (index init q) (fst (snd z)))\n 3. index init x < index init y", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init y < length (flip (index init q) (fst (snd z)))\n 2. index init x < index init y", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. index init y < length (flip (index init q) (fst (snd z)))\n 2. index init x < index init y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < index init y", "by fact"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  [flip (index init q) (fst (snd z)) ! index init x,\n   flip (index init q) (fst (snd z)) ! index init y]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "also"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  [flip (index init q) (fst (snd z)) ! index init x,\n   flip (index init q) (fst (snd z)) ! index init y]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have \"\\<dots> = flip (index (Lxy init {x,y}) (q)) [(fst (snd z)) ! index init x, (fst (snd z)) ! index init y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "apply(cases \"q=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "apply(simp add: ix)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    flip (index init x) (fst (snd z)) ! index init x =\n    (\\<not> fst (snd z) ! index init x) \\<and>\n    flip (index init x) (fst (snd z)) ! index init y =\n    fst (snd z) ! index init y\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "using flip_other[OF f2 f1 3] flip_itself[OF f1]"], ["proof (prove)\nusing this:\n  flip (index init x) (fst (snd z)) ! index init y =\n  fst (snd z) ! index init y\n  flip (index init x) (fst (snd z)) ! index init x =\n  (\\<not> fst (snd z) ! index init x)\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    flip (index init x) (fst (snd z)) ! index init x =\n    (\\<not> fst (snd z) ! index init x) \\<and>\n    flip (index init x) (fst (snd z)) ! index init y =\n    fst (snd z) ! index init y\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "using whatisq"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init x, fst (snd z) ! index init y]", "apply(simp add: iy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> x; q = y\\<rbrakk>\n    \\<Longrightarrow> flip (index init y) (fst (snd z)) ! index init x =\n                      fst (snd z) ! index init x \\<and>\n                      flip (index init y) (fst (snd z)) ! index init y =\n                      (\\<not> fst (snd z) ! index init y)", "using flip_other[OF f1 f2 3[symmetric]] flip_itself[OF f2]"], ["proof (prove)\nusing this:\n  flip (index init y) (fst (snd z)) ! index init x =\n  fst (snd z) ! index init x\n  flip (index init y) (fst (snd z)) ! index init y =\n  (\\<not> fst (snd z) ! index init y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> x; q = y\\<rbrakk>\n    \\<Longrightarrow> flip (index init y) (fst (snd z)) ! index init x =\n                      fst (snd z) ! index init x \\<and>\n                      flip (index init y) (fst (snd z)) ! index init y =\n                      (\\<not> fst (snd z) ! index init y)", "by(simp)"], ["proof (state)\nthis:\n  [flip (index init q) (fst (snd z)) ! index init x,\n   flip (index init q) (fst (snd z)) ! index init y] =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init x, fst (snd z) ! index init y]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "finally"], ["proof (chain)\npicking this:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init x, fst (snd z) ! index init y]", "have \"nths (flip (index init (q)) (fst (snd z))) {index init x,index init y}\n                    = flip (index (Lxy init {x,y}) (q)) (nths (fst (snd z)) {index init x,index init y})\""], ["proof (prove)\nusing this:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init x, fst (snd z) ! index init y]\n\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y})", "by(simp add: g1)"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "}"], ["proof (state)\nthis:\n  index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "note cas1=this"], ["proof (state)\nthis:\n  index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have man: \"{x,y} = {y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {y, x}", "by auto"], ["proof (state)\nthis:\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "{"], ["proof (state)\nthis:\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "assume \"~ index init x < index init y\""], ["proof (state)\nthis:\n  \\<not> index init x < index init y\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "then"], ["proof (chain)\npicking this:\n  \\<not> index init x < index init y", "have ass: \"index init y < index init x\""], ["proof (prove)\nusing this:\n  \\<not> index init x < index init y\n\ngoal (1 subgoal):\n 1. index init y < index init x", "using 3"], ["proof (prove)\nusing this:\n  \\<not> index init x < index init y\n  index init x \\<noteq> index init y\n\ngoal (1 subgoal):\n 1. index init y < index init x", "by auto"], ["proof (state)\nthis:\n  index init y < index init x\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "then"], ["proof (chain)\npicking this:\n  index init y < index init x", "have \"index (Lxy init {x,y}) y < index (Lxy init {x,y}) x\""], ["proof (prove)\nusing this:\n  index init y < index init x\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) y < index (Lxy init {x, y}) x", "using Lxy_mono[OF xyininit' dinit] xyininit a(1) man"], ["proof (prove)\nusing this:\n  index init y < index init x\n  y < x in init = y < x in Lxy init {y, x}\n  {x, y} \\<subseteq> set init\n  x \\<in> set init\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) y < index (Lxy init {x, y}) x", "by(simp add: before_in_def)"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "with 31 32"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x", "have ix: \"index (Lxy init {x,y}) x = 1\"\n                      and iy: \"index (Lxy init {x,y}) y = 0\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x = 1 &&& index (Lxy init {x, y}) y = 0", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x = 1\n  index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have g1: \"(nths (fst (snd z)) {index init y,index init x}) \n                        = [(fst (snd z)) ! index init y, (fst (snd z)) ! index init x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init y, index init x} =\n    [fst (snd z) ! index init y, fst (snd z) ! index init x]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init y < length (fst (snd z))\n 2. index init x < length (fst (snd z))\n 3. index init y < index init x", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. index init y < length (fst (snd z))\n 2. index init x < length (fst (snd z))\n 3. index init y < index init x", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init x < length (fst (snd z))\n 2. index init y < index init x", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. index init x < length (fst (snd z))\n 2. index init y < index init x", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init y < index init x", "by fact"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init y, index init x} =\n  [fst (snd z) ! index init y, fst (snd z) ! index init x]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have man2: \"{index init x,index init y} = {index init y,index init x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init x, index init y} = {index init y, index init x}", "by auto"], ["proof (state)\nthis:\n  {index init x, index init y} = {index init y, index init x}\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have \"nths (flip (index init (q)) (fst (snd z))) {index init y,index init x}\n                  = [flip (index init (q)) (fst (snd z))!index init y,\n                        flip (index init (q)) (fst (snd z))!index init x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init y < length (flip (index init q) (fst (snd z)))\n 2. index init x < length (flip (index init q) (fst (snd z)))\n 3. index init y < index init x", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (3 subgoals):\n 1. index init y < length (flip (index init q) (fst (snd z)))\n 2. index init x < length (flip (index init q) (fst (snd z)))\n 3. index init y < index init x", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init x < length (flip (index init q) (fst (snd z)))\n 2. index init y < index init x", "using xyininit"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. index init x < length (flip (index init q) (fst (snd z)))\n 2. index init y < index init x", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init y < index init x", "by fact"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  [flip (index init q) (fst (snd z)) ! index init y,\n   flip (index init q) (fst (snd z)) ! index init x]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "also"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  [flip (index init q) (fst (snd z)) ! index init y,\n   flip (index init q) (fst (snd z)) ! index init x]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "have \"\\<dots> = flip (index (Lxy init {x,y}) (q)) [(fst (snd z)) ! index init y, (fst (snd z)) ! index init x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "apply(cases \"q=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "apply(simp add: ix)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    flip (index init x) (fst (snd z)) ! index init y =\n    fst (snd z) ! index init y \\<and>\n    flip (index init x) (fst (snd z)) ! index init x =\n    (\\<not> fst (snd z) ! index init x)\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "using flip_other[OF f2 f1 3] flip_itself[OF f1]"], ["proof (prove)\nusing this:\n  flip (index init x) (fst (snd z)) ! index init y =\n  fst (snd z) ! index init y\n  flip (index init x) (fst (snd z)) ! index init x =\n  (\\<not> fst (snd z) ! index init x)\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    flip (index init x) (fst (snd z)) ! index init y =\n    fst (snd z) ! index init y \\<and>\n    flip (index init x) (fst (snd z)) ! index init x =\n    (\\<not> fst (snd z) ! index init x)\n 2. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "using whatisq"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    flip (index (Lxy init {x, y}) q)\n     [fst (snd z) ! index init y, fst (snd z) ! index init x]", "apply(simp add: iy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> x; q = y\\<rbrakk>\n    \\<Longrightarrow> flip (index init y) (fst (snd z)) ! index init y =\n                      (\\<not> fst (snd z) ! index init y) \\<and>\n                      flip (index init y) (fst (snd z)) ! index init x =\n                      fst (snd z) ! index init x", "using flip_other[OF f1 f2 3[symmetric]] flip_itself[OF f2]"], ["proof (prove)\nusing this:\n  flip (index init y) (fst (snd z)) ! index init x =\n  fst (snd z) ! index init x\n  flip (index init y) (fst (snd z)) ! index init y =\n  (\\<not> fst (snd z) ! index init y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> x; q = y\\<rbrakk>\n    \\<Longrightarrow> flip (index init y) (fst (snd z)) ! index init y =\n                      (\\<not> fst (snd z) ! index init y) \\<and>\n                      flip (index init y) (fst (snd z)) ! index init x =\n                      fst (snd z) ! index init x", "by(simp)"], ["proof (state)\nthis:\n  [flip (index init q) (fst (snd z)) ! index init y,\n   flip (index init q) (fst (snd z)) ! index init x] =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init y, fst (snd z) ! index init x]\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "finally"], ["proof (chain)\npicking this:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init y, fst (snd z) ! index init x]", "have \"nths (flip (index init (q)) (fst (snd z))) {index init y,index init x}\n                    = flip (index (Lxy init {x,y}) (q)) (nths (fst (snd z)) {index init y,index init x})\""], ["proof (prove)\nusing this:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   [fst (snd z) ! index init y, fst (snd z) ! index init x]\n\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init y, index init x})", "by(simp add: g1)"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init y, index init x})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "then"], ["proof (chain)\npicking this:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init y, index init x})", "have \"nths (flip (index init (q)) (fst (snd z))) {index init x,index init y}\n                    = flip (index (Lxy init {x,y}) (q)) (nths (fst (snd z)) {index init x,index init y})\""], ["proof (prove)\nusing this:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init y, index init x})\n\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y})", "using man2"], ["proof (prove)\nusing this:\n  nths (flip (index init q) (fst (snd z))) {index init y, index init x} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init y, index init x})\n  {index init x, index init y} = {index init y, index init x}\n\ngoal (1 subgoal):\n 1. nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y})", "by auto"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "}"], ["proof (state)\nthis:\n  \\<not> index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "note cas2=this"], ["proof (state)\nthis:\n  \\<not> index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "from cas1 cas2 3"], ["proof (chain)\npicking this:\n  index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n  \\<not> index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n  index init x \\<noteq> index init y", "show ?case"], ["proof (prove)\nusing this:\n  index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n  \\<not> index init x < index init y \\<Longrightarrow>\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n  index init x \\<noteq> index init y\n\ngoal (1 subgoal):\n 1. length\n     (nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y}) =\n    length\n     (flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y})) \\<and>\n    (\\<forall>i<length\n                 (nths (flip (index init q) (fst (snd z)))\n                   {index init x, index init y}).\n        nths (flip (index init q) (fst (snd z)))\n         {index init x, index init y} !\n        i =\n        flip (index (Lxy init {x, y}) q)\n         (nths (fst (snd z)) {index init x, index init y}) !\n        i)", "by metis"], ["proof (state)\nthis:\n  length\n   (nths (flip (index init q) (fst (snd z))) {index init x, index init y}) =\n  length\n   (flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y})) \\<and>\n  (\\<forall>i<length\n               (nths (flip (index init q) (fst (snd z)))\n                 {index init x, index init y}).\n      nths (flip (index init q) (fst (snd z)))\n       {index init x, index init y} !\n      i =\n      flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y}) !\n      i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have a: \"nths (fst (snd z)) {index init x, index init y} ! (index (Lxy init {x,y}) (q))\n                    = fst (snd z) ! (index init (q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "from 31 32  33"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x, y}) y", "have ca: \"(index (Lxy init {x,y}) x = 0 \\<and> index (Lxy init {x,y}) y = 1)\n                    \\<or> (index (Lxy init {x,y}) x = 1 \\<and> index (Lxy init {x,y}) y = 0)\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < 2\n  index (Lxy init {x, y}) y < 2\n  index (Lxy init {x, y}) x \\<noteq> index (Lxy init {x, y}) y\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n    index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0", "by force"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "proof (cases \"index (Lxy init {x,y}) x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "case True"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x = 0\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "from True ca"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x = 0\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0", "have y1: \"index (Lxy init {x,y}) y = 1\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x = 0\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) y = 1", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) y = 1\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "with True"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x = 0\n  index (Lxy init {x, y}) y = 1", "have \"index (Lxy init {x,y}) x < index (Lxy init {x,y}) y\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x = 0\n  index (Lxy init {x, y}) y = 1\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x < index (Lxy init {x, y}) y", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "then"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y", "have xy: \"index init x < index init y\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n\ngoal (1 subgoal):\n 1. index init x < index init y", "using dinit dfil Lxy_mono"], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n  distinct init\n  distinct (Lxy init {x, y})\n  \\<lbrakk>{?x, ?y} \\<subseteq> set ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in ?xs = ?x < ?y in Lxy ?xs {?x, ?y}\n\ngoal (1 subgoal):\n 1. index init x < index init y", "using \"32\" before_in_def Lxy_length xyininit"], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x < index (Lxy init {x, y}) y\n  distinct init\n  distinct (Lxy init {x, y})\n  \\<lbrakk>{?x, ?y} \\<subseteq> set ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in ?xs = ?x < ?y in Lxy ?xs {?x, ?y}\n  index (Lxy init {x, y}) y < 2\n  ?x < ?y in ?xs = (index ?xs ?x < index ?xs ?y \\<and> ?y \\<in> set ?xs)\n  length (Lxy init {x, y}) = 2\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init x < index init y", "by fastforce"], ["proof (state)\nthis:\n  index init x < index init y\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "have 4: \" {index init y, index init x} =  {index init x, index init y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init y, index init x} = {index init x, index init y}", "by auto"], ["proof (state)\nthis:\n  {index init y, index init x} = {index init x, index init y}\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "have \"nths (fst (snd z)) {index init x, index init y} ! index (Lxy init {x,y}) x = (fst (snd z)) ! index init x\"\n                       \"nths (fst (snd z)) {index init x, index init y} ! index (Lxy init {x,y}) y = (fst (snd z)) ! index init y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) x =\n    fst (snd z) ! index init x &&&\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) y =\n    fst (snd z) ! index init y", "unfolding True y1"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} ! 0 =\n    fst (snd z) ! index init x &&&\n    nths (fst (snd z)) {index init x, index init y} ! 1 =\n    fst (snd z) ! index init y", "by (simp_all only: nths_project[OF f1 f2 xy])"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y\n\ngoal (2 subgoals):\n 1. index (Lxy init {x, y}) x = 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q\n 2. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "with whatisq"], ["proof (chain)\npicking this:\n  q \\<in> {x, y}\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y\n\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "by auto"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) q =\n  fst (snd z) ! index init q\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "case False"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "with ca"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0\n  index (Lxy init {x, y}) x \\<noteq> 0", "have x1: \"index (Lxy init {x,y}) x = 1\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0\n  index (Lxy init {x, y}) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x = 1", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) x = 1\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "from dinit"], ["proof (chain)\npicking this:\n  distinct init", "have dfil: \"distinct (Lxy init {x,y})\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "by(rule Lxy_distinct)"], ["proof (state)\nthis:\n  distinct (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "from x1 ca"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x = 1\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0", "have y1: \"index (Lxy init {x,y}) y = 0\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x = 1\n  index (Lxy init {x, y}) x = 0 \\<and> index (Lxy init {x, y}) y = 1 \\<or>\n  index (Lxy init {x, y}) x = 1 \\<and> index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) y = 0", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "with x1"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) x = 1\n  index (Lxy init {x, y}) y = 0", "have \"index (Lxy init {x,y}) y < index (Lxy init {x,y}) x\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) x = 1\n  index (Lxy init {x, y}) y = 0\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) y < index (Lxy init {x, y}) x", "by auto"], ["proof (state)\nthis:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "then"], ["proof (chain)\npicking this:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x", "have xy: \"index init y < index init x\""], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n\ngoal (1 subgoal):\n 1. index init y < index init x", "using dinit dfil Lxy_mono"], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n  distinct init\n  distinct (Lxy init {x, y})\n  \\<lbrakk>{?x, ?y} \\<subseteq> set ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in ?xs = ?x < ?y in Lxy ?xs {?x, ?y}\n\ngoal (1 subgoal):\n 1. index init y < index init x", "using \"32\" before_in_def Lxy_length xyininit"], ["proof (prove)\nusing this:\n  index (Lxy init {x, y}) y < index (Lxy init {x, y}) x\n  distinct init\n  distinct (Lxy init {x, y})\n  \\<lbrakk>{?x, ?y} \\<subseteq> set ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in ?xs = ?x < ?y in Lxy ?xs {?x, ?y}\n  index (Lxy init {x, y}) y < 2\n  ?x < ?y in ?xs = (index ?xs ?x < index ?xs ?y \\<and> ?y \\<in> set ?xs)\n  length (Lxy init {x, y}) = 2\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init y < index init x", "by (metis a(2) indnot linorder_neqE_nat not_less0 y1)"], ["proof (state)\nthis:\n  index init y < index init x\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "have 4: \" {index init y, index init x} =  {index init x, index init y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init y, index init x} = {index init x, index init y}", "by auto"], ["proof (state)\nthis:\n  {index init y, index init x} = {index init x, index init y}\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "have \"nths (?b) {index init x, index init y} ! index (Lxy init {x,y}) x = (?b) ! index init x\"\n                       \"nths (?b) {index init x, index init y} ! index (Lxy init {x,y}) y = (?b) ! index init y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) x =\n    fst (snd z) ! index init x &&&\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) y =\n    fst (snd z) ! index init y", "unfolding x1 y1"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} ! 1 =\n    fst (snd z) ! index init x &&&\n    nths (fst (snd z)) {index init x, index init y} ! 0 =\n    fst (snd z) ! index init y", "using 4 nths_project[OF  f2 f1 xy]"], ["proof (prove)\nusing this:\n  {index init y, index init x} = {index init x, index init y}\n  nths (fst (snd z)) {index init y, index init x} ! 0 =\n  fst (snd z) ! index init y \\<and>\n  nths (fst (snd z)) {index init y, index init x} ! 1 =\n  fst (snd z) ! index init x\n\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} ! 1 =\n    fst (snd z) ! index init x &&&\n    nths (fst (snd z)) {index init x, index init y} ! 0 =\n    fst (snd z) ! index init y", "by simp_all"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y\n\ngoal (1 subgoal):\n 1. index (Lxy init {x, y}) x \\<noteq> 0 \\<Longrightarrow>\n    nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "with whatisq"], ["proof (chain)\npicking this:\n  q \\<in> {x, y}\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) x =\n  fst (snd z) ! index init x\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) y =\n  fst (snd z) ! index init y\n\ngoal (1 subgoal):\n 1. nths (fst (snd z)) {index init x, index init y} !\n    index (Lxy init {x, y}) q =\n    fst (snd z) ! index init q", "by auto"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) q =\n  fst (snd z) ! index init q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) q =\n  fst (snd z) ! index init q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nths (fst (snd z)) {index init x, index init y} !\n  index (Lxy init {x, y}) q =\n  fst (snd z) ! index init q\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have b: \"Lxy (mtf2 (length ?s) (q) ?s) {x, y} \n                =  mtf2 (length (Lxy ?s {x, y})) (q) (Lxy ?s {x, y})\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have sA: \"set ?A = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}", "using z xyininit"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}", "have xlxymA: \"x \\<in> set ?A\"\n                      and ylxymA: \"y \\<in> set ?A\""], ["proof (prove)\nusing this:\n  set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) &&&\n    y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have dA: \"distinct ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})", "apply(rule Lxy_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (mtf2 (length (fst z)) q (fst z))", "by(simp add: dz)"], ["proof (state)\nthis:\n  distinct (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have lA: \"length ?A = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2", "using xny sA dA distinct_card"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = {x, y}\n  distinct (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2", "by fastforce"], ["proof (state)\nthis:\n  length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "from lA ylxymA"], ["proof (chain)\npicking this:\n  length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})", "have yindA: \"index ?A y < 2\""], ["proof (prove)\nusing this:\n  length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y < 2", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y < 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "from lA xlxymA"], ["proof (chain)\npicking this:\n  length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})", "have xindA: \"index ?A x < 2\""], ["proof (prove)\nusing this:\n  length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) = 2\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x < 2", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x < 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have geA: \"{x,y} \\<subseteq> set (mtf2 (length ?s) (q) ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))", "using xyininit z"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  set (fst z) = set init\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))", "by auto"], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have geA': \"{y,x} \\<subseteq> set (mtf2 (length ?s) (q) (?s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y, x} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))", "using xyininit z"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  set (fst z) = set init\n\ngoal (1 subgoal):\n 1. {y, x} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))", "by auto"], ["proof (state)\nthis:\n  {y, x} \\<subseteq> set (mtf2 (length (fst z)) q (fst z))\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have man: \"{y,x} = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y, x} = {x, y}", "by auto"], ["proof (state)\nthis:\n  {y, x} = {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have sB: \"set ?B = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}", "using z xyininit"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}", "by(simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}", "have xlxymB: \"x \\<in> set ?B\"\n                  and ylxymB: \"y \\<in> set ?B\""], ["proof (prove)\nusing this:\n  set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q\n                  (Lxy (fst z) {x, y})) &&&\n    y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have dB: \"distinct ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (Lxy (fst z) {x, y})", "apply(rule Lxy_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst z)", "by(simp add: dz)"], ["proof (state)\nthis:\n  distinct (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have lB: \"length ?B = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2", "using xny sB dB distinct_card"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = {x, y}\n  distinct (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2", "by fastforce"], ["proof (state)\nthis:\n  length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "from lB ylxymB"], ["proof (chain)\npicking this:\n  length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))", "have yindB: \"index ?B y < 2\""], ["proof (prove)\nusing this:\n  length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y < 2", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y < 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "from lB xlxymB"], ["proof (chain)\npicking this:\n  length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))", "have xindB: \"index ?B x < 2\""], ["proof (prove)\nusing this:\n  length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) = 2\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x < 2", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x < 2\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "proof (cases \"q = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "case True"], ["proof (state)\nthis:\n  q = x\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  q = x", "have xby: \"x < y in (mtf2 (length (?s)) (q) (?s))\""], ["proof (prove)\nusing this:\n  q = x\n\ngoal (1 subgoal):\n 1. x < y in mtf2 (length (fst z)) q (fst z)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = x \\<Longrightarrow> x < y in mtf2 (length (fst z)) x (fst z)", "apply(rule mtf2_moves_to_front''[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. q = x \\<Longrightarrow> distinct (fst z)\n 2. q = x \\<Longrightarrow> y \\<in> set (fst z)\n 3. q = x \\<Longrightarrow> x \\<in> set (fst z)\n 4. q = x \\<Longrightarrow> x \\<noteq> y", "using z xyininit xny"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. q = x \\<Longrightarrow> distinct (fst z)\n 2. q = x \\<Longrightarrow> y \\<in> set (fst z)\n 3. q = x \\<Longrightarrow> x \\<in> set (fst z)\n 4. q = x \\<Longrightarrow> x \\<noteq> y", "by(simp_all add: dz)"], ["proof (state)\nthis:\n  x < y in mtf2 (length (fst z)) q (fst z)\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  x < y in mtf2 (length (fst z)) q (fst z)", "have \"x < y in ?A\""], ["proof (prove)\nusing this:\n  x < y in mtf2 (length (fst z)) q (fst z)\n\ngoal (1 subgoal):\n 1. x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "using Lxy_mono[OF geA] dz"], ["proof (prove)\nusing this:\n  x < y in mtf2 (length (fst z)) q (fst z)\n  distinct (mtf2 (length (fst z)) q (fst z)) \\<Longrightarrow>\n  x < y in mtf2 (length (fst z)) q (fst z) =\n  x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}\n  distinct (fst z)\n\ngoal (1 subgoal):\n 1. x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "by(auto)"], ["proof (state)\nthis:\n  x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "have \"index ?A x < index ?A y\""], ["proof (prove)\nusing this:\n  x < y in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n    < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y \\<and>\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n    < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y", "have in1: \"index ?A x = 0\"\n                          and in2: \"index ?A y = 1\""], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 0 &&&\n    index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 1", "using yindA"], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y < 2\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 0 &&&\n    index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 1", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 0\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 1\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"?A = [?A!0,?A!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]", "apply(simp only: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) =\n    length\n     [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n      Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] \\<and>\n    (\\<forall>i<length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}).\n        Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n        [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n         Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] !\n        i)", "apply(auto simp: lA)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 2 \\<Longrightarrow>\n       Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n       [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n        Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! Suc 0] !\n       i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 2; i = 0\\<rbrakk>\n       \\<Longrightarrow> Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n                         [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n                          Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n                          Suc 0] !\n                         i\n 2. \\<And>i nat.\n       \\<lbrakk>i < 2; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n                         [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n                          Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n                          Suc 0] !\n                         i", "by(auto)"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [?A!index ?A x, ?A!index ?A y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n    [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y]", "by(simp only: in1 in2)"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y] =\n    [x, y]", "using xlxymA ylxymA"], ["proof (prove)\nusing this:\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y] =\n    [x, y]", "by simp"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y] =\n  [x, y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "finally"], ["proof (chain)\npicking this:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [x, y]", "have end1: \"?A  = [x,y]\""], ["proof (prove)\nusing this:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [x, y]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [x, y]", "."], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [x, y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"x < y in ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "using True"], ["proof (prove)\nusing this:\n  q = x\n\ngoal (1 subgoal):\n 1. x < y in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = x \\<Longrightarrow>\n    x < y in mtf2 (length (Lxy (fst z) {x, y})) x (Lxy (fst z) {x, y})", "apply(rule mtf2_moves_to_front''[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. q = x \\<Longrightarrow> distinct (Lxy (fst z) {x, y})\n 2. q = x \\<Longrightarrow> y \\<in> set (Lxy (fst z) {x, y})\n 3. q = x \\<Longrightarrow> x \\<in> set (Lxy (fst z) {x, y})\n 4. q = x \\<Longrightarrow> x \\<noteq> y", "using z xyininit xny"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. q = x \\<Longrightarrow> distinct (Lxy (fst z) {x, y})\n 2. q = x \\<Longrightarrow> y \\<in> set (Lxy (fst z) {x, y})\n 3. q = x \\<Longrightarrow> x \\<in> set (Lxy (fst z) {x, y})\n 4. q = x \\<Longrightarrow> x \\<noteq> y", "by(simp_all add: Lxy_distinct dz Lxy_set_filter)"], ["proof (state)\nthis:\n  x < y in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  x < y in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"index ?B x < index ?B y\""], ["proof (prove)\nusing this:\n  x < y in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n    < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n     y \\<and>\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n    < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y", "have in1: \"index ?B x = 0\"\n                          and in2: \"index ?B y = 1\""], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x =\n    0 &&&\n    index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y = 1", "using yindB"], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y < 2\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x =\n    0 &&&\n    index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y = 1", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x = 0\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y = 1\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"?B = [?B!0, ?B!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n    [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]", "apply(simp only: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) =\n    length\n     [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n      mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] \\<and>\n    (\\<forall>i<length\n                 (mtf2 (length (Lxy (fst z) {x, y})) q\n                   (Lxy (fst z) {x, y})).\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n        [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n         mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] !\n        i)", "apply(simp only: lB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 =\n    length\n     [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n      mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] \\<and>\n    (\\<forall>i<2.\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n        [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n         mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] !\n        i)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 2 \\<Longrightarrow>\n       mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n       [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! Suc 0] !\n       i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 2; i = 0\\<rbrakk>\n       \\<Longrightarrow> mtf2 (length (Lxy (fst z) {x, y})) q\n                          (Lxy (fst z) {x, y}) !\n                         i =\n                         [mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          0,\n                          mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          Suc 0] !\n                         i\n 2. \\<And>i nat.\n       \\<lbrakk>i < 2; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mtf2 (length (Lxy (fst z) {x, y})) q\n                          (Lxy (fst z) {x, y}) !\n                         i =\n                         [mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          0,\n                          mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          Suc 0] !\n                         i", "by(auto)"], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [?B!index ?B x,  ?B!index ?B y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n    [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y]", "by(simp only: in1 in2)"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y] =\n    [x, y]", "using xlxymB ylxymB"], ["proof (prove)\nusing this:\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y] =\n    [x, y]", "by simp"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y] =\n  [x, y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "finally"], ["proof (chain)\npicking this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]", "have end2: \"?B = [x,y]\""], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]\n\ngoal (1 subgoal):\n 1. mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]", "."], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n 2. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]", "show \"?A = ?B \""], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "using end1 end2"], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [x, y]\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [x, y]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "by simp"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "case False"], ["proof (state)\nthis:\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "with whatisq"], ["proof (chain)\npicking this:\n  q \\<in> {x, y}\n  q \\<noteq> x", "have qsy: \"q=y\""], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. q = y", "by simp"], ["proof (state)\nthis:\n  q = y\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  q = y", "have xby: \"y < x in (mtf2 (length (?s)) (q) (?s))\""], ["proof (prove)\nusing this:\n  q = y\n\ngoal (1 subgoal):\n 1. y < x in mtf2 (length (fst z)) q (fst z)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = y \\<Longrightarrow> y < x in mtf2 (length (fst z)) y (fst z)", "apply(rule mtf2_moves_to_front''[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. q = y \\<Longrightarrow> distinct (fst z)\n 2. q = y \\<Longrightarrow> x \\<in> set (fst z)\n 3. q = y \\<Longrightarrow> y \\<in> set (fst z)\n 4. q = y \\<Longrightarrow> y \\<noteq> x", "using z xyininit xny"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. q = y \\<Longrightarrow> distinct (fst z)\n 2. q = y \\<Longrightarrow> x \\<in> set (fst z)\n 3. q = y \\<Longrightarrow> y \\<in> set (fst z)\n 4. q = y \\<Longrightarrow> y \\<noteq> x", "by(simp_all add: dz)"], ["proof (state)\nthis:\n  y < x in mtf2 (length (fst z)) q (fst z)\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  y < x in mtf2 (length (fst z)) q (fst z)", "have \"y < x in ?A\""], ["proof (prove)\nusing this:\n  y < x in mtf2 (length (fst z)) q (fst z)\n\ngoal (1 subgoal):\n 1. y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "using Lxy_mono[OF geA'] man dz"], ["proof (prove)\nusing this:\n  y < x in mtf2 (length (fst z)) q (fst z)\n  distinct (mtf2 (length (fst z)) q (fst z)) \\<Longrightarrow>\n  y < x in mtf2 (length (fst z)) q (fst z) =\n  y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {y, x}\n  {y, x} = {x, y}\n  distinct (fst z)\n\ngoal (1 subgoal):\n 1. y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "by auto"], ["proof (state)\nthis:\n  y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}", "have \"index ?A y < index ?A x\""], ["proof (prove)\nusing this:\n  y < x in Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n    < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x \\<and>\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n    < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x", "have in1: \"index ?A y = 0\"\n                          and in2: \"index ?A x = 1\""], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 0 &&&\n    index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 1", "using xindA"], ["proof (prove)\nusing this:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y\n  < index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x < 2\n\ngoal (1 subgoal):\n 1. index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 0 &&&\n    index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 1", "by auto"], ["proof (state)\nthis:\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y = 0\n  index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"?A = [?A!0,?A!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]", "apply(simp only: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) =\n    length\n     [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n      Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] \\<and>\n    (\\<forall>i<length (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}).\n        Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n        [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n         Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] !\n        i)", "apply(auto simp: lA)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 2 \\<Longrightarrow>\n       Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n       [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n        Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! Suc 0] !\n       i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 2; i = 0\\<rbrakk>\n       \\<Longrightarrow> Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n                         [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n                          Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n                          Suc 0] !\n                         i\n 2. \\<And>i nat.\n       \\<lbrakk>i < 2; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! i =\n                         [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n                          Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n                          Suc 0] !\n                         i", "by(auto)"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [?A!index ?A y, ?A!index ?A x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n    [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x]", "by(simp only: in1 in2)"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 0,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} ! 1] =\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x] =\n    [y, x]", "using xlxymA ylxymA"], ["proof (prove)\nusing this:\n  x \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n  y \\<in> set (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y})\n\ngoal (1 subgoal):\n 1. [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n     Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n     index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x] =\n    [y, x]", "by simp"], ["proof (state)\nthis:\n  [Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) y,\n   Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} !\n   index (Lxy (mtf2 (length (fst z)) q (fst z)) {x, y}) x] =\n  [y, x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "finally"], ["proof (chain)\npicking this:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [y, x]", "have end1: \"?A  = [y,x]\""], ["proof (prove)\nusing this:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [y, x]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [y, x]", "."], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [y, x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"y < x in ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "using qsy"], ["proof (prove)\nusing this:\n  q = y\n\ngoal (1 subgoal):\n 1. y < x in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = y \\<Longrightarrow>\n    y < x in mtf2 (length (Lxy (fst z) {x, y})) y (Lxy (fst z) {x, y})", "apply(rule mtf2_moves_to_front''[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. q = y \\<Longrightarrow> distinct (Lxy (fst z) {x, y})\n 2. q = y \\<Longrightarrow> x \\<in> set (Lxy (fst z) {x, y})\n 3. q = y \\<Longrightarrow> y \\<in> set (Lxy (fst z) {x, y})\n 4. q = y \\<Longrightarrow> y \\<noteq> x", "using z xyininit xny"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. q = y \\<Longrightarrow> distinct (Lxy (fst z) {x, y})\n 2. q = y \\<Longrightarrow> x \\<in> set (Lxy (fst z) {x, y})\n 3. q = y \\<Longrightarrow> y \\<in> set (Lxy (fst z) {x, y})\n 4. q = y \\<Longrightarrow> y \\<noteq> x", "by(simp_all add: Lxy_distinct dz Lxy_set_filter)"], ["proof (state)\nthis:\n  y < x in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  y < x in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"index ?B y < index ?B x\""], ["proof (prove)\nusing this:\n  y < x in mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n    < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n     x \\<and>\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n    < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x", "have in1: \"index ?B y = 0\"\n                          and in2: \"index ?B x = 1\""], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y =\n    0 &&&\n    index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x = 1", "using xindB"], ["proof (prove)\nusing this:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y\n  < index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x < 2\n\ngoal (1 subgoal):\n 1. index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y =\n    0 &&&\n    index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x = 1", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y = 0\n  index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"?B = [?B!0, ?B!1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n    [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]", "apply(simp only: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) =\n    length\n     [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n      mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] \\<and>\n    (\\<forall>i<length\n                 (mtf2 (length (Lxy (fst z) {x, y})) q\n                   (Lxy (fst z) {x, y})).\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n        [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n         mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] !\n        i)", "apply(simp only: lB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 =\n    length\n     [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n      mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] \\<and>\n    (\\<forall>i<2.\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n        [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n         mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] !\n        i)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 2 \\<Longrightarrow>\n       mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! i =\n       [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n        mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! Suc 0] !\n       i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 2; i = 0\\<rbrakk>\n       \\<Longrightarrow> mtf2 (length (Lxy (fst z) {x, y})) q\n                          (Lxy (fst z) {x, y}) !\n                         i =\n                         [mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          0,\n                          mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          Suc 0] !\n                         i\n 2. \\<And>i nat.\n       \\<lbrakk>i < 2; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mtf2 (length (Lxy (fst z) {x, y})) q\n                          (Lxy (fst z) {x, y}) !\n                         i =\n                         [mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          0,\n                          mtf2 (length (Lxy (fst z) {x, y})) q\n                           (Lxy (fst z) {x, y}) !\n                          Suc 0] !\n                         i", "by(auto)"], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [?B!index ?B y,  ?B!index ?B x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n    [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x]", "by(simp only: in1 in2)"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "also"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 0,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) ! 1] =\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "have \"\\<dots> = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x] =\n    [y, x]", "using xlxymB ylxymB"], ["proof (prove)\nusing this:\n  x \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n  y \\<in> set (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}))\n\ngoal (1 subgoal):\n 1. [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n     mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n     index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x] =\n    [y, x]", "by(simp )"], ["proof (state)\nthis:\n  [mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) y,\n   mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) !\n   index (mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})) x] =\n  [y, x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "finally"], ["proof (chain)\npicking this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]", "have end2: \"?B = [y,x]\""], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]\n\ngoal (1 subgoal):\n 1. mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]", "."], ["proof (state)\nthis:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "then"], ["proof (chain)\npicking this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]", "show \"?A = ?B \""], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "using end1 end2"], ["proof (prove)\nusing this:\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} = [y, x]\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y}) = [y, x]\n\ngoal (1 subgoal):\n 1. Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "by simp"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n  mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "have a2: \" Lxy (step (?s) (q) (if ?b ! (index init (q)) then 0 else length (?s), [])) {x, y}\n              = step (Lxy (?s) {x, y}) (q) (if nths (?b) {index init x, index init y} ! (index (Lxy init {x,y}) (q)) \n                              then 0 \n                              else length (Lxy (?s) {x, y}), [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index init q then 0 else length (fst z), []))\n     {x, y} =\n    step (Lxy (fst z) {x, y}) q\n     (if nths (fst (snd z)) {index init x, index init y} !\n         index (Lxy init {x, y}) q\n      then 0 else length (Lxy (fst z) {x, y}),\n      [])", "apply(auto simp add: a step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> fst (snd z) ! index init q \\<Longrightarrow>\n    Lxy (mtf2 (length (fst z)) q (fst z)) {x, y} =\n    mtf2 (length (Lxy (fst z) {x, y})) q (Lxy (fst z) {x, y})", "by(simp add: b)"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index init q then 0 else length (fst z), []))\n   {x, y} =\n  step (Lxy (fst z) {x, y}) q\n   (if nths (fst (snd z)) {index init x, index init y} !\n       index (Lxy init {x, y}) q\n    then 0 else length (Lxy (fst z) {x, y}),\n    [])\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (step (Lxy (fst xa) {x, y}) q\n          (if nths (fst (snd xa)) {index init x, index init y} !\n              index (Lxy init {x, y}) q\n           then 0\n           else length\n                 (fst (Lxy (fst xa) {x, y},\n                       nths (fst (snd xa)) {index init x, index init y},\n                       Lxy init {x, y})),\n           []),\n         flip (index (Lxy init {x, y}) q)\n          (nths (fst (snd xa)) {index init x, index init y}),\n         Lxy init {x, y})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf\n     (Lxy (step (fst z) q\n            (if fst (snd z) ! index (snd (snd z)) q then 0\n             else length (fst z),\n             []))\n       {x, y},\n      nths (flip (index (snd (snd z)) q) (fst (snd z)))\n       {index init x, index init y},\n      Lxy init {x, y}) =\n    return_pmf\n     (step (Lxy (fst z) {x, y}) q\n       (if nths (fst (snd z)) {index init x, index init y} !\n           index (Lxy init {x, y}) q\n        then 0\n        else length\n              (fst (Lxy (fst z) {x, y},\n                    nths (fst (snd z)) {index init x, index init y},\n                    Lxy init {x, y})),\n        []),\n      flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y}),\n      Lxy init {x, y})", "using a1 a2"], ["proof (prove)\nusing this:\n  nths (flip (index init q) (fst (snd z))) {index init x, index init y} =\n  flip (index (Lxy init {x, y}) q)\n   (nths (fst (snd z)) {index init x, index init y})\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index init q then 0 else length (fst z), []))\n   {x, y} =\n  step (Lxy (fst z) {x, y}) q\n   (if nths (fst (snd z)) {index init x, index init y} !\n       index (Lxy init {x, y}) q\n    then 0 else length (Lxy (fst z) {x, y}),\n    [])\n\ngoal (1 subgoal):\n 1. return_pmf\n     (Lxy (step (fst z) q\n            (if fst (snd z) ! index (snd (snd z)) q then 0\n             else length (fst z),\n             []))\n       {x, y},\n      nths (flip (index (snd (snd z)) q) (fst (snd z)))\n       {index init x, index init y},\n      Lxy init {x, y}) =\n    return_pmf\n     (step (Lxy (fst z) {x, y}) q\n       (if nths (fst (snd z)) {index init x, index init y} !\n           index (Lxy init {x, y}) q\n        then 0\n        else length\n              (fst (Lxy (fst z) {x, y},\n                    nths (fst (snd z)) {index init x, index init y},\n                    Lxy init {x, y})),\n        []),\n      flip (index (Lxy init {x, y}) q)\n       (nths (fst (snd z)) {index init x, index init y}),\n      Lxy init {x, y})", "by(simp)"], ["proof (state)\nthis:\n  return_pmf\n   (Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y},\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y},\n    Lxy init {x, y}) =\n  return_pmf\n   (step (Lxy (fst z) {x, y}) q\n     (if nths (fst (snd z)) {index init x, index init y} !\n         index (Lxy init {x, y}) q\n      then 0\n      else length\n            (fst (Lxy (fst z) {x, y},\n                  nths (fst (snd z)) {index init x, index init y},\n                  Lxy init {x, y})),\n      []),\n    flip (index (Lxy init {x, y}) q)\n     (nths (fst (snd z)) {index init x, index init y}),\n    Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs", "qed simp"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))) =\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) \\<bind>\n  (\\<lambda>s.\n      BIT_step s q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))) =\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) \\<bind>\n  (\\<lambda>s.\n      BIT_step s q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis)))\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"\\<dots> = ?R (qs@[q])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "using True"], ["proof (prove)\nusing this:\n  q \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "apply(simp add: Lxy_snoc take_Suc_conv_app_nth config'_rand_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = x \\<or> q = y \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is')))", "using iH"], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. q = x \\<or> q = y \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}) \\<bind>\n    (\\<lambda>s.\n        BIT_step s q \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is')))", "by(simp add: split_def )"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) \\<bind>\n  (\\<lambda>s.\n      BIT_step s q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (step (fst s) q a, nis))) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal (2 subgoals):\n 1. q \\<in> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})\n 2. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "finally"], ["proof (chain)\npicking this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "."], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "case False"], ["proof (state)\nthis:\n  q \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "then"], ["proof (chain)\npicking this:\n  q \\<notin> {x, y}", "have qnx: \"(q) \\<noteq> x\" and qny: \"(q) \\<noteq> y\""], ["proof (prove)\nusing this:\n  q \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. q \\<noteq> x &&& q \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> x\n  q \\<noteq> y\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "let ?proj=\"(\\<lambda>a. (Lxy (fst a) {x, y}, (nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y})))\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"map_pmf ?proj (config_rand BIT init (qs@[q]))\n             = map_pmf ?proj (config_rand (BIT_init, BIT_step) init qs\n                \\<bind> (\\<lambda>p. BIT_step p (q) \\<bind> (\\<lambda>pa. return_pmf (step (fst p) (q) (fst pa), snd pa)))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs \\<bind>\n      (\\<lambda>p.\n          BIT_step p q \\<bind>\n          (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa))))", "by (simp add: split_def take_Suc_conv_app_nth config'_rand_snoc)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>p.\n        BIT_step p q \\<bind>\n        (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa))))\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>p.\n        BIT_step p q \\<bind>\n        (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa))))\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"\\<dots> = map_pmf ?proj (config_rand (BIT_init, BIT_step) init qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs \\<bind>\n      (\\<lambda>p.\n          BIT_step p q \\<bind>\n          (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa)))) =\n    map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)", "apply(simp add: map_pmf_def bind_assoc_pmf bind_return_pmf BIT_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        return_pmf\n         (Lxy (step (fst xa) q\n                (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                 else length (fst xa),\n                 []))\n           {x, y},\n          nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n           {index init x, index init y},\n          Lxy init {x, y})) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa.\n        return_pmf\n         (Lxy (fst xa) {x, y},\n          nths (fst (snd xa)) {index init x, index init y},\n          Lxy init {x, y}))", "proof (rule bind_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "let ?s = \"fst z\""], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "let ?m = \"snd (snd z)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "let ?b = \"fst (snd z)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have sf_init: \"?m = init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "using config_n_init3"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     snd (snd x) = ?init\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "by auto"], ["proof (state)\nthis:\n  snd (snd z) = init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have ff_len: \"length (?b) = length init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. length (fst (snd z)) = length init", "using config_n_fst_init_length2"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (fst BIT ?s0.0 \\<bind>\n                     (\\<lambda>is. return_pmf (?s0.0, is)))\n                    ?qs).\n     length (fst (snd x)) = length ?s0.0\n\ngoal (1 subgoal):\n 1. length (fst (snd z)) = length init", "by auto"], ["proof (state)\nthis:\n  length (fst (snd z)) = length init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have ff_ix: \"index init x < length (?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < length (fst (snd z))", "unfolding ff_len"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x < length init", "using a(1)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. index init x < length init", "by auto"], ["proof (state)\nthis:\n  index init x < length (fst (snd z))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have ff_iy: \"index init y < length (?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init y < length (fst (snd z))", "unfolding ff_len"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init y < length init", "using a(2)"], ["proof (prove)\nusing this:\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. index init y < length init", "by auto"], ["proof (state)\nthis:\n  index init y < length (fst (snd z))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have ff_q: \"index init (q) < length (?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init q < length (fst (snd z))", "unfolding ff_len"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init q < length init", "using qininit"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. index init q < length init", "by auto"], ["proof (state)\nthis:\n  index init q < length (fst (snd z))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have iq_ix: \"index init (q) \\<noteq> index init x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init q \\<noteq> index init x", "using a(1) qnx"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. index init q \\<noteq> index init x", "by auto"], ["proof (state)\nthis:\n  index init q \\<noteq> index init x\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have iq_iy: \"index init (q) \\<noteq> index init y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init q \\<noteq> index init y", "using a(2) qny"], ["proof (prove)\nusing this:\n  y \\<in> set init\n  q \\<noteq> y\n\ngoal (1 subgoal):\n 1. index init q \\<noteq> index init y", "by auto"], ["proof (state)\nthis:\n  index init q \\<noteq> index init y\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have ix_iy: \"index init x \\<noteq> index init y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init x \\<noteq> index init y", "using a(2) xny"], ["proof (prove)\nusing this:\n  y \\<in> set init\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index init x \\<noteq> index init y", "by auto"], ["proof (state)\nthis:\n  index init x \\<noteq> index init y\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have s_set[simp]: \"set (?s) = set init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "using config_rand_set"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "by force"], ["proof (state)\nthis:\n  set (fst z) = set init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have s_xin: \"x\\<in>set (?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (fst z)", "using a(1)"], ["proof (prove)\nusing this:\n  x \\<in> set init\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst z)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (fst z)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have s_yin: \"y\\<in>set (?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (fst z)", "using a(2)"], ["proof (prove)\nusing this:\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. y \\<in> set (fst z)", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (fst z)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "from 2"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have s_dist: \"distinct (?s)\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "using config_rand_distinct dinit"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "by force"], ["proof (state)\nthis:\n  distinct (fst z)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have s_qin: \"q \\<in> set (?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (fst z)", "using qininit"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set (fst z)", "by simp"], ["proof (state)\nthis:\n  q \\<in> set (fst z)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have fstfst: \"nths (flip (index ?m (q)) (?b))\n              {index init x, index init y}\n                  = nths (?b) {index init x, index init y}\" (is \"nths ?A ?I = nths ?B ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "proof (cases \"index init x < index init y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "case True"], ["proof (state)\nthis:\n  index init x < index init y\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"nths ?A ?I = [?A!index init x, ?A!index init y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n     flip (index (snd (snd z)) q) (fst (snd z)) ! index init y]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init x < length (flip (index (snd (snd z)) q) (fst (snd z)))\n 2. index init y < length (flip (index (snd (snd z)) q) (fst (snd z)))\n 3. index init x < index init y", "by(simp_all add: ff_ix ff_iy True)"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init y]\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "also"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init y]\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"\\<dots> = [?B!index init x, ?B!index init y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n     flip (index (snd (snd z)) q) (fst (snd z)) ! index init y] =\n    [fst (snd z) ! index init x, fst (snd z) ! index init y]", "unfolding sf_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    [fst (snd z) ! index init x, fst (snd z) ! index init y]", "using flip_other ff_ix ff_iy ff_q iq_ix iq_iy"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  index init x < length (fst (snd z))\n  index init y < length (fst (snd z))\n  index init q < length (fst (snd z))\n  index init q \\<noteq> index init x\n  index init q \\<noteq> index init y\n\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init x,\n     flip (index init q) (fst (snd z)) ! index init y] =\n    [fst (snd z) ! index init x, fst (snd z) ! index init y]", "by auto"], ["proof (state)\nthis:\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init y] =\n  [fst (snd z) ! index init x, fst (snd z) ! index init y]\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "also"], ["proof (state)\nthis:\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init x,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init y] =\n  [fst (snd z) ! index init x, fst (snd z) ! index init y]\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"\\<dots> = nths ?B ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (snd z) ! index init x, fst (snd z) ! index init y] =\n    nths (fst (snd z)) {index init x, index init y}", "apply(rule nths_project'[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init x < length (fst (snd z))\n 2. index init y < length (fst (snd z))\n 3. index init x < index init y", "by(simp_all add: ff_ix ff_iy True)"], ["proof (state)\nthis:\n  [fst (snd z) ! index init x, fst (snd z) ! index init y] =\n  nths (fst (snd z)) {index init x, index init y}\n\ngoal (2 subgoals):\n 1. index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}\n 2. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "finally"], ["proof (chain)\npicking this:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  nths (fst (snd z)) {index init x, index init y}", "show ?thesis"], ["proof (prove)\nusing this:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  nths (fst (snd z)) {index init x, index init y}\n\ngoal (1 subgoal):\n 1. nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "."], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  nths (fst (snd z)) {index init x, index init y}\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "case False"], ["proof (state)\nthis:\n  \\<not> index init x < index init y\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "then"], ["proof (chain)\npicking this:\n  \\<not> index init x < index init y", "have yx: \"index init y < index init x\""], ["proof (prove)\nusing this:\n  \\<not> index init x < index init y\n\ngoal (1 subgoal):\n 1. index init y < index init x", "using ix_iy"], ["proof (prove)\nusing this:\n  \\<not> index init x < index init y\n  index init x \\<noteq> index init y\n\ngoal (1 subgoal):\n 1. index init y < index init x", "by auto"], ["proof (state)\nthis:\n  index init y < index init x\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have man: \"?I =  {index init y, index init x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init x, index init y} = {index init y, index init x}", "by auto"], ["proof (state)\nthis:\n  {index init x, index init y} = {index init y, index init x}\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"nths ?A {index init y, index init x}  = [?A!index init y, ?A!index init x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init y, index init x} =\n    [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n     flip (index (snd (snd z)) q) (fst (snd z)) ! index init x]", "apply(rule nths_project')"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init y < length (flip (index (snd (snd z)) q) (fst (snd z)))\n 2. index init x < length (flip (index (snd (snd z)) q) (fst (snd z)))\n 3. index init y < index init x", "by(simp_all add: ff_ix ff_iy yx)"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init y, index init x} =\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init x]\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "also"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init y, index init x} =\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init x]\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"\\<dots> = [?B!index init y, ?B!index init x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n     flip (index (snd (snd z)) q) (fst (snd z)) ! index init x] =\n    [fst (snd z) ! index init y, fst (snd z) ! index init x]", "unfolding sf_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    [fst (snd z) ! index init y, fst (snd z) ! index init x]", "using flip_other ff_ix ff_iy ff_q iq_ix iq_iy"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  index init x < length (fst (snd z))\n  index init y < length (fst (snd z))\n  index init q < length (fst (snd z))\n  index init q \\<noteq> index init x\n  index init q \\<noteq> index init y\n\ngoal (1 subgoal):\n 1. [flip (index init q) (fst (snd z)) ! index init y,\n     flip (index init q) (fst (snd z)) ! index init x] =\n    [fst (snd z) ! index init y, fst (snd z) ! index init x]", "by auto"], ["proof (state)\nthis:\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init x] =\n  [fst (snd z) ! index init y, fst (snd z) ! index init x]\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "also"], ["proof (state)\nthis:\n  [flip (index (snd (snd z)) q) (fst (snd z)) ! index init y,\n   flip (index (snd (snd z)) q) (fst (snd z)) ! index init x] =\n  [fst (snd z) ! index init y, fst (snd z) ! index init x]\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "have \"\\<dots> = nths ?B {index init y, index init x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (snd z) ! index init y, fst (snd z) ! index init x] =\n    nths (fst (snd z)) {index init y, index init x}", "apply(rule nths_project'[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. index init y < length (fst (snd z))\n 2. index init x < length (fst (snd z))\n 3. index init y < index init x", "by(simp_all add: ff_ix ff_iy yx)"], ["proof (state)\nthis:\n  [fst (snd z) ! index init y, fst (snd z) ! index init x] =\n  nths (fst (snd z)) {index init y, index init x}\n\ngoal (1 subgoal):\n 1. \\<not> index init x < index init y \\<Longrightarrow>\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "finally"], ["proof (chain)\npicking this:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init y, index init x} =\n  nths (fst (snd z)) {index init y, index init x}", "show ?thesis"], ["proof (prove)\nusing this:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init y, index init x} =\n  nths (fst (snd z)) {index init y, index init x}\n\ngoal (1 subgoal):\n 1. nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y} =\n    nths (fst (snd z)) {index init x, index init y}", "by(simp add: man)"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  nths (fst (snd z)) {index init x, index init y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nths (flip (index (snd (snd z)) q) (fst (snd z)))\n   {index init x, index init y} =\n  nths (fst (snd z)) {index init x, index init y}\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "have snd: \"Lxy (step (?s) (q)\n                  (if ?b ! index ?m (q) then 0 else length (?s),\n                   [])) {x, y} = Lxy (?s) {x, y}\" (is \"Lxy ?A {x,y} = Lxy ?B {x,y}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "proof (cases \"x < y in ?B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "case True"], ["proof (state)\nthis:\n  x < y in fst z\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "note B=this"], ["proof (state)\nthis:\n  x < y in fst z\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "then"], ["proof (chain)\npicking this:\n  x < y in fst z", "have A: \"x<y in ?A\""], ["proof (prove)\nusing this:\n  x < y in fst z\n\ngoal (1 subgoal):\n 1. x < y\n    in step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         [])", "apply(auto simp add: step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> x < y in mtf2 (length (fst z)) q (fst z)", "apply(rule x_stays_before_y_if_y_not_moved_to_front)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (fst z)\n 2. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> distinct (fst z)\n 3. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (fst z)\n 4. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (fst z)\n 5. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> q\n 6. \\<lbrakk>x < y in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> x < y in fst z", "by(simp_all add: a s_dist qny[symmetric] qininit)"], ["proof (state)\nthis:\n  x < y\n  in step (fst z) q\n      (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n       [])\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "have \"Lxy ?A {x,y} = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    [x, y]", "apply(rule Lxy_project)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. x \\<in> set (step (fst z) q\n                  (if fst (snd z) ! index (snd (snd z)) q then 0\n                   else length (fst z),\n                   []))\n 3. y \\<in> set (step (fst z) q\n                  (if fst (snd z) ! index (snd (snd z)) q then 0\n                   else length (fst z),\n                   []))\n 4. distinct\n     (step (fst z) q\n       (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n        []))\n 5. x < y\n    in step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         [])", "by(simp_all add: xny set_step distinct_step A s_dist a)"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  [x, y]\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "also"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  [x, y]\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "have \"... = Lxy ?B {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x, y] = Lxy (fst z) {x, y}", "apply(rule Lxy_project[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. x \\<in> set (fst z)\n 3. y \\<in> set (fst z)\n 4. distinct (fst z)\n 5. x < y in fst z", "by(simp_all add: xny B s_dist a)"], ["proof (state)\nthis:\n  [x, y] = Lxy (fst z) {x, y}\n\ngoal (2 subgoals):\n 1. x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}\n 2. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "finally"], ["proof (chain)\npicking this:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  Lxy (fst z) {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  Lxy (fst z) {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "."], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  Lxy (fst z) {x, y}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "case False"], ["proof (state)\nthis:\n  \\<not> x < y in fst z\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "then"], ["proof (chain)\npicking this:\n  \\<not> x < y in fst z", "have B: \"y < x in ?B\""], ["proof (prove)\nusing this:\n  \\<not> x < y in fst z\n\ngoal (1 subgoal):\n 1. y < x in fst z", "using not_before_in[OF s_xin s_yin] xny"], ["proof (prove)\nusing this:\n  \\<not> x < y in fst z\n  (\\<not> x < y in fst z) = (y < x in fst z \\<or> x = y)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y < x in fst z", "by simp"], ["proof (state)\nthis:\n  y < x in fst z\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "then"], ["proof (chain)\npicking this:\n  y < x in fst z", "have A: \"y < x in ?A \""], ["proof (prove)\nusing this:\n  y < x in fst z\n\ngoal (1 subgoal):\n 1. y < x\n    in step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         [])", "apply(auto simp add: step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> y < x in mtf2 (length (fst z)) q (fst z)", "apply(rule x_stays_before_y_if_y_not_moved_to_front)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (fst z)\n 2. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> distinct (fst z)\n 3. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (fst z)\n 4. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (fst z)\n 5. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> q\n 6. \\<lbrakk>y < x in fst z;\n     \\<not> fst (snd z) ! index (snd (snd z)) q\\<rbrakk>\n    \\<Longrightarrow> y < x in fst z", "by(simp_all add: a s_dist qnx[symmetric] qininit)"], ["proof (state)\nthis:\n  y < x\n  in step (fst z) q\n      (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n       [])\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "have man: \"{x,y} = {y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {y, x}", "by auto"], ["proof (state)\nthis:\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "have \"Lxy ?A {y,x} = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {y, x} =\n    [y, x]", "apply(rule Lxy_project)"], ["proof (prove)\ngoal (5 subgoals):\n 1. y \\<noteq> x\n 2. y \\<in> set (step (fst z) q\n                  (if fst (snd z) ! index (snd (snd z)) q then 0\n                   else length (fst z),\n                   []))\n 3. x \\<in> set (step (fst z) q\n                  (if fst (snd z) ! index (snd (snd z)) q then 0\n                   else length (fst z),\n                   []))\n 4. distinct\n     (step (fst z) q\n       (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n        []))\n 5. y < x\n    in step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         [])", "by(simp_all add: xny[symmetric] set_step distinct_step A s_dist a)"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {y, x} =\n  [y, x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "also"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {y, x} =\n  [y, x]\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "have \"... = Lxy ?B {y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y, x] = Lxy (fst z) {y, x}", "apply(rule Lxy_project[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. y \\<noteq> x\n 2. y \\<in> set (fst z)\n 3. x \\<in> set (fst z)\n 4. distinct (fst z)\n 5. y < x in fst z", "by(simp_all add: xny[symmetric] B s_dist a)"], ["proof (state)\nthis:\n  [y, x] = Lxy (fst z) {y, x}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in fst z \\<Longrightarrow>\n    Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "finally"], ["proof (chain)\npicking this:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {y, x} =\n  Lxy (fst z) {y, x}", "show ?thesis"], ["proof (prove)\nusing this:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {y, x} =\n  Lxy (fst z) {y, x}\n\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "using man"], ["proof (prove)\nusing this:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {y, x} =\n  Lxy (fst z) {y, x}\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y} =\n    Lxy (fst z) {x, y}", "by auto"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  Lxy (fst z) {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lxy (step (fst z) q\n        (if fst (snd z) ! index (snd (snd z)) q then 0 else length (fst z),\n         []))\n   {x, y} =\n  Lxy (fst z) {x, y}\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf\n        (Lxy (step (fst xa) q\n               (if fst (snd xa) ! index (snd (snd xa)) q then 0\n                else length (fst xa),\n                []))\n          {x, y},\n         nths (flip (index (snd (snd xa)) q) (fst (snd xa)))\n          {index init x, index init y},\n         Lxy init {x, y}) =\n       return_pmf\n        (Lxy (fst xa) {x, y},\n         nths (fst (snd xa)) {index init x, index init y}, Lxy init {x, y})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf\n     (Lxy (step (fst z) q\n            (if fst (snd z) ! index (snd (snd z)) q then 0\n             else length (fst z),\n             []))\n       {x, y},\n      nths (flip (index (snd (snd z)) q) (fst (snd z)))\n       {index init x, index init y},\n      Lxy init {x, y}) =\n    return_pmf\n     (Lxy (fst z) {x, y}, nths (fst (snd z)) {index init x, index init y},\n      Lxy init {x, y})", "by(simp add: fstfst snd)"], ["proof (state)\nthis:\n  return_pmf\n   (Lxy (step (fst z) q\n          (if fst (snd z) ! index (snd (snd z)) q then 0\n           else length (fst z),\n           []))\n     {x, y},\n    nths (flip (index (snd (snd z)) q) (fst (snd z)))\n     {index init x, index init y},\n    Lxy init {x, y}) =\n  return_pmf\n   (Lxy (fst z) {x, y}, nths (fst (snd z)) {index init x, index init y},\n    Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs", "qed simp"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>p.\n        BIT_step p q \\<bind>\n        (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa)))) =\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>p.\n        BIT_step p q \\<bind>\n        (\\<lambda>pa. return_pmf (step (fst p) q (fst pa), snd pa)))) =\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"\\<dots> = config_rand BIT (Lxy init {x, y}) (Lxy qs {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y})", "using iH"], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         (Lxy (fst a) {x, y},\n          nths (fst (snd a)) {index init x, index init y}, Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y})", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "have \"\\<dots> = ?R (qs@[q])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "using False"], ["proof (prove)\nusing this:\n  q \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "by(simp add: Lxy_snoc)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y}) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal (1 subgoal):\n 1. q \\<notin> {x, y} \\<Longrightarrow>\n    map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "finally"], ["proof (chain)\npicking this:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf\n   (\\<lambda>a.\n       (Lxy (fst a) {x, y}, nths (fst (snd a)) {index init x, index init y},\n        Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>a.\n         case a of\n         (l, w, i) \\<Rightarrow>\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q])) =\n    Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (qs @ [q]) {x, y})", "by (simp add: split_def)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>a.\n       case a of\n       (l, w, i) \\<Rightarrow>\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q])) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (qs @ [q]) {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "}"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "note strong=this"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "{"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init \\<Longrightarrow>\n  map_pmf\n   (\\<lambda>(l, w, i).\n       (Lxy l {x, y}, nths w {index init x, index init y}, Lxy init {x, y}))\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have \"Pbefore_in x y BIT qs init = \n        map_pmf (\\<lambda>p. x < y in fst p)\n            (map_pmf (\\<lambda>(l, (w, i)). (Lxy l {x, y}, (nths w {index init x, index init y}, Lxy init {x, y})))\n                  (config_rand BIT init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (map_pmf\n       (\\<lambda>(l, w, i).\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n       (Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "unfolding Pbefore_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (map_pmf\n       (\\<lambda>(l, w, i).\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n       (Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "apply(simp add: map_pmf_def bind_return_pmf bind_assoc_pmf split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa. return_pmf (x < y in fst xa)) =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n    (\\<lambda>xa. return_pmf (x < y in Lxy (fst xa) {x, y}))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    Partial_Cost_Model.config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "case (1 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "let ?s = \"fst z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "from 1"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have u: \"set (?s) = set init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "using config_rand[of BIT, simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init \\<and>\n     distinct (fst x) = distinct ?init \\<and> length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "by metis"], ["proof (state)\nthis:\n  set (fst z) = set init\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "from 1"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)", "have v: \"distinct (?s)\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "using dinit config_rand[of BIT, simplified]"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs)\n  distinct init\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand BIT\n                    (BIT_init ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init \\<and>\n     distinct (fst x) = distinct ?init \\<and> length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "by metis"], ["proof (state)\nthis:\n  distinct (fst z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "have \"(x < y in ?s) = (x < y in Lxy (?s) {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in fst z = x < y in Lxy (fst z) {x, y}", "apply(rule Lxy_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set (fst z)\n 2. distinct (fst z)", "using u xyininit"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. {x, y} \\<subseteq> set (fst z)\n 2. distinct (fst z)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst z)", "using v"], ["proof (prove)\nusing this:\n  distinct (fst z)\n\ngoal (1 subgoal):\n 1. distinct (fst z)", "by simp"], ["proof (state)\nthis:\n  x < y in fst z = x < y in Lxy (fst z) {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand BIT\n                   (BIT_init init \\<bind>\n                    (\\<lambda>is. return_pmf (init, is)))\n                   qs) \\<Longrightarrow>\n       return_pmf (x < y in fst xa) =\n       return_pmf (x < y in Lxy (fst xa) {x, y})", "then"], ["proof (chain)\npicking this:\n  x < y in fst z = x < y in Lxy (fst z) {x, y}", "show ?case"], ["proof (prove)\nusing this:\n  x < y in fst z = x < y in Lxy (fst z) {x, y}\n\ngoal (1 subgoal):\n 1. return_pmf (x < y in fst z) = return_pmf (x < y in Lxy (fst z) {x, y})", "by simp"], ["proof (state)\nthis:\n  return_pmf (x < y in fst z) = return_pmf (x < y in Lxy (fst z) {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "also"], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have \"\\<dots> = map_pmf (\\<lambda>p. x < y in fst p) (config_rand BIT (Lxy init {x, y}) (Lxy qs {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (map_pmf\n       (\\<lambda>(l, w, i).\n           (Lxy l {x, y}, nths w {index init x, index init y},\n            Lxy init {x, y}))\n       (Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "apply(subst strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set qs \\<subseteq> set init\n 2. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y})) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "using assms"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n\ngoal (2 subgoals):\n 1. set qs \\<subseteq> set init\n 2. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y})) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "by simp_all"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (map_pmf\n     (\\<lambda>(l, w, i).\n         (Lxy l {x, y}, nths w {index init x, index init y},\n          Lxy init {x, y}))\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have \"\\<dots> = Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y})) =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "unfolding Pbefore_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y})) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "by simp"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>p. x < y in fst p)\n   (Partial_Cost_Model.config'_rand BIT\n     (fst BIT (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy qs {x, y})) =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "finally"], ["proof (chain)\npicking this:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "have \"Pbefore_in x y BIT qs init =\n        Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\""], ["proof (prove)\nusing this:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "."], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "}"], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "note fine=this"], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "with assms"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "show ?thesis"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n  distinct init\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. Pbefore_in x y BIT qs init =\n    Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})", "by simp"], ["proof (state)\nthis:\n  Pbefore_in x y BIT qs init =\n  Pbefore_in x y BIT (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem BIT_pairwise: \"pairwise BIT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise BIT", "apply(rule pairwise_property_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> Pbefore_in x y BIT qs init =\n                         Pbefore_in x y BIT (Lxy qs {x, y})\n                          (Lxy init {x, y})\n 2. \\<And>xa r. \\<forall>z\\<in>set_pmf (snd BIT xa r). snd (fst z) = []", "apply(rule BIT_pairwise')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> set qs \\<subseteq> set init\n 2. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> {(x, y).\n                                x \\<in> set init \\<and>\n                                y \\<in> set init \\<and> x \\<noteq> y}\n 3. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y\n 4. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> distinct init\n 5. \\<And>xa r. \\<forall>z\\<in>set_pmf (snd BIT xa r). snd (fst z) = []", "by(simp_all add: BIT_step_def)"], ["", "end"]]}