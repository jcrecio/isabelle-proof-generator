{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Phase_Partitioning.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma Lxx_not_nullable: \"[] \\<notin> Lxx x y\"", "lemma Lxx_ends_in_two_equal: \"xs \\<in> Lxx x y \\<Longrightarrow> \\<exists>pref e. xs = pref @ [e,e]\"", "lemma \"Lxx x y = Lxx y x\"", "lemma Lxx_othercase: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> \\<not> (\\<exists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y) \\<Longrightarrow> qs \\<in> lang (hideit x y)\"", "lemma pad_adds2: \"qs \\<noteq> [] \\<Longrightarrow> set qs \\<subseteq> {x,y} \\<Longrightarrow> pad qs x y = qs @ [last qs]\"", "lemma nodouble_padded: \"qs \\<noteq> [] \\<Longrightarrow> qs \\<in> lang (nodouble x y) \\<Longrightarrow> pad qs x y \\<in> Lxx x y\"", "lemma \"c \\<in> A \\<union> B \\<Longrightarrow> P\"", "lemma LxxE: \"qs \\<in> Lxx x y\n    \\<Longrightarrow> (qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> P x y qs\"", "lemma \"qs \\<in> Lxx x y \\<Longrightarrow> P\"", "lemma LxxI: \"(qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> Lxx x y \\<Longrightarrow> P x y qs)\"", "lemma Lxx1: \"xs \\<in> Lxx x y \\<Longrightarrow> length xs \\<ge> 2\"", "lemma ayay: \"length qs = length as \\<Longrightarrow> T\\<^sub>p s (qs@[q]) (as@[a]) = T\\<^sub>p s qs as + t\\<^sub>p (steps s qs as) q a\"", "lemma tlofOPT2: \"Q \\<in> {x,y} \\<Longrightarrow> set QS \\<subseteq> {x,y} \\<Longrightarrow> R \\<in> {[x, y], [y, x]} \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n    OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\"", "lemma T\\<^sub>p_split: \"length qs1=length as1 \\<Longrightarrow> T\\<^sub>p s (qs1@qs2) (as1@as2) = T\\<^sub>p s qs1 as1 + T\\<^sub>p (steps s qs1 as1) qs2 as2\"", "lemma T\\<^sub>p_spliting: \"x\\<noteq>y \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow>\n      R \\<in> {[x,y],[y,x]} \\<Longrightarrow>\n      T\\<^sub>p R (xs@[x,x]) (OPT2 (xs@[x,x]) R) + T\\<^sub>p [x,y] ys (OPT2 ys [x,y])\n      = T\\<^sub>p R (xs@[x,x]@ys) (OPT2 (xs@[x,x]@ys) R)\"", "lemma OPTauseinander: \"x\\<noteq>y \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow>\n      LTS \\<in> {[x,y],[y,x]} \\<Longrightarrow> hd LTS = last xs \\<Longrightarrow>\n     xs = (pref @ [hd LTS, hd LTS]) \\<Longrightarrow> \n      T\\<^sub>p [x,y] xs (OPT2 xs [x,y]) + T\\<^sub>p LTS ys (OPT2 ys LTS)\n      = T\\<^sub>p [x,y] (xs@ys) (OPT2 (xs@ys) [x,y])\"", "theorem Phase_partitioning_general: \n  fixes P :: \"(nat state * 'is) pmf \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> bool\"\n      and A :: \"(nat state,'is,nat,answer) alg_on_rand\"\n  assumes xny: \"(x0::nat) \\<noteq> y0\" \n    and cpos: \"(c::real)\\<ge>0\"\n    and static: \"set \\<sigma> \\<subseteq> {x0,y0}\" \n    and initial: \"P (map_pmf (%is. ([x0,y0],is)) (fst A [x0,y0])) x0 [x0,y0]\"\n    and D: \"\\<And>a b \\<sigma> s.  \\<sigma> \\<in> Lxx a b \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> {a,b}={x0,y0} \\<Longrightarrow> P s a [x0,y0]  \\<Longrightarrow> set \\<sigma> \\<subseteq> {a,b}\n          \\<Longrightarrow> T_on_rand' A s \\<sigma> \\<le> c * T\\<^sub>p [a,b] \\<sigma> (OPT2 \\<sigma> [a,b])  \\<and> P (config'_rand A s \\<sigma>) (last \\<sigma>) [x0,y0]\"\n  shows \"T\\<^sub>p_on_rand A [x0,y0] \\<sigma>  \\<le> c * T\\<^sub>p_opt [x0,y0] \\<sigma> + c\"", "theorem Phase_partitioning_general_det: \n  fixes P :: \"(nat state * 'is) \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> bool\"\n      and A :: \"(nat,'is) alg_on\"\n  assumes xny: \"(x0::nat) \\<noteq> y0\" \n    and cpos: \"(c::real)\\<ge>0\"\n    and static: \"set \\<sigma> \\<subseteq> {x0,y0}\" \n    and initial: \"P ([x0,y0],(fst A [x0,y0])) x0 [x0,y0]\"\n    and D: \"\\<And>a b \\<sigma> s.  \\<sigma> \\<in> Lxx a b \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> {a,b}={x0,y0} \\<Longrightarrow> P s a [x0,y0]  \\<Longrightarrow> set \\<sigma> \\<subseteq> {a,b}\n          \\<Longrightarrow> T_on' A s \\<sigma> \\<le> c * T\\<^sub>p [a,b] \\<sigma> (OPT2 \\<sigma> [a,b])  \\<and> P (config' A s \\<sigma>) (last \\<sigma>) [x0,y0]\"\n  shows \"T\\<^sub>p_on A [x0,y0] \\<sigma>  \\<le> c * T\\<^sub>p_opt [x0,y0] \\<sigma> + c\""], "translations": [["", "lemma Lxx_not_nullable: \"[] \\<notin> Lxx x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> Lxx x y", "unfolding Lxx_def L_lasthasxx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> lang\n                 (Plus\n                   (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                         Atom y, Atom y])\n                   (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                         Atom x, Atom x]))", "by simp"], ["", "(* lemma set_Lxx: \"xs \\<in> Lxx x y \\<Longrightarrow> set xs \\<subseteq> {x,y}\"\nunfolding Lxx_def L_lasthasxx_def apply(simp add: star_def) sle dgehammer *)"], ["", "lemma Lxx_ends_in_two_equal: \"xs \\<in> Lxx x y \\<Longrightarrow> \\<exists>pref e. xs = pref @ [e,e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Lxx x y \\<Longrightarrow> \\<exists>pref e. xs = pref @ [e, e]", "by(auto simp: conc_def Lxx_def L_lasthasxx_def)"], ["", "lemma \"Lxx x y = Lxx y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxx x y = Lxx y x", "unfolding Lxx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (L_lasthasxx x y) = lang (L_lasthasxx y x)", "by(rule lastxx_com)"], ["", "definition \"hideit x y = (Plus rexp.One (nodouble x y))\""], ["", "lemma Lxx_othercase: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> \\<not> (\\<exists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y) \\<Longrightarrow> qs \\<in> lang (hideit x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "assume \"set qs \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {x, y}", "have \"qs \\<in> lang (myUNIV x y)\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (myUNIV x y)", "using myUNIV_alle[of x y]"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {x, y}\n  lang (myUNIV x y) = {xs. set xs \\<subseteq> {x, y}}\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (myUNIV x y)", "by blast"], ["proof (state)\nthis:\n  qs \\<in> lang (myUNIV x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (myUNIV x y)", "have \"qs \\<in> star (lang (L_lasthasxx x y)) @@  lang (hideit x y)\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (myUNIV x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> star (lang (L_lasthasxx x y)) @@ lang (hideit x y)", "unfolding hideit_def"], ["proof (prove)\nusing this:\n  qs \\<in> lang (myUNIV x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> star (lang (L_lasthasxx x y)) @@\n             lang (Plus rexp.One (nodouble x y))", "by(auto simp add: myUNIV_char)"], ["proof (state)\nthis:\n  qs \\<in> star (lang (L_lasthasxx x y)) @@ lang (hideit x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "then"], ["proof (chain)\npicking this:\n  qs \\<in> star (lang (L_lasthasxx x y)) @@ lang (hideit x y)", "have qs: \"qs \\<in> star (Lxx x y) @@  lang (hideit x y)\""], ["proof (prove)\nusing this:\n  qs \\<in> star (lang (L_lasthasxx x y)) @@ lang (hideit x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> star (Lxx x y) @@ lang (hideit x y)", "by(simp add: Lxx_def)"], ["proof (state)\nthis:\n  qs \\<in> star (Lxx x y) @@ lang (hideit x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "assume notpos: \"\\<not> (\\<exists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y)\""], ["proof (state)\nthis:\n  \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y};\n     \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang (hideit x y)", "show \"qs \\<in> lang (hideit x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "from qs"], ["proof (chain)\npicking this:\n  qs \\<in> star (Lxx x y) @@ lang (hideit x y)", "obtain A B where qsAB: \"qs=A@B\" and A: \"A\\<in>star (Lxx x y)\" and B: \"B\\<in>lang (hideit x y)\""], ["proof (prove)\nusing this:\n  qs \\<in> star (Lxx x y) @@ lang (hideit x y)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>qs = A @ B; A \\<in> star (Lxx x y);\n         B \\<in> lang (hideit x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qs = A @ B\n  A \\<in> star (Lxx x y)\n  B \\<in> lang (hideit x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "with notpos"], ["proof (chain)\npicking this:\n  \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\n  qs = A @ B\n  A \\<in> star (Lxx x y)\n  B \\<in> lang (hideit x y)", "have notin: \"A \\<notin> (Lxx x y)\""], ["proof (prove)\nusing this:\n  \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\n  qs = A @ B\n  A \\<in> star (Lxx x y)\n  B \\<in> lang (hideit x y)\n\ngoal (1 subgoal):\n 1. A \\<notin> Lxx x y", "by blast"], ["proof (state)\nthis:\n  A \\<notin> Lxx x y\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> star (Lxx x y)", "have 1: \"A = [] \\<or> A \\<in> (Lxx x y) @@ star (Lxx x y)\""], ["proof (prove)\nusing this:\n  A \\<in> star (Lxx x y)\n\ngoal (1 subgoal):\n 1. A = [] \\<or> A \\<in> Lxx x y @@ star (Lxx x y)", "using Regular_Set.star_unfold_left"], ["proof (prove)\nusing this:\n  A \\<in> star (Lxx x y)\n  star ?A = ?A @@ star ?A \\<union> {[]}\n\ngoal (1 subgoal):\n 1. A = [] \\<or> A \\<in> Lxx x y @@ star (Lxx x y)", "by auto"], ["proof (state)\nthis:\n  A = [] \\<or> A \\<in> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "have 2: \"A \\<notin> (Lxx x y) @@ star (Lxx x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<notin> Lxx x y @@ star (Lxx x y)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "assume \"\\<not> A \\<notin> Lxx x y @@ star (Lxx x y)\""], ["proof (state)\nthis:\n  \\<not> A \\<notin> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> A \\<notin> Lxx x y @@ star (Lxx x y)", "have \" A \\<in> Lxx x y @@ star (Lxx x y)\""], ["proof (prove)\nusing this:\n  \\<not> A \\<notin> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. A \\<in> Lxx x y @@ star (Lxx x y)", "by auto"], ["proof (state)\nthis:\n  A \\<in> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  A \\<in> Lxx x y @@ star (Lxx x y)", "obtain A1 A2 where \"A=A1@A2\" and A1: \"A1\\<in>(Lxx x y)\" and \"A2\\<in> star (Lxx x y)\""], ["proof (prove)\nusing this:\n  A \\<in> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. (\\<And>A1 A2.\n        \\<lbrakk>A = A1 @ A2; A1 \\<in> Lxx x y;\n         A2 \\<in> star (Lxx x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A = A1 @ A2\n  A1 \\<in> Lxx x y\n  A2 \\<in> star (Lxx x y)\n\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "with qsAB"], ["proof (chain)\npicking this:\n  qs = A @ B\n  A = A1 @ A2\n  A1 \\<in> Lxx x y\n  A2 \\<in> star (Lxx x y)", "have \"qs=A1@(A2@B)\" \"A1\\<in>(Lxx x y)\""], ["proof (prove)\nusing this:\n  qs = A @ B\n  A = A1 @ A2\n  A1 \\<in> Lxx x y\n  A2 \\<in> star (Lxx x y)\n\ngoal (1 subgoal):\n 1. qs = A1 @ A2 @ B &&& A1 \\<in> Lxx x y", "by auto"], ["proof (state)\nthis:\n  qs = A1 @ A2 @ B\n  A1 \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "with notpos"], ["proof (chain)\npicking this:\n  \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\n  qs = A1 @ A2 @ B\n  A1 \\<in> Lxx x y", "have \"A1 \\<notin> (Lxx x y)\""], ["proof (prove)\nusing this:\n  \\<nexists>xs ys. qs = xs @ ys \\<and> xs \\<in> Lxx x y\n  qs = A1 @ A2 @ B\n  A1 \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. A1 \\<notin> Lxx x y", "by blast"], ["proof (state)\nthis:\n  A1 \\<notin> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<not> A \\<notin> Lxx x y @@ star (Lxx x y) \\<Longrightarrow> False", "with A1"], ["proof (chain)\npicking this:\n  A1 \\<in> Lxx x y\n  A1 \\<notin> Lxx x y", "show \"False\""], ["proof (prove)\nusing this:\n  A1 \\<in> Lxx x y\n  A1 \\<notin> Lxx x y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<notin> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "from 1 2"], ["proof (chain)\npicking this:\n  A = [] \\<or> A \\<in> Lxx x y @@ star (Lxx x y)\n  A \\<notin> Lxx x y @@ star (Lxx x y)", "have \"A=[]\""], ["proof (prove)\nusing this:\n  A = [] \\<or> A \\<in> Lxx x y @@ star (Lxx x y)\n  A \\<notin> Lxx x y @@ star (Lxx x y)\n\ngoal (1 subgoal):\n 1. A = []", "by auto"], ["proof (state)\nthis:\n  A = []\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "with qsAB"], ["proof (chain)\npicking this:\n  qs = A @ B\n  A = []", "have \"qs=B\""], ["proof (prove)\nusing this:\n  qs = A @ B\n  A = []\n\ngoal (1 subgoal):\n 1. qs = B", "by auto"], ["proof (state)\nthis:\n  qs = B\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "with B"], ["proof (chain)\npicking this:\n  B \\<in> lang (hideit x y)\n  qs = B", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> lang (hideit x y)\n  qs = B\n\ngoal (1 subgoal):\n 1. qs \\<in> lang (hideit x y)", "by simp"], ["proof (state)\nthis:\n  qs \\<in> lang (hideit x y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qs \\<in> lang (hideit x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun pad where \"pad xs x y = (if xs=[] then [x,x] else \n                                    (if last xs = x then xs @ [x] else xs @ [y]))\""], ["", "lemma pad_adds2: \"qs \\<noteq> [] \\<Longrightarrow> set qs \\<subseteq> {x,y} \\<Longrightarrow> pad qs x y = qs @ [last qs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; set qs \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> pad qs x y = qs @ [last qs]", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; set qs \\<subseteq> {x, y};\n     last qs \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> y = last qs", "by (metis insertE insert_absorb insert_not_empty last_in_set subset_iff)"], ["", "lemma nodouble_padded: \"qs \\<noteq> [] \\<Longrightarrow> qs \\<in> lang (nodouble x y) \\<Longrightarrow> pad qs x y \\<in> Lxx x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; qs \\<in> lang (nodouble x y)\\<rbrakk>\n    \\<Longrightarrow> pad qs x y \\<in> Lxx x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; qs \\<in> lang (nodouble x y)\\<rbrakk>\n    \\<Longrightarrow> pad qs x y \\<in> Lxx x y", "assume nn: \"qs \\<noteq> []\""], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; qs \\<in> lang (nodouble x y)\\<rbrakk>\n    \\<Longrightarrow> pad qs x y \\<in> Lxx x y", "assume \"qs \\<in> lang (nodouble x y)\""], ["proof (state)\nthis:\n  qs \\<in> lang (nodouble x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; qs \\<in> lang (nodouble x y)\\<rbrakk>\n    \\<Longrightarrow> pad qs x y \\<in> Lxx x y", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (nodouble x y)", "have a: \"qs \\<in> lang         (seq\n          [Plus (Atom x) rexp.One,\n           Star (Times (Atom y) (Atom x)),\n           Atom y]) \\<or> qs \\<in> lang\n        (seq\n          [Plus (Atom y) rexp.One,\n           Star (Times (Atom x) (Atom y)),\n           Atom x])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (nodouble x y)\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<or>\n    qs \\<in> lang\n              (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                    Atom x])", "unfolding nodouble_def"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (Plus\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y])\n              (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                    Atom x]))\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<or>\n    qs \\<in> lang\n              (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                    Atom x])", "by auto"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y]) \\<or>\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<noteq> []; qs \\<in> lang (nodouble x y)\\<rbrakk>\n    \\<Longrightarrow> pad qs x y \\<in> Lxx x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y \\<in> Lxx x y", "proof (cases \"qs \\<in> lang (seq [Plus (Atom x) One, Star (Times (Atom y) (Atom x)), Atom y])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "case True"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y])\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y])", "have \"qs \\<in> lang (seq [Plus (Atom x) One, Star (Times (Atom y) (Atom x))]) @@ {[y]}\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x))]) @@\n             {[y]}", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> lang (seq [question (Atom x), Star (Times (Atom y) (Atom x))]) @@\n           {[y]}\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [question (Atom x), Star (Times (Atom y) (Atom x))]) @@\n           {[y]}", "have \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Star (Times (Atom y) (Atom x))]) @@\n           {[y]}\n\ngoal (1 subgoal):\n 1. last qs = y", "by auto"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "with nn"], ["proof (chain)\npicking this:\n  qs \\<noteq> []\n  last qs = y", "have p: \"pad qs x y = qs @ [y]\""], ["proof (prove)\nusing this:\n  qs \\<noteq> []\n  last qs = y\n\ngoal (1 subgoal):\n 1. pad qs x y = qs @ [y]", "by auto"], ["proof (state)\nthis:\n  pad qs x y = qs @ [y]\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "have A: \"pad qs x y \\<in> lang  (seq [Plus (Atom x) One, Star (Times (Atom y) (Atom x)),\n             Atom y]) @@ {[y]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y]) @@\n          {[y]}", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs @ [y]\n    \\<in> lang\n           (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y]) @@\n          {[y]}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs @ [y] \\<in> ({[], [x]} @@ star ({[y]} @@ {[x]}) @@ {[y]}) @@ {[y]}", "apply(rule concI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> {[], [x]} @@ star ({[y]} @@ {[x]}) @@ {[y]}\n 2. [y] \\<in> {[y]}", "using True"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y])\n\ngoal (2 subgoals):\n 1. qs \\<in> {[], [x]} @@ star ({[y]} @@ {[x]}) @@ {[y]}\n 2. [y] \\<in> {[y]}", "by auto"], ["proof (state)\nthis:\n  pad qs x y\n  \\<in> lang\n         (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n               Atom y]) @@\n        {[y]}\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "have B: \"lang  (seq [Plus (Atom x) One, Star (Times (Atom y) (Atom x)),\n             Atom y]) @@ {[y]} = lang  (seq [Plus (Atom x) One, Star (Times (Atom y) (Atom x)),\n             Atom y, Atom y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang\n     (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y]) @@\n    {[y]} =\n    lang\n     (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y,\n           Atom y])", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  lang (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y]) @@\n  {[y]} =\n  lang\n   (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y\n 2. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "show \"pad qs x y \\<in> Lxx x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y \\<in> Lxx x y", "unfolding Lxx_def L_lasthasxx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (Plus\n             (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])\n             (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                   Atom x, Atom x]))", "using B A"], ["proof (prove)\nusing this:\n  lang (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y]) @@\n  {[y]} =\n  lang\n   (seq [question (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n  pad qs x y\n  \\<in> lang\n         (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n               Atom y]) @@\n        {[y]}\n\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (Plus\n             (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])\n             (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                   Atom x, Atom x]))", "by auto"], ["proof (state)\nthis:\n  pad qs x y \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "case False"], ["proof (state)\nthis:\n  qs \\<notin> lang\n               (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                     Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "with a"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y]) \\<or>\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n  qs \\<notin> lang\n               (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                     Atom y])", "have T: \"qs \\<in> lang (seq [Plus (Atom y) One, Star (Times (Atom x) (Atom y)), Atom x])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y]) \\<or>\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n  qs \\<notin> lang\n               (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                     Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                    Atom x])", "by auto"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])", "have \"qs \\<in> lang (seq [Plus (Atom y) One, Star (Times (Atom x) (Atom y))]) @@ {[x]}\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom y), Star (Times (Atom x) (Atom y))]) @@\n             {[x]}", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> lang (seq [question (Atom y), Star (Times (Atom x) (Atom y))]) @@\n           {[x]}\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [question (Atom y), Star (Times (Atom x) (Atom y))]) @@\n           {[x]}", "have \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom y), Star (Times (Atom x) (Atom y))]) @@\n           {[x]}\n\ngoal (1 subgoal):\n 1. last qs = x", "by auto"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "with nn"], ["proof (chain)\npicking this:\n  qs \\<noteq> []\n  last qs = x", "have p: \"pad qs x y = qs @ [x]\""], ["proof (prove)\nusing this:\n  qs \\<noteq> []\n  last qs = x\n\ngoal (1 subgoal):\n 1. pad qs x y = qs @ [x]", "by auto"], ["proof (state)\nthis:\n  pad qs x y = qs @ [x]\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "have A: \"pad qs x y \\<in> lang  (seq [Plus (Atom y) One, Star (Times (Atom x) (Atom y)),\n             Atom x]) @@ {[x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                 Atom x]) @@\n          {[x]}", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs @ [x]\n    \\<in> lang\n           (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                 Atom x]) @@\n          {[x]}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs @ [x] \\<in> ({[], [y]} @@ star ({[x]} @@ {[y]}) @@ {[x]}) @@ {[x]}", "apply(rule concI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> {[], [y]} @@ star ({[x]} @@ {[y]}) @@ {[x]}\n 2. [x] \\<in> {[x]}", "using T"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                  Atom x])\n\ngoal (2 subgoals):\n 1. qs \\<in> {[], [y]} @@ star ({[x]} @@ {[y]}) @@ {[x]}\n 2. [x] \\<in> {[x]}", "by auto"], ["proof (state)\nthis:\n  pad qs x y\n  \\<in> lang\n         (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n               Atom x]) @@\n        {[x]}\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "have B: \"lang  (seq [Plus (Atom y) One, Star (Times (Atom x) (Atom y)),\n             Atom x]) @@ {[x]} = lang  (seq [Plus (Atom y) One, Star (Times (Atom x) (Atom y)),\n             Atom x, Atom x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang\n     (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x]) @@\n    {[x]} =\n    lang\n     (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x,\n           Atom x])", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  lang (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x]) @@\n  {[x]} =\n  lang\n   (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<notin> lang\n                 (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                       Atom y]) \\<Longrightarrow>\n    pad qs x y \\<in> Lxx x y", "show \"pad qs x y \\<in> Lxx x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y \\<in> Lxx x y", "unfolding Lxx_def L_lasthasxx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (Plus\n             (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])\n             (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                   Atom x, Atom x]))", "using B A"], ["proof (prove)\nusing this:\n  lang (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x]) @@\n  {[x]} =\n  lang\n   (seq [question (Atom y), Star (Times (Atom x) (Atom y)), Atom x, Atom x])\n  pad qs x y\n  \\<in> lang\n         (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n               Atom x]) @@\n        {[x]}\n\ngoal (1 subgoal):\n 1. pad qs x y\n    \\<in> lang\n           (Plus\n             (seq [question (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])\n             (seq [question (Atom y), Star (Times (Atom x) (Atom y)),\n                   Atom x, Atom x]))", "by auto"], ["proof (state)\nthis:\n  pad qs x y \\<in> Lxx x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pad qs x y \\<in> Lxx x y\n\ngoal:\nNo subgoals!", "qed"], ["", "thm UnE"], ["", "lemma \"c \\<in> A \\<union> B \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> A \\<union> B \\<Longrightarrow> P", "apply(erule UnE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. c \\<in> A \\<Longrightarrow> P\n 2. c \\<in> B \\<Longrightarrow> P", "oops"], ["", "lemma LxxE: \"qs \\<in> Lxx x y\n    \\<Longrightarrow> (qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> P x y qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> Lxx x y;\n     qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "unfolding Lxx_def lastxx_is_4cases[symmetric] L_4cases_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang\n                       (verund\n                         [seq [question (Atom x), Atom y, Atom y],\n                          seq [question (Atom x), Atom y, Atom x,\n                               Star (Times (Atom y) (Atom x)), Atom y,\n                               Atom y],\n                          seq [question (Atom x), Atom y, Atom x,\n                               Star (Times (Atom y) (Atom x)), Atom x],\n                          seq [Atom x, Atom x]]);\n     qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "apply(simp only: verund.simps lang.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang\n                       (seq [question (Atom x), Atom y, Atom y]) \\<union>\n                      (lang\n                        (seq [question (Atom x), Atom y, Atom x,\n                              Star (Times (Atom y) (Atom x)), Atom y,\n                              Atom y]) \\<union>\n                       (lang\n                         (seq [question (Atom x), Atom y, Atom x,\n                               Star (Times (Atom y) (Atom x)),\n                               Atom x]) \\<union>\n                        lang (seq [Atom x, Atom x])));\n     qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "using UnE"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<in> ?A \\<union> ?B; ?c \\<in> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang\n                       (seq [question (Atom x), Atom y, Atom y]) \\<union>\n                      (lang\n                        (seq [question (Atom x), Atom y, Atom x,\n                              Star (Times (Atom y) (Atom x)), Atom y,\n                              Atom y]) \\<union>\n                       (lang\n                         (seq [question (Atom x), Atom y, Atom x,\n                               Star (Times (Atom y) (Atom x)),\n                               Atom x]) \\<union>\n                        lang (seq [Atom x, Atom x])));\n     qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "by blast"], ["", "thm UnE LxxE"], ["", "lemma \"qs \\<in> Lxx x y \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> Lxx x y \\<Longrightarrow> P", "apply(erule LxxE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P\n 2. qs \\<in> lang\n              (seq [question (Atom x), Atom y, Atom x,\n                    Star (Times (Atom y) (Atom x)), Atom y,\n                    Atom y]) \\<Longrightarrow>\n    P\n 3. qs \\<in> lang\n              (seq [question (Atom x), Atom y, Atom x,\n                    Star (Times (Atom y) (Atom x)),\n                    Atom x]) \\<Longrightarrow>\n    P\n 4. qs \\<in> lang\n              (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n    P", "oops"], ["", "lemma LxxI: \"(qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> lang (seq [Plus (Atom x) rexp.One, Atom y, Atom y]) \\<Longrightarrow> P x y qs)\n    \\<Longrightarrow> (qs \\<in> Lxx x y \\<Longrightarrow> P x y qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n             P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> Lxx x y\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "unfolding Lxx_def lastxx_is_4cases[symmetric] L_4cases_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n             P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (verund\n                 [seq [question (Atom x), Atom y, Atom y],\n                  seq [question (Atom x), Atom y, Atom x,\n                       Star (Times (Atom y) (Atom x)), Atom y, Atom y],\n                  seq [question (Atom x), Atom y, Atom x,\n                       Star (Times (Atom y) (Atom x)), Atom x],\n                  seq [Atom x, Atom x]])\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "apply(simp only: verund.simps lang.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs \\<in> lang (seq [Atom x, Atom x]) \\<Longrightarrow>\n             P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)),\n                     Atom x]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom y]) \\<Longrightarrow>\n     P x y qs;\n     qs \\<in> lang (seq [question (Atom x), Atom y, Atom y]) \\<union>\n              (lang\n                (seq [question (Atom x), Atom y, Atom x,\n                      Star (Times (Atom y) (Atom x)), Atom y,\n                      Atom y]) \\<union>\n               (lang\n                 (seq [question (Atom x), Atom y, Atom x,\n                       Star (Times (Atom y) (Atom x)), Atom x]) \\<union>\n                lang (seq [Atom x, Atom x])))\\<rbrakk>\n    \\<Longrightarrow> P x y qs", "by blast"], ["", "lemma Lxx1: \"xs \\<in> Lxx x y \\<Longrightarrow> length xs \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Lxx x y \\<Longrightarrow> 2 \\<le> length xs", "apply(rule LxxI[where P=\"(\\<lambda>x y qs. length qs \\<ge> 2)\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> lang (seq [Atom ?x, Atom ?x])\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 2. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> lang\n               (seq [question (Atom ?x), Atom ?y, Atom ?x,\n                     Star (Times (Atom ?y) (Atom ?x)), Atom ?y,\n                     Atom ?y])\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 3. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> lang\n               (seq [question (Atom ?x), Atom ?y, Atom ?x,\n                     Star (Times (Atom ?y) (Atom ?x)), Atom ?x])\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 4. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> lang (seq [question (Atom ?x), Atom ?y, Atom ?y])\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 5. xs \\<in> Lxx x y \\<Longrightarrow> xs \\<in> Lxx ?x ?y", "apply(auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> {[], [x]} @@\n              {[y]} @@\n              {[x]} @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 2. \\<lbrakk>xs \\<in> Lxx x y;\n     xs \\<in> {[], [x]} @@\n              {[y]} @@ {[x]} @@ star ({[y]} @@ {[x]}) @@ {[x]}\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs\n 3. \\<lbrakk>xs \\<in> Lxx x y; xs \\<in> {[], [x]} @@ {[y]} @@ {[y]}\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length xs", "by(auto simp: conc_def)"], ["", "subsection \"OPT2 Splitting\""], ["", "lemma ayay: \"length qs = length as \\<Longrightarrow> T\\<^sub>p s (qs@[q]) (as@[a]) = T\\<^sub>p s qs as + t\\<^sub>p (steps s qs as) q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    T\\<^sub>p s (qs @ [q]) (as @ [a]) =\n    T\\<^sub>p s qs as + t\\<^sub>p (Partial_Cost_Model.steps s qs as) q a", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       T\\<^sub>p s ([] @ [q]) ([] @ [a]) =\n       T\\<^sub>p s [] [] + t\\<^sub>p (Partial_Cost_Model.steps s [] []) q a\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           T\\<^sub>p s (xs @ [q]) (ys @ [a]) =\n           T\\<^sub>p s xs ys +\n           t\\<^sub>p (Partial_Cost_Model.steps s xs ys) q a\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p s ((x # xs) @ [q]) ((y # ys) @ [a]) =\n                         T\\<^sub>p s (x # xs) (y # ys) +\n                         t\\<^sub>p\n                          (Partial_Cost_Model.steps s (x # xs) (y # ys)) q a", "by simp_all"], ["", "lemma tlofOPT2: \"Q \\<in> {x,y} \\<Longrightarrow> set QS \\<subseteq> {x,y} \\<Longrightarrow> R \\<in> {[x, y], [y, x]} \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n    OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(cases \"Q=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q = x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q = x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n 3. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp add: OPT2x step_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set QS \\<subseteq> {x, y}; R = [y, x]; Q = x;\n     y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 (x # QS @ [x, x]) [y, x]) =\n                      OPT2 (QS @ [x, x])\n                       (step [y, x] x (hd (OPT2 (x # QS @ [x, x]) [y, x])))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(cases QS)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set QS \\<subseteq> {x, y}; R = [y, x]; Q = x; y \\<noteq> x;\n     QS = []\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 (x # QS @ [x, x]) [y, x]) =\n                      OPT2 (QS @ [x, x])\n                       (step [y, x] x (hd (OPT2 (x # QS @ [x, x]) [y, x])))\n 2. \\<And>a list.\n       \\<lbrakk>set QS \\<subseteq> {x, y}; R = [y, x]; Q = x; y \\<noteq> x;\n        QS = a # list\\<rbrakk>\n       \\<Longrightarrow> tl (OPT2 (x # QS @ [x, x]) [y, x]) =\n                         OPT2 (QS @ [x, x])\n                          (step [y, x] x\n                            (hd (OPT2 (x # QS @ [x, x]) [y, x])))\n 3. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp add: step_def mtf2_def swap_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>set QS \\<subseteq> {x, y}; R = [y, x]; Q = x; y \\<noteq> x;\n        QS = a # list\\<rbrakk>\n       \\<Longrightarrow> tl (OPT2 (x # QS @ [x, x]) [y, x]) =\n                         OPT2 (QS @ [x, x])\n                          (step [y, x] x\n                            (hd (OPT2 (x # QS @ [x, x]) [y, x])))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp add: step_def mtf2_def swap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Q = y; set QS \\<subseteq> {x, y}; y \\<noteq> x;\n     R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 (y # QS @ [x, x]) [x, y]) =\n                      OPT2 (QS @ [x, x])\n                       (step [x, y] y (hd (OPT2 (y # QS @ [x, x]) [x, y])))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(cases QS)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Q = y; set QS \\<subseteq> {x, y}; y \\<noteq> x; R = [x, y];\n     QS = []\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 (y # QS @ [x, x]) [x, y]) =\n                      OPT2 (QS @ [x, x])\n                       (step [x, y] y (hd (OPT2 (y # QS @ [x, x]) [x, y])))\n 2. \\<And>a list.\n       \\<lbrakk>Q = y; set QS \\<subseteq> {x, y}; y \\<noteq> x; R = [x, y];\n        QS = a # list\\<rbrakk>\n       \\<Longrightarrow> tl (OPT2 (y # QS @ [x, x]) [x, y]) =\n                         OPT2 (QS @ [x, x])\n                          (step [x, y] y\n                            (hd (OPT2 (y # QS @ [x, x]) [x, y])))\n 3. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp add: step_def mtf2_def swap_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>Q = y; set QS \\<subseteq> {x, y}; y \\<noteq> x; R = [x, y];\n        QS = a # list\\<rbrakk>\n       \\<Longrightarrow> tl (OPT2 (y # QS @ [x, x]) [x, y]) =\n                         OPT2 (QS @ [x, x])\n                          (step [x, y] y\n                            (hd (OPT2 (y # QS @ [x, x]) [x, y])))\n 2. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "apply(simp add: step_def mtf2_def swap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<in> {x, y}; set QS \\<subseteq> {x, y};\n     R \\<in> {[x, y], [y, x]}; Q \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> tl (OPT2 ((Q # QS) @ [x, x]) R) =\n                      OPT2 (QS @ [x, x])\n                       (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "by(simp add: OPT2x step_def)"], ["", "lemma T\\<^sub>p_split: \"length qs1=length as1 \\<Longrightarrow> T\\<^sub>p s (qs1@qs2) (as1@as2) = T\\<^sub>p s qs1 as1 + T\\<^sub>p (steps s qs1 as1) qs2 as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs1 = length as1 \\<Longrightarrow>\n    T\\<^sub>p s (qs1 @ qs2) (as1 @ as2) =\n    T\\<^sub>p s qs1 as1 +\n    T\\<^sub>p (Partial_Cost_Model.steps s qs1 as1) qs2 as2", "apply(induct qs1 as1 arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       T\\<^sub>p s ([] @ qs2) ([] @ as2) =\n       T\\<^sub>p s [] [] +\n       T\\<^sub>p (Partial_Cost_Model.steps s [] []) qs2 as2\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           T\\<^sub>p s (xs @ qs2) (ys @ as2) =\n           T\\<^sub>p s xs ys +\n           T\\<^sub>p (Partial_Cost_Model.steps s xs ys) qs2 as2\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p s ((x # xs) @ qs2) ((y # ys) @ as2) =\n                         T\\<^sub>p s (x # xs) (y # ys) +\n                         T\\<^sub>p\n                          (Partial_Cost_Model.steps s (x # xs) (y # ys)) qs2\n                          as2", "by(simp_all)"], ["", "lemma T\\<^sub>p_spliting: \"x\\<noteq>y \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow>\n      R \\<in> {[x,y],[y,x]} \\<Longrightarrow>\n      T\\<^sub>p R (xs@[x,x]) (OPT2 (xs@[x,x]) R) + T\\<^sub>p [x,y] ys (OPT2 ys [x,y])\n      = T\\<^sub>p R (xs@[x,x]@ys) (OPT2 (xs@[x,x]@ys) R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "assume nxy: \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "assume XSxy: \"set xs \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set xs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "assume YSxy: \"set ys \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "assume R: \"R \\<in> {[x,y],[y,x]}\""], ["proof (state)\nthis:\n  R \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "{"], ["proof (state)\nthis:\n  R \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "fix R"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "assume XSxy: \"set xs \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set xs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "have \"R\\<in>{[x,y],[y,x]} \\<Longrightarrow> set xs \\<subseteq> {x,y}  \\<Longrightarrow> steps R (xs@[x,x]) (OPT2 (xs@[x,x]) R) = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set xs \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.steps R (xs @ [x, x])\n                       (OPT2 (xs @ [x, x]) R) =\n                      [x, y]", "proof(induct xs arbitrary: R)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                          (OPT2 ([] @ [x, x]) R) =\n                         [x, y]\n 2. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "case Nil"], ["proof (state)\nthis:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                          (OPT2 ([] @ [x, x]) R) =\n                         [x, y]\n 2. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}", "show ?case"], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R ([] @ [x, x]) (OPT2 ([] @ [x, x]) R) = [x, y]", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n     R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                       (OPT2 ([] @ [x, x]) R) =\n                      [x, y]\n 2. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n     R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                       (OPT2 ([] @ [x, x]) R) =\n                      [x, y]", "(* FIXME why is simp_all needed? *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n     R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                       (OPT2 ([] @ [x, x]) R) =\n                      [x, y]\n 2. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n     R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.steps R ([] @ [x, x])\n                       (OPT2 ([] @ [x, x]) R) =\n                      [x, y]", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. R = [x, y] \\<Longrightarrow>\n    step (step [x, y] x (0, [])) x (0, []) = [x, y]\n 2. \\<lbrakk>R = [y, x]; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> step (step [y, x] x (Suc 0, [])) x (0, []) = [x, y]", "apply(simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = [y, x]; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> step (step [y, x] x (Suc 0, [])) x (0, []) = [x, y]", "by(simp add: step_def mtf2_def swap_def)"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ([] @ [x, x]) (OPT2 ([] @ [x, x]) R) = [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "case (Cons Q QS)"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set QS \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?R (QS @ [x, x])\n                     (OPT2 (QS @ [x, x]) ?R) =\n                    [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (Q # QS) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "let ?R'=\"(step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "have a: \"Q \\<in> {x,y}\"  and b: \"set QS \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> {x, y} &&& set QS \\<subseteq> {x, y}", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set QS \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?R (QS @ [x, x])\n                     (OPT2 (QS @ [x, x]) ?R) =\n                    [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (Q # QS) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. Q \\<in> {x, y} &&& set QS \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  Q \\<in> {x, y}\n  set QS \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "have t: \"?R' \\<in> {[x,y],[y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) \\<in> {[x, y], [y, x]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q \\<in> {x, y}\n 2. R \\<in> {[x, y], [y, x]}", "using nxy Cons"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set QS \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?R (QS @ [x, x])\n                     (OPT2 (QS @ [x, x]) ?R) =\n                    [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (Q # QS) \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. Q \\<in> {x, y}\n 2. R \\<in> {[x, y], [y, x]}", "by auto"], ["proof (state)\nthis:\n  step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) \\<in> {[x, y], [y, x]}", "have \"length (OPT2 (QS @ [x, x]) ?R') > 0\""], ["proof (prove)\nusing this:\n  step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. 0 < length\n         (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "apply(cases \"?R' = [x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))\n             \\<in> {[x, y], [y, x]};\n     step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) = [x, y]\\<rbrakk>\n    \\<Longrightarrow> 0 < length\n                           (OPT2 (QS @ [x, x])\n                             (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n 2. \\<lbrakk>step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))\n             \\<in> {[x, y], [y, x]};\n     step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)) \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> 0 < length\n                           (OPT2 (QS @ [x, x])\n                             (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "by(simp_all add: OPT2_length)"], ["proof (state)\nthis:\n  0 < length\n       (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  0 < length\n       (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "have \"OPT2 (QS @ [x, x]) ?R' \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < length\n       (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) \\<noteq>\n  []", "have hdtl: \"OPT2 (QS @ [x, x]) ?R' = hd (OPT2 (QS @ [x, x]) ?R') # tl (OPT2 (QS @ [x, x]) ?R')\""], ["proof (prove)\nusing this:\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) =\n    hd (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) #\n    tl (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "by auto"], ["proof (state)\nthis:\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))) =\n  hd (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) #\n  tl (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "have maa: \"(tl (OPT2 ((Q # QS) @ [x, x]) R)) = OPT2 (QS @ [x, x]) ?R' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (OPT2 ((Q # QS) @ [x, x]) R) =\n    OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "using tlofOPT2[OF a b Cons(2)]"], ["proof (prove)\nusing this:\n  tl (OPT2 ((Q # QS) @ [x, x]) R) =\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n\ngoal (1 subgoal):\n 1. tl (OPT2 ((Q # QS) @ [x, x]) R) =\n    OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))", "by auto"], ["proof (state)\nthis:\n  tl (OPT2 ((Q # QS) @ [x, x]) R) =\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "from Cons(2)"], ["proof (chain)\npicking this:\n  R \\<in> {[x, y], [y, x]}", "have \"length (OPT2 ((Q # QS) @ [x, x]) R) > 0\""], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. 0 < length (OPT2 ((Q # QS) @ [x, x]) R)", "apply(cases \"R = [x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> 0 < length (OPT2 ((Q # QS) @ [x, x]) R)\n 2. \\<lbrakk>R \\<in> {[x, y], [y, x]}; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> 0 < length (OPT2 ((Q # QS) @ [x, x]) R)", "by(simp_all add: OPT2_length)"], ["proof (state)\nthis:\n  0 < length (OPT2 ((Q # QS) @ [x, x]) R)\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  0 < length (OPT2 ((Q # QS) @ [x, x]) R)", "have nempty: \"OPT2 ((Q # QS) @ [x, x]) R \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < length (OPT2 ((Q # QS) @ [x, x]) R)\n\ngoal (1 subgoal):\n 1. OPT2 ((Q # QS) @ [x, x]) R \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  OPT2 ((Q # QS) @ [x, x]) R \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "then"], ["proof (chain)\npicking this:\n  OPT2 ((Q # QS) @ [x, x]) R \\<noteq> []", "have \"steps R ((Q # QS) @ [x, x]) (OPT2 ((Q # QS) @ [x, x]) R)\n        = steps R ((Q # QS) @ [x, x]) (hd(OPT2 ((Q # QS) @ [x, x]) R) #  tl(OPT2 ((Q # QS) @ [x, x]) R))\""], ["proof (prove)\nusing this:\n  OPT2 ((Q # QS) @ [x, x]) R \\<noteq> []\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n     (OPT2 ((Q # QS) @ [x, x]) R) =\n    Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n     (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R))", "by(simp)"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (OPT2 ((Q # QS) @ [x, x]) R) =\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (OPT2 ((Q # QS) @ [x, x]) R) =\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "have \"\\<dots>    \n        = steps ?R' (QS @ [x,x]) (tl (OPT2 ((Q # QS) @ [x, x]) R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n     (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n    Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R))", "unfolding maa"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n     (hd (OPT2 ((Q # QS) @ [x, x]) R) #\n      OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) =\n    Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x])\n     (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (hd (OPT2 ((Q # QS) @ [x, x]) R) # tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "have \"\\<dots> = steps ?R' (QS @ [x,x]) (OPT2 (QS @ [x, x]) ?R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n    Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x])\n     (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "using maa"], ["proof (prove)\nusing this:\n  tl (OPT2 ((Q # QS) @ [x, x]) R) =\n  OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n    Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x])\n     (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "with Cons(1)[OF t b]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) =\n  [x, y]\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))", "have \"\\<dots> = [x,y]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) =\n  [x, y]\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x]) (tl (OPT2 ((Q # QS) @ [x, x]) R)) =\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R))))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n     (QS @ [x, x])\n     (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) =\n    [x, y]", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))\n   (QS @ [x, x])\n   (OPT2 (QS @ [x, x]) (step R Q (hd (OPT2 ((Q # QS) @ [x, x]) R)))) =\n  [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> Partial_Cost_Model.steps R\n(xs @ [x, x]) (OPT2 (xs @ [x, x]) R) =\n                                     [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps R ((a # xs) @ [x, x])\n                          (OPT2 ((a # xs) @ [x, x]) R) =\n                         [x, y]", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (OPT2 ((Q # QS) @ [x, x]) R) =\n  [x, y]", "show ?case"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (OPT2 ((Q # QS) @ [x, x]) R) =\n  [x, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n     (OPT2 ((Q # QS) @ [x, x]) R) =\n    [x, y]", "."], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R ((Q # QS) @ [x, x])\n   (OPT2 ((Q # QS) @ [x, x]) R) =\n  [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>R \\<in> {[x, y], [y, x]}; set xs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps R (xs @ [x, x])\n                     (OPT2 (xs @ [x, x]) R) =\n                    [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set xs \\<subseteq> {x, y}; ?Ra2 \\<in> {[x, y], [y, x]};\n   set xs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?Ra2 (xs @ [x, x])\n                     (OPT2 (xs @ [x, x]) ?Ra2) =\n                    [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "note aa=this"], ["proof (state)\nthis:\n  \\<lbrakk>set xs \\<subseteq> {x, y}; ?Ra2 \\<in> {[x, y], [y, x]};\n   set xs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?Ra2 (xs @ [x, x])\n                     (OPT2 (xs @ [x, x]) ?Ra2) =\n                    [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "from aa XSxy R"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs \\<subseteq> {x, y}; ?Ra2 \\<in> {[x, y], [y, x]};\n   set xs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?Ra2 (xs @ [x, x])\n                     (OPT2 (xs @ [x, x]) ?Ra2) =\n                    [x, y]\n  set xs \\<subseteq> {x, y}\n  R \\<in> {[x, y], [y, x]}", "have ll: \"steps R (xs@[x,x]) (OPT2 (xs@[x,x]) R)\n      = [x,y]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> {x, y}; ?Ra2 \\<in> {[x, y], [y, x]};\n   set xs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> Partial_Cost_Model.steps ?Ra2 (xs @ [x, x])\n                     (OPT2 (xs @ [x, x]) ?Ra2) =\n                    [x, y]\n  set xs \\<subseteq> {x, y}\n  R \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) = [x, y]", "by auto"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) = [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "have uer: \" length (xs @ [x, x]) = length (OPT2 (xs @ [x, x]) R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ [x, x]) = length (OPT2 (xs @ [x, x]) R)", "using R"], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. length (xs @ [x, x]) = length (OPT2 (xs @ [x, x]) R)", "by (auto simp: OPT2_length)"], ["proof (state)\nthis:\n  length (xs @ [x, x]) = length (OPT2 (xs @ [x, x]) R)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "have \"OPT2 (xs @ [x, x] @ ys) R = OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OPT2 (xs @ [x, x] @ ys) R = OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]", "apply(rule OPT2_split11)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. R \\<in> {[x, y], [y, x]}\n 3. set xs \\<subseteq> {x, y}\n 4. set ys \\<subseteq> {x, y}", "using nxy XSxy YSxy R"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set xs \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n  R \\<in> {[x, y], [y, x]}\n\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. R \\<in> {[x, y], [y, x]}\n 3. set xs \\<subseteq> {x, y}\n 4. set ys \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  OPT2 (xs @ [x, x] @ ys) R = OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "then"], ["proof (chain)\npicking this:\n  OPT2 (xs @ [x, x] @ ys) R = OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]", "have \"T\\<^sub>p R (xs@[x,x]@ys) (OPT2 (xs@[x,x]@ys) R)\n        = T\\<^sub>p R ((xs@[x,x])@ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y])\""], ["proof (prove)\nusing this:\n  OPT2 (xs @ [x, x] @ ys) R = OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R) =\n    T\\<^sub>p R ((xs @ [x, x]) @ ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y])", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R) =\n  T\\<^sub>p R ((xs @ [x, x]) @ ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R) =\n  T\\<^sub>p R ((xs @ [x, x]) @ ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "have \"\\<dots> = T\\<^sub>p R (xs@[x,x]) (OPT2 (xs @ [x, x]) R)\n                + T\\<^sub>p [x,y] ys (OPT2 ys [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p R ((xs @ [x, x]) @ ys)\n     (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]) =\n    T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n    T\\<^sub>p [x, y] ys (OPT2 ys [x, y])", "using T\\<^sub>p_split[of \"xs@[x,x]\" \"OPT2 (xs @ [x, x]) R\" R ys \"OPT2 ys [x, y]\", OF uer, unfolded ll]"], ["proof (prove)\nusing this:\n  T\\<^sub>p R ((xs @ [x, x]) @ ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]) =\n  T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n  T\\<^sub>p [x, y] ys (OPT2 ys [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p R ((xs @ [x, x]) @ ys)\n     (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]) =\n    T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n    T\\<^sub>p [x, y] ys (OPT2 ys [x, y])", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p R ((xs @ [x, x]) @ ys) (OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]) =\n  T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n  T\\<^sub>p [x, y] ys (OPT2 ys [x, y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; R \\<in> {[x, y], [y, x]}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n                      T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n                      T\\<^sub>p R (xs @ [x, x] @ ys)\n                       (OPT2 (xs @ [x, x] @ ys) R)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R) =\n  T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n  T\\<^sub>p [x, y] ys (OPT2 ys [x, y])", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R) =\n  T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n  T\\<^sub>p [x, y] ys (OPT2 ys [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n    T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n    T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R)", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p R (xs @ [x, x]) (OPT2 (xs @ [x, x]) R) +\n  T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n  T\\<^sub>p R (xs @ [x, x] @ ys) (OPT2 (xs @ [x, x] @ ys) R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPTauseinander: \"x\\<noteq>y \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow>\n      LTS \\<in> {[x,y],[y,x]} \\<Longrightarrow> hd LTS = last xs \\<Longrightarrow>\n     xs = (pref @ [hd LTS, hd LTS]) \\<Longrightarrow> \n      T\\<^sub>p [x,y] xs (OPT2 xs [x,y]) + T\\<^sub>p LTS ys (OPT2 ys LTS)\n      = T\\<^sub>p [x,y] (xs@ys) (OPT2 (xs@ys) [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume nxy: \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume xsxy: \"set xs \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set xs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume ysxy: \"set ys \\<subseteq> {x,y}\""], ["proof (state)\nthis:\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume L: \"LTS \\<in> {[x,y],[y,x]}\""], ["proof (state)\nthis:\n  LTS \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume \"hd LTS = last xs\""], ["proof (state)\nthis:\n  hd LTS = last xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "assume prefix: \"xs = (pref @ [hd LTS, hd LTS])\""], ["proof (state)\nthis:\n  xs = pref @ [hd LTS, hd LTS]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}; LTS \\<in> {[x, y], [y, x]};\n     hd LTS = last xs; xs = pref @ [hd LTS, hd LTS]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n                      T\\<^sub>p LTS ys (OPT2 ys LTS) =\n                      T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "proof (cases \"LTS = [x,y]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. LTS = [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n 2. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "case True"], ["proof (state)\nthis:\n  LTS = [x, y]\n\ngoal (2 subgoals):\n 1. LTS = [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n 2. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "unfolding True prefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (pref @ [hd [x, y], hd [x, y]])\n     (OPT2 (pref @ [hd [x, y], hd [x, y]]) [x, y]) +\n    T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n    T\\<^sub>p [x, y] ((pref @ [hd [x, y], hd [x, y]]) @ ys)\n     (OPT2 ((pref @ [hd [x, y], hd [x, y]]) @ ys) [x, y])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (pref @ [x, x]) (OPT2 (pref @ [x, x]) [x, y]) +\n    T\\<^sub>p [x, y] ys (OPT2 ys [x, y]) =\n    T\\<^sub>p [x, y] (pref @ x # x # ys) (OPT2 (pref @ x # x # ys) [x, y])", "apply(rule T\\<^sub>p_spliting[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. set pref \\<subseteq> {x, y}\n 3. set ys \\<subseteq> {x, y}\n 4. [x, y] = [x, y] \\<or> [x, y] = [y, x]", "using nxy xsxy ysxy prefix"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set xs \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n  xs = pref @ [hd LTS, hd LTS]\n\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. set pref \\<subseteq> {x, y}\n 3. set ys \\<subseteq> {x, y}\n 4. [x, y] = [x, y] \\<or> [x, y] = [y, x]", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n  T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n\ngoal (1 subgoal):\n 1. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "case False"], ["proof (state)\nthis:\n  LTS \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "with L"], ["proof (chain)\npicking this:\n  LTS \\<in> {[x, y], [y, x]}\n  LTS \\<noteq> [x, y]", "have TT: \"LTS = [y,x]\""], ["proof (prove)\nusing this:\n  LTS \\<in> {[x, y], [y, x]}\n  LTS \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. LTS = [y, x]", "by auto"], ["proof (state)\nthis:\n  LTS = [y, x]\n\ngoal (1 subgoal):\n 1. LTS \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "unfolding TT prefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (pref @ [hd [y, x], hd [y, x]])\n     (OPT2 (pref @ [hd [y, x], hd [y, x]]) [x, y]) +\n    T\\<^sub>p [y, x] ys (OPT2 ys [y, x]) =\n    T\\<^sub>p [x, y] ((pref @ [hd [y, x], hd [y, x]]) @ ys)\n     (OPT2 ((pref @ [hd [y, x], hd [y, x]]) @ ys) [x, y])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (pref @ [y, y]) (OPT2 (pref @ [y, y]) [x, y]) +\n    T\\<^sub>p [y, x] ys (OPT2 ys [y, x]) =\n    T\\<^sub>p [x, y] (pref @ y # y # ys) (OPT2 (pref @ y # y # ys) [x, y])", "apply(rule T\\<^sub>p_spliting[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. y \\<noteq> x\n 2. set pref \\<subseteq> {y, x}\n 3. set ys \\<subseteq> {y, x}\n 4. [x, y] = [y, x] \\<or> [x, y] = [x, y]", "using nxy xsxy ysxy prefix"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set xs \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n  xs = pref @ [hd LTS, hd LTS]\n\ngoal (4 subgoals):\n 1. y \\<noteq> x\n 2. set pref \\<subseteq> {y, x}\n 3. set ys \\<subseteq> {y, x}\n 4. [x, y] = [y, x] \\<or> [x, y] = [x, y]", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n  T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p LTS ys (OPT2 ys LTS) =\n  T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Phase Partitioning lemma\""], ["", "theorem Phase_partitioning_general: \n  fixes P :: \"(nat state * 'is) pmf \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> bool\"\n      and A :: \"(nat state,'is,nat,answer) alg_on_rand\"\n  assumes xny: \"(x0::nat) \\<noteq> y0\" \n    and cpos: \"(c::real)\\<ge>0\"\n    and static: \"set \\<sigma> \\<subseteq> {x0,y0}\" \n    and initial: \"P (map_pmf (%is. ([x0,y0],is)) (fst A [x0,y0])) x0 [x0,y0]\"\n    and D: \"\\<And>a b \\<sigma> s.  \\<sigma> \\<in> Lxx a b \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> {a,b}={x0,y0} \\<Longrightarrow> P s a [x0,y0]  \\<Longrightarrow> set \\<sigma> \\<subseteq> {a,b}\n          \\<Longrightarrow> T_on_rand' A s \\<sigma> \\<le> c * T\\<^sub>p [a,b] \\<sigma> (OPT2 \\<sigma> [a,b])  \\<and> P (config'_rand A s \\<sigma>) (last \\<sigma>) [x0,y0]\"\n  shows \"T\\<^sub>p_on_rand A [x0,y0] \\<sigma>  \\<le> c * T\\<^sub>p_opt [x0,y0] \\<sigma> + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "fix x y s"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "have \"x \\<noteq> y \\<Longrightarrow> P s x [x0,y0] \\<Longrightarrow> set \\<sigma> \\<subseteq> {x,y} \\<Longrightarrow> {x,y}={x0,y0} \\<Longrightarrow> T_on_rand' A s \\<sigma> \\<le> c * T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y]) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; P s x [x0, y0]; set \\<sigma> \\<subseteq> {x, y};\n     {x, y} = {x0, y0}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>\n                      \\<le> c *\n                            real\n                             (T\\<^sub>p [x, y] \\<sigma>\n                               (OPT2 \\<sigma> [x, y])) +\n                            c", "proof (induction \"length \\<sigma>\" arbitrary: \\<sigma> x y s rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x y s.\n       \\<lbrakk>\\<And>\\<sigma>' x y s.\n                   \\<lbrakk>length \\<sigma>' < length \\<sigma>;\n                    x \\<noteq> y; P s x [x0, y0];\n                    set \\<sigma>' \\<subseteq> {x, y};\n                    {x, y} = {x0, y0}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>'\n                                     \\<le> c *\n     real (T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])) +\n     c;\n        x \\<noteq> y; P s x [x0, y0]; set \\<sigma> \\<subseteq> {x, y};\n        {x, y} = {x0, y0}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>\n                         \\<le> c *\n                               real\n                                (T\\<^sub>p [x, y] \\<sigma>\n                                  (OPT2 \\<sigma> [x, y])) +\n                               c", "case (less \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>; ?x \\<noteq> ?y;\n   P ?s ?x [x0, y0]; set ?\\<sigma> \\<subseteq> {?x, ?y};\n   {?x, ?y} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A ?s ?\\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [?x, ?y] ?\\<sigma>\n                             (OPT2 ?\\<sigma> [?x, ?y])) +\n                          c\n  x \\<noteq> y\n  P s x [x0, y0]\n  set \\<sigma> \\<subseteq> {x, y}\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x y s.\n       \\<lbrakk>\\<And>\\<sigma>' x y s.\n                   \\<lbrakk>length \\<sigma>' < length \\<sigma>;\n                    x \\<noteq> y; P s x [x0, y0];\n                    set \\<sigma>' \\<subseteq> {x, y};\n                    {x, y} = {x0, y0}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>'\n                                     \\<le> c *\n     real (T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])) +\n     c;\n        x \\<noteq> y; P s x [x0, y0]; set \\<sigma> \\<subseteq> {x, y};\n        {x, y} = {x0, y0}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>\n                         \\<le> c *\n                               real\n                                (T\\<^sub>p [x, y] \\<sigma>\n                                  (OPT2 \\<sigma> [x, y])) +\n                               c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "proof (cases \"\\<exists>xs ys. \\<sigma>=xs@ys \\<and> xs \\<in> Lxx x y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "case True"], ["proof (state)\nthis:\n  \\<exists>xs ys. \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs ys. \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y", "obtain xs ys where qs: \"\\<sigma>=xs@ys\" and xsLxx: \"xs \\<in> Lxx x y\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys. \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>\\<sigma> = xs @ ys; xs \\<in> Lxx x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> = xs @ ys\n  xs \\<in> Lxx x y\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "with Lxx1"], ["proof (chain)\npicking this:\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> 2 \\<le> length ?xs\n  \\<sigma> = xs @ ys\n  xs \\<in> Lxx x y", "have len: \"length ys < length \\<sigma>\""], ["proof (prove)\nusing this:\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> 2 \\<le> length ?xs\n  \\<sigma> = xs @ ys\n  xs \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. length ys < length \\<sigma>", "by fastforce"], ["proof (state)\nthis:\n  length ys < length \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from qs(1) less(4)"], ["proof (chain)\npicking this:\n  \\<sigma> = xs @ ys\n  set \\<sigma> \\<subseteq> {x, y}", "have ysxy: \"set ys \\<subseteq> {x,y}\""], ["proof (prove)\nusing this:\n  \\<sigma> = xs @ ys\n  set \\<sigma> \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have xsset: \"set xs \\<subseteq> {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {x, y}", "using less(4) qs"], ["proof (prove)\nusing this:\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma> = xs @ ys\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from xsLxx Lxx1"], ["proof (chain)\npicking this:\n  xs \\<in> Lxx x y\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> 2 \\<le> length ?xs", "have lxsgt1: \"length xs \\<ge> 2\""], ["proof (prove)\nusing this:\n  xs \\<in> Lxx x y\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> 2 \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. 2 \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  2 \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "then"], ["proof (chain)\npicking this:\n  2 \\<le> length xs", "have xs_not_Nil: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  2 \\<le> length xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from D[OF xsLxx less(2) less(5) less(3) xsset]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A s xs\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) \\<and>\n  P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]", "have D1: \"T_on_rand' A s xs \\<le> c * T\\<^sub>p [x, y] xs (OPT2 xs [x, y])\" \n         and inv: \"P (config'_rand A s xs) (last xs) [x0, y0]\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s xs\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) \\<and>\n  P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s xs\n    \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) &&&\n    P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s xs\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]))\n  P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from xsLxx Lxx_ends_in_two_equal"], ["proof (chain)\npicking this:\n  xs \\<in> Lxx x y\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> \\<exists>pref e. ?xs = pref @ [e, e]", "obtain pref e where \"xs = pref @ [e,e]\""], ["proof (prove)\nusing this:\n  xs \\<in> Lxx x y\n  ?xs \\<in> Lxx ?x ?y \\<Longrightarrow> \\<exists>pref e. ?xs = pref @ [e, e]\n\ngoal (1 subgoal):\n 1. (\\<And>pref e.\n        xs = pref @ [e, e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = pref @ [e, e]\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "then"], ["proof (chain)\npicking this:\n  xs = pref @ [e, e]", "have endswithsame: \"xs = pref @ [last xs, last xs]\""], ["proof (prove)\nusing this:\n  xs = pref @ [e, e]\n\ngoal (1 subgoal):\n 1. xs = pref @ [last xs, last xs]", "by auto"], ["proof (state)\nthis:\n  xs = pref @ [last xs, last xs]\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "let ?c' = \"[last xs, other (last xs) x y]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have setys: \"set ys \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> {x, y}", "using qs less"], ["proof (prove)\nusing this:\n  \\<sigma> = xs @ ys\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>; ?x \\<noteq> ?y;\n   P ?s ?x [x0, y0]; set ?\\<sigma> \\<subseteq> {?x, ?y};\n   {?x, ?y} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A ?s ?\\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [?x, ?y] ?\\<sigma>\n                             (OPT2 ?\\<sigma> [?x, ?y])) +\n                          c\n  x \\<noteq> y\n  P s x [x0, y0]\n  set \\<sigma> \\<subseteq> {x, y}\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have setxs: \"set xs \\<subseteq> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {x, y}", "using qs less"], ["proof (prove)\nusing this:\n  \\<sigma> = xs @ ys\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>; ?x \\<noteq> ?y;\n   P ?s ?x [x0, y0]; set ?\\<sigma> \\<subseteq> {?x, ?y};\n   {?x, ?y} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A ?s ?\\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [?x, ?y] ?\\<sigma>\n                             (OPT2 ?\\<sigma> [?x, ?y])) +\n                          c\n  x \\<noteq> y\n  P s x [x0, y0]\n  set \\<sigma> \\<subseteq> {x, y}\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have lxs: \"last xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs \\<in> set xs", "using xs_not_Nil"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  last xs \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from lxs setxs"], ["proof (chain)\npicking this:\n  last xs \\<in> set xs\n  set xs \\<subseteq> {x, y}", "have lxsxy: \"last xs \\<in> {x,y}\""], ["proof (prove)\nusing this:\n  last xs \\<in> set xs\n  set xs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. last xs \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  last xs \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from lxs setxs"], ["proof (chain)\npicking this:\n  last xs \\<in> set xs\n  set xs \\<subseteq> {x, y}", "have otherxy: \"other (last xs) x y \\<in> {x,y}\""], ["proof (prove)\nusing this:\n  last xs \\<in> set xs\n  set xs \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. other (last xs) x y \\<in> {x, y}", "by (simp add: other_def)"], ["proof (state)\nthis:\n  other (last xs) x y \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from less(2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have other_diff: \"last xs \\<noteq> other (last xs) x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. last xs \\<noteq> other (last xs) x y", "by(simp add: other_def)"], ["proof (state)\nthis:\n  last xs \\<noteq> other (last xs) x y\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have lo: \"{last xs, other (last xs) x y} = {x0, y0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {last xs, other (last xs) x y} = {x0, y0}", "using lxsxy otherxy other_diff less(5)"], ["proof (prove)\nusing this:\n  last xs \\<in> {x, y}\n  other (last xs) x y \\<in> {x, y}\n  last xs \\<noteq> other (last xs) x y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. {last xs, other (last xs) x y} = {x0, y0}", "by force"], ["proof (state)\nthis:\n  {last xs, other (last xs) x y} = {x0, y0}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have nextstate: \"{[last xs, other (last xs) x y], [other (last xs) x y, last xs]}\n            = { [x,y],[y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[last xs, other (last xs) x y], [other (last xs) x y, last xs]} =\n    {[x, y], [y, x]}", "using lxsxy otherxy other_diff"], ["proof (prove)\nusing this:\n  last xs \\<in> {x, y}\n  other (last xs) x y \\<in> {x, y}\n  last xs \\<noteq> other (last xs) x y\n\ngoal (1 subgoal):\n 1. {[last xs, other (last xs) x y], [other (last xs) x y, last xs]} =\n    {[x, y], [y, x]}", "by fastforce"], ["proof (state)\nthis:\n  {[last xs, other (last xs) x y], [other (last xs) x y, last xs]} =\n  {[x, y], [y, x]}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have setys': \"set ys \\<subseteq> {last xs, other (last xs) x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> {last xs, other (last xs) x y}", "using setys lxsxy otherxy other_diff"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> {x, y}\n  last xs \\<in> {x, y}\n  other (last xs) x y \\<in> {x, y}\n  last xs \\<noteq> other (last xs) x y\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> {last xs, other (last xs) x y}", "by fastforce"], ["proof (state)\nthis:\n  set ys \\<subseteq> {last xs, other (last xs) x y}\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have c: \"T_on_rand' A (config'_rand A s xs) ys\n        \\<le> c * T\\<^sub>p ?c' ys (OPT2 ys ?c') + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n    \\<le> c *\n          real\n           (T\\<^sub>p [last xs, other (last xs) x y] ys\n             (OPT2 ys [last xs, other (last xs) x y])) +\n          c", "apply(rule less(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. length ys < length \\<sigma>\n 2. last xs \\<noteq> other (last xs) x y\n 3. P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]\n 4. set ys \\<subseteq> {last xs, other (last xs) x y}\n 5. {last xs, other (last xs) x y} = {x0, y0}", "apply(fact len)"], ["proof (prove)\ngoal (4 subgoals):\n 1. last xs \\<noteq> other (last xs) x y\n 2. P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]\n 3. set ys \\<subseteq> {last xs, other (last xs) x y}\n 4. {last xs, other (last xs) x y} = {x0, y0}", "apply(fact other_diff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. P (Partial_Cost_Model.config'_rand A s xs) (last xs) [x0, y0]\n 2. set ys \\<subseteq> {last xs, other (last xs) x y}\n 3. {last xs, other (last xs) x y} = {x0, y0}", "apply(fact inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set ys \\<subseteq> {last xs, other (last xs) x y}\n 2. {last xs, other (last xs) x y} = {x0, y0}", "apply(fact setys')"], ["proof (prove)\ngoal (1 subgoal):\n 1. {last xs, other (last xs) x y} = {x0, y0}", "by(fact lo)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n  \\<le> c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have well: \"T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + T\\<^sub>p ?c' ys (OPT2 ys ?c')\n        = T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n    T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y]) =\n    T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])", "apply(rule OPTauseinander[where pref=pref])"], ["proof (prove)\ngoal (6 subgoals):\n 1. x \\<noteq> y\n 2. set xs \\<subseteq> {x, y}\n 3. set ys \\<subseteq> {x, y}\n 4. [last xs, other (last xs) x y] \\<in> {[x, y], [y, x]}\n 5. hd [last xs, other (last xs) x y] = last xs\n 6. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "apply(fact)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. [last xs, other (last xs) x y] \\<in> {[x, y], [y, x]}\n 2. hd [last xs, other (last xs) x y] = last xs\n 3. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "using lxsxy other_diff otherxy"], ["proof (prove)\nusing this:\n  last xs \\<in> {x, y}\n  last xs \\<noteq> other (last xs) x y\n  other (last xs) x y \\<in> {x, y}\n\ngoal (3 subgoals):\n 1. [last xs, other (last xs) x y] \\<in> {[x, y], [y, x]}\n 2. hd [last xs, other (last xs) x y] = last xs\n 3. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hd [last xs, other (last xs) x y] = last xs\n 2. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "using endswithsame"], ["proof (prove)\nusing this:\n  xs = pref @ [last xs, last xs]\n\ngoal (1 subgoal):\n 1. xs =\n    pref @\n    [hd [last xs, other (last xs) x y], hd [last xs, other (last xs) x y]]", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n  T\\<^sub>p [last xs, other (last xs) x y] ys\n   (OPT2 ys [last xs, other (last xs) x y]) =\n  T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E0: \"T_on_rand' A s \\<sigma>\n          =  T_on_rand' A s (xs@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma> = T\\<^sub>p_on_rand' A s (xs @ ys)", "using qs"], ["proof (prove)\nusing this:\n  \\<sigma> = xs @ ys\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma> = T\\<^sub>p_on_rand' A s (xs @ ys)", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma> = T\\<^sub>p_on_rand' A s (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma> = T\\<^sub>p_on_rand' A s (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E1: \"\\<dots> = T_on_rand' A s xs + T_on_rand' A (config'_rand A s xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s (xs @ ys) =\n    T\\<^sub>p_on_rand' A s xs +\n    T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys", "by (rule T_on_rand'_append)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s (xs @ ys) =\n  T\\<^sub>p_on_rand' A s xs +\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s (xs @ ys) =\n  T\\<^sub>p_on_rand' A s xs +\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E2: \"\\<dots> \\<le> T_on_rand' A s xs + c * T\\<^sub>p ?c' ys (OPT2 ys ?c') + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s xs +\n    T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n    \\<le> T\\<^sub>p_on_rand' A s xs +\n          c *\n          real\n           (T\\<^sub>p [last xs, other (last xs) x y] ys\n             (OPT2 ys [last xs, other (last xs) x y])) +\n          c", "using c"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n  \\<le> c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s xs +\n    T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n    \\<le> T\\<^sub>p_on_rand' A s xs +\n          c *\n          real\n           (T\\<^sub>p [last xs, other (last xs) x y] ys\n             (OPT2 ys [last xs, other (last xs) x y])) +\n          c", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s xs +\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n  \\<le> T\\<^sub>p_on_rand' A s xs +\n        c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s xs +\n  T\\<^sub>p_on_rand' A (Partial_Cost_Model.config'_rand A s xs) ys\n  \\<le> T\\<^sub>p_on_rand' A s xs +\n        c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E3: \"\\<dots> \\<le> c * T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) + c * T\\<^sub>p ?c' ys (OPT2 ys ?c') + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s xs +\n    c *\n    real\n     (T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c\n    \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n          c *\n          real\n           (T\\<^sub>p [last xs, other (last xs) x y] ys\n             (OPT2 ys [last xs, other (last xs) x y])) +\n          c", "using D1"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s xs\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s xs +\n    c *\n    real\n     (T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c\n    \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n          c *\n          real\n           (T\\<^sub>p [last xs, other (last xs) x y] ys\n             (OPT2 ys [last xs, other (last xs) x y])) +\n          c", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s xs +\n  c *\n  real\n   (T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n        c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s xs +\n  c *\n  real\n   (T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c\n  \\<le> c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n        c *\n        real\n         (T\\<^sub>p [last xs, other (last xs) x y] ys\n           (OPT2 ys [last xs, other (last xs) x y])) +\n        c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have \"\\<dots> = c * (T\\<^sub>p [x,y] xs (OPT2 xs [x,y]) + T\\<^sub>p ?c' ys (OPT2 ys ?c')) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n    c *\n    real\n     (T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c =\n    c *\n    real\n     (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n      T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c", "using cpos"], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n    c *\n    real\n     (T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c =\n    c *\n    real\n     (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n      T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c \\<Longrightarrow>\n    c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n    c *\n    real\n     (T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) =\n    c *\n    (real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n     real\n      (T\\<^sub>p [last xs, other (last xs) x y] ys\n        (OPT2 ys [last xs, other (last xs) x y])))", "by algebra"], ["proof (state)\nthis:\n  c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n  c *\n  real\n   (T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c =\n  c *\n  real\n   (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n    T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  c * real (T\\<^sub>p [x, y] xs (OPT2 xs [x, y])) +\n  c *\n  real\n   (T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c =\n  c *\n  real\n   (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n    T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have  \"\\<dots> = c * (T\\<^sub>p [x,y] (xs@ys) (OPT2 (xs@ys) [x,y])) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n      T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c =\n    c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c", "using well"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n  T\\<^sub>p [last xs, other (last xs) x y] ys\n   (OPT2 ys [last xs, other (last xs) x y]) =\n  T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n      T\\<^sub>p [last xs, other (last xs) x y] ys\n       (OPT2 ys [last xs, other (last xs) x y])) +\n    c =\n    c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c", "by auto"], ["proof (state)\nthis:\n  c *\n  real\n   (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n    T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c =\n  c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  c *\n  real\n   (T\\<^sub>p [x, y] xs (OPT2 xs [x, y]) +\n    T\\<^sub>p [last xs, other (last xs) x y] ys\n     (OPT2 ys [last xs, other (last xs) x y])) +\n  c =\n  c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E4: \"\\<dots> = c * (T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y])) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c =\n    c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "using qs"], ["proof (prove)\nusing this:\n  \\<sigma> = xs @ ys\n\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c =\n    c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "by auto"], ["proof (state)\nthis:\n  c * real (T\\<^sub>p [x, y] (xs @ ys) (OPT2 (xs @ ys) [x, y])) + c =\n  c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (2 subgoals):\n 1. \\<exists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (1 subgoal):\n 1. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "case False"], ["proof (state)\nthis:\n  \\<nexists>xs ys. \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "note f1=this"], ["proof (state)\nthis:\n  \\<nexists>xs ys. \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from Lxx_othercase[OF less(4) this, unfolded hideit_def]"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> lang (Plus rexp.One (nodouble x y))", "have\n        nodouble: \"\\<sigma> = [] \\<or> \\<sigma> \\<in> lang (nodouble x y)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> lang (Plus rexp.One (nodouble x y))\n\ngoal (1 subgoal):\n 1. \\<sigma> = [] \\<or> \\<sigma> \\<in> lang (nodouble x y)", "by  auto"], ["proof (state)\nthis:\n  \\<sigma> = [] \\<or> \\<sigma> \\<in> lang (nodouble x y)\n\ngoal (1 subgoal):\n 1. \\<nexists>xs ys.\n       \\<sigma> = xs @ ys \\<and> xs \\<in> Lxx x y \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "proof (cases \"\\<sigma> = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "case True"], ["proof (state)\nthis:\n  \\<sigma> = []\n\ngoal (2 subgoals):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n 2. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "then"], ["proof (chain)\npicking this:\n  \\<sigma> = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> = []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "using cpos"], ["proof (prove)\nusing this:\n  \\<sigma> = []\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "case False"], ["proof (state)\nthis:\n  \\<sigma> \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "(* with padding *)"], ["proof (state)\nthis:\n  \\<sigma> \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from False nodouble"], ["proof (chain)\npicking this:\n  \\<sigma> \\<noteq> []\n  \\<sigma> = [] \\<or> \\<sigma> \\<in> lang (nodouble x y)", "have qsnodouble: \"\\<sigma> \\<in> lang (nodouble x y)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> []\n  \\<sigma> = [] \\<or> \\<sigma> \\<in> lang (nodouble x y)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> lang (nodouble x y)", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<in> lang (nodouble x y)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "let ?padded = \"pad \\<sigma> x y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have padset: \"set ?padded \\<subseteq> {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pad \\<sigma> x y) \\<subseteq> {x, y}", "using less(4)"], ["proof (prove)\nusing this:\n  set \\<sigma> \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set (pad \\<sigma> x y) \\<subseteq> {x, y}", "by(simp)"], ["proof (state)\nthis:\n  set (pad \\<sigma> x y) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from False pad_adds2[of \\<sigma> x y] less(4)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<noteq> []\n  \\<lbrakk>\\<sigma> \\<noteq> []; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]\n  set \\<sigma> \\<subseteq> {x, y}", "obtain addum where ui: \"pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> []\n  \\<lbrakk>\\<sigma> \\<noteq> []; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]\n  set \\<sigma> \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. (pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>] \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "from nodouble_padded[OF False qsnodouble]"], ["proof (chain)\npicking this:\n  pad \\<sigma> x y \\<in> Lxx x y", "have pLxx: \"?padded \\<in> Lxx x y\""], ["proof (prove)\nusing this:\n  pad \\<sigma> x y \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. pad \\<sigma> x y \\<in> Lxx x y", "."], ["proof (state)\nthis:\n  pad \\<sigma> x y \\<in> Lxx x y\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E0: \"T_on_rand' A s \\<sigma> \\<le> T_on_rand' A s ?padded\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "have \"T_on_rand' A s \\<sigma> = sum (T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma> =\n    sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>}", "by(rule T_on_rand'_as_sum)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma> =\n  sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma> =\n  sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "have \"\\<dots>\n             = sum (T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>])) {..<length \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>)\n     {..<length \\<sigma>} =\n    sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n     {..<length \\<sigma>}", "proof(rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..<length \\<sigma>} = {..<length \\<sigma>}\n 2. \\<And>x.\n       x \\<in> {..<length \\<sigma>} \\<Longrightarrow>\n       Partial_Cost_Model.T_on_rand'_n A s \\<sigma> x =\n       Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]) x", "case (2 t)"], ["proof (state)\nthis:\n  t \\<in> {..<length \\<sigma>}\n\ngoal (2 subgoals):\n 1. {..<length \\<sigma>} = {..<length \\<sigma>}\n 2. \\<And>x.\n       x \\<in> {..<length \\<sigma>} \\<Longrightarrow>\n       Partial_Cost_Model.T_on_rand'_n A s \\<sigma> x =\n       Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]) x", "then"], ["proof (chain)\npicking this:\n  t \\<in> {..<length \\<sigma>}", "have \"t < length \\<sigma>\""], ["proof (prove)\nusing this:\n  t \\<in> {..<length \\<sigma>}\n\ngoal (1 subgoal):\n 1. t < length \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t < length \\<sigma>\n\ngoal (2 subgoals):\n 1. {..<length \\<sigma>} = {..<length \\<sigma>}\n 2. \\<And>x.\n       x \\<in> {..<length \\<sigma>} \\<Longrightarrow>\n       Partial_Cost_Model.T_on_rand'_n A s \\<sigma> x =\n       Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]) x", "then"], ["proof (chain)\npicking this:\n  t < length \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  t < length \\<sigma>\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A s \\<sigma> t =\n    Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]) t", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on_rand'_n A s \\<sigma> t =\n  Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]) t\n\ngoal (1 subgoal):\n 1. {..<length \\<sigma>} = {..<length \\<sigma>}", "qed simp"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>} =\n  sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n   {..<length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "also"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A s \\<sigma>) {..<length \\<sigma>} =\n  sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n   {..<length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "have \"\\<dots> \\<le> T_on_rand' A s ?padded\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n     {..<length \\<sigma>}\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "unfolding ui"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n     {..<length \\<sigma>}\n    \\<le> T\\<^sub>p_on_rand' A s (\\<sigma> @ [last \\<sigma>])", "apply(subst (2) T_on_rand'_as_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n     {..<length \\<sigma>}\n    \\<le> sum (Partial_Cost_Model.T_on_rand'_n A s\n                (\\<sigma> @ [last \\<sigma>]))\n           {..<length (\\<sigma> @ [last \\<sigma>])}", "by(simp add: T_on_rand'_nn del: T_on_rand'.simps)"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A s (\\<sigma> @ [last \\<sigma>]))\n   {..<length \\<sigma>}\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E1: \"\\<dots> \\<le> c * T\\<^sub>p [x,y] ?padded (OPT2 ?padded [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n    \\<le> c *\n          real\n           (T\\<^sub>p [x, y] (pad \\<sigma> x y)\n             (OPT2 (pad \\<sigma> x y) [x, y]))", "using D[OF pLxx less(2) less(5) less(3) padset]"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n  \\<le> c *\n        real\n         (T\\<^sub>p [x, y] (pad \\<sigma> x y)\n           (OPT2 (pad \\<sigma> x y) [x, y])) \\<and>\n  P (Partial_Cost_Model.config'_rand A s (pad \\<sigma> x y))\n   (last (pad \\<sigma> x y)) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n    \\<le> c *\n          real\n           (T\\<^sub>p [x, y] (pad \\<sigma> x y)\n             (OPT2 (pad \\<sigma> x y) [x, y]))", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n  \\<le> c *\n        real\n         (T\\<^sub>p [x, y] (pad \\<sigma> x y)\n           (OPT2 (pad \\<sigma> x y) [x, y]))\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s (pad \\<sigma> x y)\n  \\<le> c *\n        real\n         (T\\<^sub>p [x, y] (pad \\<sigma> x y)\n           (OPT2 (pad \\<sigma> x y) [x, y]))\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have E2: \"\\<dots> \\<le> c * (T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y]) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "from False less(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<noteq> []\n  x \\<noteq> y", "obtain \\<sigma>' x' y' where qs': \"\\<sigma> = \\<sigma>' @ [x']\" and x': \"x' = last \\<sigma>\" \"y'\\<noteq>x'\" \"y' \\<in>{x,y}\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> []\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' x' y'.\n        \\<lbrakk>\\<sigma> = \\<sigma>'' @ [x']; x' = last \\<sigma>;\n         y' \\<noteq> x'; y' \\<in> {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id insert_iff)"], ["proof (state)\nthis:\n  \\<sigma> = \\<sigma>' @ [x']\n  x' = last \\<sigma>\n  y' \\<noteq> x'\n  y' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "have tla: \"last \\<sigma> \\<in> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last \\<sigma> \\<in> {x, y}", "using less(4) False last_in_set"], ["proof (prove)\nusing this:\n  set \\<sigma> \\<subseteq> {x, y}\n  \\<sigma> \\<noteq> []\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. last \\<sigma> \\<in> {x, y}", "by blast"], ["proof (state)\nthis:\n  last \\<sigma> \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "with x'"], ["proof (chain)\npicking this:\n  x' = last \\<sigma>\n  y' \\<noteq> x'\n  y' \\<in> {x, y}\n  last \\<sigma> \\<in> {x, y}", "have grgr: \"{x,y} = {x',y'}\""], ["proof (prove)\nusing this:\n  x' = last \\<sigma>\n  y' \\<noteq> x'\n  y' \\<in> {x, y}\n  last \\<sigma> \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. {x, y} = {x', y'}", "by auto"], ["proof (state)\nthis:\n  {x, y} = {x', y'}\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "then"], ["proof (chain)\npicking this:\n  {x, y} = {x', y'}", "have \"(x = x' \\<and> y = y') \\<or> (x = y' \\<and> y = x')\""], ["proof (prove)\nusing this:\n  {x, y} = {x', y'}\n\ngoal (1 subgoal):\n 1. x = x' \\<and> y = y' \\<or> x = y' \\<and> y = x'", "using less(2)"], ["proof (prove)\nusing this:\n  {x, y} = {x', y'}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x = x' \\<and> y = y' \\<or> x = y' \\<and> y = x'", "by auto"], ["proof (state)\nthis:\n  x = x' \\<and> y = y' \\<or> x = y' \\<and> y = x'\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "then"], ["proof (chain)\npicking this:\n  x = x' \\<and> y = y' \\<or> x = y' \\<and> y = x'", "have tts: \"[x, y] \\<in> {[x', y'], [y', x']}\""], ["proof (prove)\nusing this:\n  x = x' \\<and> y = y' \\<or> x = y' \\<and> y = x'\n\ngoal (1 subgoal):\n 1. [x, y] \\<in> {[x', y'], [y', x']}", "by blast"], ["proof (state)\nthis:\n  [x, y] \\<in> {[x', y'], [y', x']}\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "from qs' ui"], ["proof (chain)\npicking this:\n  \\<sigma> = \\<sigma>' @ [x']\n  pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]", "have pd: \"?padded = \\<sigma>' @ [x', x']\""], ["proof (prove)\nusing this:\n  \\<sigma> = \\<sigma>' @ [x']\n  pad \\<sigma> x y = \\<sigma> @ [last \\<sigma>]\n\ngoal (1 subgoal):\n 1. pad \\<sigma> x y = \\<sigma>' @ [x', x']", "by auto"], ["proof (state)\nthis:\n  pad \\<sigma> x y = \\<sigma>' @ [x', x']\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "have \"T\\<^sub>p [x,y] (?padded) (OPT2 (?padded) [x,y])\n              = T\\<^sub>p [x,y] (\\<sigma>' @ [x', x']) (OPT2 (\\<sigma>' @ [x', x']) [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]) =\n    T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n     (OPT2 (\\<sigma>' @ [x', x']) [x, y])", "unfolding pd"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n     (OPT2 (\\<sigma>' @ [x', x']) [x, y]) =\n    T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n     (OPT2 (\\<sigma>' @ [x', x']) [x, y])", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]) =\n  T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n   (OPT2 (\\<sigma>' @ [x', x']) [x, y])\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]) =\n  T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n   (OPT2 (\\<sigma>' @ [x', x']) [x, y])\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "have gr: \"\\<dots>\n            \\<le> T\\<^sub>p [x,y] (\\<sigma>' @ [x']) (OPT2 (\\<sigma>' @ [x']) [x,y]) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n     (OPT2 (\\<sigma>' @ [x', x']) [x, y])\n    \\<le> T\\<^sub>p [x, y] (\\<sigma>' @ [x'])\n           (OPT2 (\\<sigma>' @ [x']) [x, y]) +\n          1", "apply(rule OPT2_padded[where x=\"x'\" and y=\"y'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. [x, y] \\<in> {[x', y'], [y', x']}\n 2. set \\<sigma>' \\<subseteq> {x', y'}", "apply(fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<sigma>' \\<subseteq> {x', y'}", "using grgr qs' less(4)"], ["proof (prove)\nusing this:\n  {x, y} = {x', y'}\n  \\<sigma> = \\<sigma>' @ [x']\n  set \\<sigma> \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set \\<sigma>' \\<subseteq> {x', y'}", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n   (OPT2 (\\<sigma>' @ [x', x']) [x, y])\n  \\<le> T\\<^sub>p [x, y] (\\<sigma>' @ [x'])\n         (OPT2 (\\<sigma>' @ [x']) [x, y]) +\n        1\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (\\<sigma>' @ [x', x'])\n   (OPT2 (\\<sigma>' @ [x', x']) [x, y])\n  \\<le> T\\<^sub>p [x, y] (\\<sigma>' @ [x'])\n         (OPT2 (\\<sigma>' @ [x']) [x, y]) +\n        1\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "have \"\\<dots> \\<le> T\\<^sub>p [x,y] (\\<sigma>) (OPT2 (\\<sigma>) [x,y]) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (\\<sigma>' @ [x']) (OPT2 (\\<sigma>' @ [x']) [x, y]) + 1\n    \\<le> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1", "unfolding qs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (\\<sigma>' @ [x']) (OPT2 (\\<sigma>' @ [x']) [x, y]) + 1\n    \\<le> T\\<^sub>p [x, y] (\\<sigma>' @ [x'])\n           (OPT2 (\\<sigma>' @ [x']) [x, y]) +\n          1", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (\\<sigma>' @ [x']) (OPT2 (\\<sigma>' @ [x']) [x, y]) + 1\n  \\<le> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y])\n  \\<le> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y])\n  \\<le> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "using cpos"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y])\n  \\<le> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)", "by (meson mult_left_mono of_nat_le_iff)"], ["proof (state)\nthis:\n  c *\n  real\n   (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c *\n  real\n   (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "also"], ["proof (state)\nthis:\n  c *\n  real\n   (T\\<^sub>p [x, y] (pad \\<sigma> x y) (OPT2 (pad \\<sigma> x y) [x, y]))\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "have \"\\<dots> =  c * T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y]) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1) =\n    c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "by (metis (no_types, lifting) mult.commute of_nat_1 of_nat_add semiring_normalization_rules(2))"], ["proof (state)\nthis:\n  c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y]) + 1) =\n  c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> [] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A s \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A s \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])) + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq> y; P s x [x0, y0]; set \\<sigma> \\<subseteq> {x, y};\n   {x, y} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A s \\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [x, y] \\<sigma>\n                             (OPT2 \\<sigma> [x, y])) +\n                          c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<noteq> ?y2; P ?s2 ?x2 [x0, y0];\n   set \\<sigma> \\<subseteq> {?x2, ?y2}; {?x2, ?y2} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A ?s2 \\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [?x2, ?y2] \\<sigma>\n                             (OPT2 \\<sigma> [?x2, ?y2])) +\n                          c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "note allg=this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<noteq> ?y2; P ?s2 ?x2 [x0, y0];\n   set \\<sigma> \\<subseteq> {?x2, ?y2}; {?x2, ?y2} = {x0, y0}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' A ?s2 \\<sigma>\n                    \\<le> c *\n                          real\n                           (T\\<^sub>p [?x2, ?y2] \\<sigma>\n                             (OPT2 \\<sigma> [?x2, ?y2])) +\n                          c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "have \"T_on_rand A [x0,y0] \\<sigma> \\<le> c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) +\n          c", "apply(rule allg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x0 \\<noteq> y0\n 2. P (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is))) x0\n     [x0, y0]\n 3. set \\<sigma> \\<subseteq> {x0, y0}\n 4. {x0, y0} = {x0, y0}", "apply(fact)"], ["proof (prove)\ngoal (3 subgoals):\n 1. P (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is))) x0\n     [x0, y0]\n 2. set \\<sigma> \\<subseteq> {x0, y0}\n 3. {x0, y0} = {x0, y0}", "using initial"], ["proof (prove)\nusing this:\n  P (map_pmf (Pair [x0, y0]) (fst A [x0, y0])) x0 [x0, y0]\n\ngoal (3 subgoals):\n 1. P (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is))) x0\n     [x0, y0]\n 2. set \\<sigma> \\<subseteq> {x0, y0}\n 3. {x0, y0} = {x0, y0}", "apply(simp add: map_pmf_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set \\<sigma> \\<subseteq> {x0, y0}\n 2. {x0, y0} = {x0, y0}", "apply(fact assms(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x0, y0} = {x0, y0}", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n   \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n   \\<sigma>\n  \\<le> c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "have \"\\<dots> = c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c =\n    c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "using OPT2_is_opt[OF assms(3,1)]"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0]) =\n  T\\<^sub>p_opt [x0, y0] \\<sigma>\n\ngoal (1 subgoal):\n 1. c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c =\n    c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "by(simp)"], ["proof (state)\nthis:\n  c * real (T\\<^sub>p [x0, y0] \\<sigma> (OPT2 \\<sigma> [x0, y0])) + c =\n  c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n   \\<sigma>\n  \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n   \\<sigma>\n  \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n     \\<sigma>\n    \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A [x0, y0] \\<bind> (\\<lambda>is. return_pmf ([x0, y0], is)))\n   \\<sigma>\n  \\<le> c * real (T\\<^sub>p_opt [x0, y0] \\<sigma>) + c\n\ngoal:\nNo subgoals!", "qed"], ["", "term \"A::(nat,'is) alg_on\""], ["", "theorem Phase_partitioning_general_det: \n  fixes P :: \"(nat state * 'is) \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> bool\"\n      and A :: \"(nat,'is) alg_on\"\n  assumes xny: \"(x0::nat) \\<noteq> y0\" \n    and cpos: \"(c::real)\\<ge>0\"\n    and static: \"set \\<sigma> \\<subseteq> {x0,y0}\" \n    and initial: \"P ([x0,y0],(fst A [x0,y0])) x0 [x0,y0]\"\n    and D: \"\\<And>a b \\<sigma> s.  \\<sigma> \\<in> Lxx a b \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> {a,b}={x0,y0} \\<Longrightarrow> P s a [x0,y0]  \\<Longrightarrow> set \\<sigma> \\<subseteq> {a,b}\n          \\<Longrightarrow> T_on' A s \\<sigma> \\<le> c * T\\<^sub>p [a,b] \\<sigma> (OPT2 \\<sigma> [a,b])  \\<and> P (config' A s \\<sigma>) (last \\<sigma>) [x0,y0]\"\n  shows \"T\\<^sub>p_on A [x0,y0] \\<sigma>  \\<le> c * T\\<^sub>p_opt [x0,y0] \\<sigma> + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "thm Phase_partitioning_general"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "thm T_deter_rand"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "term T_on'"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "term \"embed\""], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on A [x0, y0] \\<sigma>\n    \\<le> c * T\\<^sub>p_opt [x0, y0] \\<sigma> + c", "oops"], ["", "end"]]}