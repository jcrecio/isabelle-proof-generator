{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Comb.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma COMB_init[simp]: \"COMB_init h init =\n                do {\n                    (b::bool) \\<leftarrow> (bernoulli_pmf 0.8);\n                    (xs::bool list) \\<leftarrow> Prob_Theory.bv (length init);\n                    return_pmf (if b then Inl (xs, init) else Inr h)\n                  }\"", "lemma noccon: \"noc o con = id\"", "lemma connoc: \"con o noc = id\"", "lemma obligation1': assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    shows \"config'_rand (COMB h) s qs =\n    map_pmf noc (Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS h)) Db qs))\"", "lemma obligation1'': \n    shows \"config_rand (COMB h) init qs =\n    map_pmf noc (Sum_pmf (8 / 10) (config_rand BIT init qs)\n                     (config_rand (embed (rTS h)) init qs))\"", "lemma obligation1: assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    shows \"map_pmf con (config'_rand (COMB []) s qs) = \n    Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS [])) Db qs)\"", "lemma BIT_config'_fin: \"finite (set_pmf s) \\<Longrightarrow> finite (set_pmf (config'_rand BIT s qs))\"", "lemma TS_config'_fin: \"finite (set_pmf s) \\<Longrightarrow> finite (set_pmf (config'_rand (embed (rTS h)) s qs))\"", "lemma obligation2: assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    and \"finite (set_pmf Da)\"\n    and \"finite (set_pmf Db)\"\n  shows \"T\\<^sub>p_on_rand' (COMB []) s qs =\n    2 / 10 * T\\<^sub>p_on_rand' (embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\"", "lemma Combination:\n  fixes bit\n  assumes \"qs \\<in> pattern\" \"a \\<noteq> b\" \"{a, b} = {x, y}\" \"set qs \\<subseteq> {a, b}\"\n    and \"inv_COMB s a [x,y]\"\n    and TS: \"\\<And>s h. a \\<noteq> b \\<Longrightarrow> {a, b} = {x, y} \\<Longrightarrow> TS_inv s a [x, y] \\<Longrightarrow> set qs \\<subseteq> {a, b}\n      \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow>\n            TS_inv (config'_rand (embed (rTS h)) s qs) (last qs) [x, y] \n          \\<and> T\\<^sub>p_on_rand' (embed (rTS h)) s qs = ts\"\n    and BIT: \"\\<And>s. a \\<noteq> b \\<Longrightarrow> {a, b} = {x, y} \\<Longrightarrow> BIT_inv s a [x, y] \\<Longrightarrow> set qs \\<subseteq> {a, b}\n      \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow>\n            BIT_inv (config'_rand BIT s qs) (last qs) [x, y] \n          \\<and> T\\<^sub>p_on_rand' BIT s qs = bit\"\n    and OPT_cost: \"a \\<noteq> b \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = opt\"\n    and absch: \"qs \\<in> pattern \\<Longrightarrow> 0.2 * ts + 0.8 * bit \\<le> 1.6 * opt\"\n  shows \"T\\<^sub>p_on_rand' (COMB []) s qs \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\"", "theorem COMB_OPT2':  \"(x::nat) \\<noteq> y \\<Longrightarrow> set \\<sigma> \\<subseteq> {x,y}\n     \\<Longrightarrow> T\\<^sub>p_on_rand (COMB []) [x,y] \\<sigma>  \\<le> 1.6 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 1.6\"", "lemma config_rand_COMB: \"config_rand (COMB h) init qs = do {\n                    (b::bool) \\<leftarrow> (bernoulli_pmf 0.8); \n                    (b1,b2) \\<leftarrow>  (config_rand BIT init qs);\n                    (t1,t2) \\<leftarrow>  (config_rand (embed (rTS h)) init qs);\n                    return_pmf (if b then  (b1, Inl b2) else (t1, Inr t2))\n                    }\" (is \"?LHS = ?RHS\")", "lemma COMB_no_paid: \" \\<forall>((free, paid), t)\\<in>set_pmf (snd (COMB []) (s, is) q). paid = []\"", "lemma COMB_pairwise: \"pairwise (COMB [])\"", "lemma finite_config_TS: \"finite (set_pmf (config'' (embed (rTS h)) qs init n))\" (is \"finite ?D\")", "lemma COMB_has_finite_config_set: assumes [simp]: \"distinct init\"\n      and \"set qs \\<subseteq> set init\" \n      shows \"finite (set_pmf (config_rand (COMB h) init qs))\"", "theorem COMB_competitive: \"\\<forall>s0\\<in>{x::nat list. distinct x \\<and> x\\<noteq>[]}.\n   \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand (COMB []) s0 qs \\<le> ((8::nat)/(5::nat)) *  T\\<^sub>p_opt s0 qs + b\"", "theorem COMB_competitive_nice: \"compet_rand (COMB []) ((8::nat)/(5::nat)) {x::nat list. distinct x \\<and> x\\<noteq>[]}\""], "translations": [["", "lemma COMB_init[simp]: \"COMB_init h init =\n                do {\n                    (b::bool) \\<leftarrow> (bernoulli_pmf 0.8);\n                    (xs::bool list) \\<leftarrow> Prob_Theory.bv (length init);\n                    return_pmf (if b then Inl (xs, init) else Inr h)\n                  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COMB_init h init =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        bv (length init) \\<bind>\n        (\\<lambda>xs. return_pmf (if b then Inl (xs, init) else Inr h)))", "apply(simp add: bind_return_pmf COMB_init_def BIT_init_def rTS_def\n              bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf (4 / 5) (map_pmf (\\<lambda>l. (l, init)) (bv (length init)))\n     (return_pmf h) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        bv (length init) \\<bind>\n        (\\<lambda>xs. return_pmf (if b then Inl (xs, init) else Inr h)))", "unfolding map_pmf_def Sum_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then bv (length init) \\<bind>\n             (\\<lambda>x. return_pmf (x, init)) \\<bind>\n             (\\<lambda>x. return_pmf (Inl x))\n        else return_pmf h \\<bind> (\\<lambda>x. return_pmf (Inr x))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        bv (length init) \\<bind>\n        (\\<lambda>xs. return_pmf (if b then Inl (xs, init) else Inr h)))", "apply(simp add: if_distrib bind_return_pmf bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then bv (length init) \\<bind>\n             (\\<lambda>x. return_pmf (x, init)) \\<bind>\n             (\\<lambda>x. return_pmf (Inl x))\n        else return_pmf h \\<bind> (\\<lambda>x. return_pmf (Inr x))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        bv (length init) \\<bind>\n        (\\<lambda>xs.\n            if b then return_pmf (Inl (xs, init)) else return_pmf (Inr h)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       (if x\n        then bv (length init) \\<bind>\n             (\\<lambda>x. return_pmf (x, init)) \\<bind>\n             (\\<lambda>x. return_pmf (Inl x))\n        else return_pmf h \\<bind> (\\<lambda>x. return_pmf (Inr x))) =\n       bv (length init) \\<bind>\n       (\\<lambda>xs.\n           if x then return_pmf (Inl (xs, init)) else return_pmf (Inr h))", "by(auto simp add: bind_return_pmf bind_assoc_pmf)"], ["", "definition COMB_step :: \"(nat state, CombState, nat, answer) alg_on_step\" where\n\"COMB_step s q = (case snd s of Inl b \\<Rightarrow> map_pmf (\\<lambda>((a,b),c). ((a,b),Inl c)) (BIT_step (fst s, b) q)\n                              | Inr b \\<Rightarrow> map_pmf (\\<lambda>((a,b),c). ((a,b),Inr c)) (return_pmf (TS_step_d (fst s, b) q)))\""], ["", "definition \"COMB h = (COMB_init h, COMB_step)\""], ["", "subsection \"Comb 1.6-competitive on 2 elements\""], ["", "abbreviation \"noc == (%x. case x of Inl (s,is) \\<Rightarrow> (s,Inl is) | Inr (s,is) \\<Rightarrow> (s,Inr is) )\""], ["", "abbreviation \"con == (%(s,is). case is of Inl is \\<Rightarrow> Inl (s,is) | Inr is \\<Rightarrow> Inr (s,is) )\""], ["", "definition \"inv_COMB s x i == (\\<exists>Da Db. finite (set_pmf Da) \\<and> finite (set_pmf Db) \\<and>\n      (map_pmf con s) = Sum_pmf 0.8 Da Db \\<and> BIT_inv Da x i \\<and> TS_inv Db x i)\""], ["", "lemma noccon: \"noc o con = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noc \\<circ> con = id", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (noc \\<circ> con) x = id x", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b. x = (a, b) \\<Longrightarrow> (noc \\<circ> con) x = id x", "by(auto simp add: sum.case_eq_if)"], ["", "lemma connoc: \"con o noc = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. con \\<circ> noc = id", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (con \\<circ> noc) x = id x", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a. x = Inl a \\<Longrightarrow> (con \\<circ> noc) x = id x\n 2. \\<And>x b. x = Inr b \\<Longrightarrow> (con \\<circ> noc) x = id x", "by(auto simp add: sum.case_eq_if)"], ["", "lemma obligation1': assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    shows \"config'_rand (COMB h) s qs =\n    map_pmf noc (Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS h)) Db qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h) s qs =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db qs))", "proof (induct qs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "have \"s = map_pmf noc (map_pmf con s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = map_pmf noc (map_pmf con s)", "by(simp add: pmf.map_comp noccon)"], ["proof (state)\nthis:\n  s = map_pmf noc (map_pmf con s)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "also"], ["proof (state)\nthis:\n  s = map_pmf noc (map_pmf con s)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "from assms"], ["proof (chain)\npicking this:\n  map_pmf con s = Sum_pmf (8 / 10) Da Db", "have \"\\<dots> = map_pmf noc (Sum_pmf (8 / 10) Da Db)\""], ["proof (prove)\nusing this:\n  map_pmf con s = Sum_pmf (8 / 10) Da Db\n\ngoal (1 subgoal):\n 1. map_pmf noc (map_pmf con s) = map_pmf noc (Sum_pmf (8 / 10) Da Db)", "by simp"], ["proof (state)\nthis:\n  map_pmf noc (map_pmf con s) = map_pmf noc (Sum_pmf (8 / 10) Da Db)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "finally"], ["proof (chain)\npicking this:\n  s = map_pmf noc (Sum_pmf (8 / 10) Da Db)", "show ?case"], ["proof (prove)\nusing this:\n  s = map_pmf noc (Sum_pmf (8 / 10) Da Db)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h) s [] =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db []))", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h) s [] =\n  map_pmf noc\n   (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da [])\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h)) Db\n       []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "case (snoc q qs)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h) s qs =\n  map_pmf noc\n   (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h)) Db\n       qs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h) s xs =\n       map_pmf noc\n        (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da xs)\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db xs)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h) s (xs @ [x]) =\n       map_pmf noc\n        (Sum_pmf (8 / 10)\n          (Partial_Cost_Model.config'_rand BIT Da (xs @ [x]))\n          (Partial_Cost_Model.config'_rand\n            (Partial_Cost_Model.embed (rTS h)) Db (xs @ [x])))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h) s (qs @ [q]) =\n    map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         Db (qs @ [q])))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h) s (qs @ [q]) =\n    map_pmf noc\n     (Sum_pmf (4 / 5) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n       (Partial_Cost_Model.config'_rand\n         (\\<lambda>s. return_pmf (fst (rTS h) s),\n          \\<lambda>s r. return_pmf (snd (rTS h) s r))\n         Db (qs @ [q])))", "apply(subst config'_rand_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (Partial_Cost_Model.config'_rand (COMB h) s qs) [q] =\n    map_pmf noc\n     (Sum_pmf (4 / 5) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n       (Partial_Cost_Model.config'_rand\n         (\\<lambda>s. return_pmf (fst (rTS h) s),\n          \\<lambda>s r. return_pmf (snd (rTS h) s r))\n         Db (qs @ [q])))", "apply(subst snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (map_pmf noc\n       (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n         (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n           Db qs)))\n     [q] =\n    map_pmf noc\n     (Sum_pmf (4 / 5) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n       (Partial_Cost_Model.config'_rand\n         (\\<lambda>s. return_pmf (fst (rTS h) s),\n          \\<lambda>s r. return_pmf (snd (rTS h) s r))\n         Db (qs @ [q])))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf noc\n     (Sum_pmf (4 / 5) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand\n         (\\<lambda>s. return_pmf (fst (rTS h) s),\n          \\<lambda>s r. return_pmf (snd (rTS h) s r))\n         Db qs)) \\<bind>\n    (\\<lambda>s.\n        snd (COMB h) s q \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    map_pmf noc\n     (Sum_pmf (4 / 5) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n       (Partial_Cost_Model.config'_rand\n         (\\<lambda>s. return_pmf (fst (rTS h) s),\n          \\<lambda>s r. return_pmf (snd (rTS h) s r))\n         Db (qs @ [q])))", "unfolding Sum_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs))) \\<bind>\n    (\\<lambda>s.\n        snd (COMB h) s q \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b\n          then map_pmf Inl\n                (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db (qs @ [q]))))", "apply(simp add: \n          bind_assoc_pmf bind_return_pmf COMB_def COMB_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs))) \\<bind>\n    (\\<lambda>s.\n        (case snd s of\n         Inl b \\<Rightarrow>\n           map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n            (BIT_step (fst s, b) q)\n         | Inr b \\<Rightarrow>\n             map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n              (return_pmf (TS_step_d (fst s, b) q))) \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b\n          then map_pmf Inl\n                (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db (qs @ [q]))))", "apply(subst config'_rand_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs))) \\<bind>\n    (\\<lambda>s.\n        (case snd s of\n         Inl b \\<Rightarrow>\n           map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n            (BIT_step (fst s, b) q)\n         | Inr b \\<Rightarrow>\n             map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n              (return_pmf (TS_step_d (fst s, b) q))) \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b\n          then map_pmf Inl\n                (Partial_Cost_Model.config'_rand BIT\n                  (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db (qs @ [q]))))", "apply(subst config'_rand_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs))) \\<bind>\n    (\\<lambda>s.\n        (case snd s of\n         Inl b \\<Rightarrow>\n           map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n            (BIT_step (fst s, b) q)\n         | Inr b \\<Rightarrow>\n             map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n              (return_pmf (TS_step_d (fst s, b) q))) \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    map_pmf noc\n     (bernoulli_pmf (4 / 5) \\<bind>\n      (\\<lambda>b.\n          if b\n          then map_pmf Inl\n                (Partial_Cost_Model.config'_rand BIT\n                  (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n          else map_pmf Inr\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  (Partial_Cost_Model.config'_rand\n                    (\\<lambda>s. return_pmf (fst (rTS h) s),\n                     \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                    Db qs)\n                  [q])))", "apply(simp only: map_pmf_def[where f=noc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                Db qs)) \\<bind>\n    (\\<lambda>x. return_pmf (noc x)) \\<bind>\n    (\\<lambda>s.\n        (case snd s of\n         Inl b \\<Rightarrow>\n           map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n            (BIT_step (fst s, b) q)\n         | Inr b \\<Rightarrow>\n             map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n              (return_pmf (TS_step_d (fst s, b) q))) \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then map_pmf Inl\n              (Partial_Cost_Model.config'_rand BIT\n                (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs)\n                [q])) \\<bind>\n    (\\<lambda>x. return_pmf (noc x))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>x.\n        (if x then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n         else map_pmf Inr\n               (Partial_Cost_Model.config'_rand\n                 (\\<lambda>s. return_pmf (fst (rTS h) s),\n                  \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                 Db qs)) \\<bind>\n        (\\<lambda>x.\n            (case snd (noc x) of\n             Inl b \\<Rightarrow>\n               map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                (BIT_step (fst (noc x), b) q)\n             | Inr b \\<Rightarrow>\n                 map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                  (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n            (\\<lambda>(a, is').\n                return_pmf (step (fst (noc x)) q a, is')))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>x.\n        (if x\n         then map_pmf Inl\n               (Partial_Cost_Model.config'_rand BIT\n                 (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n         else map_pmf Inr\n               (Partial_Cost_Model.config'_rand\n                 (\\<lambda>s. return_pmf (fst (rTS h) s),\n                  \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                 (Partial_Cost_Model.config'_rand\n                   (\\<lambda>s. return_pmf (fst (rTS h) s),\n                    \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                   Db qs)\n                 [q])) \\<bind>\n        (\\<lambda>x. return_pmf (noc x)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       (if x then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                Db qs)) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       (if x\n        then map_pmf Inl\n              (Partial_Cost_Model.config'_rand BIT\n                (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs)\n                [q])) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       (if x then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                Db qs)) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       (if x\n        then map_pmf Inl\n              (Partial_Cost_Model.config'_rand BIT\n                (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs)\n                [q])) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp only: set_pmf_bernoulli UNIV_bool)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {False, True} \\<Longrightarrow>\n       (if x then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                Db qs)) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       (if x\n        then map_pmf Inl\n              (Partial_Cost_Model.config'_rand BIT\n                (Partial_Cost_Model.config'_rand BIT Da qs) [q])\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (Partial_Cost_Model.config'_rand\n                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                   \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                  Db qs)\n                [q])) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inl\n        (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n         (\\<lambda>s.\n             BIT_step s q \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp only: map_pmf_def[where f=Inl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x. return_pmf (Inl x)) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) \\<bind>\n       (\\<lambda>x. return_pmf (Inl x)) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x.\n           (case snd (case x of (s, is) \\<Rightarrow> (s, Inl is)) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc (Inl x)), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc (Inl x)), b) q))) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (step (fst (case x of (s, is) \\<Rightarrow> (s, Inl is))) q\n                  a,\n                 is'))) =\n       Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x.\n           BIT_step x q \\<bind>\n           (\\<lambda>xa.\n               (case xa of\n                (a, is') \\<Rightarrow>\n                  return_pmf (step (fst x) q a, is')) \\<bind>\n               (\\<lambda>x.\n                   return_pmf\n                    (case x of (s, is) \\<Rightarrow> (s, Inl is)))))\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT Da qs =\n       Partial_Cost_Model.config'_rand BIT Da qs\n 2. \\<And>x xa.\n       \\<lbrakk>x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand BIT Da qs)\\<rbrakk>\n       \\<Longrightarrow> (case snd (case xa of\n                                    (s, is) \\<Rightarrow> (s, Inl is)) of\n                          Inl b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                             (BIT_step (fst (noc (Inl xa)), b) q)\n                          | Inr b \\<Rightarrow>\n                              map_pmf\n                               (\\<lambda>((a, b), c). ((a, b), Inr c))\n                               (return_pmf\n                                 (TS_step_d (fst (noc (Inl xa)), b)\n                                   q))) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (step\n                                (fst (case xa of\n(s, is) \\<Rightarrow> (s, Inl is)))\n                                q a,\n                               is')) =\n                         BIT_step xa q \\<bind>\n                         (\\<lambda>x.\n                             (case x of\n                              (a, is') \\<Rightarrow>\n                                return_pmf (step (fst xa) q a, is')) \\<bind>\n                             (\\<lambda>x.\n                                 return_pmf\n                                  (case x of\n                                   (s, is) \\<Rightarrow> (s, Inl is))))\n 3. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp add: bind_return_pmf bind_assoc_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand BIT Da qs)\\<rbrakk>\n       \\<Longrightarrow> (case snd (case xa of\n                                    (s, is) \\<Rightarrow> (s, Inl is)) of\n                          Inl b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                             (BIT_step (fst (noc (Inl xa)), b) q)\n                          | Inr b \\<Rightarrow>\n                              map_pmf\n                               (\\<lambda>((a, b), c). ((a, b), Inr c))\n                               (return_pmf\n                                 (TS_step_d (fst (noc (Inl xa)), b)\n                                   q))) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (step\n                                (fst (case xa of\n(s, is) \\<Rightarrow> (s, Inl is)))\n                                q a,\n                               is')) =\n                         BIT_step xa q \\<bind>\n                         (\\<lambda>x.\n                             (case x of\n                              (a, is') \\<Rightarrow>\n                                return_pmf (step (fst xa) q a, is')) \\<bind>\n                             (\\<lambda>x.\n                                 return_pmf\n                                  (case x of\n                                   (s, is) \\<Rightarrow> (s, Inl is))))\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp add:  split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand BIT Da qs)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>p. (fst p, Inl (snd p)))\n                          (BIT_step xa q) \\<bind>\n                         (\\<lambda>p.\n                             return_pmf (step (fst xa) q (fst p), snd p)) =\n                         BIT_step xa q \\<bind>\n                         (\\<lambda>x.\n                             return_pmf\n                              (step (fst xa) q (fst x), snd x) \\<bind>\n                             (\\<lambda>x. return_pmf (fst x, Inl (snd x))))\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp add: bind_return_pmf bind_assoc_pmf map_pmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS h) s),\n           \\<lambda>s r. return_pmf (snd (rTS h) s r))\n          Db qs \\<bind>\n         (\\<lambda>s.\n             return_pmf (snd (rTS h) s q) \\<bind>\n             (\\<lambda>(a, is').\n                 return_pmf (step (fst s) q a, is')))) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp only: map_pmf_def[where f=Inr])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs \\<bind>\n       (\\<lambda>x. return_pmf (Inr x)) \\<bind>\n       (\\<lambda>x.\n           (case snd (noc x) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc x), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc x), b) q))) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst (noc x)) q a, is'))) =\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS h) s q) \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) \\<bind>\n       (\\<lambda>x. return_pmf (Inr x)) \\<bind>\n       (\\<lambda>x. return_pmf (noc x))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs \\<bind>\n       (\\<lambda>x.\n           (case snd (case x of (s, is) \\<Rightarrow> (s, Inr is)) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc (Inr x)), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc (Inr x)), b) q))) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (step (fst (case x of (s, is) \\<Rightarrow> (s, Inr is))) q\n                  a,\n                 is'))) =\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs \\<bind>\n       (\\<lambda>x.\n           (case snd (rTS h) x q of\n            (a, is') \\<Rightarrow>\n              return_pmf (step (fst x) q a, is')) \\<bind>\n           (\\<lambda>x.\n               return_pmf (case x of (s, is) \\<Rightarrow> (s, Inr is))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs =\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS h) s),\n         \\<lambda>s r. return_pmf (snd (rTS h) s r))\n        Db qs\n 2. \\<And>x xa.\n       \\<lbrakk>\\<not> x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand\n                    (\\<lambda>s. return_pmf (fst (rTS h) s),\n                     \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                    Db qs)\\<rbrakk>\n       \\<Longrightarrow> (case snd (case xa of\n                                    (s, is) \\<Rightarrow> (s, Inr is)) of\n                          Inl b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                             (BIT_step (fst (noc (Inr xa)), b) q)\n                          | Inr b \\<Rightarrow>\n                              map_pmf\n                               (\\<lambda>((a, b), c). ((a, b), Inr c))\n                               (return_pmf\n                                 (TS_step_d (fst (noc (Inr xa)), b)\n                                   q))) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (step\n                                (fst (case xa of\n(s, is) \\<Rightarrow> (s, Inr is)))\n                                q a,\n                               is')) =\n                         (case snd (rTS h) xa q of\n                          (a, is') \\<Rightarrow>\n                            return_pmf (step (fst xa) q a, is')) \\<bind>\n                         (\\<lambda>x.\n                             return_pmf\n                              (case x of (s, is) \\<Rightarrow> (s, Inr is)))", "apply(simp add: bind_return_pmf bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<not> x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand\n                    (\\<lambda>s. return_pmf (fst (rTS h) s),\n                     \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                    Db qs)\\<rbrakk>\n       \\<Longrightarrow> (case snd (case xa of\n                                    (s, is) \\<Rightarrow> (s, Inr is)) of\n                          Inl b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                             (BIT_step (fst (noc (Inr xa)), b) q)\n                          | Inr b \\<Rightarrow>\n                              map_pmf\n                               (\\<lambda>((a, b), c). ((a, b), Inr c))\n                               (return_pmf\n                                 (TS_step_d (fst (noc (Inr xa)), b)\n                                   q))) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (step\n                                (fst (case xa of\n(s, is) \\<Rightarrow> (s, Inr is)))\n                                q a,\n                               is')) =\n                         (case snd (rTS h) xa q of\n                          (a, is') \\<Rightarrow>\n                            return_pmf (step (fst xa) q a, is')) \\<bind>\n                         (\\<lambda>x.\n                             return_pmf\n                              (case x of (s, is) \\<Rightarrow> (s, Inr is)))", "apply(simp add:  split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<not> x;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand\n                    (\\<lambda>s. return_pmf (fst (rTS h) s),\n                     \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                    Db qs)\\<rbrakk>\n       \\<Longrightarrow> return_pmf\n                          (fst (TS_step_d xa q),\n                           Inr (snd (TS_step_d xa q))) \\<bind>\n                         (\\<lambda>p.\n                             return_pmf (step (fst xa) q (fst p), snd p)) =\n                         return_pmf\n                          (step (fst xa) q (fst (snd (rTS h) xa q)),\n                           snd (snd (rTS h) xa q)) \\<bind>\n                         (\\<lambda>x. return_pmf (fst x, Inr (snd x)))", "apply(simp add: bind_return_pmf bind_assoc_pmf map_pmf_def rTS_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h) s (qs @ [q]) =\n  map_pmf noc\n   (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da (qs @ [q]))\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h)) Db\n       (qs @ [q])))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obligation1'': \n    shows \"config_rand (COMB h) init qs =\n    map_pmf noc (Sum_pmf (8 / 10) (config_rand BIT init qs)\n                     (config_rand (embed (rTS h)) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    map_pmf noc\n     (Sum_pmf (8 / 10)\n       (Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n          (\\<lambda>is. return_pmf (init, is)))\n         qs))", "apply(rule obligation1')"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf con\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) =\n    Sum_pmf (8 / 10)\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n      (\\<lambda>is. return_pmf (init, is)))", "apply(simp add: Sum_pmf_def COMB_def map_pmf_def bind_assoc_pmf bind_return_pmf split_def COMB_init_def del: COMB_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>x.\n        (if x then map_pmf Inl (BIT_init init)\n         else map_pmf Inr (return_pmf (fst (rTS h) init))) \\<bind>\n        (\\<lambda>x.\n            return_pmf\n             (case x of Inl is \\<Rightarrow> Inl (fst (init, x), is)\n              | Inr is \\<Rightarrow> Inr (fst (init, x), is)))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then map_pmf Inl\n              (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        else map_pmf Inr (return_pmf (init, fst (rTS h) init)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       (if x then map_pmf Inl (BIT_init init)\n        else map_pmf Inr (return_pmf (fst (rTS h) init))) \\<bind>\n       (\\<lambda>x.\n           return_pmf\n            (case x of Inl is \\<Rightarrow> Inl (fst (init, x), is)\n             | Inr is \\<Rightarrow> Inr (fst (init, x), is))) =\n       (if x\n        then map_pmf Inl\n              (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        else map_pmf Inr (return_pmf (init, fst (rTS h) init)))", "by(auto simp add: split_def map_pmf_def bind_return_pmf bind_assoc_pmf)"], ["", "lemma obligation1: assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    shows \"map_pmf con (config'_rand (COMB []) s qs) = \n    Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS [])) Db qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "from obligation1'[OF assms]"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand (COMB ?h) s ?qs =\n  map_pmf noc\n   (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da ?qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h)) Db\n       ?qs))", "have \"map_pmf con (config'_rand (COMB []) s qs)\n      = map_pmf con (map_pmf noc (Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS [])) Db qs)))\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand (COMB ?h) s ?qs =\n  map_pmf noc\n   (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da ?qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h)) Db\n       ?qs))\n\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    map_pmf con\n     (map_pmf noc\n       (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n         (Partial_Cost_Model.config'_rand\n           (Partial_Cost_Model.embed (rTS [])) Db qs)))", "by simp"], ["proof (state)\nthis:\n  map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n  map_pmf con\n   (map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs)))\n\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "also"], ["proof (state)\nthis:\n  map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n  map_pmf con\n   (map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs)))\n\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "have \"\\<dots> = Sum_pmf (8 / 10) (config'_rand BIT Da qs)\n                     (config'_rand (embed (rTS [])) Db qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf con\n     (map_pmf noc\n       (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n         (Partial_Cost_Model.config'_rand\n           (Partial_Cost_Model.embed (rTS [])) Db qs))) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "apply(simp only: pmf.map_comp connoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf id\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs)) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "by simp"], ["proof (state)\nthis:\n  map_pmf con\n   (map_pmf noc\n     (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs))) =\n  Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)\n\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "finally"], ["proof (chain)\npicking this:\n  map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n  Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n  Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)\n\ngoal (1 subgoal):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)", "."], ["proof (state)\nthis:\n  map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n  Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BIT_config'_fin: \"finite (set_pmf s) \\<Longrightarrow> finite (set_pmf (config'_rand BIT s qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf s) \\<Longrightarrow>\n    finite (set_pmf (Partial_Cost_Model.config'_rand BIT s qs))", "apply(induct qs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf s) \\<Longrightarrow>\n    finite (set_pmf (Partial_Cost_Model.config'_rand BIT s []))\n 2. \\<And>x xs.\n       \\<lbrakk>finite (set_pmf s) \\<Longrightarrow>\n                finite (set_pmf (Partial_Cost_Model.config'_rand BIT s xs));\n        finite (set_pmf s)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand BIT s\n                              (xs @ [x])))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>finite (set_pmf s) \\<Longrightarrow>\n                finite (set_pmf (Partial_Cost_Model.config'_rand BIT s xs));\n        finite (set_pmf s)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand BIT s\n                              (xs @ [x])))", "by(simp add: config'_rand_append BIT_step_def)"], ["", "lemma TS_config'_fin: \"finite (set_pmf s) \\<Longrightarrow> finite (set_pmf (config'_rand (embed (rTS h)) s qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf s) \\<Longrightarrow>\n    finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h)) s\n         qs))", "apply(induct qs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf s) \\<Longrightarrow>\n    finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h)) s\n         []))\n 2. \\<And>x xs.\n       \\<lbrakk>finite (set_pmf s) \\<Longrightarrow>\n                finite\n                 (set_pmf\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS h)) s xs));\n        finite (set_pmf s)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed (rTS h)) s\n                              (xs @ [x])))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>finite (set_pmf s) \\<Longrightarrow>\n                finite\n                 (set_pmf\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS h)) s xs));\n        finite (set_pmf s)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand\n                              (Partial_Cost_Model.embed (rTS h)) s\n                              (xs @ [x])))", "by(simp add: config'_rand_append rTS_def TS_step_d_def)"], ["", "lemma obligation2: assumes \"map_pmf con s = Sum_pmf (8 / 10) Da Db\"\n    and \"finite (set_pmf Da)\"\n    and \"finite (set_pmf Db)\"\n  shows \"T\\<^sub>p_on_rand' (COMB []) s qs =\n    2 / 10 * T\\<^sub>p_on_rand' (embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs", "proof (induct qs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' (COMB []) s [] =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db [] +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da []\n 2. \\<And>x xs.\n       T\\<^sub>p_on_rand' (COMB []) s xs =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db xs +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da xs \\<Longrightarrow>\n       T\\<^sub>p_on_rand' (COMB []) s (xs @ [x]) =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db\n        (xs @ [x]) +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da (xs @ [x])", "case (snoc q qs)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs =\n  2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' (COMB []) s [] =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db [] +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da []\n 2. \\<And>x xs.\n       T\\<^sub>p_on_rand' (COMB []) s xs =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db xs +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da xs \\<Longrightarrow>\n       T\\<^sub>p_on_rand' (COMB []) s (xs @ [x]) =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db\n        (xs @ [x]) +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da (xs @ [x])", "have P: \"T\\<^sub>p_on_rand' (COMB []) (config'_rand (COMB []) s qs) [q]\n      = 2 / 10 * T\\<^sub>p_on_rand' (embed (rTS [])) (config'_rand (embed (rTS [])) Db qs) [q] +\n          8 / 10 * T\\<^sub>p_on_rand' BIT (config'_rand BIT Da qs) [q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB [])\n     (Partial_Cost_Model.config'_rand (COMB []) s qs) [q] =\n    2 / 10 *\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     [q] +\n    8 / 10 *\n    T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q]", "apply(subst obligation1'[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB [])\n     (map_pmf noc\n       (Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n         (Partial_Cost_Model.config'_rand\n           (Partial_Cost_Model.embed (rTS [])) Db qs)))\n     [q] =\n    2 / 10 *\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     [q] +\n    8 / 10 *\n    T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q]", "unfolding Sum_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB [])\n     (map_pmf noc\n       (bernoulli_pmf (8 / 10) \\<bind>\n        (\\<lambda>b.\n            if b\n            then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n            else map_pmf Inr\n                  (Partial_Cost_Model.config'_rand\n                    (Partial_Cost_Model.embed (rTS [])) Db qs))))\n     [q] =\n    2 / 10 *\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     [q] +\n    8 / 10 *\n    T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf noc\n        (bernoulli_pmf (4 / 5) \\<bind>\n         (\\<lambda>b.\n             if b\n             then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n             else map_pmf Inr\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS [])) Db qs))) \\<bind>\n       (\\<lambda>s.\n           snd (COMB []) s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp only: map_pmf_def[where f=noc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (bernoulli_pmf (4 / 5) \\<bind>\n       (\\<lambda>b.\n           if b then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n           else map_pmf Inr\n                 (Partial_Cost_Model.config'_rand\n                   (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x. return_pmf (noc x)) \\<bind>\n       (\\<lambda>s.\n           snd (COMB []) s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp add: bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (bernoulli_pmf (4 / 5) \\<bind>\n       (\\<lambda>x.\n           (if x\n            then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n            else map_pmf Inr\n                  (Partial_Cost_Model.config'_rand\n                    (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n           (\\<lambda>x.\n               return_pmf (noc x) \\<bind>\n               (\\<lambda>s.\n                   snd (COMB []) s q \\<bind>\n                   (\\<lambda>(a, is').\n                       return_pmf (real (t\\<^sub>p (fst s) q a))))))) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(subst E_bernoulli3)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < 4 / 5\n 2. 4 / 5 < 1\n 3. finite\n     (set_pmf\n       (bernoulli_pmf (4 / 5) \\<bind>\n        (\\<lambda>x.\n            (if x\n             then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n             else map_pmf Inr\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n            (\\<lambda>x.\n                return_pmf (noc x) \\<bind>\n                (\\<lambda>s.\n                    snd (COMB []) s q \\<bind>\n                    (\\<lambda>(a, is').\n                        return_pmf (real (t\\<^sub>p (fst s) q a))))))))\n 4. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 4 / 5 < 1\n 2. finite\n     (set_pmf\n       (bernoulli_pmf (4 / 5) \\<bind>\n        (\\<lambda>x.\n            (if x\n             then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n             else map_pmf Inr\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n            (\\<lambda>x.\n                return_pmf (noc x) \\<bind>\n                (\\<lambda>s.\n                    snd (COMB []) s q \\<bind>\n                    (\\<lambda>(a, is').\n                        return_pmf (real (t\\<^sub>p (fst s) q a))))))))\n 3. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (set_pmf\n       (bernoulli_pmf (4 / 5) \\<bind>\n        (\\<lambda>x.\n            (if x\n             then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n             else map_pmf Inr\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n            (\\<lambda>x.\n                return_pmf (noc x) \\<bind>\n                (\\<lambda>s.\n                    snd (COMB []) s q \\<bind>\n                    (\\<lambda>(a, is').\n                        return_pmf (real (t\\<^sub>p (fst s) q a))))))))\n 2. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp add: set_pmf_bernoulli)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (x \\<longrightarrow>\n        finite\n         (\\<Union>x\\<in>set_pmf (Partial_Cost_Model.config'_rand BIT Da qs).\n             \\<Union>xa\\<in>set_pmf\n                             (snd (COMB [])\n                               (case x of (s, is) \\<Rightarrow> (s, Inl is))\n                               q).\n                set_pmf\n                 (case xa of\n                  (a, is') \\<Rightarrow>\n                    return_pmf\n                     (real\n                       (t\\<^sub>p\n                         (fst (case x of (s, is) \\<Rightarrow> (s, Inl is)))\n                         q a))))) \\<and>\n       (\\<not> x \\<longrightarrow>\n        finite\n         (\\<Union>x\\<in>set_pmf\n                         (Partial_Cost_Model.config'_rand\n                           (\\<lambda>s. return_pmf (fst (rTS []) s),\n                            \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                           Db qs).\n             \\<Union>xa\\<in>set_pmf\n                             (snd (COMB [])\n                               (case x of (s, is) \\<Rightarrow> (s, Inr is))\n                               q).\n                set_pmf\n                 (case xa of\n                  (a, is') \\<Rightarrow>\n                    return_pmf\n                     (real\n                       (t\\<^sub>p\n                         (fst (case x of (s, is) \\<Rightarrow> (s, Inr is)))\n                         q a)))))\n 2. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp add: BIT_step_def COMB_def COMB_step_def split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (x \\<longrightarrow>\n        finite\n         (\\<Union>x\\<in>set_pmf (Partial_Cost_Model.config'_rand BIT Da qs).\n             {real\n               (t\\<^sub>p (fst x) q\n                 (if fst (snd x) ! index (snd (snd x)) q then 0\n                  else length (fst x),\n                  []))})) \\<and>\n       (\\<not> x \\<longrightarrow>\n        finite\n         (\\<Union>x\\<in>set_pmf\n                         (Partial_Cost_Model.config'_rand\n                           (\\<lambda>s. return_pmf (fst (rTS []) s),\n                            \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                           Db qs).\n             {real (t\\<^sub>p (fst x) q (fst (TS_step_d x q)))}))\n 2. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf (Partial_Cost_Model.config'_rand BIT Da qs).\n            {real\n              (t\\<^sub>p (fst x) q\n                (if fst (snd x) ! index (snd (snd x)) q then 0\n                 else length (fst x),\n                 []))})\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand\n                          (\\<lambda>s. return_pmf (fst (rTS []) s),\n                           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                          Db qs).\n            {real (t\\<^sub>p (fst x) q (fst (TS_step_d x q)))})\n 3. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "using BIT_config'_fin[OF assms(2)]"], ["proof (prove)\nusing this:\n  finite (set_pmf (Partial_Cost_Model.config'_rand BIT Da ?qs))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf (Partial_Cost_Model.config'_rand BIT Da qs).\n            {real\n              (t\\<^sub>p (fst x) q\n                (if fst (snd x) ! index (snd (snd x)) q then 0\n                 else length (fst x),\n                 []))})\n 2. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand\n                          (\\<lambda>s. return_pmf (fst (rTS []) s),\n                           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                          Db qs).\n            {real (t\\<^sub>p (fst x) q (fst (TS_step_d x q)))})\n 3. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand\n                          (\\<lambda>s. return_pmf (fst (rTS []) s),\n                           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                          Db qs).\n            {real (t\\<^sub>p (fst x) q (fst (TS_step_d x q)))})\n 2. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "using TS_config'_fin[OF assms(3)]"], ["proof (prove)\nusing this:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h)) Db\n       ?qs))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> x \\<Longrightarrow>\n       finite\n        (\\<Union>x\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand\n                          (\\<lambda>s. return_pmf (fst (rTS []) s),\n                           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n                          Db qs).\n            {real (t\\<^sub>p (fst x) q (fst (TS_step_d x q)))})\n 2. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E ((if True then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (4 / 5) +\n    E ((if False\n        then map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs)\n        else map_pmf Inr\n              (Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS [])) Db qs)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    (1 - 4 / 5) =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf Inl (Partial_Cost_Model.config'_rand BIT Da qs) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    4 /\n    5 +\n    E (map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS []) s),\n           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) /\n    5 =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp only: map_pmf_def[where f=Inl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x. return_pmf (Inl x)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    4 /\n    5 +\n    E (map_pmf Inr\n        (Partial_Cost_Model.config'_rand\n          (\\<lambda>s. return_pmf (fst (rTS []) s),\n           \\<lambda>s r. return_pmf (snd (rTS []) s r))\n          Db qs) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) /\n    5 =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp only: map_pmf_def[where f=Inr])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x. return_pmf (Inl x)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) *\n    4 /\n    5 +\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>x. return_pmf (Inr x)) \\<bind>\n       (\\<lambda>x.\n           return_pmf (noc x) \\<bind>\n           (\\<lambda>s.\n               snd (COMB []) s q \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (real (t\\<^sub>p (fst s) q a)))))) /\n    5 =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf (snd (rTS []) s q) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp add: bind_return_pmf bind_assoc_pmf COMB_def COMB_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x.\n           (case snd (case x of (s, is) \\<Rightarrow> (s, Inl is)) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc (Inl x)), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc (Inl x)), b) q))) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (real\n                  (t\\<^sub>p\n                    (fst (case x of (s, is) \\<Rightarrow> (s, Inl is))) q\n                    a))))) *\n    4 /\n    5 +\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>x.\n           (case snd (case x of (s, is) \\<Rightarrow> (s, Inr is)) of\n            Inl b \\<Rightarrow>\n              map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n               (BIT_step (fst (noc (Inr x)), b) q)\n            | Inr b \\<Rightarrow>\n                map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                 (return_pmf (TS_step_d (fst (noc (Inr x)), b) q))) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (real\n                  (t\\<^sub>p\n                    (fst (case x of (s, is) \\<Rightarrow> (s, Inr is))) q\n                    a))))) /\n    5 =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           case snd (rTS []) s q of\n           (a, is') \\<Rightarrow>\n             return_pmf (real (t\\<^sub>p (fst s) q a)))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) q a))))) /\n    5", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>x.\n           map_pmf (\\<lambda>p. (fst p, Inl (snd p))) (BIT_step x q) \\<bind>\n           (\\<lambda>p. return_pmf (real (t\\<^sub>p (fst x) q (fst p)))))) *\n    4 /\n    5 +\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>x.\n           return_pmf\n            (fst (TS_step_d x q), Inr (snd (TS_step_d x q))) \\<bind>\n           (\\<lambda>p. return_pmf (real (t\\<^sub>p (fst x) q (fst p)))))) /\n    5 =\n    E (Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        Db qs \\<bind>\n       (\\<lambda>s.\n           return_pmf\n            (real (t\\<^sub>p (fst s) q (fst (snd (rTS []) s q)))))) /\n    5 +\n    4 *\n    E (Partial_Cost_Model.config'_rand BIT Da qs \\<bind>\n       (\\<lambda>s.\n           BIT_step s q \\<bind>\n           (\\<lambda>p. return_pmf (real (t\\<^sub>p (fst s) q (fst p)))))) /\n    5", "apply(simp add: rTS_def map_pmf_def bind_return_pmf bind_assoc_pmf COMB_def COMB_step_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB [])\n   (Partial_Cost_Model.config'_rand (COMB []) s qs) [q] =\n  2 / 10 *\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)\n   [q] +\n  8 / 10 *\n  T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' (COMB []) s [] =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db [] +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da []\n 2. \\<And>x xs.\n       T\\<^sub>p_on_rand' (COMB []) s xs =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db xs +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da xs \\<Longrightarrow>\n       T\\<^sub>p_on_rand' (COMB []) s (xs @ [x]) =\n       2 / 10 *\n       T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db\n        (xs @ [x]) +\n       8 / 10 * T\\<^sub>p_on_rand' BIT Da (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s (qs @ [q]) =\n    2 / 10 *\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db (qs @ [q]) +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da (qs @ [q])", "apply(simp only: T_on_rand'_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs +\n    T\\<^sub>p_on_rand' (COMB [])\n     (Partial_Cost_Model.config'_rand (COMB []) s qs) [q] =\n    2 / 10 *\n    (T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n     T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        Db qs)\n      [q]) +\n    8 / 10 *\n    (T\\<^sub>p_on_rand' BIT Da qs +\n     T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q])", "apply(subst snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs +\n    T\\<^sub>p_on_rand' (COMB [])\n     (Partial_Cost_Model.config'_rand (COMB []) s qs) [q] =\n    2 / 10 *\n    (T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n     T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        Db qs)\n      [q]) +\n    8 / 10 *\n    (T\\<^sub>p_on_rand' BIT Da qs +\n     T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q])", "apply(subst P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs +\n    (2 / 10 *\n     T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        Db qs)\n      [q] +\n     8 / 10 *\n     T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs)\n      [q]) =\n    2 / 10 *\n    (T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n     T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS []))\n      (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n        Db qs)\n      [q]) +\n    8 / 10 *\n    (T\\<^sub>p_on_rand' BIT Da qs +\n     T\\<^sub>p_on_rand' BIT (Partial_Cost_Model.config'_rand BIT Da qs) [q])", "by algebra"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s (qs @ [q]) =\n  2 / 10 *\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db (qs @ [q]) +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da (qs @ [q])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s [] =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db [] +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da []", "qed simp"], ["", "lemma Combination:\n  fixes bit\n  assumes \"qs \\<in> pattern\" \"a \\<noteq> b\" \"{a, b} = {x, y}\" \"set qs \\<subseteq> {a, b}\"\n    and \"inv_COMB s a [x,y]\"\n    and TS: \"\\<And>s h. a \\<noteq> b \\<Longrightarrow> {a, b} = {x, y} \\<Longrightarrow> TS_inv s a [x, y] \\<Longrightarrow> set qs \\<subseteq> {a, b}\n      \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow>\n            TS_inv (config'_rand (embed (rTS h)) s qs) (last qs) [x, y] \n          \\<and> T\\<^sub>p_on_rand' (embed (rTS h)) s qs = ts\"\n    and BIT: \"\\<And>s. a \\<noteq> b \\<Longrightarrow> {a, b} = {x, y} \\<Longrightarrow> BIT_inv s a [x, y] \\<Longrightarrow> set qs \\<subseteq> {a, b}\n      \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow>\n            BIT_inv (config'_rand BIT s qs) (last qs) [x, y] \n          \\<and> T\\<^sub>p_on_rand' BIT s qs = bit\"\n    and OPT_cost: \"a \\<noteq> b \\<Longrightarrow> qs \\<in> pattern \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = opt\"\n    and absch: \"qs \\<in> pattern \\<Longrightarrow> 0.2 * ts + 0.8 * bit \\<le> 1.6 * opt\"\n  shows \"T\\<^sub>p_on_rand' (COMB []) s qs \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "let ?D = \"map_pmf con s\""], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "from assms(5)"], ["proof (chain)\npicking this:\n  inv_COMB s a [x, y]", "obtain Da Db where Daf: \"finite (set_pmf Da)\"\n      and Dbf: \"finite (set_pmf Db)\"\n      and D: \"?D = Sum_pmf 0.8 Da Db\"\n             and B: \"BIT_inv Da a [x,y]\" and T: \"TS_inv Db a [x,y]\""], ["proof (prove)\nusing this:\n  inv_COMB s a [x, y]\n\ngoal (1 subgoal):\n 1. (\\<And>Da Db.\n        \\<lbrakk>finite (set_pmf Da); finite (set_pmf Db);\n         map_pmf con s = Sum_pmf (8 / 10) Da Db; BIT_inv Da a [x, y];\n         TS_inv Db a [x, y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inv_COMB_def"], ["proof (prove)\nusing this:\n  \\<exists>Da Db.\n     finite (set_pmf Da) \\<and>\n     finite (set_pmf Db) \\<and>\n     map_pmf con s = Sum_pmf (8 / 10) Da Db \\<and>\n     BIT_inv Da a [x, y] \\<and> TS_inv Db a [x, y]\n\ngoal (1 subgoal):\n 1. (\\<And>Da Db.\n        \\<lbrakk>finite (set_pmf Da); finite (set_pmf Db);\n         map_pmf con s = Sum_pmf (8 / 10) Da Db; BIT_inv Da a [x, y];\n         TS_inv Db a [x, y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite (set_pmf Da)\n  finite (set_pmf Db)\n  map_pmf con s = Sum_pmf (8 / 10) Da Db\n  BIT_inv Da a [x, y]\n  TS_inv Db a [x, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "let ?Da' = \"config'_rand BIT Da qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "from BIT[OF assms(2,3) B assms(4,1) ]"], ["proof (chain)\npicking this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs)\n   [x, y] \\<and>\n  T\\<^sub>p_on_rand' BIT Da qs = bit", "have B': \"BIT_inv ?Da' (last qs) [x, y]\"\n    and B_cost: \"T\\<^sub>p_on_rand' BIT Da qs = bit\""], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs)\n   [x, y] \\<and>\n  T\\<^sub>p_on_rand' BIT Da qs = bit\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y] &&&\n    T\\<^sub>p_on_rand' BIT Da qs = bit", "by auto"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n  T\\<^sub>p_on_rand' BIT Da qs = bit\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "let ?Db' = \"config'_rand (embed (rTS [])) Db qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "(* ?hnlich *)"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "from TS[OF assms(2,3) T assms(4,1)]"], ["proof (chain)\npicking this:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h)) Db\n     qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS ?h)) Db qs = ts", "have T': \"TS_inv ?Db' (last qs) [x, y]\"\n    and T_cost: \"T\\<^sub>p_on_rand' (embed (rTS [])) Db qs = ts\""], ["proof (prove)\nusing this:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h)) Db\n     qs)\n   (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS ?h)) Db qs = ts\n\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y] &&&\n    T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs = ts", "by auto"], ["proof (state)\nthis:\n  TS_inv\n   (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n     qs)\n   (last qs) [x, y]\n  T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs = ts\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "have \"T\\<^sub>p_on_rand' (COMB []) s qs\n        = 0.2 * T\\<^sub>p_on_rand' (embed (rTS [])) Db qs\n            + 0.8 * T\\<^sub>p_on_rand' BIT Da qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs", "using D"], ["proof (prove)\nusing this:\n  map_pmf con s = Sum_pmf (8 / 10) Da Db\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs =\n    2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs", "apply(rule obligation2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf Da)\n 2. finite (set_pmf Db)", "apply(fact Daf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf Db)", "apply(fact Dbf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs =\n  2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs =\n  2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "have \"\\<dots>  \\<le> 1.6 * opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n    8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n    \\<le> 16 / 10 * opt", "by (simp only: B_cost T_cost absch[OF assms(1)])"], ["proof (state)\nthis:\n  2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n  \\<le> 16 / 10 * opt\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "also"], ["proof (state)\nthis:\n  2 / 10 * T\\<^sub>p_on_rand' (Partial_Cost_Model.embed (rTS [])) Db qs +\n  8 / 10 * T\\<^sub>p_on_rand' BIT Da qs\n  \\<le> 16 / 10 * opt\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "have \"\\<dots> = 1.6 * T\\<^sub>p [a, b] qs (OPT2 qs [a, b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 16 / 10 * opt = 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))", "by (simp add: OPT_cost[OF assms(2,1)])"], ["proof (state)\nthis:\n  16 / 10 * opt = 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))", "have Comb_cost: \"T\\<^sub>p_on_rand' (COMB []) s qs \\<le> 1.6 * T\\<^sub>p [a, b] qs (OPT2 qs [a, b])\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "have Comb_inv: \"inv_COMB (config'_rand (COMB []) s qs) (last qs) [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "unfolding inv_COMB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Da Db.\n       finite (set_pmf Da) \\<and>\n       finite (set_pmf Db) \\<and>\n       map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n       Sum_pmf (8 / 10) Da Db \\<and>\n       BIT_inv Da (last qs) [x, y] \\<and> TS_inv Db (last qs) [x, y]", "apply(rule exI[where x=\"?Da'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Db.\n       finite (set_pmf (Partial_Cost_Model.config'_rand BIT Da qs)) \\<and>\n       finite (set_pmf Db) \\<and>\n       map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n       Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n        Db \\<and>\n       BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs)\n        [x, y] \\<and>\n       TS_inv Db (last qs) [x, y]", "apply(rule exI[where x=\"?Db'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (Partial_Cost_Model.config'_rand BIT Da qs)) \\<and>\n    finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs)) \\<and>\n    map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs)\n     [x, y] \\<and>\n    TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite (set_pmf (Partial_Cost_Model.config'_rand BIT Da qs))\n 2. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs))\n 3. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n 4. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n 5. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(rule BIT_config'_fin[OF Daf])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n         Db qs))\n 2. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n 3. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n 4. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(rule TS_config'_fin[OF Dbf])"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_pmf con (Partial_Cost_Model.config'_rand (COMB []) s qs) =\n    Sum_pmf (8 / 10) (Partial_Cost_Model.config'_rand BIT Da qs)\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n 2. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n 3. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(rule obligation1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_pmf con s = Sum_pmf (8 / 10) Da Db\n 2. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n 3. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(fact D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT Da qs) (last qs) [x, y]\n 2. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(fact B')"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS [])) Db\n       qs)\n     (last qs) [x, y]", "apply(fact T')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "from Comb_cost Comb_inv"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b]))\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem COMB_OPT2':  \"(x::nat) \\<noteq> y \\<Longrightarrow> set \\<sigma> \\<subseteq> {x,y}\n     \\<Longrightarrow> T\\<^sub>p_on_rand (COMB []) [x,y] \\<sigma>  \\<le> 1.6 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 1.6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                       (fst (COMB []) [x, y] \\<bind>\n                        (\\<lambda>is. return_pmf ([x, y], is)))\n                       \\<sigma>\n                      \\<le> 16 / 10 * real (T\\<^sub>p_opt [x, y] \\<sigma>) +\n                            16 / 10", "proof (rule Phase_partitioning_general[where P=\"inv_COMB\"], goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> inv_COMB\n                       (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x\n                       [x, y]\n 5. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "case 4"], ["proof (state)\nthis:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> inv_COMB\n                       (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x\n                       [x, y]\n 5. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "let ?initBIT =\"(map_pmf (Pair [x, y]) (fst BIT [x, y]))\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> inv_COMB\n                       (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x\n                       [x, y]\n 5. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "let ?initTS =\"(map_pmf (Pair [x, y]) (fst (embed (rTS [])) [x, y]))\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> inv_COMB\n                       (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x\n                       [x, y]\n 5. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "show  \"inv_COMB (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_COMB (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x [x, y]", "unfolding inv_COMB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Da Db.\n       finite (set_pmf Da) \\<and>\n       finite (set_pmf Db) \\<and>\n       map_pmf con (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) =\n       Sum_pmf (8 / 10) Da Db \\<and>\n       BIT_inv Da x [x, y] \\<and> TS_inv Db x [x, y]", "apply(rule exI[where x=\"?initBIT\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Db.\n       finite (set_pmf (map_pmf (Pair [x, y]) (fst BIT [x, y]))) \\<and>\n       finite (set_pmf Db) \\<and>\n       map_pmf con (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) =\n       Sum_pmf (8 / 10) (map_pmf (Pair [x, y]) (fst BIT [x, y])) Db \\<and>\n       BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y] \\<and>\n       TS_inv Db x [x, y]", "apply(rule exI[where x=\"?initTS\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (map_pmf (Pair [x, y]) (fst BIT [x, y]))) \\<and>\n    finite\n     (set_pmf\n       (map_pmf (Pair [x, y])\n         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))) \\<and>\n    map_pmf con (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) =\n    Sum_pmf (8 / 10) (map_pmf (Pair [x, y]) (fst BIT [x, y]))\n     (map_pmf (Pair [x, y])\n       (fst (Partial_Cost_Model.embed (rTS [])) [x, y])) \\<and>\n    BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y] \\<and>\n    TS_inv\n     (map_pmf (Pair [x, y])\n       (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n     x [x, y]", "apply(simp only: BIT_inv_initial[OF 4(1)] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (map_pmf (Pair [x, y]) (fst BIT [x, y]))) \\<and>\n    finite\n     (set_pmf\n       (map_pmf (Pair [x, y])\n         (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))) \\<and>\n    map_pmf con (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) =\n    Sum_pmf (8 / 10) (map_pmf (Pair [x, y]) (fst BIT [x, y]))\n     (map_pmf (Pair [x, y])\n       (fst (Partial_Cost_Model.embed (rTS [])) [x, y])) \\<and>\n    True \\<and>\n    TS_inv\n     (map_pmf (Pair [x, y])\n       (fst (Partial_Cost_Model.embed (rTS [])) [x, y]))\n     x [x, y]", "apply(simp add: map_pmf_def bind_return_pmf bind_assoc_pmf COMB_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>xa\\<in>set_pmf (BIT_init [x, y]). {([x, y], xa)}) \\<and>\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xaa.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>xaaa.\n                return_pmf\n                 (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                  Inl is \\<Rightarrow> Inl ([x, y], is)\n                  | Inr is \\<Rightarrow> Inr ([x, y], is))))) =\n    Sum_pmf (4 / 5)\n     (BIT_init [x, y] \\<bind> (\\<lambda>xa. return_pmf ([x, y], xa)))\n     (return_pmf ([x, y], fst (rTS []) [x, y])) \\<and>\n    TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(simp add: Sum_pmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>xa\\<in>set_pmf (BIT_init [x, y]). {([x, y], xa)}) \\<and>\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xaa.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>xaaa.\n                return_pmf\n                 (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                  Inl is \\<Rightarrow> Inl ([x, y], is)\n                  | Inr is \\<Rightarrow> Inr ([x, y], is))))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then map_pmf Inl\n              (BIT_init [x, y] \\<bind>\n               (\\<lambda>xa. return_pmf ([x, y], xa)))\n        else map_pmf Inr (return_pmf ([x, y], fst (rTS []) [x, y]))) \\<and>\n    TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (\\<Union>xa\\<in>set_pmf (BIT_init [x, y]). {([x, y], xa)})\n 2. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xaa.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>xaaa.\n                return_pmf\n                 (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                  Inl is \\<Rightarrow> Inl ([x, y], is)\n                  | Inr is \\<Rightarrow> Inr ([x, y], is))))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then map_pmf Inl\n              (BIT_init [x, y] \\<bind>\n               (\\<lambda>xa. return_pmf ([x, y], xa)))\n        else map_pmf Inr (return_pmf ([x, y], fst (rTS []) [x, y])))\n 3. TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(simp add: BIT_init_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xaa.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>xaaa.\n                return_pmf\n                 (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                  Inl is \\<Rightarrow> Inl ([x, y], is)\n                  | Inr is \\<Rightarrow> Inr ([x, y], is))))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        if b\n        then map_pmf Inl\n              (BIT_init [x, y] \\<bind>\n               (\\<lambda>xa. return_pmf ([x, y], xa)))\n        else map_pmf Inr (return_pmf ([x, y], fst (rTS []) [x, y])))\n 2. TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>xa.\n       xa \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xaa.\n           bernoulli_pmf (1 / 2) \\<bind>\n           (\\<lambda>xaaa.\n               return_pmf\n                (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                 Inl is \\<Rightarrow> Inl ([x, y], is)\n                 | Inr is \\<Rightarrow> Inr ([x, y], is)))) =\n       (if xa\n        then map_pmf Inl\n              (BIT_init [x, y] \\<bind>\n               (\\<lambda>xa. return_pmf ([x, y], xa)))\n        else map_pmf Inr (return_pmf ([x, y], fst (rTS []) [x, y])))\n 3. TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xaa.\n           bernoulli_pmf (1 / 2) \\<bind>\n           (\\<lambda>xaaa.\n               return_pmf\n                (case if xa then Inl ([xaaa, xaa], [x, y]) else Inr [] of\n                 Inl is \\<Rightarrow> Inl ([x, y], is)\n                 | Inr is \\<Rightarrow> Inr ([x, y], is)))) =\n       (if xa\n        then map_pmf Inl\n              (BIT_init [x, y] \\<bind>\n               (\\<lambda>xa. return_pmf ([x, y], xa)))\n        else map_pmf Inr (return_pmf ([x, y], fst (rTS []) [x, y])))\n 2. TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(simp add: bind_return_pmf bind_assoc_pmf rTS_def map_pmf_def BIT_init_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TS_inv' ([x, y], fst (rTS []) [x, y]) x [x, y]", "apply(simp add: TS_inv_def rTS_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv_COMB (map_pmf (Pair [x, y]) (fst (COMB []) [x, y])) x [x, y]\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "case (5 a b qs s)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  set \\<sigma> \\<subseteq> {x, y}\n  qs \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  inv_COMB s a [x, y]\n  set qs \\<subseteq> {a, b}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma>' s.\n       \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y};\n        \\<sigma>' \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        inv_COMB s a [x, y]; set \\<sigma>' \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB []) s \\<sigma>'\n                         \\<le> 16 / 10 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>'\n                                  (OPT2 \\<sigma>' [a, b])) \\<and>\n                         inv_COMB\n                          (Partial_Cost_Model.config'_rand (COMB []) s\n                            \\<sigma>')\n                          (last \\<sigma>') [x, y]", "from 5(3)"], ["proof (chain)\npicking this:\n  qs \\<in> Lxx a b", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> Lxx a b\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "proof (rule LxxE, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "case 4"], ["proof (state)\nthis:\n  qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\n\ngoal (4 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])", "show ?thesis"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(rule Combination)"], ["proof (prove)\ngoal (8 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 7. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 8. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(fact)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "using TS_a''"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; {?x, ?y} = {?x0.0, ?y0.0};\n   TS_inv ?s ?x [?x0.0, ?y0.0]; set ?qs \\<subseteq> {?x, ?y};\n   ?qs \\<in> lang (seq [question (Atom ?x), Atom ?y, Atom ?y])\\<rbrakk>\n  \\<Longrightarrow> TS_inv\n                     (Partial_Cost_Model.config'_rand\n                       (Partial_Cost_Model.embed (rTS ?h0.0)) ?s ?qs)\n                     (last ?qs) [?x0.0, ?y0.0] \\<and>\n                    T\\<^sub>p_on_rand'\n                     (Partial_Cost_Model.embed (rTS ?h0.0)) ?s ?qs =\n                    2\n\ngoal (4 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 2. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * 2 + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(fact bit_a'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * 2 + 8 / 10 * (15 / 10) \\<le> 16 / 10 * ?opt", "apply(fact OPT2_A')"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * 2 + 8 / 10 * (15 / 10) \\<le> 16 / 10 * 1", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (3 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "case 1"], ["proof (state)\nthis:\n  qs \\<in> lang (seq [Atom a, Atom a])\n\ngoal (3 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [Atom a, Atom a])", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom a, Atom a])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(rule Combination)"], ["proof (prove)\ngoal (8 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 7. \\<lbrakk>a \\<noteq> b; qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 8. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(fact)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 3. \\<lbrakk>a \\<noteq> b; qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 4. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(fact TS_d'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit\n 2. \\<lbrakk>a \\<noteq> b; qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 3. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    2 / 10 * 0 + 8 / 10 * ?bit \\<le> 16 / 10 * ?opt", "apply(fact bit_d')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> b; qs \\<in> lang (seq [Atom a, Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt\n 2. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    2 / 10 * 0 + 8 / 10 * 0 \\<le> 16 / 10 * ?opt", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "case 2"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom b, Atom b])\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom b, Atom b])", "have \"qs \\<in> lang (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b, Atom b])\n              \\<or> qs \\<in> lang (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b, Atom b])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom b, Atom b])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<or>\n    qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b])", "by auto"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                  Atom b]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom b, Atom b])\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                  Atom b]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom b, Atom b])", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                  Atom b]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom b, Atom b])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(erule Combination)"], ["proof (prove)\ngoal (9 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts3\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 7. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                     Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 8. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts3 + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 9. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts3\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                     Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 4. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts3 + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 5. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact TS_b1'')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom b, Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 2. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                     Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 3. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 4. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact bit_b''1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                     Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 2. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs) - 5 / 10)\n    \\<le> 16 / 10 * ?opt3\n 3. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact OPT2_B1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs) / 2)\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(simp add: ring_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(erule Combination)"], ["proof (prove)\ngoal (8 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom b,\n                        Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts39\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom b,\n                        Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit39\n 7. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt39\n 8. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts39 + 8 / 10 * ?bit39 \\<le> 16 / 10 * ?opt39", "apply(fact)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom b,\n                        Atom b])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts39\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom b,\n                        Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit39\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt39\n 4. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * ?ts39 + 8 / 10 * ?bit39 \\<le> 16 / 10 * ?opt39", "apply(fact TS_b2'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom b,\n                        Atom b])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit39\n 2. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt39\n 3. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) + 8 / 10 * ?bit39 \\<le> 16 / 10 * ?opt39", "apply(fact bit_b''2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt39\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10)\n    \\<le> 16 / 10 * ?opt39", "apply(fact OPT2_B2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom b, Atom b]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs - 1) / 2)", "apply(simp add: ring_distribs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "case 3"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom a])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom a])", "have len: \"length qs \\<ge> 2\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom a])\n\ngoal (1 subgoal):\n 1. 2 \\<le> length qs", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  2 \\<le> length qs\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "have len2: \"qs \\<in> lang (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom a]) \n                  \\<Longrightarrow> length qs \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    3 \\<le> length qs", "by (auto simp add: conc_def)"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a]) \\<Longrightarrow>\n  3 \\<le> length qs\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "from 3"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom a])", "have \"qs \\<in> lang (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom a])\n              \\<or> qs \\<in> lang (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)), Atom a])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom a), Atom b, Atom a,\n                  Star (Times (Atom b) (Atom a)), Atom a])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<or>\n    qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a])", "by auto"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a])", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a]) \\<or>\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(erule Combination)"], ["proof (prove)\ngoal (9 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts3\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 7. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 8. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts3 + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 9. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts3\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 4. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts3 + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 5. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact TS_c1'')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                        Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit3\n 2. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 3. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) + 8 / 10 * ?bit3 \\<le> 16 / 10 * ?opt3\n 4. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact bit_c''1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt3\n 2. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs) - 5 / 10)\n    \\<le> 16 / 10 * ?opt3\n 3. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(fact OPT2_C1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs - 1) / 2)\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "using len"], ["proof (prove)\nusing this:\n  2 \\<le> length qs\n\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 2) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs - 1) / 2)\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(simp add: ring_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB []) s qs\n    \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs)\n     [x, y]", "apply(erule Combination)"], ["proof (prove)\ngoal (8 subgoals):\n 1. a \\<noteq> b\n 2. {a, b} = {x, y}\n 3. set qs \\<subseteq> {a, b}\n 4. inv_COMB s a [x, y]\n 5. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts85\n 6. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit85\n 7. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt85\n 8. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts85 + 8 / 10 * ?bit85 \\<le> 16 / 10 * ?opt85", "apply(fact)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; TS_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom a])\\<rbrakk>\n       \\<Longrightarrow> TS_inv\n                          (Partial_Cost_Model.config'_rand\n                            (Partial_Cost_Model.embed (rTS h)) s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand'\n                          (Partial_Cost_Model.embed (rTS h)) s qs =\n                         ?ts85\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit85\n 3. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt85\n 4. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * ?ts85 + 8 / 10 * ?bit85 \\<le> 16 / 10 * ?opt85", "apply(fact TS_c2'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n        set qs \\<subseteq> {a, b};\n        qs \\<in> lang\n                  (seq [Atom a, Atom b, Atom a,\n                        Star (Times (Atom b) (Atom a)), Atom a])\\<rbrakk>\n       \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                          (last qs) [x, y] \\<and>\n                         T\\<^sub>p_on_rand' BIT s qs = ?bit85\n 2. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt85\n 3. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) + 8 / 10 * ?bit85 \\<le> 16 / 10 * ?opt85", "apply(fact bit_c''2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> b;\n     qs \\<in> lang\n               (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                     Atom a])\\<rbrakk>\n    \\<Longrightarrow> real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) = ?opt85\n 2. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10)\n    \\<le> 16 / 10 * ?opt85", "apply(fact OPT2_C2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs - 2) / 2)", "using len2"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                  Atom a]) \\<Longrightarrow>\n  3 \\<le> length qs\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom a, Atom b, Atom a, Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    2 / 10 * real (length qs - 3) +\n    8 / 10 * (75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10)\n    \\<le> 16 / 10 * (real (length qs - 2) / 2)", "apply(simp add: ring_distribs conc_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB []) s qs\n  \\<le> 16 / 10 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  inv_COMB (Partial_Cost_Model.config'_rand (COMB []) s qs) (last qs) [x, y]\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 16 / 10\n 3. \\<lbrakk>x \\<noteq> y; set \\<sigma> \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> set \\<sigma> \\<subseteq> {x, y}", "qed (simp_all)"], ["", "subsection \"COMB pairwise\""], ["", "lemma config_rand_COMB: \"config_rand (COMB h) init qs = do {\n                    (b::bool) \\<leftarrow> (bernoulli_pmf 0.8); \n                    (b1,b2) \\<leftarrow>  (config_rand BIT init qs);\n                    (t1,t2) \\<leftarrow>  (config_rand (embed (rTS h)) init qs);\n                    return_pmf (if b then  (b1, Inl b2) else (t1, Inr t2))\n                    }\" (is \"?LHS = ?RHS\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs \\<bind>\n        (\\<lambda>(b1, b2).\n            Partial_Cost_Model.config'_rand\n             (Partial_Cost_Model.embed (rTS h))\n             (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             qs \\<bind>\n            (\\<lambda>(t1, t2).\n                return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "proof (induct qs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) [] =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         [] \\<bind>\n        (\\<lambda>a.\n            case a of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS h))\n               (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               [] \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (t1, t2) \\<Rightarrow>\n                    return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        xs =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            xs \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  xs \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2)\n                         else (t1, Inr t2))))) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (xs @ [x]) =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (xs @ [x]) \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (xs @ [x]) \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2) else (t1, Inr t2)))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) [] =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         [] \\<bind>\n        (\\<lambda>a.\n            case a of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS h))\n               (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               [] \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (t1, t2) \\<Rightarrow>\n                    return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))\n 2. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        xs =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            xs \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  xs \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2)\n                         else (t1, Inr t2))))) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (xs @ [x]) =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (xs @ [x]) \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (xs @ [x]) \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2) else (t1, Inr t2)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) [] =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         [] \\<bind>\n        (\\<lambda>a.\n            case a of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS h))\n               (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               [] \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (t1, t2) \\<Rightarrow>\n                    return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(simp add: BIT_init_def COMB_def rTS_def map_pmf_def bind_return_pmf bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>x.\n        bv (length init) \\<bind>\n        (\\<lambda>xa.\n            return_pmf (init, if x then Inl (xa, init) else Inr h))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        bv (length init) \\<bind>\n        (\\<lambda>x.\n            return_pmf\n             (if b then (init, Inl (x, init)) else (init, Inr h))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (init, if x then Inl (xa, init) else Inr h)) =\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (if x then (init, Inl (xa, init)) else (init, Inr h)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (init, if x then Inl (xa, init) else Inr h)) =\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (if x then (init, Inl (xa, init)) else (init, Inr h)))", "apply(simp only: set_pmf_bernoulli)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (init, if x then Inl (xa, init) else Inr h)) =\n       bv (length init) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (if x then (init, Inl (xa, init)) else (init, Inr h)))", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x\\<rbrakk>\n       \\<Longrightarrow> bv (length init) \\<bind>\n                         (\\<lambda>xa.\n                             return_pmf\n                              (init, if x then Inl (xa, init) else Inr h)) =\n                         bv (length init) \\<bind>\n                         (\\<lambda>xa.\n                             return_pmf\n                              (if x then (init, Inl (xa, init))\n                               else (init, Inr h)))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> bv (length init) \\<bind>\n                         (\\<lambda>xa.\n                             return_pmf\n                              (init, if x then Inl (xa, init) else Inr h)) =\n                         bv (length init) \\<bind>\n                         (\\<lambda>xa.\n                             return_pmf\n                              (if x then (init, Inl (xa, init))\n                               else (init, Inr h)))", "by(simp_all)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h)\n   (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) [] =\n  bernoulli_pmf (8 / 10) \\<bind>\n  (\\<lambda>b.\n      Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       [] \\<bind>\n      (\\<lambda>a.\n          case a of\n          (b1, b2) \\<Rightarrow>\n            Partial_Cost_Model.config'_rand\n             (Partial_Cost_Model.embed (rTS h))\n             (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             [] \\<bind>\n            (\\<lambda>a.\n                case a of\n                (t1, t2) \\<Rightarrow>\n                  return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        xs =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            xs \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  xs \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2)\n                         else (t1, Inr t2))))) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (xs @ [x]) =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (xs @ [x]) \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (xs @ [x]) \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2) else (t1, Inr t2)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        xs =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            xs \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  xs \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2)\n                         else (t1, Inr t2))))) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (xs @ [x]) =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (xs @ [x]) \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (xs @ [x]) \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2) else (t1, Inr t2)))))", "case (snoc q qs)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h)\n   (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  bernoulli_pmf (8 / 10) \\<bind>\n  (\\<lambda>b.\n      Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs \\<bind>\n      (\\<lambda>a.\n          case a of\n          (b1, b2) \\<Rightarrow>\n            Partial_Cost_Model.config'_rand\n             (Partial_Cost_Model.embed (rTS h))\n             (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             qs \\<bind>\n            (\\<lambda>a.\n                case a of\n                (t1, t2) \\<Rightarrow>\n                  return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        xs =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            xs \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  xs \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2)\n                         else (t1, Inr t2))))) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand (COMB h)\n        (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (xs @ [x]) =\n       bernoulli_pmf (8 / 10) \\<bind>\n       (\\<lambda>b.\n           Partial_Cost_Model.config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (xs @ [x]) \\<bind>\n           (\\<lambda>a.\n               case a of\n               (b1, b2) \\<Rightarrow>\n                 Partial_Cost_Model.config'_rand\n                  (Partial_Cost_Model.embed (rTS h))\n                  (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (xs @ [x]) \\<bind>\n                 (\\<lambda>a.\n                     case a of\n                     (t1, t2) \\<Rightarrow>\n                       return_pmf\n                        (if b then (b1, Inl b2) else (t1, Inr t2)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q]) =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (qs @ [q]) \\<bind>\n        (\\<lambda>a.\n            case a of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS h))\n               (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               (qs @ [q]) \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (t1, t2) \\<Rightarrow>\n                    return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(simp add: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (qs @ [q]) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (qs @ [q]) \\<bind>\n        (\\<lambda>a.\n            case a of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (\\<lambda>s. return_pmf (fst (rTS h) s),\n                \\<lambda>s r. return_pmf (snd (rTS h) s r))\n               (return_pmf (fst (rTS h) init) \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               (qs @ [q]) \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (t1, t2) \\<Rightarrow>\n                    return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(subst config'_rand_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (Partial_Cost_Model.config'_rand (COMB h)\n       (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     [q] =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (qs @ [q]) \\<bind>\n        (\\<lambda>(b1, b2).\n            Partial_Cost_Model.config'_rand\n             (\\<lambda>s. return_pmf (fst (rTS h) s),\n              \\<lambda>s r. return_pmf (snd (rTS h) s r))\n             (return_pmf (fst (rTS h) init) \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             (qs @ [q]) \\<bind>\n            (\\<lambda>(t1, t2).\n                return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(subst snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand (COMB h)\n     (bernoulli_pmf (8 / 10) \\<bind>\n      (\\<lambda>b.\n          Partial_Cost_Model.config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           qs \\<bind>\n          (\\<lambda>(b1, b2).\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS h))\n               (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf (if b then (b1, Inl b2) else (t1, Inr t2))))))\n     [q] =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (qs @ [q]) \\<bind>\n        (\\<lambda>(b1, b2).\n            Partial_Cost_Model.config'_rand\n             (\\<lambda>s. return_pmf (fst (rTS h) s),\n              \\<lambda>s r. return_pmf (snd (rTS h) s r))\n             (return_pmf (fst (rTS h) init) \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             (qs @ [q]) \\<bind>\n            (\\<lambda>(t1, t2).\n                return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs \\<bind>\n        (\\<lambda>(b1, b2).\n            Partial_Cost_Model.config'_rand\n             (\\<lambda>s. return_pmf (fst (rTS h) s),\n              \\<lambda>s r. return_pmf (snd (rTS h) s r))\n             (return_pmf (fst (rTS h) init) \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             qs \\<bind>\n            (\\<lambda>(t1, t2).\n                return_pmf\n                 (if b then (b1, Inl b2) else (t1, Inr t2))))) \\<bind>\n    (\\<lambda>s.\n        snd (COMB h) s q \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) q a, is'))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (qs @ [q]) \\<bind>\n        (\\<lambda>(b1, b2).\n            Partial_Cost_Model.config'_rand\n             (\\<lambda>s. return_pmf (fst (rTS h) s),\n              \\<lambda>s r. return_pmf (snd (rTS h) s r))\n             (return_pmf (fst (rTS h) init) \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             (qs @ [q]) \\<bind>\n            (\\<lambda>(t1, t2).\n                return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))", "apply(simp add: bind_return_pmf bind_assoc_pmf split_def config'_rand_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>x.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs \\<bind>\n        (\\<lambda>xa.\n            Partial_Cost_Model.config'_rand\n             (\\<lambda>s. return_pmf (fst (rTS h) s),\n              \\<lambda>s r. return_pmf (snd (rTS h) s r))\n             (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n            (\\<lambda>xb.\n                snd (COMB h)\n                 (if x then (fst xa, Inl (snd xa))\n                  else (fst xb, Inr (snd xb)))\n                 q \\<bind>\n                (\\<lambda>p.\n                    return_pmf\n                     (step\n                       (fst (if x then (fst xa, Inl (snd xa))\n                             else (fst xb, Inr (snd xb))))\n                       q (fst p),\n                      snd p))))) =\n    bernoulli_pmf (4 / 5) \\<bind>\n    (\\<lambda>b.\n        Partial_Cost_Model.config'_rand BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs \\<bind>\n        (\\<lambda>x.\n            BIT_step x q \\<bind>\n            (\\<lambda>xa.\n                Partial_Cost_Model.config'_rand\n                 (\\<lambda>s. return_pmf (fst (rTS h) s),\n                  \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                 (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n                (\\<lambda>xb.\n                    return_pmf\n                     (if b\n                      then (fst (step (fst x) q (fst xa), snd xa),\n                            Inl (snd (step (fst x) q (fst xa), snd xa)))\n                      else (fst (step (fst xb) q (fst (snd (rTS h) xb q)),\n                                 snd (snd (rTS h) xb q)),\n                            Inr (snd (step (fst xb) q\n (fst (snd (rTS h) xb q)),\nsnd (snd (rTS h) xb q)))))))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (4 / 5) = bernoulli_pmf (4 / 5)\n 2. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           Partial_Cost_Model.config'_rand\n            (\\<lambda>s. return_pmf (fst (rTS h) s),\n             \\<lambda>s r. return_pmf (snd (rTS h) s r))\n            (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n           (\\<lambda>xb.\n               snd (COMB h)\n                (if x then (fst xa, Inl (snd xa))\n                 else (fst xb, Inr (snd xb)))\n                q \\<bind>\n               (\\<lambda>p.\n                   return_pmf\n                    (step\n                      (fst (if x then (fst xa, Inl (snd xa))\n                            else (fst xb, Inr (snd xb))))\n                      q (fst p),\n                     snd p)))) =\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           BIT_step xa q \\<bind>\n           (\\<lambda>xb.\n               Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n               (\\<lambda>xc.\n                   return_pmf\n                    (if x\n                     then (fst (step (fst xa) q (fst xb), snd xb),\n                           Inl (snd (step (fst xa) q (fst xb), snd xb)))\n                     else (fst (step (fst xc) q (fst (snd (rTS h) xc q)),\n                                snd (snd (rTS h) xc q)),\n                           Inr (snd (step (fst xc) q\n(fst (snd (rTS h) xc q)),\n                                     snd (snd (rTS h) xc q))))))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (bernoulli_pmf (4 / 5)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           Partial_Cost_Model.config'_rand\n            (\\<lambda>s. return_pmf (fst (rTS h) s),\n             \\<lambda>s r. return_pmf (snd (rTS h) s r))\n            (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n           (\\<lambda>xb.\n               snd (COMB h)\n                (if x then (fst xa, Inl (snd xa))\n                 else (fst xb, Inr (snd xb)))\n                q \\<bind>\n               (\\<lambda>p.\n                   return_pmf\n                    (step\n                      (fst (if x then (fst xa, Inl (snd xa))\n                            else (fst xb, Inr (snd xb))))\n                      q (fst p),\n                     snd p)))) =\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           BIT_step xa q \\<bind>\n           (\\<lambda>xb.\n               Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n               (\\<lambda>xc.\n                   return_pmf\n                    (if x\n                     then (fst (step (fst xa) q (fst xb), snd xb),\n                           Inl (snd (step (fst xa) q (fst xb), snd xb)))\n                     else (fst (step (fst xc) q (fst (snd (rTS h) xc q)),\n                                snd (snd (rTS h) xc q)),\n                           Inr (snd (step (fst xc) q\n(fst (snd (rTS h) xc q)),\n                                     snd (snd (rTS h) xc q))))))))", "apply(simp only: set_pmf_bernoulli)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           Partial_Cost_Model.config'_rand\n            (\\<lambda>s. return_pmf (fst (rTS h) s),\n             \\<lambda>s r. return_pmf (snd (rTS h) s r))\n            (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n           (\\<lambda>xb.\n               snd (COMB h)\n                (if x then (fst xa, Inl (snd xa))\n                 else (fst xb, Inr (snd xb)))\n                q \\<bind>\n               (\\<lambda>p.\n                   return_pmf\n                    (step\n                      (fst (if x then (fst xa, Inl (snd xa))\n                            else (fst xb, Inr (snd xb))))\n                      q (fst p),\n                     snd p)))) =\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           BIT_step xa q \\<bind>\n           (\\<lambda>xb.\n               Partial_Cost_Model.config'_rand\n                (\\<lambda>s. return_pmf (fst (rTS h) s),\n                 \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                (return_pmf (init, fst (rTS h) init)) qs \\<bind>\n               (\\<lambda>xc.\n                   return_pmf\n                    (if x\n                     then (fst (step (fst xa) q (fst xb), snd xb),\n                           Inl (snd (step (fst xa) q (fst xb), snd xb)))\n                     else (fst (step (fst xc) q (fst (snd (rTS h) xc q)),\n                                snd (snd (rTS h) xc q)),\n                           Inr (snd (step (fst xc) q\n(fst (snd (rTS h) xc q)),\n                                     snd (snd (rTS h) xc q))))))))", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xa.\n                             Partial_Cost_Model.config'_rand\n                              (\\<lambda>s. return_pmf (fst (rTS h) s),\n                               \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                              (return_pmf (init, fst (rTS h) init))\n                              qs \\<bind>\n                             (\\<lambda>xb.\n                                 snd (COMB h)\n                                  (if x then (fst xa, Inl (snd xa))\n                                   else (fst xb, Inr (snd xb)))\n                                  q \\<bind>\n                                 (\\<lambda>p.\n                                     return_pmf\n(step (fst (if x then (fst xa, Inl (snd xa)) else (fst xb, Inr (snd xb)))) q\n  (fst p),\n snd p)))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xa.\n                             BIT_step xa q \\<bind>\n                             (\\<lambda>xb.\n                                 Partial_Cost_Model.config'_rand\n                                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                                   \\<lambda>s r.\nreturn_pmf (snd (rTS h) s r))\n                                  (return_pmf (init, fst (rTS h) init))\n                                  qs \\<bind>\n                                 (\\<lambda>xc.\n                                     return_pmf\n(if x\n then (fst (step (fst xa) q (fst xb), snd xb),\n       Inl (snd (step (fst xa) q (fst xb), snd xb)))\n else (fst (step (fst xc) q (fst (snd (rTS h) xc q)),\n            snd (snd (rTS h) xc q)),\n       Inr (snd (step (fst xc) q (fst (snd (rTS h) xc q)),\n                 snd (snd (rTS h) xc q))))))))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xa.\n                             Partial_Cost_Model.config'_rand\n                              (\\<lambda>s. return_pmf (fst (rTS h) s),\n                               \\<lambda>s r. return_pmf (snd (rTS h) s r))\n                              (return_pmf (init, fst (rTS h) init))\n                              qs \\<bind>\n                             (\\<lambda>xb.\n                                 snd (COMB h)\n                                  (if x then (fst xa, Inl (snd xa))\n                                   else (fst xb, Inr (snd xb)))\n                                  q \\<bind>\n                                 (\\<lambda>p.\n                                     return_pmf\n(step (fst (if x then (fst xa, Inl (snd xa)) else (fst xb, Inr (snd xb)))) q\n  (fst p),\n snd p)))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xa.\n                             BIT_step xa q \\<bind>\n                             (\\<lambda>xb.\n                                 Partial_Cost_Model.config'_rand\n                                  (\\<lambda>s. return_pmf (fst (rTS h) s),\n                                   \\<lambda>s r.\nreturn_pmf (snd (rTS h) s r))\n                                  (return_pmf (init, fst (rTS h) init))\n                                  qs \\<bind>\n                                 (\\<lambda>xc.\n                                     return_pmf\n(if x\n then (fst (step (fst xa) q (fst xb), snd xb),\n       Inl (snd (step (fst xa) q (fst xb), snd xb)))\n else (fst (step (fst xc) q (fst (snd (rTS h) xc q)),\n            snd (snd (rTS h) xc q)),\n       Inr (snd (step (fst xc) q (fst (snd (rTS h) xc q)),\n                 snd (snd (rTS h) xc q))))))))", "by(simp_all add: COMB_def COMB_step_def rTS_def map_pmf_def split_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand (COMB h)\n   (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   (qs @ [q]) =\n  bernoulli_pmf (8 / 10) \\<bind>\n  (\\<lambda>b.\n      Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (qs @ [q]) \\<bind>\n      (\\<lambda>a.\n          case a of\n          (b1, b2) \\<Rightarrow>\n            Partial_Cost_Model.config'_rand\n             (Partial_Cost_Model.embed (rTS h))\n             (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n              (\\<lambda>is. return_pmf (init, is)))\n             (qs @ [q]) \\<bind>\n            (\\<lambda>a.\n                case a of\n                (t1, t2) \\<Rightarrow>\n                  return_pmf (if b then (b1, Inl b2) else (t1, Inr t2)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma COMB_no_paid: \" \\<forall>((free, paid), t)\\<in>set_pmf (snd (COMB []) (s, is) q). paid = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((free, paid), t)\\<in>set_pmf (snd (COMB []) (s, is) q).\n       paid = []", "apply(simp add:  COMB_def COMB_step_def split_def BIT_step_def TS_step_d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (case is of\n                     Inl b \\<Rightarrow>\n                       map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                        (BIT_step (fst (s, is), b) q)\n                     | Inr b \\<Rightarrow>\n                         map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                          (return_pmf (TS_step_d (fst (s, is), b) q))).\n       snd (fst x) = []", "apply(case_tac \"is\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       is = Inl a \\<Longrightarrow>\n       \\<forall>x\\<in>set_pmf\n                       (case is of\n                        Inl b \\<Rightarrow>\n                          map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                           (BIT_step (fst (s, is), b) q)\n                        | Inr b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                             (return_pmf (TS_step_d (fst (s, is), b) q))).\n          snd (fst x) = []\n 2. \\<And>b.\n       is = Inr b \\<Longrightarrow>\n       \\<forall>x\\<in>set_pmf\n                       (case is of\n                        Inl b \\<Rightarrow>\n                          map_pmf (\\<lambda>((a, b), c). ((a, b), Inl c))\n                           (BIT_step (fst (s, is), b) q)\n                        | Inr b \\<Rightarrow>\n                            map_pmf (\\<lambda>((a, b), c). ((a, b), Inr c))\n                             (return_pmf (TS_step_d (fst (s, is), b) q))).\n          snd (fst x) = []", "by(simp_all add: BIT_step_def TS_step_d_def)"], ["", "lemma COMB_pairwise: \"pairwise (COMB [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise (COMB [])", "proof(rule pairwise_property_lemma, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> Pbefore_in x y (COMB []) qs init =\n                         Pbefore_in x y (COMB []) (Lxy qs {x, y})\n                          (Lxy init {x, y})\n 2. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "case (1 init qs x y)"], ["proof (state)\nthis:\n  distinct init\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> Pbefore_in x y (COMB []) qs init =\n                         Pbefore_in x y (COMB []) (Lxy qs {x, y})\n                          (Lxy init {x, y})\n 2. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "then"], ["proof (chain)\npicking this:\n  distinct init\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y", "have qsininit: \"set qs \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  distinct init\n  qs \\<in> {xs. set xs \\<subseteq> set init}\n  (x, y)\n  \\<in> {(x, y).\n         x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. set qs \\<subseteq> set init", "by simp"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. \\<And>init qs x y.\n       \\<lbrakk>distinct init; qs \\<in> {xs. set xs \\<subseteq> set init};\n        (x, y)\n        \\<in> {(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> Pbefore_in x y (COMB []) qs init =\n                         Pbefore_in x y (COMB []) (Lxy qs {x, y})\n                          (Lxy init {x, y})\n 2. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "show \"Pbefore_in x y (COMB []) qs init \n        = Pbefore_in x y (COMB []) (Lxy qs {x, y}) (Lxy init {x, y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y (COMB []) qs init =\n    Pbefore_in x y (COMB []) (Lxy qs {x, y}) (Lxy init {x, y})", "unfolding Pbefore_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (COMB [])\n       (fst (COMB []) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       qs) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (COMB [])\n       (fst (COMB []) (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "apply(subst config_rand_COMB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (bernoulli_pmf (8 / 10) \\<bind>\n      (\\<lambda>b.\n          Partial_Cost_Model.config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           qs \\<bind>\n          (\\<lambda>(b1, b2).\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if b then (b1, Inl b2) else (t1, Inr t2)))))) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (Partial_Cost_Model.config'_rand (COMB [])\n       (fst (COMB []) (Lxy init {x, y}) \\<bind>\n        (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n       (Lxy qs {x, y}))", "apply(subst config_rand_COMB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>p. x < y in fst p)\n     (bernoulli_pmf (8 / 10) \\<bind>\n      (\\<lambda>b.\n          Partial_Cost_Model.config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           qs \\<bind>\n          (\\<lambda>(b1, b2).\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if b then (b1, Inl b2) else (t1, Inr t2)))))) =\n    map_pmf (\\<lambda>p. x < y in fst p)\n     (bernoulli_pmf (8 / 10) \\<bind>\n      (\\<lambda>b.\n          Partial_Cost_Model.config'_rand BIT\n           (fst BIT (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}) \\<bind>\n          (\\<lambda>(b1, b2).\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS []))\n                 (Lxy init {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n               (Lxy qs {x, y}) \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf (if b then (b1, Inl b2) else (t1, Inr t2))))))", "apply(simp only: map_pmf_def  bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>xa.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs \\<bind>\n        (\\<lambda>xaa.\n            (case xaa of\n             (b1, b2) \\<Rightarrow>\n               Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS []))\n                (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                 (\\<lambda>is. return_pmf (init, is)))\n                qs \\<bind>\n               (\\<lambda>(t1, t2).\n                   return_pmf\n                    (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n            (\\<lambda>xa. return_pmf (x < y in fst xa)))) =\n    bernoulli_pmf (8 / 10) \\<bind>\n    (\\<lambda>xa.\n        Partial_Cost_Model.config'_rand BIT\n         (fst BIT (Lxy init {x, y}) \\<bind>\n          (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n         (Lxy qs {x, y}) \\<bind>\n        (\\<lambda>xaa.\n            (case xaa of\n             (b1, b2) \\<Rightarrow>\n               Partial_Cost_Model.config'_rand\n                (Partial_Cost_Model.embed (rTS []))\n                (fst (Partial_Cost_Model.embed (rTS []))\n                  (Lxy init {x, y}) \\<bind>\n                 (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                (Lxy qs {x, y}) \\<bind>\n               (\\<lambda>(t1, t2).\n                   return_pmf\n                    (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n            (\\<lambda>xa. return_pmf (x < y in fst xa))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bernoulli_pmf (8 / 10) = bernoulli_pmf (8 / 10)\n 2. \\<And>xa.\n       xa \\<in> set_pmf (bernoulli_pmf (8 / 10)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS []))\n                 (Lxy init {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n               (Lxy qs {x, y}) \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf (bernoulli_pmf (8 / 10)) \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS []))\n                 (Lxy init {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n               (Lxy qs {x, y}) \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(simp only: set_pmf_bernoulli)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n                (\\<lambda>is. return_pmf (init, is)))\n               qs \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n       Partial_Cost_Model.config'_rand BIT\n        (fst BIT (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>xaa.\n           (case xaa of\n            (b1, b2) \\<Rightarrow>\n              Partial_Cost_Model.config'_rand\n               (Partial_Cost_Model.embed (rTS []))\n               (fst (Partial_Cost_Model.embed (rTS []))\n                 (Lxy init {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n               (Lxy qs {x, y}) \\<bind>\n              (\\<lambda>(t1, t2).\n                  return_pmf\n                   (if xa then (b1, Inl b2) else (t1, Inr t2)))) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(case_tac xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> UNIV; xa\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (fst BIT init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   init \\<bind>\n                                  (\\<lambda>is. return_pmf (init, is)))\n                                 qs \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy qs {x, y}) \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   (Lxy init {x, y}) \\<bind>\n                                  (\\<lambda>is.\nreturn_pmf (Lxy init {x, y}, is)))\n                                 (Lxy qs {x, y}) \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa)))\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> UNIV; \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (fst BIT init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   init \\<bind>\n                                  (\\<lambda>is. return_pmf (init, is)))\n                                 qs \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy qs {x, y}) \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   (Lxy init {x, y}) \\<bind>\n                                  (\\<lambda>is.\nreturn_pmf (Lxy init {x, y}, is)))\n                                 (Lxy qs {x, y}) \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(simp add: split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           return_pmf (fst xa, Inl (snd xa)) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (fst xa, Inl (snd xa)) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa)))\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> UNIV; \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (fst BIT init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   init \\<bind>\n                                  (\\<lambda>is. return_pmf (init, is)))\n                                 qs \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy qs {x, y}) \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   (Lxy init {x, y}) \\<bind>\n                                  (\\<lambda>is.\nreturn_pmf (Lxy init {x, y}, is)))\n                                 (Lxy qs {x, y}) \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa)))", "using BIT_pairwise'[OF qsininit 1(3,4,1), unfolded Pbefore_in_def map_pmf_def]"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs \\<bind>\n  (\\<lambda>xa. return_pmf (x < y in fst xa)) =\n  Partial_Cost_Model.config'_rand BIT\n   (fst BIT (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y}) \\<bind>\n  (\\<lambda>xa. return_pmf (x < y in fst xa))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>xa.\n           return_pmf (fst xa, Inl (snd xa)) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n       Partial_Cost_Model.config'_rand BIT\n        (BIT_init (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>xa.\n           return_pmf (fst xa, Inl (snd xa)) \\<bind>\n           (\\<lambda>xa. return_pmf (x < y in fst xa)))\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> UNIV; \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (fst BIT init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   init \\<bind>\n                                  (\\<lambda>is. return_pmf (init, is)))\n                                 qs \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy qs {x, y}) \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   (Lxy init {x, y}) \\<bind>\n                                  (\\<lambda>is.\nreturn_pmf (Lxy init {x, y}, is)))\n                                 (Lxy qs {x, y}) \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> UNIV; \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                          (fst BIT init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   init \\<bind>\n                                  (\\<lambda>is. return_pmf (init, is)))\n                                 qs \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa))) =\n                         Partial_Cost_Model.config'_rand BIT\n                          (fst BIT (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy qs {x, y}) \\<bind>\n                         (\\<lambda>xaa.\n                             (case xaa of\n                              (b1, b2) \\<Rightarrow>\n                                Partial_Cost_Model.config'_rand\n                                 (Partial_Cost_Model.embed (rTS []))\n                                 (fst (Partial_Cost_Model.embed (rTS []))\n                                   (Lxy init {x, y}) \\<bind>\n                                  (\\<lambda>is.\nreturn_pmf (Lxy init {x, y}, is)))\n                                 (Lxy qs {x, y}) \\<bind>\n                                (\\<lambda>(t1, t2).\n                                    return_pmf\n                                     (if xa then (b1, Inl b2)\nelse (t1, Inr t2)))) \\<bind>\n                             (\\<lambda>xa. return_pmf (x < y in fst xa)))", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<not> xa \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        (return_pmf (fst (rTS []) init) \\<bind>\n         (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>p. return_pmf (fst p, Inr (snd p))) \\<bind>\n       (\\<lambda>xa. return_pmf (x < y in fst xa)) =\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        (return_pmf (fst (rTS []) (Lxy init {x, y})) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>p. return_pmf (fst p, Inr (snd p))) \\<bind>\n       (\\<lambda>xa. return_pmf (x < y in fst xa))", "using TS_pairwise'[OF 1(2,3,4,1), unfolded Pbefore_in_def map_pmf_def]"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) init \\<bind>\n    (\\<lambda>is. return_pmf (init, is)))\n   qs \\<bind>\n  (\\<lambda>xa. return_pmf (x < y in fst xa)) =\n  Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS []))\n   (fst (Partial_Cost_Model.embed (rTS [])) (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy qs {x, y}) \\<bind>\n  (\\<lambda>xa. return_pmf (x < y in fst xa))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<not> xa \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        (return_pmf (fst (rTS []) init) \\<bind>\n         (\\<lambda>is. return_pmf (init, is)))\n        qs \\<bind>\n       (\\<lambda>p. return_pmf (fst p, Inr (snd p))) \\<bind>\n       (\\<lambda>xa. return_pmf (x < y in fst xa)) =\n       Partial_Cost_Model.config'_rand\n        (\\<lambda>s. return_pmf (fst (rTS []) s),\n         \\<lambda>s r. return_pmf (snd (rTS []) s r))\n        (return_pmf (fst (rTS []) (Lxy init {x, y})) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}) \\<bind>\n       (\\<lambda>p. return_pmf (fst p, Inr (snd p))) \\<bind>\n       (\\<lambda>xa. return_pmf (x < y in fst xa))", "by(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  Pbefore_in x y (COMB []) qs init =\n  Pbefore_in x y (COMB []) (Lxy qs {x, y}) (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "case (2 xa r)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa r.\n       \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "using COMB_no_paid"], ["proof (prove)\nusing this:\n  \\<forall>((free, paid), t)\\<in>set_pmf (snd (COMB []) (?s, ?is) ?q).\n     paid = []\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []", "by (metis (mono_tags) case_prod_unfold surj_pair)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set_pmf (snd (COMB []) xa r). snd (fst z) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"COMB 1.6-competitive\""], ["", "lemma finite_config_TS: \"finite (set_pmf (config'' (embed (rTS h)) qs init n))\" (is \"finite ?D\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS h))\n         (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n          (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))", "apply(subst config_embed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (return_pmf (TSdet init h qs n)))", "by(simp)"], ["", "lemma COMB_has_finite_config_set: assumes [simp]: \"distinct init\"\n      and \"set qs \\<subseteq> set init\" \n      shows \"finite (set_pmf (config_rand (COMB h) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (COMB h)\n         (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (COMB h)\n         (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs))", "from finite_config_TS[where n=\"length qs\" and qs=qs]\n      finite_config_BIT[OF assms(1)]"], ["proof (chain)\npicking this:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h))\n       (fst (Partial_Cost_Model.embed (rTS ?h)) ?init \\<bind>\n        (\\<lambda>is. return_pmf (?init, is)))\n       (take (length qs) qs)))\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand (Partial_Cost_Model.embed (rTS ?h))\n       (fst (Partial_Cost_Model.embed (rTS ?h)) ?init \\<bind>\n        (\\<lambda>is. return_pmf (?init, is)))\n       (take (length qs) qs)))\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs))\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (COMB h)\n         (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         qs))", "apply(subst obligation1'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h init.\n                finite\n                 (set_pmf\n                   (Partial_Cost_Model.config'_rand\n                     (Partial_Cost_Model.embed (rTS h))\n                     (fst (Partial_Cost_Model.embed (rTS h)) init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     (take (length qs) qs)));\n     \\<And>qs.\n        finite\n         (set_pmf\n           (Partial_Cost_Model.config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             qs))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (set_pmf\n                         (map_pmf noc\n                           (Sum_pmf (8 / 10)\n                             (Partial_Cost_Model.config'_rand BIT\n                               (fst BIT init \\<bind>\n                                (\\<lambda>is. return_pmf (init, is)))\n                               qs)\n                             (Partial_Cost_Model.config'_rand\n                               (Partial_Cost_Model.embed (rTS h))\n                               (fst (Partial_Cost_Model.embed (rTS h))\n                                 init \\<bind>\n                                (\\<lambda>is. return_pmf (init, is)))\n                               qs))))", "by(simp add: Sum_pmf_def)"], ["proof (state)\nthis:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand (COMB h)\n       (fst (COMB h) init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem COMB_competitive: \"\\<forall>s0\\<in>{x::nat list. distinct x \\<and> x\\<noteq>[]}.\n   \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand (COMB []) s0 qs \\<le> ((8::nat)/(5::nat)) *  T\\<^sub>p_opt s0 qs + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' (COMB [])\n              (fst (COMB []) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n              qs\n             \\<le> real 8 / real 5 * real (T\\<^sub>p_opt s0 qs) + b", "proof(rule factoringlemma_withconstant, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. List_Factoring.pairwise (COMB [])\n 5. \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand' (COMB [])\n                 (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> real 8 / real 5 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b\n 6. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 7. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. List_Factoring.pairwise (COMB [])\n 5. \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand' (COMB [])\n                 (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> real 8 / real 5 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b\n 6. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 7. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             \\<forall>(x, y)\n                      \\<in>{(x, y).\n                            x \\<in> set s0 \\<and>\n                            y \\<in> set s0 \\<and> x < y}.\n                T\\<^sub>p_on_rand' (COMB [])\n                 (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n                 (Lxy qs {x, y})\n                \\<le> real 8 / real 5 *\n                      real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                      b", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand' (COMB [])\n                                   (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> real 8 / real 5 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "case (1 init)"], ["proof (state)\nthis:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand' (COMB [])\n                                   (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> real 8 / real 5 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "note out=this"], ["proof (state)\nthis:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       \\<lbrakk>distinct s0; s0 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<ge>0.\n                            \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                               \\<forall>(x, y)\n  \\<in>{(x, y). x \\<in> set s0 \\<and> y \\<in> set s0 \\<and> x < y}.\n                                  T\\<^sub>p_on_rand' (COMB [])\n                                   (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                                    (\\<lambda>is.\n  return_pmf (Lxy s0 {x, y}, is)))\n                                   (Lxy qs {x, y})\n                                  \\<le> real 8 / real 5 *\n  real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n  b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n          \\<forall>(x, y)\n                   \\<in>{(x, y).\n                         x \\<in> set init \\<and>\n                         y \\<in> set init \\<and> x < y}.\n             T\\<^sub>p_on_rand' (COMB [])\n              (fst (COMB []) (Lxy init {x, y}) \\<bind>\n               (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n              (Lxy qs {x, y})\n             \\<le> real 8 / real 5 *\n                   real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                   b", "apply(rule exI[where x=2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 \\<and>\n    (\\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n        \\<forall>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n           T\\<^sub>p_on_rand' (COMB [])\n            (fst (COMB []) (Lxy init {x, y}) \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n            (Lxy qs {x, y})\n           \\<le> real 8 / real 5 *\n                 real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                 2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qs.\n       set qs \\<subseteq> set init \\<longrightarrow>\n       (\\<forall>a b.\n           a \\<in> set init \\<and>\n           b \\<in> set init \\<and> a < b \\<longrightarrow>\n           T\\<^sub>p_on_rand' (COMB [])\n            (fst (COMB []) (Lxy init {a, b}) \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n            (Lxy qs {a, b})\n           \\<le> 8 *\n                 real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) /\n                 5 +\n                 2)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "case (1 qs a b)"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b", "have a: \"a\\<noteq>b\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have twist: \"{a,b}={b, a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} = {b, a}", "by auto"], ["proof (state)\nthis:\n  {a, b} = {b, a}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have b1: \"set (Lxy qs {a, b}) \\<subseteq> {a, b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy qs {a, b}) \\<subseteq> {a, b}", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>z. z \\<in> {a, b}) qs) \\<subseteq> {a, b}", "by auto"], ["proof (state)\nthis:\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "with this[unfolded twist]"], ["proof (chain)\npicking this:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}", "have b2: \"set (Lxy qs {b, a}) \\<subseteq> {b, a}\""], ["proof (prove)\nusing this:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n  set (Lxy qs {a, b}) \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. set (Lxy qs {b, a}) \\<subseteq> {b, a}", "by(auto)"], ["proof (state)\nthis:\n  set (Lxy qs {b, a}) \\<subseteq> {b, a}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have \"set (Lxy init {a, b}) = {a,b} \\<inter> (set init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {a, b}) = {a, b} \\<inter> set init", "apply(induct init)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (Lxy [] {a, b}) = {a, b} \\<inter> set []\n 2. \\<And>aa init.\n       set (Lxy init {a, b}) = {a, b} \\<inter> set init \\<Longrightarrow>\n       set (Lxy (aa # init) {a, b}) = {a, b} \\<inter> set (aa # init)", "unfolding Lxy_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (filter (\\<lambda>z. z \\<in> {a, b}) []) = {a, b} \\<inter> set []\n 2. \\<And>aa init.\n       set (filter (\\<lambda>z. z \\<in> {a, b}) init) =\n       {a, b} \\<inter> set init \\<Longrightarrow>\n       set (filter (\\<lambda>z. z \\<in> {a, b}) (aa # init)) =\n       {a, b} \\<inter> set (aa # init)", "by(auto)"], ["proof (state)\nthis:\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "with 1"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init", "have A: \"set (Lxy init {a, b}) = {a,b}\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n  set (Lxy init {a, b}) = {a, b} \\<inter> set init\n\ngoal (1 subgoal):\n 1. set (Lxy init {a, b}) = {a, b}", "by auto"], ["proof (state)\nthis:\n  set (Lxy init {a, b}) = {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have \"finite {a,b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a, b}", "by auto"], ["proof (state)\nthis:\n  finite {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "from out"], ["proof (chain)\npicking this:\n  distinct init\n  init \\<noteq> []", "have B: \"distinct (Lxy init {a, b})\""], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {a, b})", "unfolding Lxy_def"], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>z. z \\<in> {a, b}) init)", "by auto"], ["proof (state)\nthis:\n  distinct (Lxy init {a, b})\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have C: \"length (Lxy init {a, b}) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "using distinct_card[OF B, unfolded A]"], ["proof (prove)\nusing this:\n  card {a, b} = length (Lxy init {a, b})\n\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "using a"], ["proof (prove)\nusing this:\n  card {a, b} = length (Lxy init {a, b})\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. length (Lxy init {a, b}) = 2", "by auto"], ["proof (state)\nthis:\n  length (Lxy init {a, b}) = 2\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "have \"{xs. set xs = {a,b} \\<and> distinct xs \\<and> length xs =(2::nat)} \n                    = { [a,b], [b,a] }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n    {[a, b], [b, a]}", "apply(auto simp: a a[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "case (1 xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [a, b]\n  set xs = {a, b}\n  distinct xs\n  length xs = 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from 1(4)"], ["proof (chain)\npicking this:\n  length xs = 2", "obtain x xs' where r:\"xs=x#xs'\""], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv add_2_eq_Suc' append_Nil length_append)"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "with 1(4)"], ["proof (chain)\npicking this:\n  length xs = 2\n  xs = x # xs'", "have \"length xs' = 1\""], ["proof (prove)\nusing this:\n  length xs = 2\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. length xs' = 1", "by auto"], ["proof (state)\nthis:\n  length xs' = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "then"], ["proof (chain)\npicking this:\n  length xs' = 1", "obtain y where s: \"[y] = xs'\""], ["proof (prove)\nusing this:\n  length xs' = 1\n\ngoal (1 subgoal):\n 1. (\\<And>y. [y] = xs' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis One_nat_def length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  [y] = xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from r s"], ["proof (chain)\npicking this:\n  xs = x # xs'\n  [y] = xs'", "have t: \"[x,y] = xs\""], ["proof (prove)\nusing this:\n  xs = x # xs'\n  [y] = xs'\n\ngoal (1 subgoal):\n 1. [x, y] = xs", "by auto"], ["proof (state)\nthis:\n  [x, y] = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "moreover"], ["proof (state)\nthis:\n  [x, y] = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from t 1(1)"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]", "have \"x=b\""], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n\ngoal (1 subgoal):\n 1. x = b", "using doubleton_eq_iff 1(2)"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n  ({?a, ?b} = {?c, ?d}) =\n  (?a = ?c \\<and> ?b = ?d \\<or> ?a = ?d \\<and> ?b = ?c)\n  set xs = {a, b}\n\ngoal (1 subgoal):\n 1. x = b", "by fastforce"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "moreover"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "from t 1(1)"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]", "have \"y=a\""], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n\ngoal (1 subgoal):\n 1. y = a", "using doubleton_eq_iff 1(2)"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  xs \\<noteq> [a, b]\n  ({?a, ?b} = {?c, ?d}) =\n  (?a = ?c \\<and> ?b = ?d \\<or> ?a = ?d \\<and> ?b = ?c)\n  set xs = {a, b}\n\ngoal (1 subgoal):\n 1. y = a", "by fastforce"], ["proof (state)\nthis:\n  y = a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> [a, b]; set x = {a, b}; distinct x;\n        length x = 2\\<rbrakk>\n       \\<Longrightarrow> x = [b, a]", "ultimately"], ["proof (chain)\npicking this:\n  [x, y] = xs\n  x = b\n  y = a", "show ?case"], ["proof (prove)\nusing this:\n  [x, y] = xs\n  x = b\n  y = a\n\ngoal (1 subgoal):\n 1. xs = [b, a]", "by auto"], ["proof (state)\nthis:\n  xs = [b, a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "with A B C"], ["proof (chain)\npicking this:\n  set (Lxy init {a, b}) = {a, b}\n  distinct (Lxy init {a, b})\n  length (Lxy init {a, b}) = 2\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}", "have pos: \"(Lxy init {a, b}) = [a,b]\n                  \\<or> (Lxy init {a, b}) = [b,a]\""], ["proof (prove)\nusing this:\n  set (Lxy init {a, b}) = {a, b}\n  distinct (Lxy init {a, b})\n  length (Lxy init {a, b}) = 2\n  {xs. set xs = {a, b} \\<and> distinct xs \\<and> length xs = 2} =\n  {[a, b], [b, a]}\n\ngoal (1 subgoal):\n 1. Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]", "by auto"], ["proof (state)\nthis:\n  Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]\n\ngoal (1 subgoal):\n 1. \\<And>qs a b.\n       \\<lbrakk>set qs \\<subseteq> set init; a \\<in> set init;\n        b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                          (fst (COMB []) (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b})\n                         \\<le> 8 *\n                               real\n                                (T\\<^sub>p_opt (Lxy init {a, b})\n                                  (Lxy qs {a, b})) /\n                               5 +\n                               2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "apply(cases \"(Lxy init {a, b}) = [a,b]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Lxy init {a, b} = [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2\n 2. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Lxy init {a, b} = [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) [a, b] \\<bind> (\\<lambda>is. return_pmf ([a, b], is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt [a, b] (Lxy qs {a, b})) / 5 + 2\n 2. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "using COMB_OPT2'[OF a b1] a"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (COMB [])\n   (fst (COMB []) [a, b] \\<bind> (\\<lambda>is. return_pmf ([a, b], is)))\n   (Lxy qs {a, b})\n  \\<le> 16 / 10 * real (T\\<^sub>p_opt [a, b] (Lxy qs {a, b})) + 16 / 10\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. Lxy init {a, b} = [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) [a, b] \\<bind> (\\<lambda>is. return_pmf ([a, b], is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt [a, b] (Lxy qs {a, b})) / 5 + 2\n 2. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "using pos"], ["proof (prove)\nusing this:\n  Lxy init {a, b} = [a, b] \\<or> Lxy init {a, b} = [b, a]\n\ngoal (1 subgoal):\n 1. Lxy init {a, b} \\<noteq> [a, b] \\<Longrightarrow>\n    T\\<^sub>p_on_rand' (COMB [])\n     (fst (COMB []) (Lxy init {a, b}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n     (Lxy qs {a, b})\n    \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> a; Lxy init {a, b} = [b, a]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                       (fst (COMB []) [b, a] \\<bind>\n                        (\\<lambda>is. return_pmf ([b, a], is)))\n                       (Lxy qs {a, b})\n                      \\<le> 8 *\n                            real (T\\<^sub>p_opt [b, a] (Lxy qs {a, b})) /\n                            5 +\n                            2", "unfolding twist"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> a; Lxy init {b, a} = [b, a]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                       (fst (COMB []) [b, a] \\<bind>\n                        (\\<lambda>is. return_pmf ([b, a], is)))\n                       (Lxy qs {b, a})\n                      \\<le> 8 *\n                            real (T\\<^sub>p_opt [b, a] (Lxy qs {b, a})) /\n                            5 +\n                            2", "using COMB_OPT2'[OF a[symmetric] b2]"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' (COMB [])\n   (fst (COMB []) [b, a] \\<bind> (\\<lambda>is. return_pmf ([b, a], is)))\n   (Lxy qs {b, a})\n  \\<le> 16 / 10 * real (T\\<^sub>p_opt [b, a] (Lxy qs {b, a})) + 16 / 10\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> a; Lxy init {b, a} = [b, a]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' (COMB [])\n                       (fst (COMB []) [b, a] \\<bind>\n                        (\\<lambda>is. return_pmf ([b, a], is)))\n                       (Lxy qs {b, a})\n                      \\<le> 8 *\n                            real (T\\<^sub>p_opt [b, a] (Lxy qs {b, a})) /\n                            5 +\n                            2", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' (COMB [])\n   (fst (COMB []) (Lxy init {a, b}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n   (Lxy qs {a, b})\n  \\<le> 8 * real (T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})) / 5 + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b\\<ge>0.\n     \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n        \\<forall>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n           T\\<^sub>p_on_rand' (COMB [])\n            (fst (COMB []) (Lxy init {x, y}) \\<bind>\n             (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n            (Lxy qs {x, y})\n           \\<le> real 8 / real 5 *\n                 real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                 b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n     \\<exists>b\\<ge>0.\n        \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n           \\<forall>(x, y)\n                    \\<in>{(x, y).\n                          x \\<in> set s0 \\<and>\n                          y \\<in> set s0 \\<and> x < y}.\n              T\\<^sub>p_on_rand' (COMB [])\n               (fst (COMB []) (Lxy s0 {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n               (Lxy qs {x, y})\n              \\<le> real 8 / real 5 *\n                    real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                    b\n\ngoal (6 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. List_Factoring.pairwise (COMB [])\n 5. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. List_Factoring.pairwise (COMB [])\n 5. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. List_Factoring.pairwise (COMB [])\n 5. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 6. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise (COMB [])", "using COMB_pairwise"], ["proof (prove)\nusing this:\n  List_Factoring.pairwise (COMB [])\n\ngoal (1 subgoal):\n 1. List_Factoring.pairwise (COMB [])", "by simp"], ["proof (state)\nthis:\n  List_Factoring.pairwise (COMB [])\n\ngoal (5 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 5. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 5. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "case 7"], ["proof (state)\nthis:\n  distinct init_\n  set qs_ \\<subseteq> set init_\n  x_ < length qs_\n\ngoal (5 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []\n 5. \\<And>init qs x.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        x < length qs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set_pmf\n                            (Partial_Cost_Model.config'_rand (COMB [])\n                              (fst (COMB []) init \\<bind>\n                               (\\<lambda>is. return_pmf (init, is)))\n                              (take x qs)))", "then"], ["proof (chain)\npicking this:\n  distinct init_\n  set qs_ \\<subseteq> set init_\n  x_ < length qs_", "show ?case"], ["proof (prove)\nusing this:\n  distinct init_\n  set qs_ \\<subseteq> set init_\n  x_ < length qs_\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (Partial_Cost_Model.config'_rand (COMB [])\n         (fst (COMB []) init_ \\<bind> (\\<lambda>is. return_pmf (init_, is)))\n         (take x_ qs_)))", "apply(subst COMB_has_finite_config_set[OF 7(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct init_; set qs_ \\<subseteq> set init_;\n     x_ < length qs_\\<rbrakk>\n    \\<Longrightarrow> set (take x_ qs_) \\<subseteq> set init_\n 2. \\<lbrakk>distinct init_; set qs_ \\<subseteq> set init_;\n     x_ < length qs_\\<rbrakk>\n    \\<Longrightarrow> True", "using set_take_subset"], ["proof (prove)\nusing this:\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct init_; set qs_ \\<subseteq> set init_;\n     x_ < length qs_\\<rbrakk>\n    \\<Longrightarrow> set (take x_ qs_) \\<subseteq> set init_\n 2. \\<lbrakk>distinct init_; set qs_ \\<subseteq> set init_;\n     x_ < length qs_\\<rbrakk>\n    \\<Longrightarrow> True", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct init_; set qs_ \\<subseteq> set init_;\n     x_ < length qs_\\<rbrakk>\n    \\<Longrightarrow> True", "by simp"], ["proof (state)\nthis:\n  finite\n   (set_pmf\n     (Partial_Cost_Model.config'_rand (COMB [])\n       (fst (COMB []) init_ \\<bind> (\\<lambda>is. return_pmf (init_, is)))\n       (take x_ qs_)))\n\ngoal (4 subgoals):\n 1. 1 \\<le> real 8 / real 5\n 2. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. distinct e\n 3. \\<forall>e\\<in>{x. distinct x \\<and> x \\<noteq> []}. 0 < length e\n 4. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd (COMB []) (s, is) q).\n          paid = []", "qed (simp_all add: COMB_no_paid)"], ["", "theorem COMB_competitive_nice: \"compet_rand (COMB []) ((8::nat)/(5::nat)) {x::nat list. distinct x \\<and> x\\<noteq>[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.compet_rand (COMB []) (real 8 / real 5)\n     {x. distinct x \\<and> x \\<noteq> []}", "unfolding compet_rand_def static_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' (COMB [])\n              (fst (COMB []) s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> real 8 / real 5 * real (T\\<^sub>p_opt s rs) + b", "using COMB_competitive"], ["proof (prove)\nusing this:\n  \\<forall>s0\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n     \\<exists>b\\<ge>0.\n        \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n           T\\<^sub>p_on_rand' (COMB [])\n            (fst (COMB []) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n           \\<le> real 8 / real 5 * real (T\\<^sub>p_opt s0 qs) + b\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{x. distinct x \\<and> x \\<noteq> []}.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' (COMB [])\n              (fst (COMB []) s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> real 8 / real 5 * real (T\\<^sub>p_opt s rs) + b", "by simp"], ["", "end"]]}