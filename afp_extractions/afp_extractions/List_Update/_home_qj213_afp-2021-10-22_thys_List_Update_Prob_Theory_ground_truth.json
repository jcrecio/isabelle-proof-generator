{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Prob_Theory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma integral_map_pmf[simp]:\n  fixes f::\"real \\<Rightarrow> real\"\n  shows \"(\\<integral>x. f x \\<partial>(map_pmf g M)) = (\\<integral>x. f (g x) \\<partial>M)\"", "lemma E_const[simp]: \"E (return_pmf a) = a\"", "lemma E_null[simp]: \"E (return_pmf 0) = 0\"", "lemma E_finite_sum: \"finite (set_pmf X) \\<Longrightarrow> E X = (\\<Sum>x\\<in>(set_pmf X). pmf X x * x)\"", "lemma E_of_const: \"E(map_pmf (\\<lambda>x. y) (X::real pmf)) = y\"", "lemma E_nonneg:\n  shows \"(\\<forall>x\\<in>set_pmf X. 0\\<le> x) \\<Longrightarrow> 0 \\<le> E X\"", "lemma E_nonneg_fun: fixes f::\"'a\\<Rightarrow>real\"\n  shows \"(\\<forall>x\\<in>set_pmf X. 0\\<le>f x) \\<Longrightarrow> 0 \\<le> E (map_pmf f X)\"", "lemma E_cong:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \"finite (set_pmf X) \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) = (u x)) \\<Longrightarrow> E (map_pmf f X) = E (map_pmf u X)\"", "lemma E_mono3:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \" integrable (measure_pmf X) f \\<Longrightarrow>  integrable (measure_pmf X) u \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) \\<le> (u x)) \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)\"", "lemma E_mono2:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \"finite (set_pmf X) \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) \\<le> (u x)) \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)\"", "lemma E_linear_diff2: \"finite (set_pmf A) \\<Longrightarrow> E (map_pmf f A) - E (map_pmf g A) = E (map_pmf (\\<lambda>x. (f x) - (g x)) A)\"", "lemma E_linear_plus2: \"finite (set_pmf A) \\<Longrightarrow> E (map_pmf f A) + E (map_pmf g A) = E (map_pmf (\\<lambda>x. (f x) + (g x)) A)\"", "lemma E_linear_sum2: \"finite (set_pmf D) \\<Longrightarrow> E(map_pmf (\\<lambda>x. (\\<Sum>i<up. f i x)) D)\n      = (\\<Sum>i<(up::nat). E(map_pmf (f i) D))\"", "lemma E_linear_sum_allg: \"finite (set_pmf D) \\<Longrightarrow> E(map_pmf (\\<lambda>x. (\\<Sum>i\\<in> A. f i x)) D)\n      = (\\<Sum>i\\<in> (A::'a set). E(map_pmf (f i) D))\"", "lemma E_finite_sum_fun: \"finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\"", "lemma E_bernoulli: \"0\\<le>p \\<Longrightarrow> p\\<le>1 \\<Longrightarrow>\n        E (map_pmf f (bernoulli_pmf p)) = p*(f True) + (1-p)*(f False)\"", "lemma bv_finite: \"finite (bv n)\"", "lemma len_bv_n: \"\\<forall>xs \\<in> set_pmf (bv n). length xs = n\"", "lemma bv_set: \"set_pmf (bv n) = {x::bool list. length x = n}\"", "lemma len_not_in_bv: \"length xs  \\<noteq> n \\<Longrightarrow> xs \\<notin> set_pmf (bv n)\"", "lemma not_n_bv_0: \"length xs \\<noteq> n \\<Longrightarrow> pmf (bv n) xs = 0\"", "lemma bv_comp_bernoulli: \"n < l\n        \\<Longrightarrow> map_pmf (\\<lambda>y. y!n) (bv l) = bernoulli_pmf (5 / 10)\"", "lemma pmf_2elemlist: \"pmf (bv (Suc 0)) ([x]) = pmf (bv 0) [] * pmf (bernoulli_pmf (5 / 10)) x\"", "lemma pmf_moreelemlist: \"pmf (bv (Suc n)) (x#xs) = pmf (bv n) xs * pmf (bernoulli_pmf (5 / 10)) x\"", "lemma list_pmf: \"length xs = n \\<Longrightarrow> pmf (bv n) xs = (1 / 2)^n\"", "lemma bv_0_notlen: \"pmf (bv n) xs = 0 \\<Longrightarrow> length xs \\<noteq> n \"", "lemma \"length xs > n \\<Longrightarrow> pmf (bv n) xs = 0\"", "lemma map_hd_list_pmf: \"map_pmf hd (bv (Suc n)) = bernoulli_pmf (5 / 10)\"", "lemma map_tl_list_pmf: \"map_pmf tl (bv (Suc n)) = bv n\"", "lemma flip_length[simp]: \"length (flip i xs) = length xs\"", "lemma flip_out_of_bounds: \"y \\<ge> length X \\<Longrightarrow> flip y X = X\"", "lemma flip_other: \"y < length X \\<Longrightarrow> z < length X \\<Longrightarrow> z \\<noteq> y \\<Longrightarrow> flip z X ! y = X ! y\"", "lemma flip_itself: \"y < length X \\<Longrightarrow> flip y X ! y = (\\<not> X ! y)\"", "lemma flip_twice: \"flip i (flip i b) = b\"", "lemma flipidiflip: \"y < length X \\<Longrightarrow> e < length X  \\<Longrightarrow> flip e X ! y = (if e=y then ~ (X ! y) else X ! y)\"", "lemma bernoulli_Not: \"map_pmf Not (bernoulli_pmf (1 / 2)) = (bernoulli_pmf (1 / 2))\"", "lemma inv_flip_bv: \"map_pmf (flip i) (bv n) = (bv n)\"", "lemma experiment0_7: \"pmf twocoins True = 0.7\"", "lemma b0: \"bernoulli_pmf 0 = return_pmf False\"", "lemma b1: \"bernoulli_pmf 1 = return_pmf True\"", "lemma Sum_pmf_0: \"Sum_pmf 0 Da Db = map_pmf Inr Db\"", "lemma Sum_pmf_1: \"Sum_pmf 1 Da Db = map_pmf Inl Da\"", "lemma A: \"(case_sum (\\<lambda>e. e) (\\<lambda>a. undefined)) (Inl e) = e\"", "lemma B: \"inj (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))\"", "lemma none: \"p >0 \\<Longrightarrow> p < 1 \\<Longrightarrow> (set_pmf (bernoulli_pmf p \\<bind>\n          (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n          \\<inter> {f. (\\<exists>e. Inl e = f)}) \\<noteq> {}\"", "lemma none2: \"p >0 \\<Longrightarrow> p < 1 \\<Longrightarrow>  (set_pmf (bernoulli_pmf p \\<bind>\n          (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n          \\<inter> {f. (\\<exists>e. Inr e = f)}) \\<noteq> {}\"", "lemma C: \"set_pmf (Proj1_pmf (Sum_pmf 0.5 Da Db)) = set_pmf Da\"", "lemma proj1_pmf: assumes \"p>0\" \"p<1\" shows \"Proj1_pmf (Sum_pmf p Da Db) =  Da\"", "lemma proj2_pmf: assumes \"p>0\" \"p<1\" shows \"Proj2_pmf (Sum_pmf p Da Db) =  Db\"", "lemma invSum_split: \"p>0 \\<Longrightarrow> p<1 \\<Longrightarrow> invA Da x i \\<Longrightarrow> invB Db x i \\<Longrightarrow> invSum invA invB (Sum_pmf p Da Db) x i\"", "lemma Sum_bind_pmf: assumes a: \"bind_pmf Da fa = Da'\" and b: \"bind_pmf Db fb = Db'\"\n  shows \"bind_pmf (Sum_pmf p Da Db) (f_on2 fa fb)\n              = Sum_pmf p Da' Db'\"", "lemma Sum_map_pmf: assumes a: \"map_pmf fa Da = Da'\" and b: \"map_pmf fb Db = Db'\"\n  shows \"map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db)\n              = Sum_pmf p Da' Db'\""], "translations": [["", "lemma integral_map_pmf[simp]:\n  fixes f::\"real \\<Rightarrow> real\"\n  shows \"(\\<integral>x. f x \\<partial>(map_pmf g M)) = (\\<integral>x. f (g x) \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (map_pmf g M) f =\n    measure_pmf.expectation M (\\<lambda>x. f (g x))", "unfolding map_pmf_rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (distr (measure_pmf M) (count_space UNIV) g) f =\n    measure_pmf.expectation M (\\<lambda>x. f (g x))", "using integral_distr[of g \"(measure_pmf M)\" \"(count_space UNIV)\" f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>measure_pmf.random_variable M (count_space UNIV) g;\n   f \\<in> borel_measurable (count_space UNIV)\\<rbrakk>\n  \\<Longrightarrow> integral\\<^sup>L\n                     (distr (measure_pmf M) (count_space UNIV) g) f =\n                    measure_pmf.expectation M (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (distr (measure_pmf M) (count_space UNIV) g) f =\n    measure_pmf.expectation M (\\<lambda>x. f (g x))", "by auto"], ["", "subsection \"function \\<open>E\\<close>\""], ["", "definition E :: \"real pmf \\<Rightarrow> real\"  where\n  \"E M = (\\<integral>x. x \\<partial> measure_pmf M)\""], ["", "translations\n  \"\\<integral> x. f \\<partial>M\" <= \"CONST lebesgue_integral M (\\<lambda>x. f)\""], ["", "notation (latex output) E  (\"E[_]\" [1] 100)"], ["", "lemma E_const[simp]: \"E (return_pmf a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (return_pmf a) = a", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (return_pmf a) (\\<lambda>x. x) = a", "unfolding return_pmf.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral> x. x \\<partial>return (count_space UNIV) a = a", "by (simp add: integral_return)"], ["", "lemma E_null[simp]: \"E (return_pmf 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (return_pmf 0) = 0", "by auto"], ["", "lemma E_finite_sum: \"finite (set_pmf X) \\<Longrightarrow> E X = (\\<Sum>x\\<in>(set_pmf X). pmf X x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E X = (\\<Sum>x\\<in>set_pmf X. pmf X x * x)", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    measure_pmf.expectation X (\\<lambda>x. x) =\n    (\\<Sum>x\\<in>set_pmf X. pmf X x * x)", "by (subst integral_measure_pmf) simp_all"], ["", "lemma E_of_const: \"E(map_pmf (\\<lambda>x. y) (X::real pmf)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. y) X) = y", "by auto"], ["", "lemma E_nonneg:\n  shows \"(\\<forall>x\\<in>set_pmf X. 0\\<le> x) \\<Longrightarrow> 0 \\<le> E X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf X. 0 \\<le> x \\<Longrightarrow> 0 \\<le> E X", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf X. 0 \\<le> x \\<Longrightarrow>\n    0 \\<le> measure_pmf.expectation X (\\<lambda>x. x)", "using integral_nonneg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f integrable_on ?S;\n   \\<And>x. x \\<in> ?S \\<Longrightarrow> 0 \\<le> ?f x\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> integral ?S ?f\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf X. 0 \\<le> x \\<Longrightarrow>\n    0 \\<le> measure_pmf.expectation X (\\<lambda>x. x)", "by (simp add: AE_measure_pmf_iff integral_nonneg_AE)"], ["", "lemma E_nonneg_fun: fixes f::\"'a\\<Rightarrow>real\"\n  shows \"(\\<forall>x\\<in>set_pmf X. 0\\<le>f x) \\<Longrightarrow> 0 \\<le> E (map_pmf f X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf X. 0 \\<le> f x \\<Longrightarrow>\n    0 \\<le> E (map_pmf f X)", "using E_nonneg"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf ?X. 0 \\<le> x \\<Longrightarrow> 0 \\<le> E ?X\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf X. 0 \\<le> f x \\<Longrightarrow>\n    0 \\<le> E (map_pmf f X)", "by auto"], ["", "lemma E_cong:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \"finite (set_pmf X) \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) = (u x)) \\<Longrightarrow> E (map_pmf f X) = E (map_pmf u X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> E (map_pmf f X) = E (map_pmf u X)", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation X f =\n                      measure_pmf.expectation X u", "apply(rule integral_cong_AE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable X borel f\n 2. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable X borel u\n 3. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_pmf X. f x = u x", "apply(simp add: integrable_measure_pmf_finite)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x = u x\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_pmf X. f x = u x", "by (simp add: AE_measure_pmf_iff)"], ["", "lemma E_mono3:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \" integrable (measure_pmf X) f \\<Longrightarrow>  integrable (measure_pmf X) u \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) \\<le> (u x)) \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>integrable (measure_pmf X) f; integrable (measure_pmf X) u;\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>integrable (measure_pmf X) f; integrable (measure_pmf X) u;\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation X f\n                      \\<le> measure_pmf.expectation X u", "apply(rule integral_mono_AE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>integrable (measure_pmf X) f; integrable (measure_pmf X) u;\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf X) f\n 2. \\<lbrakk>integrable (measure_pmf X) f; integrable (measure_pmf X) u;\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf X) u\n 3. \\<lbrakk>integrable (measure_pmf X) f; integrable (measure_pmf X) u;\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_pmf X. f x \\<le> u x", "by (auto simp add: AE_measure_pmf_iff)"], ["", "lemma E_mono2:\n  fixes f::\"'a \\<Rightarrow> real\"\n  shows \"finite (set_pmf X) \\<Longrightarrow> (\\<forall>x\\<in> set_pmf X. (f x) \\<le> (u x)) \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> E (map_pmf f X) \\<le> E (map_pmf u X)", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation X f\n                      \\<le> measure_pmf.expectation X u", "apply(rule integral_mono_AE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf X) f\n 2. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf X) u\n 3. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_pmf X. f x \\<le> u x", "apply(simp add: integrable_measure_pmf_finite)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (set_pmf X);\n     \\<forall>x\\<in>set_pmf X. f x \\<le> u x\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_pmf X. f x \\<le> u x", "by (simp add: AE_measure_pmf_iff)"], ["", "lemma E_linear_diff2: \"finite (set_pmf A) \\<Longrightarrow> E (map_pmf f A) - E (map_pmf g A) = E (map_pmf (\\<lambda>x. (f x) - (g x)) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf A) \\<Longrightarrow>\n    E (map_pmf f A) - E (map_pmf g A) =\n    E (map_pmf (\\<lambda>x. f x - g x) A)", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf A) \\<Longrightarrow>\n    measure_pmf.expectation A f - measure_pmf.expectation A g =\n    measure_pmf.expectation A (\\<lambda>x. f x - g x)", "apply(rule Bochner_Integration.integral_diff[of \"measure_pmf A\" f g, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf A) \\<Longrightarrow> integrable (measure_pmf A) f\n 2. finite (set_pmf A) \\<Longrightarrow> integrable (measure_pmf A) g", "by (simp_all add: integrable_measure_pmf_finite)"], ["", "lemma E_linear_plus2: \"finite (set_pmf A) \\<Longrightarrow> E (map_pmf f A) + E (map_pmf g A) = E (map_pmf (\\<lambda>x. (f x) + (g x)) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf A) \\<Longrightarrow>\n    E (map_pmf f A) + E (map_pmf g A) =\n    E (map_pmf (\\<lambda>x. f x + g x) A)", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf A) \\<Longrightarrow>\n    measure_pmf.expectation A f + measure_pmf.expectation A g =\n    measure_pmf.expectation A (\\<lambda>x. f x + g x)", "apply(rule Bochner_Integration.integral_add[of \"measure_pmf A\" f g, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf A) \\<Longrightarrow> integrable (measure_pmf A) f\n 2. finite (set_pmf A) \\<Longrightarrow> integrable (measure_pmf A) g", "by (simp_all add: integrable_measure_pmf_finite)"], ["", "lemma E_linear_sum2: \"finite (set_pmf D) \\<Longrightarrow> E(map_pmf (\\<lambda>x. (\\<Sum>i<up. f i x)) D)\n      = (\\<Sum>i<(up::nat). E(map_pmf (f i) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf D) \\<Longrightarrow>\n    E (map_pmf (\\<lambda>x. \\<Sum>i<up. f i x) D) =\n    (\\<Sum>i<up. E (map_pmf (f i) D))", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf D) \\<Longrightarrow>\n    measure_pmf.expectation D (\\<lambda>x. \\<Sum>i<up. f i x) =\n    (\\<Sum>i<up. measure_pmf.expectation D (f i))", "apply(rule Bochner_Integration.integral_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>finite (set_pmf D); i \\<in> {..<up}\\<rbrakk>\n       \\<Longrightarrow> integrable (measure_pmf D) (f i)", "by (simp add: integrable_measure_pmf_finite)"], ["", "lemma E_linear_sum_allg: \"finite (set_pmf D) \\<Longrightarrow> E(map_pmf (\\<lambda>x. (\\<Sum>i\\<in> A. f i x)) D)\n      = (\\<Sum>i\\<in> (A::'a set). E(map_pmf (f i) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf D) \\<Longrightarrow>\n    E (map_pmf (\\<lambda>x. \\<Sum>i\\<in>A. f i x) D) =\n    (\\<Sum>i\\<in>A. E (map_pmf (f i) D))", "unfolding E_def integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf D) \\<Longrightarrow>\n    measure_pmf.expectation D (\\<lambda>x. \\<Sum>i\\<in>A. f i x) =\n    (\\<Sum>i\\<in>A. measure_pmf.expectation D (f i))", "apply(rule Bochner_Integration.integral_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>finite (set_pmf D); i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> integrable (measure_pmf D) (f i)", "by (simp add: integrable_measure_pmf_finite)"], ["", "lemma E_finite_sum_fun: \"finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "assume finite: \"finite (set_pmf X)\""], ["proof (state)\nthis:\n  finite (set_pmf X)\n\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "have \"E (map_pmf f X) = (\\<integral>x. f x \\<partial>measure_pmf X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf f X) = measure_pmf.expectation X f", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (map_pmf f X) (\\<lambda>x. x) =\n    measure_pmf.expectation X f", "by auto"], ["proof (state)\nthis:\n  E (map_pmf f X) = measure_pmf.expectation X f\n\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "also"], ["proof (state)\nthis:\n  E (map_pmf f X) = measure_pmf.expectation X f\n\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "have \"\\<dots> = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation X f = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "by (subst integral_measure_pmf) (auto simp add: finite)"], ["proof (state)\nthis:\n  measure_pmf.expectation X f = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\n\ngoal (1 subgoal):\n 1. finite (set_pmf X) \\<Longrightarrow>\n    E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "finally"], ["proof (chain)\npicking this:\n  E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\n\ngoal (1 subgoal):\n 1. E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)", "."], ["proof (state)\nthis:\n  E (map_pmf f X) = (\\<Sum>x\\<in>set_pmf X. pmf X x * f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma E_bernoulli: \"0\\<le>p \\<Longrightarrow> p\\<le>1 \\<Longrightarrow>\n        E (map_pmf f (bernoulli_pmf p)) = p*(f True) + (1-p)*(f False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> E (map_pmf f (bernoulli_pmf p)) =\n                      p * f True + (1 - p) * f False", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation (map_pmf f (bernoulli_pmf p))\n                       (\\<lambda>x. x) =\n                      p * f True + (1 - p) * f False", "by (auto)"], ["", "subsection \"function \\<open>bv\\<close>\""], ["", "fun bv:: \"nat \\<Rightarrow> bool list pmf\" where\n  \"bv 0 = return_pmf []\"\n| \"bv (Suc n) =  do {\n                    (xs::bool list) \\<leftarrow> bv n;\n                    (x::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                    return_pmf (x#xs)\n                  }\""], ["", "lemma bv_finite: \"finite (bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (bv n))", "by (induct  n) auto"], ["", "lemma len_bv_n: \"\\<forall>xs \\<in> set_pmf (bv n). length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set_pmf (bv n). length xs = n", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>xs\\<in>set_pmf (bv 0). length xs = 0\n 2. \\<And>n.\n       \\<forall>xs\\<in>set_pmf (bv n). length xs = n \\<Longrightarrow>\n       \\<forall>xs\\<in>set_pmf (bv (Suc n)). length xs = Suc n", "by auto"], ["", "lemma bv_set: \"set_pmf (bv n) = {x::bool list. length x = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (bv n) = {x. length x = n}", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "case (Suc n)"], ["proof (state)\nthis:\n  set_pmf (bv n) = {x. length x = n}\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "then"], ["proof (chain)\npicking this:\n  set_pmf (bv n) = {x. length x = n}", "have \"set_pmf (bv (Suc n)) = (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x})\""], ["proof (prove)\nusing this:\n  set_pmf (bv n) = {x. length x = n}\n\ngoal (1 subgoal):\n 1. set_pmf (bv (Suc n)) =\n    (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x})", "by(simp add: set_pmf_bernoulli UNIV_bool)"], ["proof (state)\nthis:\n  set_pmf (bv (Suc n)) =\n  (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x})\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "also"], ["proof (state)\nthis:\n  set_pmf (bv (Suc n)) =\n  (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x})\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "have \"\\<dots> = {x#xs| x xs. length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x}) =\n    {x # xs |x xs. length xs = n}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x}) =\n  {x # xs |x xs. length xs = n}\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "also"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>{x. length x = n}. {True # x, False # x}) =\n  {x # xs |x xs. length xs = n}\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "have \"\\<dots> = {x. length x = Suc n} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x # xs |x xs. length xs = n} = {x. length x = Suc n}", "using Suc_length_conv"], ["proof (prove)\nusing this:\n  (Suc ?n = length ?xs) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n\ngoal (1 subgoal):\n 1. {x # xs |x xs. length xs = n} = {x. length x = Suc n}", "by fastforce"], ["proof (state)\nthis:\n  {x # xs |x xs. length xs = n} = {x. length x = Suc n}\n\ngoal (2 subgoals):\n 1. set_pmf (bv 0) = {x. length x = 0}\n 2. \\<And>n.\n       set_pmf (bv n) = {x. length x = n} \\<Longrightarrow>\n       set_pmf (bv (Suc n)) = {x. length x = Suc n}", "finally"], ["proof (chain)\npicking this:\n  set_pmf (bv (Suc n)) = {x. length x = Suc n}", "show ?case"], ["proof (prove)\nusing this:\n  set_pmf (bv (Suc n)) = {x. length x = Suc n}\n\ngoal (1 subgoal):\n 1. set_pmf (bv (Suc n)) = {x. length x = Suc n}", "."], ["proof (state)\nthis:\n  set_pmf (bv (Suc n)) = {x. length x = Suc n}\n\ngoal (1 subgoal):\n 1. set_pmf (bv 0) = {x. length x = 0}", "qed (simp)"], ["", "lemma len_not_in_bv: \"length xs  \\<noteq> n \\<Longrightarrow> xs \\<notin> set_pmf (bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<noteq> n \\<Longrightarrow> xs \\<notin> set_pmf (bv n)", "by(auto simp: len_bv_n)"], ["", "lemma not_n_bv_0: \"length xs \\<noteq> n \\<Longrightarrow> pmf (bv n) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<noteq> n \\<Longrightarrow> pmf (bv n) xs = 0", "by (simp add: len_not_in_bv pmf_eq_0_set_pmf)"], ["", "lemma bv_comp_bernoulli: \"n < l\n        \\<Longrightarrow> map_pmf (\\<lambda>y. y!n) (bv l) = bernoulli_pmf (5 / 10)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < l \\<Longrightarrow>\n    map_pmf (\\<lambda>y. y ! n) (bv l) = bernoulli_pmf (5 / 10)", "proof (induct n arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < l \\<Longrightarrow>\n       map_pmf (\\<lambda>y. y ! 0) (bv l) = bernoulli_pmf (5 / 10)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "case 0"], ["proof (state)\nthis:\n  0 < l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < l \\<Longrightarrow>\n       map_pmf (\\<lambda>y. y ! 0) (bv l) = bernoulli_pmf (5 / 10)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "then"], ["proof (chain)\npicking this:\n  0 < l", "obtain m where \"l = Suc m\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<And>m. l = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis Suc_pred)"], ["proof (state)\nthis:\n  l = Suc m\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < l \\<Longrightarrow>\n       map_pmf (\\<lambda>y. y ! 0) (bv l) = bernoulli_pmf (5 / 10)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "then"], ["proof (chain)\npicking this:\n  l = Suc m", "show \"map_pmf (\\<lambda>y. y!0) (bv l) =  bernoulli_pmf (5 / 10)\""], ["proof (prove)\nusing this:\n  l = Suc m\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>y. y ! 0) (bv l) = bernoulli_pmf (5 / 10)", "by (auto simp: map_pmf_def bind_return_pmf bind_assoc_pmf bind_return_pmf')"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>y. y ! 0) (bv l) = bernoulli_pmf (5 / 10)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "case (Suc n)"], ["proof (state)\nthis:\n  n < ?l \\<Longrightarrow>\n  map_pmf (\\<lambda>y. y ! n) (bv ?l) = bernoulli_pmf (5 / 10)\n  Suc n < l\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "then"], ["proof (chain)\npicking this:\n  n < ?l \\<Longrightarrow>\n  map_pmf (\\<lambda>y. y ! n) (bv ?l) = bernoulli_pmf (5 / 10)\n  Suc n < l", "have \"0 < l\""], ["proof (prove)\nusing this:\n  n < ?l \\<Longrightarrow>\n  map_pmf (\\<lambda>y. y ! n) (bv ?l) = bernoulli_pmf (5 / 10)\n  Suc n < l\n\ngoal (1 subgoal):\n 1. 0 < l", "by auto"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "then"], ["proof (chain)\npicking this:\n  0 < l", "obtain m where lsm: \"l = Suc m\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<And>m. l = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis Suc_pred)"], ["proof (state)\nthis:\n  l = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "with Suc(2)"], ["proof (chain)\npicking this:\n  Suc n < l\n  l = Suc m", "have nltm: \"n < m\""], ["proof (prove)\nusing this:\n  Suc n < l\n  l = Suc m\n\ngoal (1 subgoal):\n 1. n < m", "by auto"], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "from lsm"], ["proof (chain)\npicking this:\n  l = Suc m", "have \"map_pmf (\\<lambda>y. y ! Suc n) (bv l)\n       =  map_pmf (\\<lambda>x. x!n) (bind_pmf (bv m) (\\<lambda>t. (return_pmf t)))\""], ["proof (prove)\nusing this:\n  l = Suc m\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n    map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf)", "by (auto simp: map_bind_pmf)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n  map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n  map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "have \"\\<dots> =  map_pmf (\\<lambda>x. x!n) (bv m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf) =\n    map_pmf (\\<lambda>x. x ! n) (bv m)", "by (auto simp: bind_return_pmf')"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf) =\n  map_pmf (\\<lambda>x. x ! n) (bv m)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>x. x ! n) (bv m \\<bind> return_pmf) =\n  map_pmf (\\<lambda>x. x ! n) (bv m)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "have \"\\<dots> = bernoulli_pmf (5 / 10)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. x ! n) (bv m) = bernoulli_pmf (5 / 10)", "by (auto simp add: Suc(1)[of m, OF nltm])"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>x. x ! n) (bv m) = bernoulli_pmf (5 / 10)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   n < l \\<Longrightarrow>\n                   map_pmf (\\<lambda>y. y ! n) (bv l) =\n                   bernoulli_pmf (5 / 10);\n        Suc n < l\\<rbrakk>\n       \\<Longrightarrow> map_pmf (\\<lambda>y. y ! Suc n) (bv l) =\n                         bernoulli_pmf (5 / 10)", "finally"], ["proof (chain)\npicking this:\n  map_pmf (\\<lambda>y. y ! Suc n) (bv l) = bernoulli_pmf (5 / 10)", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>y. y ! Suc n) (bv l) = bernoulli_pmf (5 / 10)\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>y. y ! Suc n) (bv l) = bernoulli_pmf (5 / 10)", "."], ["proof (state)\nthis:\n  map_pmf (\\<lambda>y. y ! Suc n) (bv l) = bernoulli_pmf (5 / 10)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmf_2elemlist: \"pmf (bv (Suc 0)) ([x]) = pmf (bv 0) [] * pmf (bernoulli_pmf (5 / 10)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bv (Suc 0)) [x] = pmf (bv 0) [] * pmf (bernoulli_pmf (5 / 10)) x", "unfolding bv.simps(2)[where n=0] pmf_bind pmf_return"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bv 0)\n     (\\<lambda>xa.\n         measure_pmf.expectation (bernoulli_pmf (5 / 10))\n          (\\<lambda>xb. indicat_real {[x]} (xb # xa))) =\n    pmf (bv 0) [] * pmf (bernoulli_pmf (5 / 10)) x", "apply (subst integral_measure_pmf[where A=\"{[]}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {[]}\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv 0);\n        measure_pmf.expectation (bernoulli_pmf (5 / 10))\n         (\\<lambda>xa. indicat_real {[x]} (xa # a)) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> {[]}\n 3. (\\<Sum>a\\<in>{[]}.\n       pmf (bv 0) a *\\<^sub>R\n       measure_pmf.expectation (bernoulli_pmf (5 / 10))\n        (\\<lambda>xa. indicat_real {[x]} (xa # a))) =\n    pmf (bv 0) [] * pmf (bernoulli_pmf (5 / 10)) x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. indicat_real {[x]} [True] + indicat_real {[x]} [False] = 1", "by (cases x) auto"], ["", "lemma pmf_moreelemlist: \"pmf (bv (Suc n)) (x#xs) = pmf (bv n) xs * pmf (bernoulli_pmf (5 / 10)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) (x # xs) =\n    pmf (bv n) xs * pmf (bernoulli_pmf (5 / 10)) x", "unfolding bv.simps(2) pmf_bind pmf_return"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bv n)\n     (\\<lambda>xa.\n         measure_pmf.expectation (bernoulli_pmf (5 / 10))\n          (\\<lambda>xb. indicat_real {x # xs} (xb # xa))) =\n    pmf (bv n) xs * pmf (bernoulli_pmf (5 / 10)) x", "apply (subst integral_measure_pmf[where A=\"{xs}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {xs}\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        measure_pmf.expectation (bernoulli_pmf (5 / 10))\n         (\\<lambda>xa. indicat_real {x # xs} (xa # a)) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> {xs}\n 3. (\\<Sum>a\\<in>{xs}.\n       pmf (bv n) a *\\<^sub>R\n       measure_pmf.expectation (bernoulli_pmf (5 / 10))\n        (\\<lambda>xa. indicat_real {x # xs} (xa # a))) =\n    pmf (bv n) xs * pmf (bernoulli_pmf (5 / 10)) x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {x # xs} (True # a) / 2 +\n        indicat_real {x # xs} (False # a) / 2 \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 2. indicat_real {x # xs} (True # xs) +\n    indicat_real {x # xs} (False # xs) \\<noteq>\n    1 \\<Longrightarrow>\n    pmf (bv n) xs = 0", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {x # xs} (True # a) / 2 +\n        indicat_real {x # xs} (False # a) / 2 \\<noteq>\n        0;\n        x\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {x # xs} (True # a) / 2 +\n        indicat_real {x # xs} (False # a) / 2 \\<noteq>\n        0;\n        \\<not> x\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 3. indicat_real {x # xs} (True # xs) +\n    indicat_real {x # xs} (False # xs) \\<noteq>\n    1 \\<Longrightarrow>\n    pmf (bv n) xs = 0", "apply(auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {True # xs} (True # a) \\<noteq> 0; x\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {False # xs} (False # a) \\<noteq> 0; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 3. indicat_real {x # xs} (True # xs) +\n    indicat_real {x # xs} (False # xs) \\<noteq>\n    1 \\<Longrightarrow>\n    pmf (bv n) xs = 0", "apply (meson indicator_simps(2) list.inject singletonD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bv n);\n        indicat_real {False # xs} (False # a) \\<noteq> 0; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> a = xs\n 2. indicat_real {x # xs} (True # xs) +\n    indicat_real {x # xs} (False # xs) \\<noteq>\n    1 \\<Longrightarrow>\n    pmf (bv n) xs = 0", "apply (meson indicator_simps(2) list.inject singletonD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. indicat_real {x # xs} (True # xs) +\n    indicat_real {x # xs} (False # xs) \\<noteq>\n    1 \\<Longrightarrow>\n    pmf (bv n) xs = 0", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>indicat_real {x # xs} (True # xs) +\n             indicat_real {x # xs} (False # xs) \\<noteq>\n             1;\n     x\\<rbrakk>\n    \\<Longrightarrow> pmf (bv n) xs = 0\n 2. \\<lbrakk>indicat_real {x # xs} (True # xs) +\n             indicat_real {x # xs} (False # xs) \\<noteq>\n             1;\n     \\<not> x\\<rbrakk>\n    \\<Longrightarrow> pmf (bv n) xs = 0", "by(auto)"], ["", "lemma list_pmf: \"length xs = n \\<Longrightarrow> pmf (bv n) xs = (1 / 2)^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow> pmf (bv n) xs = (1 / 2) ^ n", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. length xs = 0 \\<Longrightarrow> pmf (bv 0) xs = (1 / 2) ^ 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "case 0"], ["proof (state)\nthis:\n  length xs = 0\n\ngoal (2 subgoals):\n 1. \\<And>xs. length xs = 0 \\<Longrightarrow> pmf (bv 0) xs = (1 / 2) ^ 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "then"], ["proof (chain)\npicking this:\n  length xs = 0", "have \"xs = []\""], ["proof (prove)\nusing this:\n  length xs = 0\n\ngoal (1 subgoal):\n 1. xs = []", "by auto"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<And>xs. length xs = 0 \\<Longrightarrow> pmf (bv 0) xs = (1 / 2) ^ 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "then"], ["proof (chain)\npicking this:\n  xs = []", "show \"pmf (bv 0) xs = (1 / 2) ^ 0\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. pmf (bv 0) xs = (1 / 2) ^ 0", "by(auto)"], ["proof (state)\nthis:\n  pmf (bv 0) xs = (1 / 2) ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "case (Suc n xs)"], ["proof (state)\nthis:\n  length ?xs = n \\<Longrightarrow> pmf (bv n) ?xs = (1 / 2) ^ n\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "then"], ["proof (chain)\npicking this:\n  length ?xs = n \\<Longrightarrow> pmf (bv n) ?xs = (1 / 2) ^ n\n  length xs = Suc n", "obtain a as where split: \"xs = a#as\""], ["proof (prove)\nusing this:\n  length ?xs = n \\<Longrightarrow> pmf (bv n) ?xs = (1 / 2) ^ n\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>a as. xs = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv)"], ["proof (state)\nthis:\n  xs = a # as\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "have \"length as = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = n", "using Suc(2) split"], ["proof (prove)\nusing this:\n  length xs = Suc n\n  xs = a # as\n\ngoal (1 subgoal):\n 1. length as = n", "by auto"], ["proof (state)\nthis:\n  length as = n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "with Suc(1)"], ["proof (chain)\npicking this:\n  length ?xs = n \\<Longrightarrow> pmf (bv n) ?xs = (1 / 2) ^ n\n  length as = n", "have 1: \"pmf (bv n) as = (1 / 2) ^ n\""], ["proof (prove)\nusing this:\n  length ?xs = n \\<Longrightarrow> pmf (bv n) ?xs = (1 / 2) ^ n\n  length as = n\n\ngoal (1 subgoal):\n 1. pmf (bv n) as = (1 / 2) ^ n", "by auto"], ["proof (state)\nthis:\n  pmf (bv n) as = (1 / 2) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "from split pmf_moreelemlist[where n=n and x=a and xs=as]"], ["proof (chain)\npicking this:\n  xs = a # as\n  pmf (bv (Suc n)) (a # as) = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "have\n    \"pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\""], ["proof (prove)\nusing this:\n  xs = a # as\n  pmf (bv (Suc n)) (a # as) = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "then"], ["proof (chain)\npicking this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "have \"pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2\""], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2", "using 1"], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n  pmf (bv n) as = (1 / 2) ^ n\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   pmf (bv n) xs = (1 / 2) ^ n;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "then"], ["proof (chain)\npicking this:\n  pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2", "show \"pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n\""], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = (1 / 2) ^ n * 1 / 2\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = (1 / 2) ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_0_notlen: \"pmf (bv n) xs = 0 \\<Longrightarrow> length xs \\<noteq> n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bv n) xs = 0 \\<Longrightarrow> length xs \\<noteq> n", "by(auto simp: list_pmf)"], ["", "lemma \"length xs > n \\<Longrightarrow> pmf (bv n) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0", "proof (induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "case (Suc n xs)"], ["proof (state)\nthis:\n  n < length ?xs \\<Longrightarrow> pmf (bv n) ?xs = 0\n  Suc n < length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "then"], ["proof (chain)\npicking this:\n  n < length ?xs \\<Longrightarrow> pmf (bv n) ?xs = 0\n  Suc n < length xs", "obtain a as where split: \"xs = a#as\""], ["proof (prove)\nusing this:\n  n < length ?xs \\<Longrightarrow> pmf (bv n) ?xs = 0\n  Suc n < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as. xs = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv Suc_lessE)"], ["proof (state)\nthis:\n  xs = a # as\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "have \"length as > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length as", "using Suc(2) split"], ["proof (prove)\nusing this:\n  Suc n < length xs\n  xs = a # as\n\ngoal (1 subgoal):\n 1. n < length as", "by auto"], ["proof (state)\nthis:\n  n < length as\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "with Suc(1)"], ["proof (chain)\npicking this:\n  n < length ?xs \\<Longrightarrow> pmf (bv n) ?xs = 0\n  n < length as", "have 1: \"pmf (bv n) as = 0\""], ["proof (prove)\nusing this:\n  n < length ?xs \\<Longrightarrow> pmf (bv n) ?xs = 0\n  n < length as\n\ngoal (1 subgoal):\n 1. pmf (bv n) as = 0", "by auto"], ["proof (state)\nthis:\n  pmf (bv n) as = 0\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "from split pmf_moreelemlist[where n=n and x=a and xs=as]"], ["proof (chain)\npicking this:\n  xs = a # as\n  pmf (bv (Suc n)) (a # as) = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "have\n    \"pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\""], ["proof (prove)\nusing this:\n  xs = a # as\n  pmf (bv (Suc n)) (a # as) = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "then"], ["proof (chain)\npicking this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a", "have \"pmf (bv (Suc n)) xs = 0 * 1 / 2\""], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = 0 * 1 / 2", "using 1"], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = pmf (bv n) as * pmf (bernoulli_pmf (5 / 10)) a\n  pmf (bv n) as = 0\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = 0 * 1 / 2", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = 0 * 1 / 2\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. n < length xs \\<Longrightarrow> pmf (bv n) xs = 0;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> pmf (bv (Suc n)) xs = 0", "then"], ["proof (chain)\npicking this:\n  pmf (bv (Suc n)) xs = 0 * 1 / 2", "show \"pmf (bv (Suc n)) xs = 0\""], ["proof (prove)\nusing this:\n  pmf (bv (Suc n)) xs = 0 * 1 / 2\n\ngoal (1 subgoal):\n 1. pmf (bv (Suc n)) xs = 0", "by auto"], ["proof (state)\nthis:\n  pmf (bv (Suc n)) xs = 0\n\ngoal (1 subgoal):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> pmf (bv 0) xs = 0", "qed simp"], ["", "lemma map_hd_list_pmf: \"map_pmf hd (bv (Suc n)) = bernoulli_pmf (5 / 10)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf hd (bv (Suc n)) = bernoulli_pmf (5 / 10)", "by (simp add: map_pmf_def bind_assoc_pmf bind_return_pmf bind_return_pmf')"], ["", "lemma map_tl_list_pmf: \"map_pmf tl (bv (Suc n)) = bv n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf tl (bv (Suc n)) = bv n", "by (simp add: map_pmf_def bind_assoc_pmf bind_return_pmf bind_return_pmf' )"], ["", "subsection \"function \\<open>flip\\<close>\""], ["", "fun flip :: \"nat \\<Rightarrow> bool list \\<Rightarrow> bool list\" where\n  \"flip _ [] = []\"\n| \"flip 0 (x#xs) = (\\<not>x)#xs\"\n| \"flip (Suc n) (x#xs) = x#(flip n xs)\""], ["", "lemma flip_length[simp]: \"length (flip i xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (flip i xs) = length xs", "apply(induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. length (flip i []) = length []\n 2. \\<And>a xs i.\n       (\\<And>i. length (flip i xs) = length xs) \\<Longrightarrow>\n       length (flip i (a # xs)) = length (a # xs)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       (\\<And>i. length (flip i xs) = length xs) \\<Longrightarrow>\n       length (flip i (a # xs)) = length (a # xs)", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i. length (flip i xs) = length xs; i = 0\\<rbrakk>\n       \\<Longrightarrow> length (flip i (a # xs)) = length (a # xs)\n 2. \\<And>a xs i nat.\n       \\<lbrakk>\\<And>i. length (flip i xs) = length xs;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length (flip i (a # xs)) = length (a # xs)", "by(simp_all)"], ["", "lemma flip_out_of_bounds: \"y \\<ge> length X \\<Longrightarrow> flip y X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length X \\<le> y \\<Longrightarrow> flip y X = X", "apply(induct X arbitrary: y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "case (Cons X Xs)"], ["proof (state)\nthis:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "hence \"y > 0\""], ["proof (prove)\nusing this:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < y", "by auto"], ["proof (state)\nthis:\n  0 < y\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "with Cons"], ["proof (chain)\npicking this:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n  0 < y", "obtain y' where y1: \"y = Suc y'\" and y2: \"y' \\<ge> length Xs\""], ["proof (prove)\nusing this:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n  0 < y\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y = Suc y'; length Xs \\<le> y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_pred' length_Cons not_less_eq_eq)"], ["proof (state)\nthis:\n  y = Suc y'\n  length Xs \\<le> y'\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "then"], ["proof (chain)\npicking this:\n  y = Suc y'\n  length Xs \\<le> y'", "have \"flip y (X # Xs) = X#(flip y' Xs)\""], ["proof (prove)\nusing this:\n  y = Suc y'\n  length Xs \\<le> y'\n\ngoal (1 subgoal):\n 1. flip y (X # Xs) = X # flip y' Xs", "by auto"], ["proof (state)\nthis:\n  flip y (X # Xs) = X # flip y' Xs\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "moreover"], ["proof (state)\nthis:\n  flip y (X # Xs) = X # flip y' Xs\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "from Cons y2"], ["proof (chain)\npicking this:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n  length Xs \\<le> y'", "have \"flip y' Xs = Xs\""], ["proof (prove)\nusing this:\n  length Xs \\<le> ?y \\<Longrightarrow> flip ?y Xs = Xs\n  length (X # Xs) \\<le> y\n  length Xs \\<le> y'\n\ngoal (1 subgoal):\n 1. flip y' Xs = Xs", "by auto"], ["proof (state)\nthis:\n  flip y' Xs = Xs\n\ngoal (2 subgoals):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []\n 2. \\<And>a X y.\n       \\<lbrakk>\\<And>y. length X \\<le> y \\<Longrightarrow> flip y X = X;\n        length (a # X) \\<le> y\\<rbrakk>\n       \\<Longrightarrow> flip y (a # X) = a # X", "ultimately"], ["proof (chain)\npicking this:\n  flip y (X # Xs) = X # flip y' Xs\n  flip y' Xs = Xs", "show ?case"], ["proof (prove)\nusing this:\n  flip y (X # Xs) = X # flip y' Xs\n  flip y' Xs = Xs\n\ngoal (1 subgoal):\n 1. flip y (X # Xs) = X # Xs", "by auto"], ["proof (state)\nthis:\n  flip y (X # Xs) = X # Xs\n\ngoal (1 subgoal):\n 1. \\<And>y. length [] \\<le> y \\<Longrightarrow> flip y [] = []", "qed simp"], ["", "lemma flip_other: \"y < length X \\<Longrightarrow> z < length X \\<Longrightarrow> z \\<noteq> y \\<Longrightarrow> flip z X ! y = X ! y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; z < length X; z \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> flip z X ! y = X ! y", "apply(induct y arbitrary: X z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X z.\n       \\<lbrakk>0 < length X; z < length X; z \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> flip z X ! 0 = X ! 0\n 2. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X z.\n       \\<lbrakk>X \\<noteq> []; z < length X; 0 < z\\<rbrakk>\n       \\<Longrightarrow> flip z X ! 0 = X ! 0\n 2. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "apply (metis flip.elims neq0_conv nth_Cons_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "proof (case_tac z, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y; z = 0\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y\n 2. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "case (1 y X z)"], ["proof (state)\nthis:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = 0\n\ngoal (2 subgoals):\n 1. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y; z = 0\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y\n 2. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = 0", "obtain a as where \"X=a#as\""], ["proof (prove)\nusing this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a as. X = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using length_greater_0_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = 0\n  (0 < length ?xs) = (?xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. (\\<And>a as. X = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) flip.elims)"], ["proof (state)\nthis:\n  X = a # as\n\ngoal (2 subgoals):\n 1. \\<And>y X z.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y; z = 0\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y\n 2. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "with 1(5)"], ["proof (chain)\npicking this:\n  z = 0\n  X = a # as", "show ?case"], ["proof (prove)\nusing this:\n  z = 0\n  X = a # as\n\ngoal (1 subgoal):\n 1. flip z X ! Suc y = X ! Suc y", "by(simp)"], ["proof (state)\nthis:\n  flip z X ! Suc y = X ! Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "case (2 y X z z')"], ["proof (state)\nthis:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = Suc z'\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = Suc z'", "have 3: \"z' \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = Suc z'\n\ngoal (1 subgoal):\n 1. z' \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  z' \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "from 2(2)"], ["proof (chain)\npicking this:\n  Suc y < length X", "have \"length X > 0\""], ["proof (prove)\nusing this:\n  Suc y < length X\n\ngoal (1 subgoal):\n 1. 0 < length X", "by auto"], ["proof (state)\nthis:\n  0 < length X\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "then"], ["proof (chain)\npicking this:\n  0 < length X", "obtain a as where aas: \"X = a#as\""], ["proof (prove)\nusing this:\n  0 < length X\n\ngoal (1 subgoal):\n 1. (\\<And>a as. X = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) flip.elims length_greater_0_conv)"], ["proof (state)\nthis:\n  X = a # as\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "then"], ["proof (chain)\npicking this:\n  X = a # as", "have a: \"flip (Suc z') X ! Suc y = flip z' as ! y\"\n    and b : \"(X ! Suc y) = (as !  y)\""], ["proof (prove)\nusing this:\n  X = a # as\n\ngoal (1 subgoal):\n 1. flip (Suc z') X ! Suc y = flip z' as ! y &&& X ! Suc y = as ! y", "by auto"], ["proof (state)\nthis:\n  flip (Suc z') X ! Suc y = flip z' as ! y\n  X ! Suc y = as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "from 2(2) aas"], ["proof (chain)\npicking this:\n  Suc y < length X\n  X = a # as", "have 1: \"y < length as\""], ["proof (prove)\nusing this:\n  Suc y < length X\n  X = a # as\n\ngoal (1 subgoal):\n 1. y < length as", "by auto"], ["proof (state)\nthis:\n  y < length as\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "from 2(3,5) aas"], ["proof (chain)\npicking this:\n  z < length X\n  z = Suc z'\n  X = a # as", "have f2: \"z' < length as\""], ["proof (prove)\nusing this:\n  z < length X\n  z = Suc z'\n  X = a # as\n\ngoal (1 subgoal):\n 1. z' < length as", "by auto"], ["proof (state)\nthis:\n  z' < length as\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "note c=2(1)[OF 1 f2 3]"], ["proof (state)\nthis:\n  flip z' as ! y = as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "have \"flip z X ! Suc y = flip (Suc z') X ! Suc y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip z X ! Suc y = flip (Suc z') X ! Suc y", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>y < length ?X; ?z < length ?X; ?z \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! y = ?X ! y\n  Suc y < length X\n  z < length X\n  z \\<noteq> Suc y\n  z = Suc z'\n\ngoal (1 subgoal):\n 1. flip z X ! Suc y = flip (Suc z') X ! Suc y", "by auto"], ["proof (state)\nthis:\n  flip z X ! Suc y = flip (Suc z') X ! Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "also"], ["proof (state)\nthis:\n  flip z X ! Suc y = flip (Suc z') X ! Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "have \"\\<dots> = flip z' as ! y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (Suc z') X ! Suc y = flip z' as ! y", "by (rule a)"], ["proof (state)\nthis:\n  flip (Suc z') X ! Suc y = flip z' as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "also"], ["proof (state)\nthis:\n  flip (Suc z') X ! Suc y = flip z' as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "have \"\\<dots> = as ! y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip z' as ! y = as ! y", "by (rule c)"], ["proof (state)\nthis:\n  flip z' as ! y = as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "also"], ["proof (state)\nthis:\n  flip z' as ! y = as ! y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "have \"\\<dots> = (X ! Suc y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as ! y = X ! Suc y", "by (rule b[symmetric])"], ["proof (state)\nthis:\n  as ! y = X ! Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y X z nat.\n       \\<lbrakk>\\<And>X z.\n                   \\<lbrakk>y < length X; z < length X;\n                    z \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> flip z X ! y = X ! y;\n        Suc y < length X; z < length X; z \\<noteq> Suc y;\n        z = Suc nat\\<rbrakk>\n       \\<Longrightarrow> flip z X ! Suc y = X ! Suc y", "finally"], ["proof (chain)\npicking this:\n  flip z X ! Suc y = X ! Suc y", "show \"flip z X ! Suc y = (X ! Suc y)\""], ["proof (prove)\nusing this:\n  flip z X ! Suc y = X ! Suc y\n\ngoal (1 subgoal):\n 1. flip z X ! Suc y = X ! Suc y", "."], ["proof (state)\nthis:\n  flip z X ! Suc y = X ! Suc y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_itself: \"y < length X \\<Longrightarrow> flip y X ! y = (\\<not> X ! y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < length X \\<Longrightarrow> flip y X ! y = (\\<not> X ! y)", "apply(induct y arbitrary: X)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X. 0 < length X \\<Longrightarrow> flip 0 X ! 0 = (\\<not> X ! 0)\n 2. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X. X \\<noteq> [] \\<Longrightarrow> flip 0 X ! 0 = (\\<not> X ! 0)\n 2. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "apply (metis flip.elims nth_Cons_0 old.nat.distinct(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "fix X::\"bool list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "assume iH: \"(\\<And>X. y < length X \\<Longrightarrow> flip y X ! y = (\\<not> X ! y))\""], ["proof (state)\nthis:\n  y < length ?X \\<Longrightarrow> flip y ?X ! y = (\\<not> ?X ! y)\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "assume len: \"Suc y < length X\""], ["proof (state)\nthis:\n  Suc y < length X\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "from len"], ["proof (chain)\npicking this:\n  Suc y < length X", "have \"y < length X\""], ["proof (prove)\nusing this:\n  Suc y < length X\n\ngoal (1 subgoal):\n 1. y < length X", "by auto"], ["proof (state)\nthis:\n  y < length X\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "from len"], ["proof (chain)\npicking this:\n  Suc y < length X", "have \"length X > 0\""], ["proof (prove)\nusing this:\n  Suc y < length X\n\ngoal (1 subgoal):\n 1. 0 < length X", "by auto"], ["proof (state)\nthis:\n  0 < length X\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "then"], ["proof (chain)\npicking this:\n  0 < length X", "obtain z zs where zzs: \"X = z#zs\""], ["proof (prove)\nusing this:\n  0 < length X\n\ngoal (1 subgoal):\n 1. (\\<And>z zs. X = z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) flip.elims length_greater_0_conv)"], ["proof (state)\nthis:\n  X = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "then"], ["proof (chain)\npicking this:\n  X = z # zs", "have a: \"flip (Suc y) X ! Suc y = flip y zs ! y\"\n    and b : \"(\\<not> X ! Suc y) = (\\<not> zs !  y)\""], ["proof (prove)\nusing this:\n  X = z # zs\n\ngoal (1 subgoal):\n 1. flip (Suc y) X ! Suc y = flip y zs ! y &&&\n    (\\<not> X ! Suc y) = (\\<not> zs ! y)", "by auto"], ["proof (state)\nthis:\n  flip (Suc y) X ! Suc y = flip y zs ! y\n  (\\<not> X ! Suc y) = (\\<not> zs ! y)\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "from len zzs"], ["proof (chain)\npicking this:\n  Suc y < length X\n  X = z # zs", "have \"y < length zs\""], ["proof (prove)\nusing this:\n  Suc y < length X\n  X = z # zs\n\ngoal (1 subgoal):\n 1. y < length zs", "by auto"], ["proof (state)\nthis:\n  y < length zs\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "note c=iH[OF this]"], ["proof (state)\nthis:\n  flip y zs ! y = (\\<not> zs ! y)\n\ngoal (1 subgoal):\n 1. \\<And>y X.\n       \\<lbrakk>\\<And>X.\n                   y < length X \\<Longrightarrow>\n                   flip y X ! y = (\\<not> X ! y);\n        Suc y < length X\\<rbrakk>\n       \\<Longrightarrow> flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "from a b c"], ["proof (chain)\npicking this:\n  flip (Suc y) X ! Suc y = flip y zs ! y\n  (\\<not> X ! Suc y) = (\\<not> zs ! y)\n  flip y zs ! y = (\\<not> zs ! y)", "show \"flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)\""], ["proof (prove)\nusing this:\n  flip (Suc y) X ! Suc y = flip y zs ! y\n  (\\<not> X ! Suc y) = (\\<not> zs ! y)\n  flip y zs ! y = (\\<not> zs ! y)\n\ngoal (1 subgoal):\n 1. flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)", "by auto"], ["proof (state)\nthis:\n  flip (Suc y) X ! Suc y = (\\<not> X ! Suc y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_twice: \"flip i (flip i b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip i (flip i b) = b", "proof (cases \"i < length b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length b \\<Longrightarrow> flip i (flip i b) = b\n 2. \\<not> i < length b \\<Longrightarrow> flip i (flip i b) = b", "case True"], ["proof (state)\nthis:\n  i < length b\n\ngoal (2 subgoals):\n 1. i < length b \\<Longrightarrow> flip i (flip i b) = b\n 2. \\<not> i < length b \\<Longrightarrow> flip i (flip i b) = b", "then"], ["proof (chain)\npicking this:\n  i < length b", "have A: \"i < length (flip i b)\""], ["proof (prove)\nusing this:\n  i < length b\n\ngoal (1 subgoal):\n 1. i < length (flip i b)", "by simp"], ["proof (state)\nthis:\n  i < length (flip i b)\n\ngoal (2 subgoals):\n 1. i < length b \\<Longrightarrow> flip i (flip i b) = b\n 2. \\<not> i < length b \\<Longrightarrow> flip i (flip i b) = b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. flip i (flip i b) = b", "apply(simp add: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia<length b. flip i (flip i b) ! ia = b ! ia", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length b \\<Longrightarrow> flip i (flip i b) ! ia = b ! ia", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length b \\<Longrightarrow> flip i (flip i b) ! ia = b ! ia", "case (1 j)"], ["proof (state)\nthis:\n  j < length b\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length b \\<Longrightarrow> flip i (flip i b) ! ia = b ! ia", "then"], ["proof (chain)\npicking this:\n  j < length b", "show ?case"], ["proof (prove)\nusing this:\n  j < length b\n\ngoal (1 subgoal):\n 1. flip i (flip i b) ! j = b ! j", "apply(cases \"i=j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length b; i = j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j\n 2. \\<lbrakk>j < length b; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j", "using flip_itself[OF A] flip_itself[OF True]"], ["proof (prove)\nusing this:\n  flip i (flip i b) ! i = (\\<not> flip i b ! i)\n  flip i b ! i = (\\<not> b ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length b; i = j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j\n 2. \\<lbrakk>j < length b; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length b; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j", "using flip_other True 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  i < length b\n  j < length b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length b; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> flip i (flip i b) ! j = b ! j", "by auto"], ["proof (state)\nthis:\n  flip i (flip i b) ! j = b ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flip i (flip i b) = b\n\ngoal (1 subgoal):\n 1. \\<not> i < length b \\<Longrightarrow> flip i (flip i b) = b", "qed (simp add: flip_out_of_bounds)"], ["", "lemma flipidiflip: \"y < length X \\<Longrightarrow> e < length X  \\<Longrightarrow> flip e X ! y = (if e=y then ~ (X ! y) else X ! y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e < length X\\<rbrakk>\n    \\<Longrightarrow> flip e X ! y = (if e = y then \\<not> X ! y else X ! y)", "apply(cases \"e=y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; e < length X; e = y\\<rbrakk>\n    \\<Longrightarrow> flip e X ! y = (if e = y then \\<not> X ! y else X ! y)\n 2. \\<lbrakk>y < length X; e < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> flip e X ! y = (if e = y then \\<not> X ! y else X ! y)", "apply(simp add: flip_itself)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> flip e X ! y = (if e = y then \\<not> X ! y else X ! y)", "by(simp add: flip_other)"], ["", "lemma bernoulli_Not: \"map_pmf Not (bernoulli_pmf (1 / 2)) = (bernoulli_pmf (1 / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf Not (bernoulli_pmf (1 / 2)) = bernoulli_pmf (1 / 2)", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "proof (case_tac i, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "case (1 i)"], ["proof (state)\nthis:\n  i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "then"], ["proof (chain)\npicking this:\n  i", "have \"pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (Not False)\""], ["proof (prove)\nusing this:\n  i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False)", "by auto"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "have \"\\<dots> = pmf (bernoulli_pmf (1 / 2)) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False) =\n    pmf (bernoulli_pmf (1 / 2)) False", "apply (rule pmf_map_inj')"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Not", "apply(rule injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (\\<not> x) = (\\<not> y) \\<Longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False) =\n  pmf (bernoulli_pmf (1 / 2)) False\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> False) =\n  pmf (bernoulli_pmf (1 / 2)) False\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "have \"\\<dots> = pmf (bernoulli_pmf (1 / 2)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bernoulli_pmf (1 / 2)) False = pmf (bernoulli_pmf (1 / 2)) i", "by auto"], ["proof (state)\nthis:\n  pmf (bernoulli_pmf (1 / 2)) False = pmf (bernoulli_pmf (1 / 2)) i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i", "show ?case"], ["proof (prove)\nusing this:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (bernoulli_pmf (1 / 2)) i", "."], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "case (2 i)"], ["proof (state)\nthis:\n  \\<not> i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "then"], ["proof (chain)\npicking this:\n  \\<not> i", "have \"pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (Not True)\""], ["proof (prove)\nusing this:\n  \\<not> i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True)", "by auto"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "have \"\\<dots> = pmf (bernoulli_pmf (1 / 2)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True) =\n    pmf (bernoulli_pmf (1 / 2)) True", "apply (rule pmf_map_inj')"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Not", "apply(rule injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (\\<not> x) = (\\<not> y) \\<Longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True) =\n  pmf (bernoulli_pmf (1 / 2)) True\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<not> True) =\n  pmf (bernoulli_pmf (1 / 2)) True\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "have \"\\<dots> = pmf (bernoulli_pmf (1 / 2)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bernoulli_pmf (1 / 2)) True = pmf (bernoulli_pmf (1 / 2)) i", "by auto"], ["proof (state)\nthis:\n  pmf (bernoulli_pmf (1 / 2)) True = pmf (bernoulli_pmf (1 / 2)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n       pmf (bernoulli_pmf (1 / 2)) i", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i", "show ?case"], ["proof (prove)\nusing this:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n    pmf (bernoulli_pmf (1 / 2)) i", "."], ["proof (state)\nthis:\n  pmf (map_pmf Not (bernoulli_pmf (1 / 2))) i =\n  pmf (bernoulli_pmf (1 / 2)) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_flip_bv: \"map_pmf (flip i) (bv n) = (bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (flip i) (bv n) = bv n", "proof(induct n arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "case (Suc n i)"], ["proof (state)\nthis:\n  map_pmf (flip ?i) (bv n) = bv n\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "note iH=this"], ["proof (state)\nthis:\n  map_pmf (flip ?i) (bv n) = bv n\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "have \"bind_pmf (bv n) (\\<lambda>x. bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x))))\n    = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa .bind_pmf (bv n) (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "also"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "have \"\\<dots> = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa . bind_pmf (bv n) (\\<lambda>x. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "then"], ["proof (chain)\npicking this:\n  i = 0", "have \"bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))\n        = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. return_pmf ((\\<not> xa) # x)))\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x)))", "by auto"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots>  = bind_pmf (bv n) (\\<lambda>x. bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. return_pmf ((\\<not> xa) # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x))) =\n    bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xa. return_pmf ((\\<not> xa) # x)))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. return_pmf ((\\<not> xa) # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf ((\\<not> xa) # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. return_pmf ((\\<not> xa) # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots>\n        = bind_pmf (bv n) (\\<lambda>x. bind_pmf (map_pmf Not (bernoulli_pmf (1 / 2))) (\\<lambda>xa. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xa. return_pmf ((\\<not> xa) # x))) =\n    bv n \\<bind>\n    (\\<lambda>x.\n        map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n        (\\<lambda>xa. return_pmf (xa # x)))", "by(auto simp add: bind_map_pmf)"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. return_pmf ((\\<not> xa) # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n      (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. return_pmf ((\\<not> xa) # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n      (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots> = bind_pmf (bv n) (\\<lambda>x. bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv n \\<bind>\n    (\\<lambda>x.\n        map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n        (\\<lambda>xa. return_pmf (xa # x))) =\n    bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))", "by (simp only: bernoulli_Not)"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n      (\\<lambda>xa. return_pmf (xa # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      map_pmf Not (bernoulli_pmf (1 / 2)) \\<bind>\n      (\\<lambda>xa. return_pmf (xa # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots> = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "finally"], ["proof (chain)\npicking this:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "."], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x))))\n        = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. return_pmf (xa # flip i' x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x)))", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind>\n        (\\<lambda>x. map_pmf (flip (Suc i')) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x)))", "by(simp)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots> = bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (map_pmf (flip i') (bv n)) (\\<lambda>x. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (flip i') (bv n) \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "by(auto simp add: bind_map_pmf)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (flip i') (bv n) \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # flip i' x))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (flip i') (bv n) \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "have \"\\<dots> =  bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. bind_pmf (bv n) (\\<lambda>x. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (flip i') (bv n) \\<bind>\n        (\\<lambda>x. return_pmf (xa # x))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "using iH[of \"i'\"]"], ["proof (prove)\nusing this:\n  map_pmf (flip i') (bv n) = bv n\n\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        map_pmf (flip i') (bv n) \\<bind>\n        (\\<lambda>x. return_pmf (xa # x))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "by simp"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      map_pmf (flip i') (bv n) \\<bind> (\\<lambda>x. return_pmf (xa # x))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa.\n           bv n \\<bind>\n           (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n       bernoulli_pmf (1 / 2) \\<bind>\n       (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "finally"], ["proof (chain)\npicking this:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))", "."], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "also"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa.\n      bv n \\<bind> (\\<lambda>x. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "have \"\\<dots> = bind_pmf (bv n) (\\<lambda>x. bind_pmf (bernoulli_pmf (1 / 2)) (\\<lambda>xa. return_pmf (xa # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x))) =\n    bv n \\<bind>\n    (\\<lambda>x.\n        bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  bernoulli_pmf (1 / 2) \\<bind>\n  (\\<lambda>xa. bv n \\<bind> (\\<lambda>x. return_pmf (xa # x))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (2 subgoals):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0\n 2. \\<And>n i.\n       (\\<And>i. map_pmf (flip i) (bv n) = bv n) \\<Longrightarrow>\n       map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "finally"], ["proof (chain)\npicking this:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))", "show ?case"], ["proof (prove)\nusing this:\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind>\n      (\\<lambda>xa. map_pmf (flip i) (return_pmf (xa # x)))) =\n  bv n \\<bind>\n  (\\<lambda>x.\n      bernoulli_pmf (1 / 2) \\<bind> (\\<lambda>xa. return_pmf (xa # x)))\n\ngoal (1 subgoal):\n 1. map_pmf (flip i) (bv (Suc n)) = bv (Suc n)", "by(simp add: map_pmf_def bind_assoc_pmf)"], ["proof (state)\nthis:\n  map_pmf (flip i) (bv (Suc n)) = bv (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>i. map_pmf (flip i) (bv 0) = bv 0", "qed simp"], ["", "subsection \"Example for pmf\""], ["", "definition \"twocoins =\n                do {\n                    x \\<leftarrow> (bernoulli_pmf 0.4);\n                    y \\<leftarrow> (bernoulli_pmf 0.5);\n                    return_pmf (x \\<or> y)\n                  }\""], ["", "lemma experiment0_7: \"pmf twocoins True = 0.7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf twocoins True = 7 / 10", "unfolding twocoins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bernoulli_pmf (4 / 10) \\<bind>\n         (\\<lambda>x.\n             bernoulli_pmf (5 / 10) \\<bind>\n             (\\<lambda>y. return_pmf (x \\<or> y))))\n     True =\n    7 / 10", "unfolding pmf_bind pmf_return"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf (4 / 10))\n     (\\<lambda>x.\n         measure_pmf.expectation (bernoulli_pmf (5 / 10))\n          (\\<lambda>xa. indicat_real {True} (x \\<or> xa))) =\n    7 / 10", "apply (subst integral_measure_pmf[where A=\"{True, False}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {True, False}\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bernoulli_pmf (4 / 10));\n        measure_pmf.expectation (bernoulli_pmf (5 / 10))\n         (\\<lambda>x. indicat_real {True} (a \\<or> x)) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> {True, False}\n 3. (\\<Sum>a\\<in>{True, False}.\n       pmf (bernoulli_pmf (4 / 10)) a *\\<^sub>R\n       measure_pmf.expectation (bernoulli_pmf (5 / 10))\n        (\\<lambda>x. indicat_real {True} (a \\<or> x))) =\n    7 / 10", "by auto"], ["", "subsection \"Sum Distribution\""], ["", "definition \"Sum_pmf p Da Db = (bernoulli_pmf p) \\<bind> (%b. if b then map_pmf Inl Da else map_pmf Inr Db )\""], ["", "lemma b0: \"bernoulli_pmf 0 = return_pmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 0 = return_pmf False", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. pmf (bernoulli_pmf 0) i = pmf (return_pmf False) i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow>\n       pmf (bernoulli_pmf 0) i = pmf (return_pmf False) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (bernoulli_pmf 0) i = pmf (return_pmf False) i", "by(simp_all)"], ["", "lemma b1: \"bernoulli_pmf 1 = return_pmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 1 = return_pmf True", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. pmf (bernoulli_pmf 1) i = pmf (return_pmf True) i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<Longrightarrow> pmf (bernoulli_pmf 1) i = pmf (return_pmf True) i\n 2. \\<And>i.\n       \\<not> i \\<Longrightarrow>\n       pmf (bernoulli_pmf 1) i = pmf (return_pmf True) i", "by(simp_all)"], ["", "lemma Sum_pmf_0: \"Sum_pmf 0 Da Db = map_pmf Inr Db\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf 0 Da Db = map_pmf Inr Db", "unfolding Sum_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 0 \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db) =\n    map_pmf Inr Db", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (bernoulli_pmf 0 \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n        i =\n       pmf (map_pmf Inr Db) i", "by(simp add: b0 bind_return_pmf)"], ["", "lemma Sum_pmf_1: \"Sum_pmf 1 Da Db = map_pmf Inl Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf 1 Da Db = map_pmf Inl Da", "unfolding Sum_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 1 \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db) =\n    map_pmf Inl Da", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (bernoulli_pmf 1 \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n        i =\n       pmf (map_pmf Inl Da) i", "by(simp add: b1 bind_return_pmf)"], ["", "definition \"Proj1_pmf D = map_pmf (%a. case a of Inl e \\<Rightarrow> e) (cond_pmf D {f. (\\<exists>e. Inl e = f)})\""], ["", "lemma A: \"(case_sum (\\<lambda>e. e) (\\<lambda>a. undefined)) (Inl e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Inl e of Inl e \\<Rightarrow> e) = e", "by(simp)"], ["", "lemma B: \"inj (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))", "oops"], ["", "lemma none: \"p >0 \\<Longrightarrow> p < 1 \\<Longrightarrow> (set_pmf (bernoulli_pmf p \\<bind>\n          (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n          \\<inter> {f. (\\<exists>e. Inl e = f)}) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> set_pmf\n                       (bernoulli_pmf p \\<bind>\n                        (\\<lambda>b.\n                            if b then map_pmf Inl Da\n                            else map_pmf Inr Db)) \\<inter>\n                      {f. \\<exists>e. Inl e = f} \\<noteq>\n                      {}", "apply(simp add: UNIV_bool)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> (Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n                      {f. \\<exists>e. Inl e = f} \\<noteq>\n                      {}", "using set_pmf_not_empty"], ["proof (prove)\nusing this:\n  set_pmf ?M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> (Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n                      {f. \\<exists>e. Inl e = f} \\<noteq>\n                      {}", "by fast"], ["", "lemma none2: \"p >0 \\<Longrightarrow> p < 1 \\<Longrightarrow>  (set_pmf (bernoulli_pmf p \\<bind>\n          (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n          \\<inter> {f. (\\<exists>e. Inr e = f)}) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> set_pmf\n                       (bernoulli_pmf p \\<bind>\n                        (\\<lambda>b.\n                            if b then map_pmf Inl Da\n                            else map_pmf Inr Db)) \\<inter>\n                      {f. \\<exists>e. Inr e = f} \\<noteq>\n                      {}", "apply(simp add: UNIV_bool)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> (Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n                      {f. \\<exists>e. Inr e = f} \\<noteq>\n                      {}", "using set_pmf_not_empty"], ["proof (prove)\nusing this:\n  set_pmf ?M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> (Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n                      {f. \\<exists>e. Inr e = f} \\<noteq>\n                      {}", "by fast"], ["", "lemma C: \"set_pmf (Proj1_pmf (Sum_pmf 0.5 Da Db)) = set_pmf Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (Proj1_pmf (Sum_pmf (5 / 10) Da Db)) = set_pmf Da", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_pmf (Proj1_pmf (Sum_pmf (5 / 10) Da Db)) = set_pmf Da", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (Proj1_pmf (Sum_pmf (5 / 10) Da Db)) = set_pmf Da", "unfolding Sum_pmf_def Proj1_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf\n     (map_pmf (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))\n       (cond_pmf\n         (bernoulli_pmf (5 / 10) \\<bind>\n          (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n         {f. \\<exists>e. Inl e = f})) =\n    set_pmf Da", "apply(simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. case x of Inl e \\<Rightarrow> e) `\n    set_pmf\n     (cond_pmf\n       (bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inl e = f}) =\n    set_pmf Da", "using none[of \"0.5\" Da Db]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 5 / 10; 5 / 10 < 1\\<rbrakk>\n  \\<Longrightarrow> set_pmf\n                     (bernoulli_pmf (5 / 10) \\<bind>\n                      (\\<lambda>b.\n                          if b then map_pmf Inl Da\n                          else map_pmf Inr Db)) \\<inter>\n                    {f. \\<exists>e. Inl e = f} \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. case x of Inl e \\<Rightarrow> e) `\n    set_pmf\n     (cond_pmf\n       (bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inl e = f}) =\n    set_pmf Da", "apply(simp add: set_cond_pmf UNIV_bool)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n    {f. \\<exists>e. Inl e = f} \\<noteq>\n    {} \\<Longrightarrow>\n    (\\<lambda>x. case x of Inl e \\<Rightarrow> e) `\n    ((Inr ` set_pmf Db \\<union> Inl ` set_pmf Da) \\<inter>\n     {f. \\<exists>e. Inl e = f}) =\n    set_pmf Da", "by force"], ["proof (state)\nthis:\n  set_pmf (Proj1_pmf (Sum_pmf (5 / 10) Da Db)) = set_pmf Da\n\ngoal:\nNo subgoals!", "qed"], ["", "thm integral_measure_pmf"], ["", "thm pmf_cond pmf_cond[OF none]"], ["", "lemma proj1_pmf: assumes \"p>0\" \"p<1\" shows \"Proj1_pmf (Sum_pmf p Da Db) =  Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "have kl: \"\\<And>e. pmf (map_pmf Inr Db) (Inl e) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. pmf (map_pmf Inr Db) (Inl e) = 0", "apply(simp only: pmf_eq_0_set_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. Inl e \\<notin> set_pmf (map_pmf Inr Db)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. Inl e \\<notin> Inr ` set_pmf Db", "by blast"], ["proof (state)\nthis:\n  pmf (map_pmf Inr Db) (Inl ?e) = 0\n\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "have ll: \"measure_pmf.prob\n           (bernoulli_pmf p \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n           {f. \\<exists>e. Inl e = f} = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inl e = f} =\n    p", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. measure_pmf.prob\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inl e = f} =\n    p", "apply(simp add: integral_pmf[symmetric] pmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p +\n                                     pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "apply(subst Bochner_Integration.integral_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inl Da) x * p)\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 3. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "using integrable_pmf"], ["proof (prove)\nusing this:\n  integrable (count_space ?X) (pmf ?M)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inl Da) x * p)\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 3. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "using integrable_pmf"], ["proof (prove)\nusing this:\n  integrable (count_space ?X) (pmf ?M)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inl e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inl e = f} =\n                      p", "by(simp add: integral_pmf)"], ["proof (state)\nthis:\n  measure_pmf.prob\n   (bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n   {f. \\<exists>e. Inl e = f} =\n  p\n\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "have E: \"(cond_pmf\n       (bernoulli_pmf p \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inl e = f}) =\n    map_pmf Inl Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inl e = f} =\n    map_pmf Inl Da", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf\n             (bernoulli_pmf p \\<bind>\n              (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n             {f. \\<exists>e. Inl e = f})\n        i =\n       pmf (map_pmf Inl Da) i", "apply(subst pmf_cond)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       set_pmf\n        (bernoulli_pmf p \\<bind>\n         (\\<lambda>b.\n             if b then map_pmf Inl Da else map_pmf Inr Db)) \\<inter>\n       {f. \\<exists>e. Inl e = f} \\<noteq>\n       {}\n 2. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inl e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inl e = f}\n        else 0) =\n       pmf (map_pmf Inl Da) i", "using none[of p Da Db] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < p; p < 1\\<rbrakk>\n  \\<Longrightarrow> set_pmf\n                     (bernoulli_pmf p \\<bind>\n                      (\\<lambda>b.\n                          if b then map_pmf Inl Da\n                          else map_pmf Inr Db)) \\<inter>\n                    {f. \\<exists>e. Inl e = f} \\<noteq>\n                    {}\n  0 < p\n  p < 1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       set_pmf\n        (bernoulli_pmf p \\<bind>\n         (\\<lambda>b.\n             if b then map_pmf Inl Da else map_pmf Inr Db)) \\<inter>\n       {f. \\<exists>e. Inl e = f} \\<noteq>\n       {}\n 2. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inl e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inl e = f}\n        else 0) =\n       pmf (map_pmf Inl Da) i", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inl e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inl e = f}\n        else 0) =\n       pmf (map_pmf Inl Da) i", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inl e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inl e = f}\n        else 0) =\n       pmf (map_pmf Inl Da) i", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>0 < p; p < 1\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf p \\<bind>\n                              (\\<lambda>b.\n                                  if b then map_pmf Inl Da\n                                  else map_pmf Inr Db))\n                          (Inl e) /\n                         measure_pmf.prob\n                          (bernoulli_pmf p \\<bind>\n                           (\\<lambda>b.\n                               if b then map_pmf Inl Da\n                               else map_pmf Inr Db))\n                          {f. \\<exists>e. Inl e = f} =\n                         pmf (map_pmf Inl Da) (Inl e)\n 2. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inl e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inl Da) i = 0", "apply(subst pmf_bind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>0 < p; p < 1\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (bernoulli_pmf p)\n                          (\\<lambda>x.\n                              pmf (if x then map_pmf Inl Da\n                                   else map_pmf Inr Db)\n                               (Inl e)) /\n                         measure_pmf.prob\n                          (bernoulli_pmf p \\<bind>\n                           (\\<lambda>b.\n                               if b then map_pmf Inl Da\n                               else map_pmf Inr Db))\n                          {f. \\<exists>e. Inl e = f} =\n                         pmf (map_pmf Inl Da) (Inl e)\n 2. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inl e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inl Da) i = 0", "apply(simp add: kl ll )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inl e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inl Da) i = 0", "apply(simp only: pmf_eq_0_set_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inl e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set_pmf (map_pmf Inl Da)", "by auto"], ["proof (state)\nthis:\n  cond_pmf\n   (bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n   {f. \\<exists>e. Inl e = f} =\n  map_pmf Inl Da\n\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "have ID: \"case_sum (\\<lambda>e. e) (\\<lambda>a. undefined) \\<circ> Inl = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sum (\\<lambda>e. e) (\\<lambda>a. undefined) \\<circ> Inl = id", "by fastforce"], ["proof (state)\nthis:\n  case_sum (\\<lambda>e. e) (\\<lambda>a. undefined) \\<circ> Inl = id\n\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj1_pmf (Sum_pmf p Da Db) = Da", "unfolding Sum_pmf_def Proj1_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))\n     (cond_pmf\n       (bernoulli_pmf p \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inl e = f}) =\n    Da", "apply(simp only: E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (case_sum (\\<lambda>e. e) (\\<lambda>a. undefined))\n     (map_pmf Inl Da) =\n    Da", "apply(simp add: pmf.map_comp ID)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Proj1_pmf (Sum_pmf p Da Db) = Da\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"Proj2_pmf D = map_pmf (%a. case a of Inr e \\<Rightarrow> e) (cond_pmf D {f. (\\<exists>e. Inr e = f)})\""], ["", "lemma proj2_pmf: assumes \"p>0\" \"p<1\" shows \"Proj2_pmf (Sum_pmf p Da Db) =  Db\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "have kl: \"\\<And>e. pmf (map_pmf Inl Da) (Inr e) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. pmf (map_pmf Inl Da) (Inr e) = 0", "apply(simp only: pmf_eq_0_set_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. Inr e \\<notin> set_pmf (map_pmf Inl Da)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. Inr e \\<notin> Inl ` set_pmf Da", "by blast"], ["proof (state)\nthis:\n  pmf (map_pmf Inl Da) (Inr ?e) = 0\n\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "have ll: \"measure_pmf.prob\n           (bernoulli_pmf p \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n           {f. \\<exists>e. Inr e = f} = 1-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inr e = f} =\n    1 - p", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. measure_pmf.prob\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inr e = f} =\n    1 - p", "apply(simp add: integral_pmf[symmetric] pmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p +\n                                     pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "apply(subst Bochner_Integration.integral_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inl Da) x * p)\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 3. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "using integrable_pmf"], ["proof (prove)\nusing this:\n  integrable (count_space ?X) (pmf ?M)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inl Da) x * p)\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 3. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "using integrable_pmf"], ["proof (prove)\nusing this:\n  integrable (count_space ?X) (pmf ?M)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> integrable (count_space {f. \\<exists>e. Inr e = f})\n                       (\\<lambda>x. pmf (map_pmf Inr Db) x * (1 - p))\n 2. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral> x. pmf (map_pmf Inl Da) x * p\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} +\n                      \\<integral> x. pmf (map_pmf Inr Db) x * (1 - p)\n                                 \\<partial>count_space\n      {f. \\<exists>e. Inr e = f} =\n                      1 - p", "by(simp add: integral_pmf)"], ["proof (state)\nthis:\n  measure_pmf.prob\n   (bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n   {f. \\<exists>e. Inr e = f} =\n  1 - p\n\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "have E: \"(cond_pmf\n       (bernoulli_pmf p \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inr e = f}) =\n    map_pmf Inr Db\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf\n     (bernoulli_pmf p \\<bind>\n      (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n     {f. \\<exists>e. Inr e = f} =\n    map_pmf Inr Db", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf\n             (bernoulli_pmf p \\<bind>\n              (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n             {f. \\<exists>e. Inr e = f})\n        i =\n       pmf (map_pmf Inr Db) i", "apply(subst pmf_cond)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       set_pmf\n        (bernoulli_pmf p \\<bind>\n         (\\<lambda>b.\n             if b then map_pmf Inl Da else map_pmf Inr Db)) \\<inter>\n       {f. \\<exists>e. Inr e = f} \\<noteq>\n       {}\n 2. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inr e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inr e = f}\n        else 0) =\n       pmf (map_pmf Inr Db) i", "using none2[of p Da Db] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < p; p < 1\\<rbrakk>\n  \\<Longrightarrow> set_pmf\n                     (bernoulli_pmf p \\<bind>\n                      (\\<lambda>b.\n                          if b then map_pmf Inl Da\n                          else map_pmf Inr Db)) \\<inter>\n                    {f. \\<exists>e. Inr e = f} \\<noteq>\n                    {}\n  0 < p\n  p < 1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       set_pmf\n        (bernoulli_pmf p \\<bind>\n         (\\<lambda>b.\n             if b then map_pmf Inl Da else map_pmf Inr Db)) \\<inter>\n       {f. \\<exists>e. Inr e = f} \\<noteq>\n       {}\n 2. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inr e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inr e = f}\n        else 0) =\n       pmf (map_pmf Inr Db) i", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inr e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inr e = f}\n        else 0) =\n       pmf (map_pmf Inr Db) i", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if i \\<in> {f. \\<exists>e. Inr e = f}\n        then pmf (bernoulli_pmf p \\<bind>\n                  (\\<lambda>b.\n                      if b then map_pmf Inl Da else map_pmf Inr Db))\n              i /\n             measure_pmf.prob\n              (bernoulli_pmf p \\<bind>\n               (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n              {f. \\<exists>e. Inr e = f}\n        else 0) =\n       pmf (map_pmf Inr Db) i", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>0 < p; p < 1\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf p \\<bind>\n                              (\\<lambda>b.\n                                  if b then map_pmf Inl Da\n                                  else map_pmf Inr Db))\n                          (Inr e) /\n                         measure_pmf.prob\n                          (bernoulli_pmf p \\<bind>\n                           (\\<lambda>b.\n                               if b then map_pmf Inl Da\n                               else map_pmf Inr Db))\n                          {f. \\<exists>e. Inr e = f} =\n                         pmf (map_pmf Inr Db) (Inr e)\n 2. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inr e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inr Db) i = 0", "apply(subst pmf_bind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>0 < p; p < 1\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (bernoulli_pmf p)\n                          (\\<lambda>x.\n                              pmf (if x then map_pmf Inl Da\n                                   else map_pmf Inr Db)\n                               (Inr e)) /\n                         measure_pmf.prob\n                          (bernoulli_pmf p \\<bind>\n                           (\\<lambda>b.\n                               if b then map_pmf Inl Da\n                               else map_pmf Inr Db))\n                          {f. \\<exists>e. Inr e = f} =\n                         pmf (map_pmf Inr Db) (Inr e)\n 2. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inr e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inr Db) i = 0", "apply(simp add: kl ll )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inr e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pmf (map_pmf Inr Db) i = 0", "apply(simp only: pmf_eq_0_set_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < p; p < 1; \\<forall>e. Inr e \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set_pmf (map_pmf Inr Db)", "by auto"], ["proof (state)\nthis:\n  cond_pmf\n   (bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n   {f. \\<exists>e. Inr e = f} =\n  map_pmf Inr Db\n\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "have ID: \"case_sum (\\<lambda>e. undefined) (\\<lambda>a. a) \\<circ> Inr = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sum (\\<lambda>e. undefined) (\\<lambda>a. a) \\<circ> Inr = id", "by fastforce"], ["proof (state)\nthis:\n  case_sum (\\<lambda>e. undefined) (\\<lambda>a. a) \\<circ> Inr = id\n\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj2_pmf (Sum_pmf p Da Db) = Db", "unfolding Sum_pmf_def Proj2_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (case_sum (\\<lambda>a. undefined) (\\<lambda>e. e))\n     (cond_pmf\n       (bernoulli_pmf p \\<bind>\n        (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db))\n       {f. \\<exists>e. Inr e = f}) =\n    Db", "apply(simp only: E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (case_sum (\\<lambda>a. undefined) (\\<lambda>e. e))\n     (map_pmf Inr Db) =\n    Db", "apply(simp add: pmf.map_comp ID)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Proj2_pmf (Sum_pmf p Da Db) = Db\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"invSum invA invB D x i == invA (Proj1_pmf D) x i \\<and> invB (Proj2_pmf D) x i\""], ["", "lemma invSum_split: \"p>0 \\<Longrightarrow> p<1 \\<Longrightarrow> invA Da x i \\<Longrightarrow> invB Db x i \\<Longrightarrow> invSum invA invB (Sum_pmf p Da Db) x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1; invA Da x i; invB Db x i\\<rbrakk>\n    \\<Longrightarrow> invSum invA invB (Sum_pmf p Da Db) x i", "by(simp add: invSum_def proj1_pmf proj2_pmf)"], ["", "term \"(%a. case a of Inl e \\<Rightarrow> Inl (fa e) | Inr e \\<Rightarrow> Inr (fb e))\""], ["", "definition \"f_on2 fa fb = (%a. case a of Inl e \\<Rightarrow> map_pmf Inl (fa e) | Inr e \\<Rightarrow> map_pmf Inr (fb e))\""], ["", "term \"bind_pmf\""], ["", "lemma Sum_bind_pmf: assumes a: \"bind_pmf Da fa = Da'\" and b: \"bind_pmf Db fb = Db'\"\n  shows \"bind_pmf (Sum_pmf p Da Db) (f_on2 fa fb)\n              = Sum_pmf p Da' Db'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "have \"(if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n                 case_sum (\\<lambda>e. map_pmf Inl (fa e))\n                  (\\<lambda>e. map_pmf Inr (fb e))\n            =\n        (if x then map_pmf Inl Da \\<bind> case_sum (\\<lambda>e. map_pmf Inl (fa e))\n                  (\\<lambda>e. map_pmf Inr (fb e))\n              else map_pmf Inr Db \\<bind> case_sum (\\<lambda>e. map_pmf Inl (fa e))\n                  (\\<lambda>e. map_pmf Inr (fb e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n    case_sum (\\<lambda>e. map_pmf Inl (fa e))\n     (\\<lambda>e. map_pmf Inr (fb e)) =\n    (if x\n     then map_pmf Inl Da \\<bind>\n          case_sum (\\<lambda>e. map_pmf Inl (fa e))\n           (\\<lambda>e. map_pmf Inr (fb e))\n     else map_pmf Inr Db \\<bind>\n          case_sum (\\<lambda>e. map_pmf Inl (fa e))\n           (\\<lambda>e. map_pmf Inr (fb e)))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if x\n   then map_pmf Inl Da \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))\n   else map_pmf Inr Db \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e)))\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "also"], ["proof (state)\nthis:\n  (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if x\n   then map_pmf Inl Da \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))\n   else map_pmf Inr Db \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e)))\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "have \"\\<dots> = (if x then map_pmf Inl (bind_pmf Da fa) else map_pmf Inr (bind_pmf Db fb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x\n     then map_pmf Inl Da \\<bind>\n          case_sum (\\<lambda>e. map_pmf Inl (fa e))\n           (\\<lambda>e. map_pmf Inr (fb e))\n     else map_pmf Inr Db \\<bind>\n          case_sum (\\<lambda>e. map_pmf Inl (fa e))\n           (\\<lambda>e. map_pmf Inr (fb e))) =\n    (if x then map_pmf Inl (Da \\<bind> fa) else map_pmf Inr (Db \\<bind> fb))", "by(auto simp add: map_pmf_def bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  (if x\n   then map_pmf Inl Da \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))\n   else map_pmf Inr Db \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))) =\n  (if x then map_pmf Inl (Da \\<bind> fa) else map_pmf Inr (Db \\<bind> fb))\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "also"], ["proof (state)\nthis:\n  (if x\n   then map_pmf Inl Da \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))\n   else map_pmf Inr Db \\<bind>\n        case_sum (\\<lambda>e. map_pmf Inl (fa e))\n         (\\<lambda>e. map_pmf Inr (fb e))) =\n  (if x then map_pmf Inl (Da \\<bind> fa) else map_pmf Inr (Db \\<bind> fb))\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "have \"\\<dots> = (if x then map_pmf Inl Da' else map_pmf Inr Db')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x then map_pmf Inl (Da \\<bind> fa)\n     else map_pmf Inr (Db \\<bind> fb)) =\n    (if x then map_pmf Inl Da' else map_pmf Inr Db')", "using a b"], ["proof (prove)\nusing this:\n  Da \\<bind> fa = Da'\n  Db \\<bind> fb = Db'\n\ngoal (1 subgoal):\n 1. (if x then map_pmf Inl (Da \\<bind> fa)\n     else map_pmf Inr (Db \\<bind> fb)) =\n    (if x then map_pmf Inl Da' else map_pmf Inr Db')", "by simp"], ["proof (state)\nthis:\n  (if x then map_pmf Inl (Da \\<bind> fa) else map_pmf Inr (Db \\<bind> fb)) =\n  (if x then map_pmf Inl Da' else map_pmf Inr Db')\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "finally"], ["proof (chain)\npicking this:\n  (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if x then map_pmf Inl Da' else map_pmf Inr Db')", "have \"(if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n                 case_sum (\\<lambda>e. map_pmf Inl (fa e))\n                  (\\<lambda>e. map_pmf Inr (fb e)) = (if x then map_pmf Inl Da' else map_pmf Inr Db')\""], ["proof (prove)\nusing this:\n  (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if x then map_pmf Inl Da' else map_pmf Inr Db')\n\ngoal (1 subgoal):\n 1. (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n    case_sum (\\<lambda>e. map_pmf Inl (fa e))\n     (\\<lambda>e. map_pmf Inr (fb e)) =\n    (if x then map_pmf Inl Da' else map_pmf Inr Db')", "."], ["proof (state)\nthis:\n  (if x then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if x then map_pmf Inl Da' else map_pmf Inr Db')\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "}"], ["proof (state)\nthis:\n  (if ?x2 then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if ?x2 then map_pmf Inl Da' else map_pmf Inr Db')\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "note gr=this"], ["proof (state)\nthis:\n  (if ?x2 then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n  case_sum (\\<lambda>e. map_pmf Inl (fa e))\n   (\\<lambda>e. map_pmf Inr (fb e)) =\n  (if ?x2 then map_pmf Inl Da' else map_pmf Inr Db')\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'", "unfolding Sum_pmf_def f_on2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n    case_sum (\\<lambda>e. map_pmf Inl (fa e))\n     (\\<lambda>e. map_pmf Inr (fb e)) =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b. if b then map_pmf Inl Da' else map_pmf Inr Db')", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b.\n                if b then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n            case_sum (\\<lambda>e. map_pmf Inl (fa e))\n             (\\<lambda>e. map_pmf Inr (fb e)))\n        i =\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da' else map_pmf Inr Db'))\n        i", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i a.\n       i = Inl a \\<Longrightarrow>\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b.\n                if b then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n            case_sum (\\<lambda>e. map_pmf Inl (fa e))\n             (\\<lambda>e. map_pmf Inr (fb e)))\n        i =\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da' else map_pmf Inr Db'))\n        i\n 2. \\<And>i b.\n       i = Inr b \\<Longrightarrow>\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b.\n                if b then map_pmf Inl Da else map_pmf Inr Db) \\<bind>\n            case_sum (\\<lambda>e. map_pmf Inl (fa e))\n             (\\<lambda>e. map_pmf Inr (fb e)))\n        i =\n       pmf (bernoulli_pmf p \\<bind>\n            (\\<lambda>b. if b then map_pmf Inl Da' else map_pmf Inr Db'))\n        i", "by(simp_all add: bind_return_pmf bind_assoc_pmf gr)"], ["proof (state)\nthis:\n  Sum_pmf p Da Db \\<bind> f_on2 fa fb = Sum_pmf p Da' Db'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"sum_map_pmf fa fb = (%a. case a of Inl e \\<Rightarrow> Inl (fa e) | Inr e \\<Rightarrow> Inr (fb e))\""], ["", "lemma Sum_map_pmf: assumes a: \"map_pmf fa Da = Da'\" and b: \"map_pmf fb Db = Db'\"\n  shows \"map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db)\n              = Sum_pmf p Da' Db'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "have \"map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db)\n        = bind_pmf (Sum_pmf p Da Db) (f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) =\n    Sum_pmf p Da Db \\<bind>\n    f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x))", "using a b"], ["proof (prove)\nusing this:\n  map_pmf fa Da = Da'\n  map_pmf fb Db = Db'\n\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) =\n    Sum_pmf p Da Db \\<bind>\n    f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x))", "unfolding map_pmf_def sum_map_pmf_def f_on2_def"], ["proof (prove)\nusing this:\n  Da \\<bind> (\\<lambda>x. return_pmf (fa x)) = Da'\n  Db \\<bind> (\\<lambda>x. return_pmf (fb x)) = Db'\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind>\n    (\\<lambda>x.\n        return_pmf\n         (case x of Inl e \\<Rightarrow> Inl (fa e)\n          | Inr e \\<Rightarrow> Inr (fb e))) =\n    Sum_pmf p Da Db \\<bind>\n    case_sum\n     (\\<lambda>e.\n         return_pmf (fa e) \\<bind> (\\<lambda>x. return_pmf (Inl x)))\n     (\\<lambda>e.\n         return_pmf (fb e) \\<bind> (\\<lambda>x. return_pmf (Inr x)))", "by(auto simp add: bind_return_pmf sum.case_distrib)"], ["proof (state)\nthis:\n  map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) =\n  Sum_pmf p Da Db \\<bind>\n  f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x))\n\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "also"], ["proof (state)\nthis:\n  map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) =\n  Sum_pmf p Da Db \\<bind>\n  f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x))\n\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "have \"\\<dots> = Sum_pmf p Da' Db'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind>\n    f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x)) =\n    Sum_pmf p Da' Db'", "using assms[unfolded map_pmf_def]"], ["proof (prove)\nusing this:\n  Da \\<bind> (\\<lambda>x. return_pmf (fa x)) = Da'\n  Db \\<bind> (\\<lambda>x. return_pmf (fb x)) = Db'\n\ngoal (1 subgoal):\n 1. Sum_pmf p Da Db \\<bind>\n    f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x)) =\n    Sum_pmf p Da' Db'", "by(rule Sum_bind_pmf )"], ["proof (state)\nthis:\n  Sum_pmf p Da Db \\<bind>\n  f_on2 (\\<lambda>x. return_pmf (fa x)) (\\<lambda>x. return_pmf (fb x)) =\n  Sum_pmf p Da' Db'\n\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "finally"], ["proof (chain)\npicking this:\n  map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'\n\ngoal (1 subgoal):\n 1. map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'", "."], ["proof (state)\nthis:\n  map_pmf (sum_map_pmf fa fb) (Sum_pmf p Da Db) = Sum_pmf p Da' Db'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}