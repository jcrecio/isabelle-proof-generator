{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/BIT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma sum_my: fixes f g::\"'b \\<Rightarrow> 'a::ab_group_add\"\n    assumes \"finite A\" \"finite B\"\n  shows \"(\\<Sum>x\\<in>A. f x) - (\\<Sum>x\\<in>B. g x)\n    = (\\<Sum>x\\<in>(A \\<inter> B). f x - g x) + (\\<Sum>x\\<in>A-B. f x) - (\\<Sum>x\\<in>B-A. g x)\"", "lemma sum_my2: \"(\\<forall>x\\<in>A. f x = g x) \\<Longrightarrow> (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. g x)\"", "lemma \"~ deterministic_init BIT_init\"", "lemma \"deterministic_step BIT_step\"", "lemma BIT_no_paid: \"\\<forall>((free,paid),_) \\<in> (BIT_step s q). paid=[]\"", "lemma config'_n_init: fixes qs init n\n  shows \"map_pmf (snd \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = map_pmf (snd \\<circ> snd) init\"", "lemma config_n_init: \"map_pmf (snd \\<circ> snd) (config_rand  (BIT_init, BIT_step) s0 qs) = return_pmf s0\"", "lemma config_n_init2: \"\\<forall>(_,(_,x)) \\<in> set_pmf (config_rand (BIT_init, BIT_step) init qs). x = init\"", "lemma config_n_init3: \"\\<forall>x \\<in> set_pmf (config_rand (BIT_init, BIT_step) init qs). snd (snd x) = init\"", "lemma config'_n_bv: fixes qs init n \n  shows \" map_pmf (snd \\<circ> snd) init = return_pmf s0\n      \\<Longrightarrow> map_pmf (fst \\<circ> snd) init = bv (length s0)\n      \\<Longrightarrow> map_pmf (snd \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = return_pmf s0\n        \\<and> map_pmf (fst \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = bv (length s0)\"", "lemma config_n_bv_2: \"map_pmf (snd \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = return_pmf s0\n        \\<and> map_pmf (fst \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = bv (length s0)\"", "lemma config_n_bv: \"map_pmf (fst \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = bv (length s0)\"", "lemma config_n_fst_init_length: \"\\<forall>(_,(x,_)) \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs). length x = length s0\"", "lemma config_n_fst_init_length2: \"\\<forall>x \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs). length (fst (snd x)) = length s0\"", "lemma fperms: \"finite {x::'a list. length x = length init \\<and> distinct x \\<and> set x = set init}\"", "lemma finite_config_BIT: assumes [simp]: \"distinct init\"\n  shows \"finite (set_pmf (config_rand (BIT_init, BIT_step) init qs))\" (is \"finite ?D\")", "lemma setinit: \"(index init) ` set init = {0..<length init}\"", "lemma len_paid_A[simp]: \"length paid_A = length qs\"", "lemma len_paid_A'[simp]: \"length paid_A' = length qs\"", "lemma paidAnm_inbound: \"n < length paid_A \\<Longrightarrow> m < length(paid_A!n) \\<Longrightarrow> (Suc ((paid_A!n)!(length (paid_A ! n) - Suc m))) < length init\"", "lemma length_s_A'[simp]: \"length(s_A' n) = length init\"", "lemma dist_s_A'[simp]: \"distinct(s_A' n)\"", "lemma set_s_A'[simp]: \"set(s_A' n) = set init\"", "lemma length_s_A[simp]: \"length(s_A n) = length init\"", "lemma dist_s_A[simp]: \"distinct(s_A n)\"", "lemma set_s_A[simp]: \"set(s_A n) = set init\"", "lemma cost_paidAA': \"n < length paid_A' \\<Longrightarrow> length (paid_A!n) \\<le> length (paid_A'!n)\"", "lemma swaps_filtered: \"swaps (filter (\\<lambda>x. Suc x < length xs) ys) xs = swaps (ys) xs\"", "lemma sAsA': \"n < length paid_A' \\<Longrightarrow> s_A' n = s_A n\"", "lemma sAsA'': \"n < length qs \\<Longrightarrow> s_A n =  s_A' n\"", "lemma t_A_A'_leq: \"n < length paid_A' \\<Longrightarrow> t_A n \\<le> t_A' n\"", "lemma T_A_A'_leq: \"n \\<le> length paid_A' \\<Longrightarrow> T_A n \\<le> T_A' n\"", "lemma T_A_A'_leq': \"n \\<le> length qs \\<Longrightarrow> T_A n \\<le> T_A' n\"", "lemma set_s'_A[simp]: \"set (s'_A n m) = set init\"", "lemma len_s'_A[simp]: \"length (s'_A n m) = length init\"", "lemma distperm_s'_A[simp]: \"dist_perm (s'_A n m) init\"", "lemma s'A_m_le: \"m \\<le> (length (paid_A ! n)) \\<Longrightarrow> swaps (drop (length (paid_A  ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\"", "lemma s'A_m: \"swaps (paid_A ! n) (s_A n) = s'_A n (length (paid_A ! n))\"", "lemma gebub_inBound: assumes 1: \" n < length paid_A \" and  2: \"m < length (paid_A !  n)\" \n          shows \"gebub n m < length init\"", "lemma phi': \"phi n z = (\\<Sum>(x,y)\\<in>(Inv (fst z) (s_A n)). (if (fst (snd z))!(index init y) then 2 else 1))\"", "lemma Inv_empty2: \"length d = 0 \\<Longrightarrow> Inv c d = {}\"", "lemma phi_empty2: \"length init = 0 \\<Longrightarrow> phi n (c,(b,i)) = 0\"", "lemma phi_nonzero: \"phi n (c,(b,i)) \\<ge> 0\"", "lemma PhiPlus_is_Phi_Suc: \"n<length qs \\<Longrightarrow> PhiPlus n = Phi (Suc n)\"", "lemma phi0: \"Phi 0 = 0\"", "lemma phi_pos: \"Phi n \\<ge> 0\"", "lemma swap_subs: \"dist_perm X Y \\<Longrightarrow> Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\"", "lemma \"InvOf y xs ys = {(x,y)|x. (x,y)\\<in>Inv xs ys}\"", "lemma \"InvOf y xs ys \\<subseteq> Inv xs ys\"", "lemma numberofIsbeschr: assumes\n    distxsys: \"dist_perm xs ys\" and\n    yinxs: \"y \\<in> set xs\"\n  shows \"index xs y \\<le> index ys y + card (InvOf y xs ys)\" \n    (is \"?iBit \\<le> ?iA + card ?I\")", "lemma \"length init = 0 \\<Longrightarrow> length xs = length init \\<Longrightarrow> t xs q (mf, sws) = 1 + length sws\"", "lemma integr_index: \"integrable (measure_pmf (config'' (BIT_init, BIT_step) qs init n))\n   (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\"", "lemma t_BIT_ub2: \"(qs!n) \\<notin> set init \\<Longrightarrow> t_BIT n \\<le> Suc(size init)\"", "lemma t_BIT_ub: \"(qs!n) \\<in> set init \\<Longrightarrow> t_BIT n \\<le> size init\"", "lemma T_BIT_ub: \"\\<forall>i<n. qs!i \\<in> set init \\<Longrightarrow> T_BIT n \\<le> n * size init\"", "lemma myub: \"n < length qs \\<Longrightarrow> t_BIT n + Phi(n + 1) - Phi n \\<le> (7 / 4) * t_A n - 3/4\"", "lemma T_BIT_absch_le: assumes nqs: \"n \\<le> length qs\"\n  shows \"T_BIT n \\<le> (7 / 4) * T_A n - 3/4*n\"", "lemma T_BIT_absch: assumes nqs: \"n \\<le> length qs\"\n  shows \"T_BIT n \\<le> (7 / 4) * T_A' n - 3/4*n\"", "lemma T_A_nneg: \"0 \\<le> T_A n\"", "lemma T_BIT_eq: \"T_BIT (length qs) = T_on_rand BIT init qs\"", "lemma t_A'_t: \"n < length qs \\<Longrightarrow> t_A' n = int (t (s_A' n) (qs!n) (acts ! n))\"", "lemma T_A'_eq_lem: \"(\\<Sum>i=0..<length qs. t_A' i) =\n  T (s_A' 0) (drop 0 qs) (drop 0 acts)\"", "lemma T_A'_eq: \"T_A' (length qs) = T init qs acts\"", "lemma setdi: \"set xs = {0..<length xs} \\<Longrightarrow> distinct xs\"", "theorem compet_BIT: assumes \"init \\<noteq> []\" \"distinct init\" \"set qs \\<subseteq> set init\"  \nshows \"T_on_rand BIT init qs \\<le> ( (7/4) - 3 / (4 * length init)) * T_opt init qs\"", "theorem compet_BIT4: assumes \"init \\<noteq> []\" \"distinct init\"   \nshows \"T_on_rand BIT init qs \\<le> 7/4 * T_opt init qs\"", "theorem compet_BIT_2:\n \"compet_rand BIT (7/4) {init. init \\<noteq> [] \\<and> distinct init}\""], "translations": [["", "lemma sum_my: fixes f g::\"'b \\<Rightarrow> 'a::ab_group_add\"\n    assumes \"finite A\" \"finite B\"\n  shows \"(\\<Sum>x\\<in>A. f x) - (\\<Sum>x\\<in>B. g x)\n    = (\\<Sum>x\\<in>(A \\<inter> B). f x - g x) + (\\<Sum>x\\<in>A-B. f x) - (\\<Sum>x\\<in>B-A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"finite (A-B)\" and \"finite (A\\<inter>B)\" and \"finite (B-A)\" and \"finite (B\\<inter>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (A - B) &&& finite (A \\<inter> B)) &&&\n    finite (B - A) &&& finite (B \\<inter> A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. (finite (A - B) &&& finite (A \\<inter> B)) &&&\n    finite (B - A) &&& finite (B \\<inter> A)", "by auto"], ["proof (state)\nthis:\n  finite (A - B)\n  finite (A \\<inter> B)\n  finite (B - A)\n  finite (B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "note finites=this"], ["proof (state)\nthis:\n  finite (A - B)\n  finite (A \\<inter> B)\n  finite (B - A)\n  finite (B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"(A-B) \\<inter> ( (A\\<inter>B)  ) = {}\" and \"(B-A) \\<inter> ( (B\\<inter>A)  ) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) \\<inter> (A \\<inter> B) = {} &&&\n    (B - A) \\<inter> (B \\<inter> A) = {}", "by auto"], ["proof (state)\nthis:\n  (A - B) \\<inter> (A \\<inter> B) = {}\n  (B - A) \\<inter> (B \\<inter> A) = {}\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "note inters=this"], ["proof (state)\nthis:\n  (A - B) \\<inter> (A \\<inter> B) = {}\n  (B - A) \\<inter> (B \\<inter> A) = {}\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have commute: \"A\\<inter>B=B\\<inter>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = B \\<inter> A", "by auto"], ["proof (state)\nthis:\n  A \\<inter> B = B \\<inter> A\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"A = (A-B) \\<union> (A\\<inter>B)\" and \"B = (B-A) \\<union> ( (B\\<inter>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A - B \\<union> A \\<inter> B &&& B = B - A \\<union> B \\<inter> A", "by auto"], ["proof (state)\nthis:\n  A = A - B \\<union> A \\<inter> B\n  B = B - A \\<union> B \\<inter> A\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "then"], ["proof (chain)\npicking this:\n  A = A - B \\<union> A \\<inter> B\n  B = B - A \\<union> B \\<inter> A", "have \"(\\<Sum>x\\<in>A. f x) - (\\<Sum>x\\<in>B. g x) = (\\<Sum>x\\<in>(A-B) \\<union> (A\\<inter>B). f x) - (\\<Sum>x\\<in>(B-A) \\<union> (B\\<inter>A). g x)\""], ["proof (prove)\nusing this:\n  A = A - B \\<union> A \\<inter> B\n  B = B - A \\<union> B \\<inter> A\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    sum f (A - B \\<union> A \\<inter> B) -\n    sum g (B - A \\<union> B \\<inter> A)", "by auto"], ["proof (state)\nthis:\n  sum f A - sum g B =\n  sum f (A - B \\<union> A \\<inter> B) - sum g (B - A \\<union> B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "also"], ["proof (state)\nthis:\n  sum f A - sum g B =\n  sum f (A - B \\<union> A \\<inter> B) - sum g (B - A \\<union> B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"\\<dots> = ( (\\<Sum>x\\<in>(A-B). f x) + (\\<Sum>x\\<in>(A\\<inter>B). f x) - (\\<Sum>x\\<in>(A-B)\\<inter>(A\\<inter>B). f x) )\n        -( (\\<Sum>x\\<in>(B-A). g x) + (\\<Sum>x\\<in>(B\\<inter>A). g x) - (\\<Sum>x\\<in>(B-A)\\<inter>(B\\<inter>A). g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (A - B \\<union> A \\<inter> B) -\n    sum g (B - A \\<union> B \\<inter> A) =\n    sum f (A - B) + sum f (A \\<inter> B) -\n    sum f ((A - B) \\<inter> (A \\<inter> B)) -\n    (sum g (B - A) + sum g (B \\<inter> A) -\n     sum g ((B - A) \\<inter> (B \\<inter> A)))", "using sum_Un[where ?f=\"f\",OF finites(1) finites(2)]\n                sum_Un[where ?f=\"g\",OF finites(3) finites(4)]"], ["proof (prove)\nusing this:\n  sum f (A - B \\<union> A \\<inter> B) =\n  sum f (A - B) + sum f (A \\<inter> B) -\n  sum f ((A - B) \\<inter> (A \\<inter> B))\n  sum g (B - A \\<union> B \\<inter> A) =\n  sum g (B - A) + sum g (B \\<inter> A) -\n  sum g ((B - A) \\<inter> (B \\<inter> A))\n\ngoal (1 subgoal):\n 1. sum f (A - B \\<union> A \\<inter> B) -\n    sum g (B - A \\<union> B \\<inter> A) =\n    sum f (A - B) + sum f (A \\<inter> B) -\n    sum f ((A - B) \\<inter> (A \\<inter> B)) -\n    (sum g (B - A) + sum g (B \\<inter> A) -\n     sum g ((B - A) \\<inter> (B \\<inter> A)))", "by(simp)"], ["proof (state)\nthis:\n  sum f (A - B \\<union> A \\<inter> B) -\n  sum g (B - A \\<union> B \\<inter> A) =\n  sum f (A - B) + sum f (A \\<inter> B) -\n  sum f ((A - B) \\<inter> (A \\<inter> B)) -\n  (sum g (B - A) + sum g (B \\<inter> A) -\n   sum g ((B - A) \\<inter> (B \\<inter> A)))\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "also"], ["proof (state)\nthis:\n  sum f (A - B \\<union> A \\<inter> B) -\n  sum g (B - A \\<union> B \\<inter> A) =\n  sum f (A - B) + sum f (A \\<inter> B) -\n  sum f ((A - B) \\<inter> (A \\<inter> B)) -\n  (sum g (B - A) + sum g (B \\<inter> A) -\n   sum g ((B - A) \\<inter> (B \\<inter> A)))\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"\\<dots> = ( (\\<Sum>x\\<in>(A-B). f x) + (\\<Sum>x\\<in>(A\\<inter>B). f x) )\n        - (\\<Sum>x\\<in>(B-A). g x) - (\\<Sum>x\\<in>(B\\<inter>A). g x) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (A - B) + sum f (A \\<inter> B) -\n    sum f ((A - B) \\<inter> (A \\<inter> B)) -\n    (sum g (B - A) + sum g (B \\<inter> A) -\n     sum g ((B - A) \\<inter> (B \\<inter> A))) =\n    sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n    sum g (B \\<inter> A)", "using inters"], ["proof (prove)\nusing this:\n  (A - B) \\<inter> (A \\<inter> B) = {}\n  (B - A) \\<inter> (B \\<inter> A) = {}\n\ngoal (1 subgoal):\n 1. sum f (A - B) + sum f (A \\<inter> B) -\n    sum f ((A - B) \\<inter> (A \\<inter> B)) -\n    (sum g (B - A) + sum g (B \\<inter> A) -\n     sum g ((B - A) \\<inter> (B \\<inter> A))) =\n    sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n    sum g (B \\<inter> A)", "by auto"], ["proof (state)\nthis:\n  sum f (A - B) + sum f (A \\<inter> B) -\n  sum f ((A - B) \\<inter> (A \\<inter> B)) -\n  (sum g (B - A) + sum g (B \\<inter> A) -\n   sum g ((B - A) \\<inter> (B \\<inter> A))) =\n  sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n  sum g (B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "also"], ["proof (state)\nthis:\n  sum f (A - B) + sum f (A \\<inter> B) -\n  sum f ((A - B) \\<inter> (A \\<inter> B)) -\n  (sum g (B - A) + sum g (B \\<inter> A) -\n   sum g ((B - A) \\<inter> (B \\<inter> A))) =\n  sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n  sum g (B \\<inter> A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"\\<dots> =  (\\<Sum>x\\<in>(A-B). f x) - (\\<Sum>x\\<in>(A\\<inter>B). g x) + (\\<Sum>x\\<in>(A\\<inter>B). f x) \n        - (\\<Sum>x\\<in>(B-A). g x)  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n    sum g (B \\<inter> A) =\n    sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n    sum g (B - A)", "using commute"], ["proof (prove)\nusing this:\n  A \\<inter> B = B \\<inter> A\n\ngoal (1 subgoal):\n 1. sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n    sum g (B \\<inter> A) =\n    sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n    sum g (B - A)", "by auto"], ["proof (state)\nthis:\n  sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n  sum g (B \\<inter> A) =\n  sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n  sum g (B - A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "also"], ["proof (state)\nthis:\n  sum f (A - B) + sum f (A \\<inter> B) - sum g (B - A) -\n  sum g (B \\<inter> A) =\n  sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n  sum g (B - A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "have \"\\<dots> = (\\<Sum>x\\<in>(A\\<inter>B). f x - g x) +(\\<Sum>x\\<in>(A-B). f x) \n        - (\\<Sum>x\\<in>(B-A). g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n    sum g (B - A) =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "using sum_subtractf[of f g \"(A\\<inter>B)\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>A \\<inter> B. f x - g x) =\n  sum f (A \\<inter> B) - sum g (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n    sum g (B - A) =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "by auto"], ["proof (state)\nthis:\n  sum f (A - B) - sum g (A \\<inter> B) + sum f (A \\<inter> B) -\n  sum g (B - A) =\n  (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "finally"], ["proof (chain)\npicking this:\n  sum f A - sum g B =\n  (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f A - sum g B =\n  (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)\n\ngoal (1 subgoal):\n 1. sum f A - sum g B =\n    (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)", "."], ["proof (state)\nthis:\n  sum f A - sum g B =\n  (\\<Sum>x\\<in>A \\<inter> B. f x - g x) + sum f (A - B) - sum g (B - A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_my2: \"(\\<forall>x\\<in>A. f x = g x) \\<Longrightarrow> (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. f x = g x \\<Longrightarrow> sum f A = sum g A", "by auto"], ["", "subsection \"Definition of BIT\""], ["", "definition BIT_init :: \"('a state,bool list * 'a list)alg_on_init\" where\n  \"BIT_init init = map_pmf (\\<lambda>l. (l,init)) (bv (length init))\""], ["", "lemma \"~ deterministic_init BIT_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> deterministic_init BIT_init", "unfolding deterministic_init_def BIT_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>init.\n               card\n                (set_pmf\n                  (map_pmf (\\<lambda>l. (l, init)) (bv (length init)))) =\n               1)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>init.\n       card ((\\<lambda>l. (l, init)) ` set_pmf (bv (length init))) \\<noteq>\n       Suc 0", "apply(intro exI[where x=\"[a]\"]) \n  \\<comment> \\<open>comment in a proof\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>l. (l, [a])) ` set_pmf (bv (length [a]))) \\<noteq> Suc 0", "by(auto simp: UNIV_bool set_pmf_bernoulli)"], ["", "definition BIT_step :: \"('a state, bool list * 'a list, 'a, answer)alg_on_step\" where\n\"BIT_step s q = ( let a=((if (fst (snd s))!(index (snd (snd s)) q) then 0 else (length (fst s))),[]) in\n                     return_pmf (a , (flip (index (snd (snd s)) q) (fst (snd s)), snd (snd s))))\""], ["", "lemma \"deterministic_step BIT_step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic_step BIT_step", "unfolding deterministic_step_def BIT_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i is q.\n       card\n        (set_pmf\n          (let a = (if fst (snd (i, is)) ! index (snd (snd (i, is))) q\n                    then 0 else length (fst (i, is)),\n                    [])\n           in return_pmf\n               (a, flip (index (snd (snd (i, is))) q) (fst (snd (i, is))),\n                snd (snd (i, is))))) =\n       1", "by simp"], ["", "abbreviation BIT :: \"('a state, bool list*'a list, 'a, answer)alg_on_rand\" where\n    \"BIT == (BIT_init, BIT_step)\""], ["", "subsection \"Properties of BIT's state distribution\""], ["", "lemma BIT_no_paid: \"\\<forall>((free,paid),_) \\<in> (BIT_step s q). paid=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((free, paid), uu_)\\<in>set_pmf (BIT_step s q). paid = []", "unfolding BIT_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((free, paid), uu_)\n             \\<in>set_pmf\n                   (let a = (if fst (snd s) ! index (snd (snd s)) q then 0\n                             else length (fst s),\n                             [])\n                    in return_pmf\n                        (a, flip (index (snd (snd s)) q) (fst (snd s)),\n                         snd (snd s))).\n       paid = []", "by(auto)"], ["", "subsubsection \"About the Internal State\""], ["", "term \"(config'_rand (BIT_init, BIT_step) s0 qs) \""], ["", "lemma config'_n_init: fixes qs init n\n  shows \"map_pmf (snd \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = map_pmf (snd \\<circ> snd) init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd) (config'_rand BIT init qs) =\n    map_pmf (snd \\<circ> snd) init", "apply (induct qs arbitrary: init)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>init.\n       map_pmf (snd \\<circ> snd) (config'_rand BIT init []) =\n       map_pmf (snd \\<circ> snd) init\n 2. \\<And>a qs init.\n       (\\<And>init.\n           map_pmf (snd \\<circ> snd) (config'_rand BIT init qs) =\n           map_pmf (snd \\<circ> snd) init) \\<Longrightarrow>\n       map_pmf (snd \\<circ> snd) (config'_rand BIT init (a # qs)) =\n       map_pmf (snd \\<circ> snd) init", "by (simp_all add: map_pmf_def bind_assoc_pmf BIT_step_def bind_return_pmf )"], ["", "lemma config_n_init: \"map_pmf (snd \\<circ> snd) (config_rand  (BIT_init, BIT_step) s0 qs) = return_pmf s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    return_pmf s0", "using config'_n_init[of \"((fst (BIT_init, BIT_step) s0) \\<bind> (\\<lambda>is. return_pmf (s0, is)))\"]"], ["proof (prove)\nusing this:\n  map_pmf (snd \\<circ> snd)\n   (config'_rand BIT\n     (fst (BIT_init, BIT_step) s0 \\<bind>\n      (\\<lambda>is. return_pmf (s0, is)))\n     ?qs) =\n  map_pmf (snd \\<circ> snd)\n   (fst (BIT_init, BIT_step) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    return_pmf s0", "by (simp_all add: map_pmf_def bind_assoc_pmf  bind_return_pmf BIT_init_def )"], ["", "lemma config_n_init2: \"\\<forall>(_,(_,x)) \\<in> set_pmf (config_rand (BIT_init, BIT_step) init qs). x = init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(uu_, uu_, x)\n             \\<in>set_pmf\n                   (config'_rand BIT\n                     (fst BIT init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     qs).\n       x = init", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "case (1 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "then"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)", "have 1: \"snd(snd z) \\<in> (snd \\<circ> snd) ` set_pmf (config_rand   (BIT_init, BIT_step) init qs)\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. snd (snd z)\n    \\<in> (snd \\<circ> snd) `\n          set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)", "by force"], ["proof (state)\nthis:\n  snd (snd z)\n  \\<in> (snd \\<circ> snd) `\n        set_pmf\n         (config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "have \"(snd \\<circ> snd) ` set_pmf (config_rand  (BIT_init, BIT_step) init qs)\n              = set_pmf (map_pmf (snd \\<circ> snd) (config_rand  (BIT_init, BIT_step) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    set_pmf\n     (map_pmf (snd \\<circ> snd)\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "by(simp)"], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "also"], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "have \"\\<dots> = {init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf\n     (map_pmf (snd \\<circ> snd)\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n    {init}", "apply(simp only: config_n_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (return_pmf init) = {init}", "by simp"], ["proof (state)\nthis:\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n  {init}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "finally"], ["proof (chain)\npicking this:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}", "have \"snd(snd z) = init\""], ["proof (prove)\nusing this:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "using 1"], ["proof (prove)\nusing this:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n  snd (snd z)\n  \\<in> (snd \\<circ> snd) `\n        set_pmf\n         (config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n\ngoal (1 subgoal):\n 1. snd (snd z) = init", "by auto"], ["proof (state)\nthis:\n  snd (snd z) = init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, uua_, xa) \\<Rightarrow> xa = init", "then"], ["proof (chain)\npicking this:\n  snd (snd z) = init", "show ?case"], ["proof (prove)\nusing this:\n  snd (snd z) = init\n\ngoal (1 subgoal):\n 1. case z of (uu_, uua_, xa) \\<Rightarrow> xa = init", "by auto"], ["proof (state)\nthis:\n  case z of (uu_, uua_, xa) \\<Rightarrow> xa = init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma config_n_init3: \"\\<forall>x \\<in> set_pmf (config_rand (BIT_init, BIT_step) init qs). snd (snd x) = init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       snd (snd x) = init", "using config_n_init2"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, uu_, x)\n           \\<in>set_pmf\n                 (config'_rand BIT\n                   (fst BIT ?init \\<bind>\n                    (\\<lambda>is. return_pmf (?init, is)))\n                   ?qs).\n     x = ?init\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       snd (snd x) = init", "by(simp add: split_def)"], ["", "lemma config'_n_bv: fixes qs init n \n  shows \" map_pmf (snd \\<circ> snd) init = return_pmf s0\n      \\<Longrightarrow> map_pmf (fst \\<circ> snd) init = bv (length s0)\n      \\<Longrightarrow> map_pmf (snd \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = return_pmf s0\n        \\<and> map_pmf (fst \\<circ> snd) (config'_rand (BIT_init, BIT_step) init qs) = bv (length s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n     map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n    \\<Longrightarrow> map_pmf (snd \\<circ> snd) (config'_rand BIT init qs) =\n                      return_pmf s0 \\<and>\n                      map_pmf (fst \\<circ> snd) (config'_rand BIT init qs) =\n                      bv (length s0)", "proof (induct qs arbitrary: init)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         bv (length s0)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n                    map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n                   \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     return_pmf s0 \\<and>\n                                     map_pmf (fst \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     bv (length s0);\n        map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         bv (length s0)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>map_pmf (snd \\<circ> snd) ?init = return_pmf s0;\n   map_pmf (fst \\<circ> snd) ?init = bv (length s0)\\<rbrakk>\n  \\<Longrightarrow> map_pmf (snd \\<circ> snd) (config'_rand BIT ?init rs) =\n                    return_pmf s0 \\<and>\n                    map_pmf (fst \\<circ> snd) (config'_rand BIT ?init rs) =\n                    bv (length s0)\n  map_pmf (snd \\<circ> snd) init = return_pmf s0\n  map_pmf (fst \\<circ> snd) init = bv (length s0)\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         bv (length s0)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n                    map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n                   \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     return_pmf s0 \\<and>\n                                     map_pmf (fst \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     bv (length s0);\n        map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         bv (length s0)", "from Cons(2)"], ["proof (chain)\npicking this:\n  map_pmf (snd \\<circ> snd) init = return_pmf s0", "have a: \"map_pmf (snd \\<circ> snd) (init \\<bind> (\\<lambda>s. snd (BIT_init, BIT_step) s r \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is'))))\n            = return_pmf s0\""], ["proof (prove)\nusing this:\n  map_pmf (snd \\<circ> snd) init = return_pmf s0\n\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd (BIT_init, BIT_step) s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0", "apply(simp add: BIT_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>a. snd (snd a)) init = return_pmf s0 \\<Longrightarrow>\n    map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          return_pmf\n           ((if fst (snd s) ! index (snd (snd s)) r then 0\n             else length (fst s),\n             []),\n            flip (index (snd (snd s)) r) (fst (snd s)), snd (snd s)) \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0", "by (simp_all add: map_pmf_def bind_assoc_pmf BIT_step_def bind_return_pmf )"], ["proof (state)\nthis:\n  map_pmf (snd \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  return_pmf s0\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         bv (length s0)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n                    map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n                   \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     return_pmf s0 \\<and>\n                                     map_pmf (fst \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     bv (length s0);\n        map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         bv (length s0)", "then"], ["proof (chain)\npicking this:\n  map_pmf (snd \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  return_pmf s0", "have b: \"\\<forall>z\\<in>set_pmf (init \\<bind> (\\<lambda>s. snd (BIT_init, BIT_step) s r \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))). snd (snd z) = s0\""], ["proof (prove)\nusing this:\n  map_pmf (snd \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  return_pmf s0\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set_pmf\n                    (init \\<bind>\n                     (\\<lambda>s.\n                         snd (BIT_init, BIT_step) s r \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf (step (fst s) r a, is')))).\n       snd (snd z) = s0", "by (metis (mono_tags, lifting) comp_eq_dest_lhs map_pmf_eq_return_pmf_iff)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set_pmf\n                  (init \\<bind>\n                   (\\<lambda>s.\n                       snd (BIT_init, BIT_step) s r \\<bind>\n                       (\\<lambda>(a, is').\n                           return_pmf (step (fst s) r a, is')))).\n     snd (snd z) = s0\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         bv (length s0)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n                    map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n                   \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     return_pmf s0 \\<and>\n                                     map_pmf (fst \\<circ> snd)\n(config'_rand BIT init qs) =\n                                     bv (length s0);\n        map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init (a # qs)) =\n                         bv (length s0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd) (config'_rand BIT init (r # rs)) =\n    return_pmf s0 \\<and>\n    map_pmf (fst \\<circ> snd) (config'_rand BIT init (r # rs)) =\n    bv (length s0)", "apply(simp only: config'_rand.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (init \\<bind>\n        (\\<lambda>s.\n            snd BIT s r \\<bind>\n            (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is'))))\n       rs) =\n    return_pmf s0 \\<and>\n    map_pmf (fst \\<circ> snd)\n     (config'_rand BIT\n       (init \\<bind>\n        (\\<lambda>s.\n            snd BIT s r \\<bind>\n            (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is'))))\n       rs) =\n    bv (length s0)", "proof (rule Cons(1), goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "have \"map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s. snd (BIT_init, BIT_step) s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (step (fst s) r a, is')))) = map_pmf (flip (index s0 r)) (bv (length s0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd (BIT_init, BIT_step) s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    map_pmf (flip (index s0 r)) (bv (length s0))", "using b"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set_pmf\n                  (init \\<bind>\n                   (\\<lambda>s.\n                       snd (BIT_init, BIT_step) s r \\<bind>\n                       (\\<lambda>(a, is').\n                           return_pmf (step (fst s) r a, is')))).\n     snd (snd z) = s0\n\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd (BIT_init, BIT_step) s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    map_pmf (flip (index s0 r)) (bv (length s0))", "apply(simp add: BIT_step_def Cons(3)[symmetric] bind_return_pmf map_pmf_def bind_assoc_pmf )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf init. snd (snd y) = s0 \\<Longrightarrow>\n    init \\<bind>\n    (\\<lambda>x. return_pmf (flip (index (snd (snd x)) r) (fst (snd x)))) =\n    init \\<bind> (\\<lambda>x. return_pmf (flip (index s0 r) (fst (snd x))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set_pmf init. snd (snd y) = s0 \\<Longrightarrow>\n    init = init\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y\\<in>set_pmf init. snd (snd y) = s0;\n        x \\<in> set_pmf init\\<rbrakk>\n       \\<Longrightarrow> return_pmf\n                          (flip (index (snd (snd x)) r) (fst (snd x))) =\n                         return_pmf (flip (index s0 r) (fst (snd x)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y\\<in>set_pmf init. snd (snd y) = s0;\n        x \\<in> set_pmf init\\<rbrakk>\n       \\<Longrightarrow> return_pmf\n                          (flip (index (snd (snd x)) r) (fst (snd x))) =\n                         return_pmf (flip (index s0 r) (fst (snd x)))", "by(simp add: inv_flip_bv)"], ["proof (state)\nthis:\n  map_pmf (fst \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  map_pmf (flip (index s0 r)) (bv (length s0))\n\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "also"], ["proof (state)\nthis:\n  map_pmf (fst \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  map_pmf (flip (index s0 r)) (bv (length s0))\n\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "have \"\\<dots> = bv (length s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (flip (index s0 r)) (bv (length s0)) = bv (length s0)", "using inv_flip_bv"], ["proof (prove)\nusing this:\n  map_pmf (flip ?i) (bv ?n) = bv ?n\n\ngoal (1 subgoal):\n 1. map_pmf (flip (index s0 r)) (bv (length s0)) = bv (length s0)", "by auto"], ["proof (state)\nthis:\n  map_pmf (flip (index s0 r)) (bv (length s0)) = bv (length s0)\n\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "finally"], ["proof (chain)\npicking this:\n  map_pmf (fst \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  bv (length s0)", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf (fst \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd (BIT_init, BIT_step) s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  bv (length s0)\n\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    bv (length s0)", "."], ["proof (state)\nthis:\n  map_pmf (fst \\<circ> snd)\n   (init \\<bind>\n    (\\<lambda>s.\n        snd BIT s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n  bv (length s0)\n\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (init \\<bind>\n      (\\<lambda>s.\n          snd BIT s r \\<bind>\n          (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))) =\n    return_pmf s0", "qed (fact)"], ["proof (state)\nthis:\n  map_pmf (snd \\<circ> snd) (config'_rand BIT init (r # rs)) =\n  return_pmf s0 \\<and>\n  map_pmf (fst \\<circ> snd) (config'_rand BIT init (r # rs)) =\n  bv (length s0)\n\ngoal (1 subgoal):\n 1. \\<And>init.\n       \\<lbrakk>map_pmf (snd \\<circ> snd) init = return_pmf s0;\n        map_pmf (fst \\<circ> snd) init = bv (length s0)\\<rbrakk>\n       \\<Longrightarrow> map_pmf (snd \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         return_pmf s0 \\<and>\n                         map_pmf (fst \\<circ> snd)\n                          (config'_rand BIT init []) =\n                         bv (length s0)", "qed simp"], ["", "lemma config_n_bv_2: \"map_pmf (snd \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = return_pmf s0\n        \\<and> map_pmf (fst \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = bv (length s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    return_pmf s0 \\<and>\n    map_pmf (fst \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    bv (length s0)", "apply(rule config'_n_bv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_pmf (snd \\<circ> snd)\n     (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) =\n    return_pmf s0\n 2. map_pmf (fst \\<circ> snd)\n     (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) =\n    bv (length s0)", "by(simp_all add: bind_return_pmf map_pmf_def bind_assoc_pmf bind_return_pmf' BIT_init_def)"], ["", "lemma config_n_bv: \"map_pmf (fst \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs) = bv (length s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    bv (length s0)", "using config_n_bv_2"], ["proof (prove)\nusing this:\n  map_pmf (snd \\<circ> snd)\n   (config'_rand BIT\n     (fst BIT ?s0.0 \\<bind> (\\<lambda>is. return_pmf (?s0.0, is))) ?qs) =\n  return_pmf ?s0.0 \\<and>\n  map_pmf (fst \\<circ> snd)\n   (config'_rand BIT\n     (fst BIT ?s0.0 \\<bind> (\\<lambda>is. return_pmf (?s0.0, is))) ?qs) =\n  bv (length ?s0.0)\n\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs) =\n    bv (length s0)", "by auto"], ["", "lemma config_n_fst_init_length: \"\\<forall>(_,(x,_)) \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs). length x = length s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(uu_, x, uu_)\n             \\<in>set_pmf\n                   (config'_rand BIT\n                     (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                     qs).\n       length x = length s0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "fix x::\"('a list \\<times> (bool list \\<times> 'a list))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "assume ass:\"x \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs)\""], ["proof (state)\nthis:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "let ?a=\"fst (snd x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "from ass"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)", "have \"(fst x,(?a,snd (snd x))) \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs)\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. (fst x, fst (snd x), snd (snd x))\n    \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)", "by auto"], ["proof (state)\nthis:\n  (fst x, fst (snd x), snd (snd x))\n  \\<in> set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "with ass"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n  (fst x, fst (snd x), snd (snd x))\n  \\<in> set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)", "have \"?a \\<in> (fst \\<circ> snd) ` set_pmf (config_rand (BIT_init, BIT_step) s0 qs)\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n  (fst x, fst (snd x), snd (snd x))\n  \\<in> set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. fst (snd x)\n    \\<in> (fst \\<circ> snd) `\n          set_pmf\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)", "by force"], ["proof (state)\nthis:\n  fst (snd x)\n  \\<in> (fst \\<circ> snd) `\n        set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "then"], ["proof (chain)\npicking this:\n  fst (snd x)\n  \\<in> (fst \\<circ> snd) `\n        set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)", "have \"?a \\<in> set_pmf (map_pmf (fst \\<circ> snd) (config_rand (BIT_init, BIT_step) s0 qs))\""], ["proof (prove)\nusing this:\n  fst (snd x)\n  \\<in> (fst \\<circ> snd) `\n        set_pmf\n         (config'_rand BIT\n           (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs)\n\ngoal (1 subgoal):\n 1. fst (snd x)\n    \\<in> set_pmf\n           (map_pmf (fst \\<circ> snd)\n             (config'_rand BIT\n               (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs))", "by auto"], ["proof (state)\nthis:\n  fst (snd x)\n  \\<in> set_pmf\n         (map_pmf (fst \\<circ> snd)\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "then"], ["proof (chain)\npicking this:\n  fst (snd x)\n  \\<in> set_pmf\n         (map_pmf (fst \\<circ> snd)\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs))", "have \"?a \\<in> bv (length s0)\""], ["proof (prove)\nusing this:\n  fst (snd x)\n  \\<in> set_pmf\n         (map_pmf (fst \\<circ> snd)\n           (config'_rand BIT\n             (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs))\n\ngoal (1 subgoal):\n 1. fst (snd x) \\<in> set_pmf (bv (length s0))", "by(simp only: config_n_bv)"], ["proof (state)\nthis:\n  fst (snd x) \\<in> set_pmf (bv (length s0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "then"], ["proof (chain)\npicking this:\n  fst (snd x) \\<in> set_pmf (bv (length s0))", "have \"length ?a = length s0\""], ["proof (prove)\nusing this:\n  fst (snd x) \\<in> set_pmf (bv (length s0))\n\ngoal (1 subgoal):\n 1. length (fst (snd x)) = length s0", "by (auto simp: len_bv_n)"], ["proof (state)\nthis:\n  length (fst (snd x)) = length s0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n                  qs) \\<Longrightarrow>\n       case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "then"], ["proof (chain)\npicking this:\n  length (fst (snd x)) = length s0", "show \"case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0\""], ["proof (prove)\nusing this:\n  length (fst (snd x)) = length s0\n\ngoal (1 subgoal):\n 1. case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0", "by(simp add: split_def)"], ["proof (state)\nthis:\n  case x of (uu_, xa, uua_) \\<Rightarrow> length xa = length s0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma config_n_fst_init_length2: \"\\<forall>x \\<in> set_pmf (config_rand (BIT_init, BIT_step) s0 qs). length (fst (snd x)) = length s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT s0 \\<bind>\n                       (\\<lambda>is. return_pmf (s0, is)))\n                      qs).\n       length (fst (snd x)) = length s0", "using config_n_fst_init_length"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x, uu_)\n           \\<in>set_pmf\n                 (config'_rand BIT\n                   (fst BIT ?s0.0 \\<bind>\n                    (\\<lambda>is. return_pmf (?s0.0, is)))\n                   ?qs).\n     length x = length ?s0.0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT s0 \\<bind>\n                       (\\<lambda>is. return_pmf (s0, is)))\n                      qs).\n       length (fst (snd x)) = length s0", "by(simp add: split_def)"], ["", "lemma fperms: \"finite {x::'a list. length x = length init \\<and> distinct x \\<and> set x = set init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. length x = length init \\<and> distinct x \\<and> set x = set init}", "apply(rule finite_subset[where B=\"{xs. set xs \\<subseteq> set init \\<and> length xs \\<le> length init}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. length x = length init \\<and> distinct x \\<and> set x = set init}\n    \\<subseteq> {xs.\n                 set xs \\<subseteq> set init \\<and>\n                 length xs \\<le> length init}\n 2. finite\n     {xs. set xs \\<subseteq> set init \\<and> length xs \\<le> length init}", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {xs. set xs \\<subseteq> set init \\<and> length xs \\<le> length init}", "apply(rule finite_lists_length_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set init)", "by auto"], ["", "lemma finite_config_BIT: assumes [simp]: \"distinct init\"\n  shows \"finite (set_pmf (config_rand (BIT_init, BIT_step) init qs))\" (is \"finite ?D\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "have a: \"(fst \\<circ> snd) ` ?D \\<subseteq> {x. length x = length init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init}", "using config_n_fst_init_length2"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?s0.0 \\<bind>\n                     (\\<lambda>is. return_pmf (?s0.0, is)))\n                    ?qs).\n     length (fst (snd x)) = length ?s0.0\n\ngoal (1 subgoal):\n 1. (fst \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init}", "by force"], ["proof (state)\nthis:\n  (fst \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "have c: \"(snd \\<circ> snd) ` ?D = {init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "have \"(snd \\<circ> snd) ` set_pmf (config_rand (BIT_init, BIT_step) init qs)\n                = set_pmf (map_pmf (snd \\<circ> snd) (config_rand (BIT_init, BIT_step) init qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    set_pmf\n     (map_pmf (snd \\<circ> snd)\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "by(simp)"], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "also"], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "have \"\\<dots> = {init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf\n     (map_pmf (snd \\<circ> snd)\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n    {init}", "apply(subst config_n_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (return_pmf init) = {init}", "by simp"], ["proof (state)\nthis:\n  set_pmf\n   (map_pmf (snd \\<circ> snd)\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)) =\n  {init}\n\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "finally"], ["proof (chain)\npicking this:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}", "show ?thesis"], ["proof (prove)\nusing this:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n\ngoal (1 subgoal):\n 1. (snd \\<circ> snd) `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n    {init}", "."], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "from a c"], ["proof (chain)\npicking this:\n  (fst \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init}\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}", "have d: \"snd ` ?D \\<subseteq> {x. length x = length init} \\<times> {init}\""], ["proof (prove)\nusing this:\n  (fst \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init}\n  (snd \\<circ> snd) `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs) =\n  {init}\n\ngoal (1 subgoal):\n 1. snd `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init} \\<times> {init}", "by force"], ["proof (state)\nthis:\n  snd `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init} \\<times> {init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "have b: \"fst ` ?D \\<subseteq> {x. length x = length init \\<and> distinct x \\<and> set x = set init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init \\<and>\n                    distinct x \\<and> set x = set init}", "using config_rand"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init \\<and>\n     distinct (fst x) = distinct ?init \\<and> length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. fst `\n    set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init \\<and>\n                    distinct x \\<and> set x = set init}", "by fastforce"], ["proof (state)\nthis:\n  fst `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "from b d"], ["proof (chain)\npicking this:\n  fst `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init}\n  snd `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init} \\<times> {init}", "have \"?D \\<subseteq> {x. length x = length init \\<and> distinct x \\<and> set x = set init} \\<times> ({x. length x = length init} \\<times> {init})\""], ["proof (prove)\nusing this:\n  fst `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init}\n  snd `\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init} \\<times> {init}\n\ngoal (1 subgoal):\n 1. set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n    \\<subseteq> {x. length x = length init \\<and>\n                    distinct x \\<and> set x = set init} \\<times>\n                {x. length x = length init} \\<times> {init}", "by auto"], ["proof (state)\nthis:\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init} \\<times>\n              {x. length x = length init} \\<times> {init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "then"], ["proof (chain)\npicking this:\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init} \\<times>\n              {x. length x = length init} \\<times> {init}", "show ?thesis"], ["proof (prove)\nusing this:\n  set_pmf\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n  \\<subseteq> {x. length x = length init \\<and>\n                  distinct x \\<and> set x = set init} \\<times>\n              {x. length x = length init} \\<times> {init}\n\ngoal (1 subgoal):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))", "apply (rule finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({x. length x = length init \\<and>\n          distinct x \\<and> set x = set init} \\<times>\n      {x. length x = length init} \\<times> {init})", "apply(rule finite_cartesian_product)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     {x. length x = length init \\<and> distinct x \\<and> set x = set init}\n 2. finite ({x. length x = length init} \\<times> {init})", "apply(rule fperms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({x. length x = length init} \\<times> {init})", "apply(rule finite_cartesian_product)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. length x = length init}\n 2. finite {init}", "apply (rule bitstrings_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {init}", "by(simp)"], ["proof (state)\nthis:\n  finite\n   (set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"BIT is $1.75$-competitive (a combinatorial proof)\""], ["", "subsubsection \"Definition of the Locale and Helper Functions\""], ["", "locale BIT_Off = \nfixes acts :: \"answer list\"  \nfixes qs :: \"'a list\" \nfixes init :: \"'a list\" \nassumes dist_init[simp]: \"distinct init\"\nassumes len_acts: \"length acts = length qs\"\nbegin"], ["", "lemma setinit: \"(index init) ` set init = {0..<length init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init ` set init = {0..<length init}", "using dist_init"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. index init ` set init = {0..<length init}", "proof(induct init)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "case (Cons a as)"], ["proof (state)\nthis:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "with Cons"], ["proof (chain)\npicking this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)", "have iH: \"index as ` set as = {0..<length as}\""], ["proof (prove)\nusing this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. index as ` set as = {0..<length as}", "by auto"], ["proof (state)\nthis:\n  index as ` set as = {0..<length as}\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "from Cons"], ["proof (chain)\npicking this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)", "have 1:\"(set as \\<inter> {x. (a \\<noteq> x)}) = set as\""], ["proof (prove)\nusing this:\n  distinct as \\<Longrightarrow> index as ` set as = {0..<length as}\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. set as \\<inter> {x. a \\<noteq> x} = set as", "by fastforce"], ["proof (state)\nthis:\n  set as \\<inter> {x. a \\<noteq> x} = set as\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "have 2: \"(\\<lambda>a. Suc (index as a)) ` set as =\n          (\\<lambda>a. Suc a) ` ((index as) ` set as )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Suc (index as a)) ` set as = Suc ` index as ` set as", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>a. Suc (index as a)) ` set as = Suc ` index as ` set as\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}\n 2. \\<And>a init.\n       \\<lbrakk>distinct init \\<Longrightarrow>\n                index init ` set init = {0..<length init};\n        distinct (a # init)\\<rbrakk>\n       \\<Longrightarrow> index (a # init) ` set (a # init) =\n                         {0..<length (a # init)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (a # as) ` set (a # as) = {0..<length (a # as)}", "apply(simp add: 1 2 iH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert 0 {Suc 0..<Suc (length as)} = {0..<Suc (length as)}", "by auto"], ["proof (state)\nthis:\n  index (a # as) ` set (a # as) = {0..<length (a # as)}\n\ngoal (1 subgoal):\n 1. distinct [] \\<Longrightarrow> index [] ` set [] = {0..<length []}", "qed simp"], ["", "definition free_A :: \"nat list\" where      (* free exchanges of A *)\n\"free_A = map fst acts\""], ["", "definition paid_A' :: \"nat list list\" where  (* paid exchanges of A' *)\n\"paid_A' = map snd acts\""], ["", "definition paid_A  :: \"nat list list\" where  (* paid exchanges of A *)\n  \"paid_A  = map (filter (\\<lambda>x. Suc x < length init)) paid_A'\""], ["", "lemma len_paid_A[simp]: \"length paid_A = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length paid_A = length qs", "unfolding paid_A_def paid_A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (filter (\\<lambda>x. Suc x < length init)) (map snd acts)) =\n    length qs", "using len_acts"], ["proof (prove)\nusing this:\n  length acts = length qs\n\ngoal (1 subgoal):\n 1. length (map (filter (\\<lambda>x. Suc x < length init)) (map snd acts)) =\n    length qs", "by auto"], ["", "lemma len_paid_A'[simp]: \"length paid_A' = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length paid_A' = length qs", "unfolding paid_A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map snd acts) = length qs", "using len_acts"], ["proof (prove)\nusing this:\n  length acts = length qs\n\ngoal (1 subgoal):\n 1. length (map snd acts) = length qs", "by auto"], ["", "lemma paidAnm_inbound: \"n < length paid_A \\<Longrightarrow> m < length(paid_A!n) \\<Longrightarrow> (Suc ((paid_A!n)!(length (paid_A ! n) - Suc m))) < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "assume \"n < length paid_A\""], ["proof (state)\nthis:\n  n < length paid_A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "then"], ["proof (chain)\npicking this:\n  n < length paid_A", "have \"n < length paid_A'\""], ["proof (prove)\nusing this:\n  n < length paid_A\n\ngoal (1 subgoal):\n 1. n < length paid_A'", "by auto"], ["proof (state)\nthis:\n  n < length paid_A'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "then"], ["proof (chain)\npicking this:\n  n < length paid_A'", "have a: \"(paid_A!n)\n      = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)\""], ["proof (prove)\nusing this:\n  n < length paid_A'\n\ngoal (1 subgoal):\n 1. paid_A ! n = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)", "unfolding paid_A_def"], ["proof (prove)\nusing this:\n  n < length paid_A'\n\ngoal (1 subgoal):\n 1. map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n =\n    filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)", "by auto"], ["proof (state)\nthis:\n  paid_A ! n = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "let ?filtered=\"(filter (\\<lambda>x. Suc x < length init) (paid_A' ! n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "assume mtt: \"m < length (paid_A!n)\""], ["proof (state)\nthis:\n  m < length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "with a"], ["proof (chain)\npicking this:\n  paid_A ! n = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)\n  m < length (paid_A ! n)", "have \"(length (paid_A ! n) - Suc m) < length ?filtered\""], ["proof (prove)\nusing this:\n  paid_A ! n = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)\n  m < length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. length (paid_A ! n) - Suc m\n    < length (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n))", "by auto"], ["proof (state)\nthis:\n  length (paid_A ! n) - Suc m\n  < length (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "with nth_mem"], ["proof (chain)\npicking this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  length (paid_A ! n) - Suc m\n  < length (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n))", "have b: \"Suc(?filtered ! (length (paid_A ! n) - Suc m)) < length init\""], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  length (paid_A ! n) - Suc m\n  < length (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n))\n\ngoal (1 subgoal):\n 1. Suc (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n) !\n         (length (paid_A ! n) - Suc m))\n    < length init", "by force"], ["proof (state)\nthis:\n  Suc (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n) !\n       (length (paid_A ! n) - Suc m))\n  < length init\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length paid_A; m < length (paid_A ! n)\\<rbrakk>\n    \\<Longrightarrow> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                      < length init", "show \"Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length init", "using a b"], ["proof (prove)\nusing this:\n  paid_A ! n = filter (\\<lambda>x. Suc x < length init) (paid_A' ! n)\n  Suc (filter (\\<lambda>x. Suc x < length init) (paid_A' ! n) !\n       (length (paid_A ! n) - Suc m))\n  < length init\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length init", "by auto"], ["proof (state)\nthis:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length init\n\ngoal:\nNo subgoals!", "qed"], ["", "fun s_A' :: \"nat \\<Rightarrow> 'a list\" where \n\"s_A' 0 = init\" |\n\"s_A'(Suc n) = step (s_A' n) (qs!n) (free_A!n, paid_A'!n)\""], ["", "lemma length_s_A'[simp]: \"length(s_A' n) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s_A' n) = length init", "by (induction n) simp_all"], ["", "lemma dist_s_A'[simp]: \"distinct(s_A' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (s_A' n)", "by(induction n) (simp_all add: step_def)"], ["", "lemma set_s_A'[simp]: \"set(s_A' n) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s_A' n) = set init", "by(induction n) (simp_all add: step_def)"], ["", "fun s_A  :: \"nat \\<Rightarrow> 'a list\" where  \n\"s_A 0 = init\" |\n\"s_A(Suc n) = step (s_A n) (qs!n) (free_A!n, paid_A!n)\""], ["", "lemma length_s_A[simp]: \"length(s_A n) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s_A n) = length init", "by (induction n) simp_all"], ["", "lemma dist_s_A[simp]: \"distinct(s_A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (s_A n)", "by(induction n) (simp_all add: step_def)"], ["", "lemma set_s_A[simp]: \"set(s_A n) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s_A n) = set init", "by(induction n) (simp_all add: step_def)"], ["", "lemma cost_paidAA': \"n < length paid_A' \\<Longrightarrow> length (paid_A!n) \\<le> length (paid_A'!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A' \\<Longrightarrow>\n    length (paid_A ! n) \\<le> length (paid_A' ! n)", "unfolding paid_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A' \\<Longrightarrow>\n    length (map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n)\n    \\<le> length (paid_A' ! n)", "by simp"], ["", "lemma swaps_filtered: \"swaps (filter (\\<lambda>x. Suc x < length xs) ys) xs = swaps (ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (filter (\\<lambda>x. Suc x < length xs) ys) xs = swaps ys xs", "apply (induct ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. swaps (filter (\\<lambda>x. Suc x < length xs) []) xs = swaps [] xs\n 2. \\<And>a ys.\n       swaps (filter (\\<lambda>x. Suc x < length xs) ys) xs =\n       swaps ys xs \\<Longrightarrow>\n       swaps (filter (\\<lambda>x. Suc x < length xs) (a # ys)) xs =\n       swaps (a # ys) xs", "by auto"], ["", "lemma sAsA': \"n < length paid_A' \\<Longrightarrow> s_A' n = s_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A' \\<Longrightarrow> s_A' n = s_A n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "case (Suc m)"], ["proof (state)\nthis:\n  m < length paid_A' \\<Longrightarrow> s_A' m = s_A m\n  Suc m < length paid_A'\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "have \" s_A' (Suc m)\n        =  mtf2 (free_A!m) (qs!m) (swaps (paid_A'!m) (s_A' m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_A' (Suc m) = mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m))", "by (simp add: step_def)"], ["proof (state)\nthis:\n  s_A' (Suc m) = mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "also"], ["proof (state)\nthis:\n  s_A' (Suc m) = mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "from Suc(2)"], ["proof (chain)\npicking this:\n  Suc m < length paid_A'", "have \"\\<dots> = mtf2 (free_A!m) (qs!m) (swaps (paid_A!m) (s_A' m))\""], ["proof (prove)\nusing this:\n  Suc m < length paid_A'\n\ngoal (1 subgoal):\n 1. mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m)) =\n    mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m))", "unfolding paid_A_def"], ["proof (prove)\nusing this:\n  Suc m < length paid_A'\n\ngoal (1 subgoal):\n 1. mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m)) =\n    mtf2 (free_A ! m) (qs ! m)\n     (swaps (map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! m)\n       (s_A' m))", "by (simp only: nth_map swaps_filtered[where xs=\"s_A' m\", simplified])"], ["proof (state)\nthis:\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m)) =\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "also"], ["proof (state)\nthis:\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A' ! m) (s_A' m)) =\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "have \"\\<dots> = mtf2 (free_A!m) (qs!m) (swaps (paid_A!m) (s_A m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m)) =\n    mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m))", "using Suc"], ["proof (prove)\nusing this:\n  m < length paid_A' \\<Longrightarrow> s_A' m = s_A m\n  Suc m < length paid_A'\n\ngoal (1 subgoal):\n 1. mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m)) =\n    mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m))", "by auto"], ["proof (state)\nthis:\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m)) =\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "also"], ["proof (state)\nthis:\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A' m)) =\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m))\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "have \"\\<dots> = s_A (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m)) = s_A (Suc m)", "by (simp add: step_def)"], ["proof (state)\nthis:\n  mtf2 (free_A ! m) (qs ! m) (swaps (paid_A ! m) (s_A m)) = s_A (Suc m)\n\ngoal (2 subgoals):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0\n 2. \\<And>n.\n       \\<lbrakk>n < length paid_A' \\<Longrightarrow> s_A' n = s_A n;\n        Suc n < length paid_A'\\<rbrakk>\n       \\<Longrightarrow> s_A' (Suc n) = s_A (Suc n)", "finally"], ["proof (chain)\npicking this:\n  s_A' (Suc m) = s_A (Suc m)", "show ?case"], ["proof (prove)\nusing this:\n  s_A' (Suc m) = s_A (Suc m)\n\ngoal (1 subgoal):\n 1. s_A' (Suc m) = s_A (Suc m)", "."], ["proof (state)\nthis:\n  s_A' (Suc m) = s_A (Suc m)\n\ngoal (1 subgoal):\n 1. 0 < length paid_A' \\<Longrightarrow> s_A' 0 = s_A 0", "qed simp"], ["", "lemma sAsA'': \"n < length qs \\<Longrightarrow> s_A n =  s_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow> s_A n = s_A' n", "using sAsA'"], ["proof (prove)\nusing this:\n  ?n < length paid_A' \\<Longrightarrow> s_A' ?n = s_A ?n\n\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow> s_A n = s_A' n", "by auto"], ["", "definition t_BIT :: \"nat \\<Rightarrow> real\" where   (* BIT's cost in nth step *)\n\"t_BIT n = T_on_rand_n BIT init qs n\""], ["", "definition T_BIT :: \"nat \\<Rightarrow> real\" where   (* BIT's cost in first n steps *)\n\"T_BIT n = (\\<Sum>i<n. t_BIT i)\""], ["", "definition c_A :: \"nat \\<Rightarrow> int\" where \n\"c_A n = index (swaps (paid_A!n) (s_A n)) (qs!n) + 1\""], ["", "definition f_A :: \"nat \\<Rightarrow> int\" where \n\"f_A n = min (free_A!n) (index (swaps (paid_A!n) (s_A n)) (qs!n))\""], ["", "definition p_A :: \"nat \\<Rightarrow> int\" where  \n\"p_A n = size(paid_A!n)\""], ["", "definition t_A :: \"nat \\<Rightarrow> int\" where  \n\"t_A n = c_A n + p_A n\""], ["", "definition c_A' :: \"nat \\<Rightarrow> int\" where  \n\"c_A' n = index (swaps (paid_A'!n) (s_A' n)) (qs!n) + 1\""], ["", "definition p_A' :: \"nat \\<Rightarrow> int\" where \n\"p_A' n = size(paid_A'!n)\""], ["", "definition t_A' :: \"nat \\<Rightarrow> int\"  where  \n\"t_A' n = c_A' n + p_A' n\""], ["", "lemma t_A_A'_leq: \"n < length paid_A' \\<Longrightarrow> t_A n \\<le> t_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A' \\<Longrightarrow> t_A n \\<le> t_A' n", "unfolding t_A_def t_A'_def c_A_def c_A'_def p_A_def p_A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A' \\<Longrightarrow>\n    int (index (swaps (paid_A ! n) (s_A n)) (qs ! n) + 1) +\n    int (length (paid_A ! n))\n    \\<le> int (index (swaps (paid_A' ! n) (s_A' n)) (qs ! n) + 1) +\n          int (length (paid_A' ! n))", "apply(simp add: sAsA')"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    int (index (swaps (paid_A ! n) (s_A n)) (qs ! n)) +\n    int (length (paid_A ! n))\n    \\<le> int (index (swaps (paid_A' ! n) (s_A n)) (qs ! n)) +\n          int (length (paid_A' ! n))", "unfolding paid_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    int (index\n          (swaps\n            (map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n)\n            (s_A n))\n          (qs ! n)) +\n    int (length\n          (map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n))\n    \\<le> int (index (swaps (paid_A' ! n) (s_A n)) (qs ! n)) +\n          int (length (paid_A' ! n))", "by (simp add: swaps_filtered[where xs=\"(s_A n)\", simplified])"], ["", "definition T_A' :: \"nat \\<Rightarrow> int\" where \n\"T_A' n = (\\<Sum>i<n. t_A' i)\""], ["", "definition T_A :: \"nat \\<Rightarrow> int\" where \n\"T_A n = (\\<Sum>i<n. t_A i)\""], ["", "lemma T_A_A'_leq: \"n \\<le> length paid_A' \\<Longrightarrow> T_A n \\<le> T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length paid_A' \\<Longrightarrow> T_A n \\<le> T_A' n", "unfolding T_A'_def T_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length paid_A' \\<Longrightarrow>\n    sum t_A {..<n} \\<le> sum t_A' {..<n}", "apply(rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> length paid_A'; i \\<in> {..<n}\\<rbrakk>\n       \\<Longrightarrow> t_A i \\<le> t_A' i", "by (simp add: t_A_A'_leq)"], ["", "lemma T_A_A'_leq': \"n \\<le> length qs \\<Longrightarrow> T_A n \\<le> T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length qs \\<Longrightarrow> T_A n \\<le> T_A' n", "using T_A_A'_leq"], ["proof (prove)\nusing this:\n  ?n \\<le> length paid_A' \\<Longrightarrow> T_A ?n \\<le> T_A' ?n\n\ngoal (1 subgoal):\n 1. n \\<le> length qs \\<Longrightarrow> T_A n \\<le> T_A' n", "by auto"], ["", "fun s'_A :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n\"s'_A n 0 = s_A n\" \n| \"(s'_A n (Suc m)) = swap ((paid_A  ! n)!(length (paid_A  ! n) -(Suc m)) ) (s'_A n m)\""], ["", "lemma set_s'_A[simp]: \"set (s'_A n m) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s'_A n m) = set init", "apply(induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (s'_A n 0) = set init\n 2. \\<And>m.\n       set (s'_A n m) = set init \\<Longrightarrow>\n       set (s'_A n (Suc m)) = set init", "by(auto)"], ["", "lemma len_s'_A[simp]: \"length (s'_A n m) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s'_A n m) = length init", "apply(induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (s'_A n 0) = length init\n 2. \\<And>m.\n       length (s'_A n m) = length init \\<Longrightarrow>\n       length (s'_A n (Suc m)) = length init", "by(auto)"], ["", "lemma distperm_s'_A[simp]: \"dist_perm (s'_A n m) init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm (s'_A n m) init", "apply(induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist_perm (s'_A n 0) init\n 2. \\<And>m.\n       dist_perm (s'_A n m) init \\<Longrightarrow>\n       dist_perm (s'_A n (Suc m)) init", "by auto"], ["", "lemma s'A_m_le: \"m \\<le> (length (paid_A ! n)) \\<Longrightarrow> swaps (drop (length (paid_A  ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length (paid_A ! n) \\<Longrightarrow>\n    swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m", "apply(induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    swaps (drop (length (paid_A ! n) - 0) (paid_A ! n)) (s_A n) = s'_A n 0\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "assume iH: \"(m \\<le> length (paid_A ! n) \\<Longrightarrow> swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m)\""], ["proof (state)\nthis:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "assume Suc: \"Suc m \\<le> length (paid_A ! n)\""], ["proof (state)\nthis:\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "then"], ["proof (chain)\npicking this:\n  Suc m \\<le> length (paid_A ! n)", "have \"m \\<le> length (paid_A ! n)\""], ["proof (prove)\nusing this:\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. m \\<le> length (paid_A ! n)", "by auto"], ["proof (state)\nthis:\n  m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "with iH"], ["proof (chain)\npicking this:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\n  m \\<le> length (paid_A ! n)", "have x: \"swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\""], ["proof (prove)\nusing this:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\n  m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m", "by auto"], ["proof (state)\nthis:\n  swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n) = s'_A n m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "from Suc"], ["proof (chain)\npicking this:\n  Suc m \\<le> length (paid_A ! n)", "have mlen: \"(length (paid_A ! n) - Suc m) < length (paid_A ! n)\""], ["proof (prove)\nusing this:\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. length (paid_A ! n) - Suc m < length (paid_A ! n)", "by auto"], ["proof (state)\nthis:\n  length (paid_A ! n) - Suc m < length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "let ?l=\"length (paid_A ! n) - Suc m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "let ?Sucl=\"length (paid_A ! n) - m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "have Sucl: \"Suc ?l = ?Sucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length (paid_A ! n) - Suc m) = length (paid_A ! n) - m", "using Suc"], ["proof (prove)\nusing this:\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. Suc (length (paid_A ! n) - Suc m) = length (paid_A ! n) - m", "by auto"], ["proof (state)\nthis:\n  Suc (length (paid_A ! n) - Suc m) = length (paid_A ! n) - m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "from mlen"], ["proof (chain)\npicking this:\n  length (paid_A ! n) - Suc m < length (paid_A ! n)", "have yu:  \"((paid_A  ! n)! ?l ) # (drop (Suc ?l) (paid_A ! n))\n        = (drop ?l (paid_A ! n))\""], ["proof (prove)\nusing this:\n  length (paid_A ! n) - Suc m < length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n) =\n    drop (length (paid_A ! n) - Suc m) (paid_A ! n)", "by (rule Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  paid_A ! n ! (length (paid_A ! n) - Suc m) #\n  drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n) =\n  drop (length (paid_A ! n) - Suc m) (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "from Suc"], ["proof (chain)\npicking this:\n  Suc m \\<le> length (paid_A ! n)", "have \"s'_A n (Suc m)\n      = swap ((paid_A  ! n)!(length (paid_A  ! n) - (Suc m)) ) (s'_A n m)\""], ["proof (prove)\nusing this:\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. s'_A n (Suc m) =\n    swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m)", "by auto"], ["proof (state)\nthis:\n  s'_A n (Suc m) =\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "also"], ["proof (state)\nthis:\n  s'_A n (Suc m) =\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "have \"\\<dots> = swap ((paid_A  ! n)!(length (paid_A  ! n) - (Suc m)) )\n                    (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m) =\n    swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n     (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n))", "by(simp only: x)"], ["proof (state)\nthis:\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m) =\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n   (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "also"], ["proof (state)\nthis:\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m) =\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n   (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "have \"\\<dots> = (swaps (((paid_A  ! n)!(length (paid_A  ! n) - (Suc m)) ) # (drop (length (paid_A ! n) - m) (paid_A ! n))) (s_A n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n     (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n)) =\n    swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (length (paid_A ! n) - m) (paid_A ! n))\n     (s_A n)", "by auto"], ["proof (state)\nthis:\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n   (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n)) =\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (length (paid_A ! n) - m) (paid_A ! n))\n   (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "also"], ["proof (state)\nthis:\n  swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n   (swaps (drop (length (paid_A ! n) - m) (paid_A ! n)) (s_A n)) =\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (length (paid_A ! n) - m) (paid_A ! n))\n   (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "have \"\\<dots> = (swaps (((paid_A  ! n)! ?l ) # (drop (Suc ?l) (paid_A ! n))) (s_A n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (length (paid_A ! n) - m) (paid_A ! n))\n     (s_A n) =\n    swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n     (s_A n)", "using Sucl"], ["proof (prove)\nusing this:\n  Suc (length (paid_A ! n) - Suc m) = length (paid_A ! n) - m\n\ngoal (1 subgoal):\n 1. swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (length (paid_A ! n) - m) (paid_A ! n))\n     (s_A n) =\n    swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n     (s_A n)", "by auto"], ["proof (state)\nthis:\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (length (paid_A ! n) - m) (paid_A ! n))\n   (s_A n) =\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n   (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "also"], ["proof (state)\nthis:\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (length (paid_A ! n) - m) (paid_A ! n))\n   (s_A n) =\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n   (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "from mlen"], ["proof (chain)\npicking this:\n  length (paid_A ! n) - Suc m < length (paid_A ! n)", "have \"\\<dots> = (swaps ((drop ?l (paid_A ! n))) (s_A n))\""], ["proof (prove)\nusing this:\n  length (paid_A ! n) - Suc m < length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. swaps\n     (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n      drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n     (s_A n) =\n    swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)", "by (simp only: yu)"], ["proof (state)\nthis:\n  swaps\n   (paid_A ! n ! (length (paid_A ! n) - Suc m) #\n    drop (Suc (length (paid_A ! n) - Suc m)) (paid_A ! n))\n   (s_A n) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "finally"], ["proof (chain)\npicking this:\n  s'_A n (Suc m) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)", "have \" s'_A n (Suc m) = swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)\""], ["proof (prove)\nusing this:\n  s'_A n (Suc m) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)\n\ngoal (1 subgoal):\n 1. s'_A n (Suc m) =\n    swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)", "."], ["proof (state)\nthis:\n  s'_A n (Suc m) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                swaps (drop (length (paid_A ! n) - m) (paid_A ! n))\n                 (s_A n) =\n                s'_A n m;\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> swaps\n                          (drop (length (paid_A ! n) - Suc m) (paid_A ! n))\n                          (s_A n) =\n                         s'_A n (Suc m)", "then"], ["proof (chain)\npicking this:\n  s'_A n (Suc m) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)", "show \" swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n) = s'_A n (Suc m)\""], ["proof (prove)\nusing this:\n  s'_A n (Suc m) =\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n)\n\ngoal (1 subgoal):\n 1. swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n) =\n    s'_A n (Suc m)", "by auto"], ["proof (state)\nthis:\n  swaps (drop (length (paid_A ! n) - Suc m) (paid_A ! n)) (s_A n) =\n  s'_A n (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s'A_m: \"swaps (paid_A ! n) (s_A n) = s'_A n (length (paid_A ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (paid_A ! n) (s_A n) = s'_A n (length (paid_A ! n))", "using s'A_m_le[of \"(length (paid_A ! n))\" \"n\", simplified]"], ["proof (prove)\nusing this:\n  swaps (paid_A ! n) (s_A n) = s'_A n (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. swaps (paid_A ! n) (s_A n) = s'_A n (length (paid_A ! n))", "by auto"], ["", "definition gebub :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"gebub n m = index init ((s'_A n m)!(Suc ((paid_A!n)!(length (paid_A ! n) - Suc m))))\""], ["", "lemma gebub_inBound: assumes 1: \" n < length paid_A \" and  2: \"m < length (paid_A !  n)\" \n          shows \"gebub n m < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gebub n m < length init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gebub n m < length init", "have \"Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)", "using paidAnm_inbound[OF 1 2]"], ["proof (prove)\nusing this:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length init\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)", "by auto"], ["proof (state)\nthis:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)\n\ngoal (1 subgoal):\n 1. gebub n m < length init", "then"], ["proof (chain)\npicking this:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)", "have \"s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) \\<in> set (s'_A n m)\""], ["proof (prove)\nusing this:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length (s'_A n m)\n\ngoal (1 subgoal):\n 1. s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    \\<in> set (s'_A n m)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n  \\<in> set (s'_A n m)\n\ngoal (1 subgoal):\n 1. gebub n m < length init", "then"], ["proof (chain)\npicking this:\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n  \\<in> set (s'_A n m)", "show ?thesis"], ["proof (prove)\nusing this:\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n  \\<in> set (s'_A n m)\n\ngoal (1 subgoal):\n 1. gebub n m < length init", "unfolding gebub_def"], ["proof (prove)\nusing this:\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n  \\<in> set (s'_A n m)\n\ngoal (1 subgoal):\n 1. index init (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    < length init", "using setinit"], ["proof (prove)\nusing this:\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n  \\<in> set (s'_A n m)\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    < length init", "by auto"], ["proof (state)\nthis:\n  gebub n m < length init\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"The Potential Function\""], ["", "fun phi :: \"nat \\<Rightarrow>'a list\\<times>  (bool list \\<times> 'a list)  \\<Rightarrow> real\" (\"\\<phi>\")  where\n\"phi n (c,(b,_)) = (\\<Sum>(x,y)\\<in>(Inv c (s_A n)). (if b!(index init y) then 2 else 1))\""], ["", "lemma phi': \"phi n z = (\\<Sum>(x,y)\\<in>(Inv (fst z) (s_A n)). (if (fst (snd z))!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "have \"phi n z = phi n (fst z, (fst(snd z),snd(snd z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> n z = \\<phi> n (fst z, fst (snd z), snd (snd z))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  \\<phi> n z = \\<phi> n (fst z, fst (snd z), snd (snd z))\n\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  \\<phi> n z = \\<phi> n (fst z, fst (snd z), snd (snd z))\n\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>(Inv (fst z) (s_A n)). (if (fst (snd z))!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> n (fst z, fst (snd z), snd (snd z)) =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "by(simp del: prod.collapse)"], ["proof (state)\nthis:\n  \\<phi> n (fst z, fst (snd z), snd (snd z)) =\n  (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n     if fst (snd z) ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  \\<phi> n z =\n  (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n     if fst (snd z) ! index init y then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> n z =\n  (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n     if fst (snd z) ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<phi> n z =\n    (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n       if fst (snd z) ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  \\<phi> n z =\n  (\\<Sum>(x, y)\\<in>Inv (fst z) (s_A n).\n     if fst (snd z) ! index init y then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Inv_empty2: \"length d = 0 \\<Longrightarrow> Inv c d = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length d = 0 \\<Longrightarrow> Inv c d = {}", "unfolding Inv_def before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length d = 0 \\<Longrightarrow>\n    {(x, y).\n     (index c x < index c y \\<and> y \\<in> set c) \\<and>\n     index d y < index d x \\<and> x \\<in> set d} =\n    {}", "by(auto)"], ["", "corollary Inv_empty3: \"length init = 0 \\<Longrightarrow> Inv c (s_A n) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length init = 0 \\<Longrightarrow> Inv c (s_A n) = {}", "apply(rule Inv_empty2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length init = 0 \\<Longrightarrow> length (s_A n) = 0", "by (metis length_s_A)"], ["", "lemma phi_empty2: \"length init = 0 \\<Longrightarrow> phi n (c,(b,i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length init = 0 \\<Longrightarrow> \\<phi> n (c, b, i) = 0", "apply(simp only: phi.simps Inv_empty3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length init = 0 \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>{}. if b ! index init y then 2 else 1) = 0", "by auto"], ["", "lemma phi_nonzero: \"phi n (c,(b,i)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> n (c, b, i)", "by (simp add: sum_nonneg split_def)"], ["", "(* definition of the potential function! *)"], ["", "definition Phi :: \"nat \\<Rightarrow> real\" (\"\\<Phi>\") where\n\"Phi n = E( map_pmf (\\<phi> n) (config'' BIT qs init n))\""], ["", "definition PhiPlus :: \"nat \\<Rightarrow> real\" (\"\\<Phi>\\<^sup>+\") where\n\"PhiPlus n = (let\n        nextconfig = bind_pmf (config'' BIT qs init n)\n                (\\<lambda>(s,is). bind_pmf  (BIT_step (s,is) (qs!n)) (\\<lambda>(a,nis). return_pmf (step s (qs!n) a,nis)) ) \n                 in\n        E( map_pmf (phi (Suc n)) nextconfig) )\""], ["", "lemma PhiPlus_is_Phi_Suc: \"n<length qs \\<Longrightarrow> PhiPlus n = Phi (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow> \\<Phi>\\<^sup>+ n = \\<Phi> (Suc n)", "unfolding PhiPlus_def Phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    (let nextconfig =\n           config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take n qs) \\<bind>\n           (\\<lambda>(s, is).\n               BIT_step (s, is) (qs ! n) \\<bind>\n               (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis)))\n     in E (map_pmf (\\<phi> (Suc n)) nextconfig)) =\n    E (map_pmf (\\<phi> (Suc n))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take (Suc n) qs)))", "apply (simp add: bind_return_pmf map_pmf_def bind_assoc_pmf split_def take_Suc_conv_app_nth )"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>x.\n           BIT_step x (qs ! n) \\<bind>\n           (\\<lambda>xa.\n               return_pmf\n                (\\<phi> (Suc n)\n                  (step (fst x) (qs ! n) (fst xa), snd xa))))) =\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs @ [qs ! n]) \\<bind>\n       (\\<lambda>x. return_pmf (\\<phi> (Suc n) x)))", "apply(simp add: config'_rand_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>x.\n           BIT_step x (qs ! n) \\<bind>\n           (\\<lambda>xa.\n               return_pmf\n                (\\<phi> (Suc n)\n                  (step (fst x) (qs ! n) (fst xa), snd xa))))) =\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s.\n           BIT_step s (qs ! n) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (step (fst s) (qs ! n) a, is'))) \\<bind>\n       (\\<lambda>x. return_pmf (\\<phi> (Suc n) x)))", "by(simp add: bind_assoc_pmf split_def bind_return_pmf)"], ["", "lemma phi0: \"Phi 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> 0 = 0", "unfolding Phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<phi> 0)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take 0 qs))) =\n    0", "by (simp add: bind_return_pmf map_pmf_def bind_assoc_pmf BIT_init_def)"], ["", "lemma phi_pos: \"Phi n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> n", "unfolding Phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> E (map_pmf (\\<phi> n)\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)))", "apply(rule E_nonneg_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       0 \\<le> \\<phi> n x", "using phi_nonzero"], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> ?n (?c, ?b, ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       0 \\<le> \\<phi> n x", "by auto"], ["", "subsubsection \"Helper lemmas\""], ["", "lemma swap_subs: \"dist_perm X Y \\<Longrightarrow> Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm X Y \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist_perm X Y \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "assume \"dist_perm X Y\""], ["proof (state)\nthis:\n  dist_perm X Y\n\ngoal (1 subgoal):\n 1. dist_perm X Y \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "note aj = Inv_swap[OF this, of z]"], ["proof (state)\nthis:\n  Inv X (swap z Y) =\n  (if Suc z < length X\n   then if Y ! z < Y ! Suc z in X then Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n        else Inv X Y - {(Y ! Suc z, Y ! z)}\n   else Inv X Y)\n\ngoal (1 subgoal):\n 1. dist_perm X Y \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "show \"Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n 2. \\<not> ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "assume c1: \"Suc z < length X\""], ["proof (state)\nthis:\n  Suc z < length X\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n 2. \\<not> ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "show \"Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n 2. \\<not> ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "assume \"Y ! z < Y ! Suc z in X\""], ["proof (state)\nthis:\n  Y ! z < Y ! Suc z in X\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n 2. \\<not> ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "with c1"], ["proof (chain)\npicking this:\n  Suc z < length X\n  Y ! z < Y ! Suc z in X", "have \"Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\nusing this:\n  Suc z < length X\n  Y ! z < Y ! Suc z in X\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "using aj"], ["proof (prove)\nusing this:\n  Suc z < length X\n  Y ! z < Y ! Suc z in X\n  Inv X (swap z Y) =\n  (if Suc z < length X\n   then if Y ! z < Y ! Suc z in X then Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n        else Inv X Y - {(Y ! Suc z, Y ! z)}\n   else Inv X Y)\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n 2. \\<not> ?P \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "then"], ["proof (chain)\npicking this:\n  Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "show \"Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\nusing this:\n  Inv X (swap z Y) = Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal (1 subgoal):\n 1. \\<not> Y ! z < Y ! Suc z in X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Y ! z < Y ! Suc z in X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "assume \"~ Y ! z < Y ! Suc z in X\""], ["proof (state)\nthis:\n  \\<not> Y ! z < Y ! Suc z in X\n\ngoal (1 subgoal):\n 1. \\<not> Y ! z < Y ! Suc z in X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "with c1"], ["proof (chain)\npicking this:\n  Suc z < length X\n  \\<not> Y ! z < Y ! Suc z in X", "have \"Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}\""], ["proof (prove)\nusing this:\n  Suc z < length X\n  \\<not> Y ! z < Y ! Suc z in X\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}", "using aj"], ["proof (prove)\nusing this:\n  Suc z < length X\n  \\<not> Y ! z < Y ! Suc z in X\n  Inv X (swap z Y) =\n  (if Suc z < length X\n   then if Y ! z < Y ! Suc z in X then Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n        else Inv X Y - {(Y ! Suc z, Y ! z)}\n   else Inv X Y)\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}\n\ngoal (1 subgoal):\n 1. \\<not> Y ! z < Y ! Suc z in X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "then"], ["proof (chain)\npicking this:\n  Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}", "show \"Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\nusing this:\n  Inv X (swap z Y) = Inv X Y - {(Y ! Suc z, Y ! z)}\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal (1 subgoal):\n 1. \\<not> Suc z < length X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc z < length X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "assume \"~ (Suc z < length X)\""], ["proof (state)\nthis:\n  \\<not> Suc z < length X\n\ngoal (1 subgoal):\n 1. \\<not> Suc z < length X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc z < length X", "have \"Inv X (swap z Y) = Inv X Y\""], ["proof (prove)\nusing this:\n  \\<not> Suc z < length X\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y", "using aj"], ["proof (prove)\nusing this:\n  \\<not> Suc z < length X\n  Inv X (swap z Y) =\n  (if Suc z < length X\n   then if Y ! z < Y ! Suc z in X then Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n        else Inv X Y - {(Y ! Suc z, Y ! z)}\n   else Inv X Y)\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) = Inv X Y", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) = Inv X Y\n\ngoal (1 subgoal):\n 1. \\<not> Suc z < length X \\<Longrightarrow>\n    Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "then"], ["proof (chain)\npicking this:\n  Inv X (swap z Y) = Inv X Y", "show \"Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\""], ["proof (prove)\nusing this:\n  Inv X (swap z Y) = Inv X Y\n\ngoal (1 subgoal):\n 1. Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}", "by auto"], ["proof (state)\nthis:\n  Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Inv X (swap z Y) \\<subseteq> Inv X Y \\<union> {(Y ! z, Y ! Suc z)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"InvOf\""], ["", "term \"Inv\""], ["", "(*    BIT A *)"], ["", "abbreviation \"InvOf y bits as \\<equiv> {(x,y)|x. x < y in bits \\<and> y < x in as}\""], ["", "lemma \"InvOf y xs ys = {(x,y)|x. (x,y)\\<in>Inv xs ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |x. x < y in xs \\<and> y < x in ys} =\n    {(x, y) |x. (x, y) \\<in> Inv xs ys}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |x. x < y in xs \\<and> y < x in ys} =\n    {(x, y) |x. (x, y) \\<in> {(x, y). x < y in xs \\<and> y < x in ys}}", "by auto"], ["", "lemma \"InvOf y xs ys \\<subseteq> Inv xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |x. x < y in xs \\<and> y < x in ys} \\<subseteq> Inv xs ys", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> {(x, y). x < y in xs \\<and> y < x in ys}", "by auto"], ["", "lemma numberofIsbeschr: assumes\n    distxsys: \"dist_perm xs ys\" and\n    yinxs: \"y \\<in> set xs\"\n  shows \"index xs y \\<le> index ys y + card (InvOf y xs ys)\" \n    (is \"?iBit \\<le> ?iA + card ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "from assms"], ["proof (chain)\npicking this:\n  dist_perm xs ys\n  y \\<in> set xs", "have distinctxs: \"distinct xs\" \n      and distinctys: \"distinct ys\"\n      and yinys: \"y \\<in> set ys\""], ["proof (prove)\nusing this:\n  dist_perm xs ys\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. distinct xs &&& distinct ys &&& y \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  distinct xs\n  distinct ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "let ?A=\"fst ` ?I\""], ["proof (state)\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have aha: \"card ?A = card ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}) =\n    card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "apply(rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst {(x, y) |x. x < y in xs \\<and> y < x in ys}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y) |x. x < y in xs \\<and> y < x in ys}.\n       \\<forall>y\\<in>{(x, y) |x. x < y in xs \\<and> y < x in ys}.\n          fst x = fst y \\<longrightarrow> x = y", "by(auto)"], ["proof (state)\nthis:\n  card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}) =\n  card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"?A \\<subseteq> (before y xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> before y xs", "by(auto)"], ["proof (state)\nthis:\n  fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys} \\<subseteq> before y xs\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"?A \\<subseteq> (after y ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys} \\<subseteq> after y ys", "by auto"], ["proof (state)\nthis:\n  fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys} \\<subseteq> after y ys\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"finite (before y ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (before y ys)", "by auto"], ["proof (state)\nthis:\n  finite (before y ys)\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have bef: \"(before y xs) - ?A \\<subseteq> before y ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> before y ys", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "assume a: \"x < y in xs\""], ["proof (state)\nthis:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "assume \" x \\<notin> fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\""], ["proof (state)\nthis:\n  x \\<notin> fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "then"], ["proof (chain)\npicking this:\n  x \\<notin> fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"~ (x < y in xs \\<and> y < x in ys)\""], ["proof (prove)\nusing this:\n  x \\<notin> fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n\ngoal (1 subgoal):\n 1. \\<not> (x < y in xs \\<and> y < x in ys)", "by force"], ["proof (state)\nthis:\n  \\<not> (x < y in xs \\<and> y < x in ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "with a"], ["proof (chain)\npicking this:\n  x < y in xs\n  \\<not> (x < y in xs \\<and> y < x in ys)", "have d: \"~ y < x in ys\""], ["proof (prove)\nusing this:\n  x < y in xs\n  \\<not> (x < y in xs \\<and> y < x in ys)\n\ngoal (1 subgoal):\n 1. \\<not> y < x in ys", "by auto"], ["proof (state)\nthis:\n  \\<not> y < x in ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "from a"], ["proof (chain)\npicking this:\n  x < y in xs", "have \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by (rule before_in_setD1)"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "with distxsys"], ["proof (chain)\npicking this:\n  dist_perm xs ys\n  x \\<in> set xs", "have b: \"x \\<in> set ys\""], ["proof (prove)\nusing this:\n  dist_perm xs ys\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "from a"], ["proof (chain)\npicking this:\n  x < y in xs", "have  \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by (rule before_in_setD2)"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "with distxsys"], ["proof (chain)\npicking this:\n  dist_perm xs ys\n  y \\<in> set xs", "have c: \"y \\<in> set ys\""], ["proof (prove)\nusing this:\n  dist_perm xs ys\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "from a"], ["proof (chain)\npicking this:\n  x < y in xs", "have e: \"~ x = y\""], ["proof (prove)\nusing this:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs x < index xs y \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "have \"(\\<not> y < x in ys) = (x < y in ys \\<or> y = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y < x in ys) = (x < y in ys \\<or> y = x)", "apply(rule not_before_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<in> set ys\n 2. x \\<in> set ys", "using b c"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  y \\<in> set ys\n\ngoal (2 subgoals):\n 1. y \\<in> set ys\n 2. x \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  (\\<not> y < x in ys) = (x < y in ys \\<or> y = x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> fst `\n                           {(x, y) |x. x < y in xs \\<and> y < x in ys};\n        x < y in xs\\<rbrakk>\n       \\<Longrightarrow> x < y in ys", "with d e"], ["proof (chain)\npicking this:\n  \\<not> y < x in ys\n  x \\<noteq> y\n  (\\<not> y < x in ys) = (x < y in ys \\<or> y = x)", "show \"x < y in ys\""], ["proof (prove)\nusing this:\n  \\<not> y < x in ys\n  x \\<noteq> y\n  (\\<not> y < x in ys) = (x < y in ys \\<or> y = x)\n\ngoal (1 subgoal):\n 1. x < y in ys", "by auto"], ["proof (state)\nthis:\n  x < y in ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<subseteq> before y ys\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"(index xs y) - card (InvOf y xs ys) = card (before y xs) - card ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys} =\n    card (before y xs) -\n    card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})", "by(simp only: aha card_before[OF distinctxs yinxs])"], ["proof (state)\nthis:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys} =\n  card (before y xs) -\n  card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "also"], ["proof (state)\nthis:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys} =\n  card (before y xs) -\n  card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"\\<dots> = card ((before y xs) - ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (before y xs) -\n    card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}) =\n    card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})", "apply(rule card_Diff_subset[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n 2. fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> before y xs", "by auto"], ["proof (state)\nthis:\n  card (before y xs) -\n  card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}) =\n  card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "also"], ["proof (state)\nthis:\n  card (before y xs) -\n  card (fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}) =\n  card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"\\<dots> \\<le> card (before y ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n    \\<le> card (before y ys)", "apply(rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (before y ys)\n 2. before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> before y ys", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> before y ys", "apply(rule bef)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n  \\<le> card (before y ys)\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "also"], ["proof (state)\nthis:\n  card (before y xs - fst ` {(x, y) |x. x < y in xs \\<and> y < x in ys})\n  \\<le> card (before y ys)\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "have \"\\<dots> = (index ys y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (before y ys) = index ys y", "by(simp only: card_before[OF distinctys yinys])"], ["proof (state)\nthis:\n  card (before y ys) = index ys y\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "finally"], ["proof (chain)\npicking this:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<le> index ys y", "have \"index xs y - card ?I \\<le> index ys y\""], ["proof (prove)\nusing this:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<le> index ys y\n\ngoal (1 subgoal):\n 1. index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n    \\<le> index ys y", "."], ["proof (state)\nthis:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<le> index ys y\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "then"], ["proof (chain)\npicking this:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<le> index ys y", "show \"index xs y  \\<le> index ys y + card ?I\""], ["proof (prove)\nusing this:\n  index xs y - card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n  \\<le> index ys y\n\ngoal (1 subgoal):\n 1. index xs y\n    \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}", "by auto"], ["proof (state)\nthis:\n  index xs y\n  \\<le> index ys y + card {(x, y) |x. x < y in xs \\<and> y < x in ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"length init = 0 \\<Longrightarrow> length xs = length init \\<Longrightarrow> t xs q (mf, sws) = 1 + length sws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length init = 0; length xs = length init\\<rbrakk>\n    \\<Longrightarrow> t xs q (mf, sws) = 1 + length sws", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length init = 0; length xs = length init\\<rbrakk>\n    \\<Longrightarrow> (let (mf, sws) = (mf, sws)\n                       in index (swaps sws xs) q + 1 + length sws) =\n                      1 + length sws", "by(auto)"], ["", "lemma integr_index: \"integrable (measure_pmf (config'' (BIT_init, BIT_step) qs init n))\n   (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>(s, is). real (Suc (index s (qs ! n))))", "apply(rule measure_pmf.integrable_const_bound[where B=\"Suc (length init)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. AE x in measure_pmf\n             (config'_rand BIT\n               (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n               (take n\n                 qs)). norm\n                        (case x of\n                         (s, is) \\<Rightarrow>\n                           real (Suc (index s (qs ! n))))\n                       \\<le> real (Suc (length init))\n 2. measure_pmf.random_variable\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (take n qs))\n     borel (\\<lambda>(s, is). real (Suc (index s (qs ! n))))", "apply(simp add: split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. AE x in measure_pmf\n             (config'_rand BIT\n               (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n               (take n qs)). index (fst x) (qs ! n) \\<le> length init\n 2. measure_pmf.random_variable\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (take n qs))\n     borel (\\<lambda>(s, is). real (Suc (index s (qs ! n))))", "apply (metis (mono_tags) index_le_size AE_measure_pmf_iff config_rand_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.random_variable\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (take n qs))\n     borel (\\<lambda>(s, is). real (Suc (index s (qs ! n))))", "by (auto)"], ["", "subsubsection \"Upper Bound on the Cost of BIT\""], ["", "lemma t_BIT_ub2: \"(qs!n) \\<notin> set init \\<Longrightarrow> t_BIT n \\<le> Suc(size init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    t_BIT n \\<le> real (Suc (length init))", "apply(simp add: t_BIT_def t_def BIT_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s.\n           return_pmf\n            ((if fst (snd s) ! index (snd (snd s)) (qs ! n) then 0\n              else length (fst s),\n              []),\n             flip (index (snd (snd s)) (qs ! n)) (fst (snd s)),\n             snd (snd s)) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (real\n                  (case a of\n                   (mf, sws) \\<Rightarrow>\n                     Suc (index (swaps sws (fst s)) (qs ! n) +\n                          length sws))))))\n    \\<le> 1 + real (length init)", "apply(simp add: bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "case 1"], ["proof (state)\nthis:\n  qs ! n \\<notin> set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "note qs=this"], ["proof (state)\nthis:\n  qs ! n \\<notin> set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "let ?D =  \"(config'' (BIT_init, BIT_step) qs init n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "have absch: \"(\\<forall>x\\<in> set_pmf ?D. ((\\<lambda>(s,is). real (Suc (index s (qs ! n)))) x) \\<le> ((\\<lambda>(is,s). Suc (length init)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "proof (rule ballI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "from 1 config_rand_length"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init", "have f1: \"length (fst x) = length init\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. length (fst x) = length init", "by fastforce"], ["proof (state)\nthis:\n  length (fst x) = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "from 1 config_rand_set"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init", "have 2: \"set (fst x) = set init\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. set (fst x) = set init", "by fastforce"], ["proof (state)\nthis:\n  set (fst x) = set init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "from qs 2"], ["proof (chain)\npicking this:\n  qs ! n \\<notin> set init\n  set (fst x) = set init", "have \"(qs!n) \\<notin>  set (fst x)\""], ["proof (prove)\nusing this:\n  qs ! n \\<notin> set init\n  set (fst x) = set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set (fst x)", "by auto"], ["proof (state)\nthis:\n  qs ! n \\<notin> set (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "then"], ["proof (chain)\npicking this:\n  qs ! n \\<notin> set (fst x)", "show ?case"], ["proof (prove)\nusing this:\n  qs ! n \\<notin> set (fst x)\n\ngoal (1 subgoal):\n 1. (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n    \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "using f1"], ["proof (prove)\nusing this:\n  qs ! n \\<notin> set (fst x)\n  length (fst x) = length init\n\ngoal (1 subgoal):\n 1. (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n    \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))", "by (simp add: split_def)"], ["proof (state)\nthis:\n  (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n  \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take n qs)).\n     (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n     \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "have \"integrable (measure_pmf (config'' (BIT_init, BIT_step) qs init n))\n     (\\<lambda>(s, is). Suc (length init))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> Suc (length init)))", "by(simp)"], ["proof (state)\nthis:\n  integrable\n   (measure_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n       (take n qs)))\n   (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "have \"E(bind_pmf ?D (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n          = E(map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n)))) ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n    E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by(simp add: split_def map_pmf_def)"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "also"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "have \"\\<dots> \\<le> E(map_pmf (\\<lambda>(s, is). Suc (length init)) ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))\n    \\<le> E (map_pmf\n              (\\<lambda>x.\n                  real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n              (config'_rand BIT\n                (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                (take n qs)))", "apply (rule E_mono3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n 2. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n 3. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> Suc (length init))", "apply(fact integr_index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n 2. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> Suc (length init))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> Suc (length init))", "using absch"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take n qs)).\n     (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n     \\<le> real (case x of (is, s) \\<Rightarrow> Suc (length init))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> Suc (length init))", "by auto"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n  \\<le> E (map_pmf\n            (\\<lambda>x.\n                real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n            (config'_rand BIT\n              (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "also"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n  \\<le> E (map_pmf\n            (\\<lambda>x.\n                real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n            (config'_rand BIT\n              (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "have \"\\<dots> = Suc (length init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    real (Suc (length init))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> Suc (length init)))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs))) =\n  real (Suc (length init))\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "finally"], ["proof (chain)\npicking this:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n  \\<le> real (Suc (length init))", "show ?case"], ["proof (prove)\nusing this:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n  \\<le> real (Suc (length init))\n\ngoal (1 subgoal):\n 1. E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> 1 + real (length init)", "by(simp add: map_pmf_def bind_assoc_pmf bind_return_pmf split_def)"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n  \\<le> 1 + real (length init)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_BIT_ub: \"(qs!n) \\<in> set init \\<Longrightarrow> t_BIT n \\<le> size init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow> t_BIT n \\<le> real (length init)", "apply(simp add: t_BIT_def t_def BIT_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s.\n           return_pmf\n            ((if fst (snd s) ! index (snd (snd s)) (qs ! n) then 0\n              else length (fst s),\n              []),\n             flip (index (snd (snd s)) (qs ! n)) (fst (snd s)),\n             snd (snd s)) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf\n                (real\n                  (case a of\n                   (mf, sws) \\<Rightarrow>\n                     Suc (index (swaps sws (fst s)) (qs ! n) +\n                          length sws))))))\n    \\<le> real (length init)", "apply(simp add: bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "case 1"], ["proof (state)\nthis:\n  qs ! n \\<in> set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "note qs=this"], ["proof (state)\nthis:\n  qs ! n \\<in> set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "let ?D =  \"(config'' (BIT_init, BIT_step) qs init n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "have absch: \"(\\<forall>x\\<in> set_pmf ?D. ((\\<lambda>(s, is). real (Suc (index s (qs ! n)))) x) \\<le> ((\\<lambda>(s, is). length init) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "proof (rule ballI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "from 1 config_rand_length"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init", "have f1: \"length (fst x) = length init\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. length (fst x) = length init", "by fastforce"], ["proof (state)\nthis:\n  length (fst x) = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "from 1 config_rand_set"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init", "have 2: \"set (fst x) = set init\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. set (fst x) = set init", "by fastforce"], ["proof (state)\nthis:\n  set (fst x) = set init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "from qs 2"], ["proof (chain)\npicking this:\n  qs ! n \\<in> set init\n  set (fst x) = set init", "have \"(qs!n) \\<in> set (fst x)\""], ["proof (prove)\nusing this:\n  qs ! n \\<in> set init\n  set (fst x) = set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set (fst x)", "by auto"], ["proof (state)\nthis:\n  qs ! n \\<in> set (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "then"], ["proof (chain)\npicking this:\n  qs ! n \\<in> set (fst x)", "have \"(index (fst x) (qs ! n)) < length init\""], ["proof (prove)\nusing this:\n  qs ! n \\<in> set (fst x)\n\ngoal (1 subgoal):\n 1. index (fst x) (qs ! n) < length init", "apply(rule index_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst x) \\<le> length init", "using f1"], ["proof (prove)\nusing this:\n  length (fst x) = length init\n\ngoal (1 subgoal):\n 1. length (fst x) \\<le> length init", "by auto"], ["proof (state)\nthis:\n  index (fst x) (qs ! n) < length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (config'_rand BIT\n                  (fst BIT init \\<bind>\n                   (\\<lambda>is. return_pmf (init, is)))\n                  (take n qs)) \\<Longrightarrow>\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "then"], ["proof (chain)\npicking this:\n  index (fst x) (qs ! n) < length init", "show ?case"], ["proof (prove)\nusing this:\n  index (fst x) (qs ! n) < length init\n\ngoal (1 subgoal):\n 1. (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n    \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "by (simp add: split_def)"], ["proof (state)\nthis:\n  (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n  \\<le> real (case x of (s, is) \\<Rightarrow> length init)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take n qs)).\n     (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n     \\<le> real (case x of (s, is) \\<Rightarrow> length init)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "have \"E(bind_pmf ?D (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n          = E(map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n)))) ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n    E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by(simp add: split_def map_pmf_def)"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "also"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n)))))) =\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "have \"\\<dots> \\<le> E(map_pmf (\\<lambda>(s, is). length init) ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))\n    \\<le> E (map_pmf\n              (\\<lambda>x.\n                  real (case x of (s, is) \\<Rightarrow> length init))\n              (config'_rand BIT\n                (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                (take n qs)))", "apply(rule E_mono3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n 2. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n 3. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "apply(fact integr_index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable\n     (measure_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n     (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n 2. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "using absch"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take n qs)).\n     (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n     \\<le> real (case x of (s, is) \\<Rightarrow> length init)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       (case x of (s, is) \\<Rightarrow> real (Suc (index s (qs ! n))))\n       \\<le> real (case x of (s, is) \\<Rightarrow> length init)", "by auto"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n  \\<le> E (map_pmf\n            (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n            (config'_rand BIT\n              (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "also"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>(s, is). real (Suc (index s (qs ! n))))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs)))\n  \\<le> E (map_pmf\n            (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n            (config'_rand BIT\n              (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take n qs)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "have \"\\<dots> = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    real (length init)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x. real (case x of (s, is) \\<Rightarrow> length init))\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs))) =\n  real (length init)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init \\<Longrightarrow>\n    E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "finally"], ["proof (chain)\npicking this:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n  \\<le> real (length init)", "show ?case"], ["proof (prove)\nusing this:\n  E (config'_rand BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>(s, is). return_pmf (real (Suc (index s (qs ! n))))))\n  \\<le> real (length init)\n\ngoal (1 subgoal):\n 1. E (config'_rand BIT\n        (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take n qs) \\<bind>\n       (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n    \\<le> real (length init)", "by(simp add: map_pmf_def bind_assoc_pmf bind_return_pmf split_def)"], ["proof (state)\nthis:\n  E (config'_rand BIT\n      (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take n qs) \\<bind>\n     (\\<lambda>s. return_pmf (1 + real (index (fst s) (qs ! n)))))\n  \\<le> real (length init)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_BIT_ub: \"\\<forall>i<n. qs!i \\<in> set init \\<Longrightarrow> T_BIT n \\<le> n * size init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n    T_BIT n \\<le> real (n * length init)", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<0. qs ! i \\<in> set init \\<Longrightarrow>\n    T_BIT 0 \\<le> real (0 * length init)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n                T_BIT n \\<le> real (n * length init);\n        \\<forall>i<Suc n. qs ! i \\<in> set init\\<rbrakk>\n       \\<Longrightarrow> T_BIT (Suc n) \\<le> real (Suc n * length init)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i<0. qs ! i \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. qs ! i \\<in> set init \\<Longrightarrow>\n    T_BIT 0 \\<le> real (0 * length init)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n                T_BIT n \\<le> real (n * length init);\n        \\<forall>i<Suc n. qs ! i \\<in> set init\\<rbrakk>\n       \\<Longrightarrow> T_BIT (Suc n) \\<le> real (Suc n * length init)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT 0 \\<le> real (0 * length init)", "by(simp add: T_BIT_def)"], ["proof (state)\nthis:\n  T_BIT 0 \\<le> real (0 * length init)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n                T_BIT n \\<le> real (n * length init);\n        \\<forall>i<Suc n. qs ! i \\<in> set init\\<rbrakk>\n       \\<Longrightarrow> T_BIT (Suc n) \\<le> real (Suc n * length init)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n                T_BIT n \\<le> real (n * length init);\n        \\<forall>i<Suc n. qs ! i \\<in> set init\\<rbrakk>\n       \\<Longrightarrow> T_BIT (Suc n) \\<le> real (Suc n * length init)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n  T_BIT n \\<le> real (n * length init)\n  \\<forall>i<Suc n. qs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n                T_BIT n \\<le> real (n * length init);\n        \\<forall>i<Suc n. qs ! i \\<in> set init\\<rbrakk>\n       \\<Longrightarrow> T_BIT (Suc n) \\<le> real (Suc n * length init)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n  T_BIT n \\<le> real (n * length init)\n  \\<forall>i<Suc n. qs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. T_BIT (Suc n) \\<le> real (Suc n * length init)", "using t_BIT_ub[where n=\"n\"]"], ["proof (prove)\nusing this:\n  \\<forall>i<n. qs ! i \\<in> set init \\<Longrightarrow>\n  T_BIT n \\<le> real (n * length init)\n  \\<forall>i<Suc n. qs ! i \\<in> set init\n  qs ! n \\<in> set init \\<Longrightarrow> t_BIT n \\<le> real (length init)\n\ngoal (1 subgoal):\n 1. T_BIT (Suc n) \\<le> real (Suc n * length init)", "by (simp add: T_BIT_def)"], ["proof (state)\nthis:\n  T_BIT (Suc n) \\<le> real (Suc n * length init)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Main Lemma\""], ["", "lemma myub: \"n < length qs \\<Longrightarrow> t_BIT n + Phi(n + 1) - Phi n \\<le> (7 / 4) * t_A n - 3/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "assume nqs: \"n < length qs\""], ["proof (state)\nthis:\n  n < length qs\n\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"t_BIT n + Phi (n+1) - Phi n \\<le> (7 / 4) * t_A n - 3/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "proof (cases \"length init > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n 2. \\<not> 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < length init\n\ngoal (2 subgoals):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n 2. \\<not> 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 < length init", "have qsn: \"(qs!n) \\<notin> set init\""], ["proof (prove)\nusing this:\n  \\<not> 0 < length init\n\ngoal (1 subgoal):\n 1. qs ! n \\<notin> set init", "by auto"], ["proof (state)\nthis:\n  qs ! n \\<notin> set init\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 < length init", "have l0: \"length init = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < length init\n\ngoal (1 subgoal):\n 1. length init = 0", "by auto"], ["proof (state)\nthis:\n  length init = 0\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "then"], ["proof (chain)\npicking this:\n  length init = 0", "have \"length (swaps (paid_A ! n) (s_A n)) = 0\""], ["proof (prove)\nusing this:\n  length init = 0\n\ngoal (1 subgoal):\n 1. length (swaps (paid_A ! n) (s_A n)) = 0", "using length_s_A"], ["proof (prove)\nusing this:\n  length init = 0\n  length (s_A ?n) = length init\n\ngoal (1 subgoal):\n 1. length (swaps (paid_A ! n) (s_A n)) = 0", "by auto"], ["proof (state)\nthis:\n  length (swaps (paid_A ! n) (s_A n)) = 0\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "with l0"], ["proof (chain)\npicking this:\n  length init = 0\n  length (swaps (paid_A ! n) (s_A n)) = 0", "have 4: \"t_A n = 1 + length (paid_A ! n)\""], ["proof (prove)\nusing this:\n  length init = 0\n  length (swaps (paid_A ! n) (s_A n)) = 0\n\ngoal (1 subgoal):\n 1. t_A n = int (1 + length (paid_A ! n))", "unfolding t_A_def c_A_def p_A_def"], ["proof (prove)\nusing this:\n  length init = 0\n  length (swaps (paid_A ! n) (s_A n)) = 0\n\ngoal (1 subgoal):\n 1. int (index (swaps (paid_A ! n) (s_A n)) (qs ! n) + 1) +\n    int (length (paid_A ! n)) =\n    int (1 + length (paid_A ! n))", "by(simp)"], ["proof (state)\nthis:\n  t_A n = int (1 + length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have 1: \"t_BIT n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n \\<le> 1", "using t_BIT_ub2[OF qsn] l0"], ["proof (prove)\nusing this:\n  t_BIT n \\<le> real (Suc (length init))\n  length init = 0\n\ngoal (1 subgoal):\n 1. t_BIT n \\<le> 1", "by auto"], ["proof (state)\nthis:\n  t_BIT n \\<le> 1\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "{"], ["proof (state)\nthis:\n  t_BIT n \\<le> 1\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"phi m = (\\<lambda>(b,(a,i)). phi m (b,(a,i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> m = (\\<lambda>(b, a, i). \\<phi> m (b, a, i))", "by auto"], ["proof (state)\nthis:\n  \\<phi> m = (\\<lambda>(b, a, i). \\<phi> m (b, a, i))\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  \\<phi> m = (\\<lambda>(b, a, i). \\<phi> m (b, a, i))\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> = (\\<lambda>(b,(a,i)). 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(b, a, i). \\<phi> m (b, a, i)) = (\\<lambda>(b, a, i). 0)", "by(simp only: phi_empty2[OF l0])"], ["proof (state)\nthis:\n  (\\<lambda>(b, a, i). \\<phi> m (b, a, i)) = (\\<lambda>(b, a, i). 0)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "finally"], ["proof (chain)\npicking this:\n  \\<phi> m = (\\<lambda>(b, a, i). 0)", "have \"phi m= (\\<lambda>(b,(a,i)). 0)\""], ["proof (prove)\nusing this:\n  \\<phi> m = (\\<lambda>(b, a, i). 0)\n\ngoal (1 subgoal):\n 1. \\<phi> m = (\\<lambda>(b, a, i). 0)", "."], ["proof (state)\nthis:\n  \\<phi> m = (\\<lambda>(b, a, i). 0)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "}"], ["proof (state)\nthis:\n  \\<phi> ?m2 = (\\<lambda>(b, a, i). 0)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "note phinull=this"], ["proof (state)\nthis:\n  \\<phi> ?m2 = (\\<lambda>(b, a, i). 0)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have 2: \"PhiPlus n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sup>+ n = 0", "unfolding PhiPlus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let nextconfig =\n           config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take n qs) \\<bind>\n           (\\<lambda>(s, is).\n               BIT_step (s, is) (qs ! n) \\<bind>\n               (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis)))\n     in E (map_pmf (\\<phi> (Suc n)) nextconfig)) =\n    0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<phi> (Suc n))\n        (config'_rand BIT\n          (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs) \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) (qs ! n) \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis))))) =\n    0", "apply(simp only: phinull)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>(b, a, i). 0)\n        (config'_rand BIT\n          (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs) \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) (qs ! n) \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis))))) =\n    0", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  \\<Phi>\\<^sup>+ n = 0\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have 3:\"Phi n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> n = 0", "unfolding Phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<phi> n)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    0", "apply(simp only: phinull)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>(b, a, i). 0)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    0", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  \\<Phi> n = 0\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"t_A n \\<ge> 1 \\<Longrightarrow> 1 \\<le> 7 / 4 *   (t_A n) - 3 / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t_A n \\<Longrightarrow>\n    1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "by(simp)"], ["proof (state)\nthis:\n  1 \\<le> t_A n \\<Longrightarrow>\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "with 4"], ["proof (chain)\npicking this:\n  t_A n = int (1 + length (paid_A ! n))\n  1 \\<le> t_A n \\<Longrightarrow>\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have 5: \"1 \\<le> 7 / 4 *   (t_A n) - 3 / 4\""], ["proof (prove)\nusing this:\n  t_A n = int (1 + length (paid_A ! n))\n  1 \\<le> t_A n \\<Longrightarrow>\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. 1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "by auto"], ["proof (state)\nthis:\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "from 1 2 3"], ["proof (chain)\npicking this:\n  t_BIT n \\<le> 1\n  \\<Phi>\\<^sup>+ n = 0\n  \\<Phi> n = 0", "have \"t_BIT n + PhiPlus n - Phi n \\<le> 1\""], ["proof (prove)\nusing this:\n  t_BIT n \\<le> 1\n  \\<Phi>\\<^sup>+ n = 0\n  \\<Phi> n = 0\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n \\<le> 1", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n \\<le> 1\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n \\<le> 1\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "from 5"], ["proof (chain)\npicking this:\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> \\<le>  7 / 4 *   (t_A n) - 3 / 4\""], ["proof (prove)\nusing this:\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. 1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "by auto"], ["proof (state)\nthis:\n  1 \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "finally"], ["proof (chain)\npicking this:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "show ?thesis"], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "using PhiPlus_is_Phi_Suc nqs"], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n  ?n < length qs \\<Longrightarrow> \\<Phi>\\<^sup>+ ?n = \\<Phi> (Suc ?n)\n  n < length qs\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "case True"], ["proof (state)\nthis:\n  0 < length init\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "let ?l = \"length init\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "from True"], ["proof (chain)\npicking this:\n  0 < length init", "obtain l' where lSuc: \"?l = Suc l'\""], ["proof (prove)\nusing this:\n  0 < length init\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        length init = Suc l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_pred)"], ["proof (state)\nthis:\n  length init = Suc l'\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have 31: \"n < length paid_A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length paid_A", "using nqs"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. n < length paid_A", "by auto"], ["proof (state)\nthis:\n  n < length paid_A\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define q where \"q = qs!n\""], ["proof (state)\nthis:\n  q = qs ! n\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define D where [simp]: \"D = (config'' (BIT_init, BIT_step) qs init n)\""], ["proof (state)\nthis:\n  D =\n  config'_rand BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) (take n qs)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define cost where [simp]: \"cost = (\\<lambda>(s, is).(t s q (if (fst is) ! (index (snd is) q) then 0 else length s, [])))\""], ["proof (state)\nthis:\n  cost =\n  (\\<lambda>(s, is).\n      t s q (if fst is ! index (snd is) q then 0 else length s, []))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define \\<Phi>\\<^sub>2 where [simp]: \"\\<Phi>\\<^sub>2 = (\\<lambda>(s, is). ((phi (Suc n)) (step s q (if (fst is) ! (index (snd is) q) then 0 else length s, []),(flip (index (snd is) q) (fst is), snd is))))\""], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 =\n  (\\<lambda>(s, is).\n      \\<phi> (Suc n)\n       (step s q (if fst is ! index (snd is) q then 0 else length s, []),\n        flip (index (snd is) q) (fst is), snd is))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define \\<Phi>\\<^sub>0 where [simp]: \"\\<Phi>\\<^sub>0 = phi n\""], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>0 = \\<phi> n\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have inEreinziehn: \"t_BIT n + Phi (n+1) - Phi n =  E (map_pmf (\\<lambda>x. (cost x) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x)) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"bind_pmf D\n                      (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a,nis). return_pmf (real(t s (q) a))))\n         = bind_pmf D\n                      (\\<lambda>(s, is). return_pmf (t s q (if (fst is) ! (index (snd is) q) then 0 else length s, [])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<bind>\n    (\\<lambda>(s, is).\n        BIT_step (s, is) q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n    D \\<bind>\n    (\\<lambda>(s, is).\n        return_pmf\n         (real\n           (t s q (if fst is ! index (snd is) q then 0 else length s, []))))", "unfolding BIT_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<bind>\n    (\\<lambda>(s, is).\n        (let a = (if fst (snd (s, is)) ! index (snd (snd (s, is))) q then 0\n                  else length (fst (s, is)),\n                  [])\n         in return_pmf\n             (a, flip (index (snd (snd (s, is))) q) (fst (snd (s, is))),\n              snd (snd (s, is)))) \\<bind>\n        (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n    D \\<bind>\n    (\\<lambda>(s, is).\n        return_pmf\n         (real\n           (t s q (if fst is ! index (snd is) q then 0 else length s, []))))", "apply (auto simp: bind_return_pmf split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (take n qs) \\<bind>\n    (\\<lambda>p.\n        return_pmf\n         (real\n           (t (fst p) q\n             (if fst (snd p) ! index (snd (snd p)) q then 0\n              else length (fst (fst p, snd p)),\n              [])))) =\n    config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (take n qs) \\<bind>\n    (\\<lambda>p.\n        return_pmf\n         (real\n           (t (fst p) q\n             (if fst (snd p) ! index (snd (snd p)) q then 0\n              else length (fst p),\n              []))))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  D \\<bind>\n  (\\<lambda>(s, is).\n      return_pmf\n       (real\n         (t s q (if fst is ! index (snd is) q then 0 else length s, []))))\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  D \\<bind>\n  (\\<lambda>(s, is).\n      return_pmf\n       (real\n         (t s q (if fst is ! index (snd is) q then 0 else length s, []))))\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> = map_pmf cost D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<bind>\n    (\\<lambda>(s, is).\n        return_pmf\n         (real\n           (t s q\n             (if fst is ! index (snd is) q then 0 else length s, [])))) =\n    map_pmf (\\<lambda>x. real (cost x)) D", "by (auto simp: map_pmf_def split_def)"], ["proof (state)\nthis:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      return_pmf\n       (real\n         (t s q (if fst is ! index (snd is) q then 0 else length s, [])))) =\n  map_pmf (\\<lambda>x. real (cost x)) D\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "finally"], ["proof (chain)\npicking this:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  map_pmf (\\<lambda>x. real (cost x)) D", "have rightform1: \"bind_pmf D\n                      (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a,nis). return_pmf (real(t s (q) a))))\n                      = map_pmf cost D\""], ["proof (prove)\nusing this:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  map_pmf (\\<lambda>x. real (cost x)) D\n\ngoal (1 subgoal):\n 1. D \\<bind>\n    (\\<lambda>(s, is).\n        BIT_step (s, is) q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n    map_pmf (\\<lambda>x. real (cost x)) D", "."], ["proof (state)\nthis:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  map_pmf (\\<lambda>x. real (cost x)) D\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have rightform2: \"map_pmf (phi (Suc n)) (bind_pmf D\n          (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a, nis). return_pmf (step s (q) a, nis))))\n            = map_pmf \\<Phi>\\<^sub>2 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<phi> (Suc n))\n     (D \\<bind>\n      (\\<lambda>(s, is).\n          BIT_step (s, is) q \\<bind>\n          (\\<lambda>(a, nis). return_pmf (step s q a, nis)))) =\n    map_pmf \\<Phi>\\<^sub>2 D", "apply(simp add:  bind_return_pmf bind_assoc_pmf map_pmf_def split_def BIT_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (take n qs) \\<bind>\n    (\\<lambda>x.\n        return_pmf\n         (\\<Sum>xa\\<in>Inv (step (fst x) q\n                             (if fst (snd x) ! index (snd (snd x)) q then 0\n                              else length (fst (fst x, snd x)),\n                              []))\n                        (step (s_A n) (qs ! n) (free_A ! n, paid_A ! n)).\n            if flip (index (snd (snd x)) q) (fst (snd x)) !\n               index init (snd xa)\n            then 2 else 1)) =\n    config'_rand BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (take n qs) \\<bind>\n    (\\<lambda>x.\n        return_pmf\n         (\\<Sum>xa\\<in>Inv (step (fst x) q\n                             (if fst (snd x) ! index (snd (snd x)) q then 0\n                              else length (fst x),\n                              []))\n                        (step (s_A n) (qs ! n) (free_A ! n, paid_A ! n)).\n            if flip (index (snd (snd x)) q) (fst (snd x)) !\n               index init (snd xa)\n            then 2 else 1))", "by (metis  prod.collapse)"], ["proof (state)\nthis:\n  map_pmf (\\<phi> (Suc n))\n   (D \\<bind>\n    (\\<lambda>(s, is).\n        BIT_step (s, is) q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step s q a, nis)))) =\n  map_pmf \\<Phi>\\<^sub>2 D\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"t_BIT n + Phi (n+1) - Phi n =\n       t_BIT n + PhiPlus n - Phi n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n", "using PhiPlus_is_Phi_Suc nqs"], ["proof (prove)\nusing this:\n  ?n < length qs \\<Longrightarrow> \\<Phi>\\<^sup>+ ?n = \\<Phi> (Suc ?n)\n  n < length qs\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> =\n          T_on_rand_n BIT init qs n\n         + E (map_pmf (phi (Suc n)) (bind_pmf D\n            (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a, nis). return_pmf (step s (q) a, nis)))))\n        - E (map_pmf (phi n) D)\n        \""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n =\n    T_on_rand'_n BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) q \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n    E (map_pmf (\\<phi> n) D)", "unfolding  PhiPlus_def Phi_def  t_BIT_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand'_n BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n    (let nextconfig =\n           config'_rand BIT\n            (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take n qs) \\<bind>\n           (\\<lambda>(s, is).\n               BIT_step (s, is) (qs ! n) \\<bind>\n               (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis)))\n     in E (map_pmf (\\<phi> (Suc n)) nextconfig)) -\n    E (map_pmf (\\<phi> n)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    T_on_rand'_n BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) (qs ! n) \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s (qs ! n) a, nis))))) -\n    E (map_pmf (\\<phi> n) D)", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n =\n  T_on_rand'_n BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf (\\<phi> n) D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi>\\<^sup>+ n - \\<Phi> n =\n  T_on_rand'_n BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf (\\<phi> n) D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> = \n        E (bind_pmf D\n                      (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a,nis). return_pmf (t s (q) a))))\n        + E (map_pmf (phi (Suc n)) (bind_pmf D\n            (\\<lambda>(s, is). bind_pmf (BIT_step (s, is) (q)) (\\<lambda>(a, nis). return_pmf (step s (q) a, nis)))))\n        - E (map_pmf \\<Phi>\\<^sub>0 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand'_n BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) q \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n    E (map_pmf (\\<phi> n) D) =\n    E (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) q \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n    E (map_pmf \\<Phi>\\<^sub>0 D)", "by (auto simp: q_def split_def)"], ["proof (state)\nthis:\n  T_on_rand'_n BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf (\\<phi> n) D) =\n  E (D \\<bind>\n     (\\<lambda>(s, is).\n         BIT_step (s, is) q \\<bind>\n         (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  T_on_rand'_n BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs n +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf (\\<phi> n) D) =\n  E (D \\<bind>\n     (\\<lambda>(s, is).\n         BIT_step (s, is) q \\<bind>\n         (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> = E (map_pmf cost D)\n                  + E (map_pmf \\<Phi>\\<^sub>2 D)\n                  - E (map_pmf \\<Phi>\\<^sub>0 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) q \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n    E (map_pmf \\<Phi>\\<^sub>0 D) =\n    E (map_pmf (\\<lambda>x. real (cost x)) D) +\n    E (map_pmf \\<Phi>\\<^sub>2 D) -\n    E (map_pmf \\<Phi>\\<^sub>0 D)", "using rightform1 rightform2 split_def"], ["proof (prove)\nusing this:\n  D \\<bind>\n  (\\<lambda>(s, is).\n      BIT_step (s, is) q \\<bind>\n      (\\<lambda>(a, nis). return_pmf (real (t s q a)))) =\n  map_pmf (\\<lambda>x. real (cost x)) D\n  map_pmf (\\<phi> (Suc n))\n   (D \\<bind>\n    (\\<lambda>(s, is).\n        BIT_step (s, is) q \\<bind>\n        (\\<lambda>(a, nis). return_pmf (step s q a, nis)))) =\n  map_pmf \\<Phi>\\<^sub>2 D\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. E (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n    E (map_pmf (\\<phi> (Suc n))\n        (D \\<bind>\n         (\\<lambda>(s, is).\n             BIT_step (s, is) q \\<bind>\n             (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n    E (map_pmf \\<Phi>\\<^sub>0 D) =\n    E (map_pmf (\\<lambda>x. real (cost x)) D) +\n    E (map_pmf \\<Phi>\\<^sub>2 D) -\n    E (map_pmf \\<Phi>\\<^sub>0 D)", "by auto"], ["proof (state)\nthis:\n  E (D \\<bind>\n     (\\<lambda>(s, is).\n         BIT_step (s, is) q \\<bind>\n         (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf \\<Phi>\\<^sub>0 D) =\n  E (map_pmf (\\<lambda>x. real (cost x)) D) + E (map_pmf \\<Phi>\\<^sub>2 D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  E (D \\<bind>\n     (\\<lambda>(s, is).\n         BIT_step (s, is) q \\<bind>\n         (\\<lambda>(a, nis). return_pmf (real (t s q a))))) +\n  E (map_pmf (\\<phi> (Suc n))\n      (D \\<bind>\n       (\\<lambda>(s, is).\n           BIT_step (s, is) q \\<bind>\n           (\\<lambda>(a, nis). return_pmf (step s q a, nis))))) -\n  E (map_pmf \\<Phi>\\<^sub>0 D) =\n  E (map_pmf (\\<lambda>x. real (cost x)) D) + E (map_pmf \\<Phi>\\<^sub>2 D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> =  E (map_pmf (\\<lambda>x. (cost x) + (\\<Phi>\\<^sub>2 x)) D) -  E (map_pmf (\\<lambda>x. (\\<Phi>\\<^sub>0 x)) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (cost x)) D) +\n    E (map_pmf \\<Phi>\\<^sub>2 D) -\n    E (map_pmf \\<Phi>\\<^sub>0 D) =\n    E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x) D) -\n    E (map_pmf \\<Phi>\\<^sub>0 D)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (cost x))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) +\n    E (map_pmf \\<Phi>\\<^sub>2\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) -\n    E (map_pmf \\<Phi>\\<^sub>0\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) -\n    E (map_pmf \\<Phi>\\<^sub>0\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "using E_linear_plus2[OF finite_config_BIT[OF dist_init]]"], ["proof (prove)\nusing this:\n  E (map_pmf ?f\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs1)) +\n  E (map_pmf ?g\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs1)) =\n  E (map_pmf (\\<lambda>x. ?f x + ?g x)\n      (config'_rand BIT\n        (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs1))\n\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (cost x))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) +\n    E (map_pmf \\<Phi>\\<^sub>2\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) -\n    E (map_pmf \\<Phi>\\<^sub>0\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) -\n    E (map_pmf \\<Phi>\\<^sub>0\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by auto"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>x. real (cost x)) D) + E (map_pmf \\<Phi>\\<^sub>2 D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D) =\n  E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x) D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "also"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>x. real (cost x)) D) + E (map_pmf \\<Phi>\\<^sub>2 D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D) =\n  E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x) D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "have \"\\<dots> =  E (map_pmf (\\<lambda>x. (cost x) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x)) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x) D) -\n    E (map_pmf \\<Phi>\\<^sub>0 D) =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) -\n    E (map_pmf \\<Phi>\\<^sub>0\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x)\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by(simp only: E_linear_diff2[OF finite_config_BIT[OF dist_init]] split_def)"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x) D) -\n  E (map_pmf \\<Phi>\\<^sub>0 D) =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "finally"], ["proof (chain)\npicking this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "show \"t_BIT n + Phi (n+1) - Phi n \n            =  E (map_pmf (\\<lambda>x. (cost x) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x)) D)\""], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define xs where [simp]: \"xs = s_A n\""], ["proof (state)\nthis:\n  xs = s_A n\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define xs' where [simp]: \"xs' = swaps (paid_A!n) xs\""], ["proof (state)\nthis:\n  xs' = swaps (paid_A ! n) xs\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define xs'' where [simp]: \"xs'' = mtf2 (free_A!n) (q) xs'\""], ["proof (state)\nthis:\n  xs'' = mtf2 (free_A ! n) q xs'\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define k where [simp]: \"k = index xs' q\""], ["proof (state)\nthis:\n  k = index xs' q\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* position of the requested element in A's list *)"], ["proof (state)\nthis:\n  k = index xs' q\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "define k' where [simp]: \"k' = max 0 (k-free_A!n)\""], ["proof (state)\nthis:\n  k' = max 0 (k - free_A ! n)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* position where A moves the requested element to *)"], ["proof (state)\nthis:\n  k' = max 0 (k - free_A ! n)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have [simp]: \"length xs = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length init", "by auto"], ["proof (state)\nthis:\n  length xs = length init\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have dp_xs_init[simp]: \"dist_perm xs init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm xs init", "by auto"], ["proof (state)\nthis:\n  dist_perm xs init\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "text \"The Transformation\""], ["proof (state)\nthis:\n  dist_perm xs init\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have ub_cost: \"\\<forall>x\\<in>set_pmf D. (real (cost x)) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x) \\<le> k + 1 + \n            (if (q) \\<in> set init\n              then (if (fst (snd x))!(index init q) then k-k' \n                                      else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1)))\n              else 0)\n              + (\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf D.\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "note xinD=1"], ["proof (state)\nthis:\n  x \\<in> set_pmf D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf D", "have [simp]: \"snd (snd x) = init\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf D\n\ngoal (1 subgoal):\n 1. snd (snd x) = init", "using D_def config_n_init3"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf D\n  D =\n  config'_rand BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) (take n qs)\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     snd (snd x) = ?init\n\ngoal (1 subgoal):\n 1. snd (snd x) = init", "by fast"], ["proof (state)\nthis:\n  snd (snd x) = init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define b where \"b = fst (snd x)\""], ["proof (state)\nthis:\n  b = fst (snd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define ys where \"ys = fst x\""], ["proof (state)\nthis:\n  ys = fst x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define aBIT where [simp]: \"aBIT = (if b ! (index (snd (snd x)) q) then 0 else length ys, ([]::nat list))\""], ["proof (state)\nthis:\n  aBIT = (if b ! index (snd (snd x)) q then 0 else length ys, [])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define ys' where \"ys' = step ys (q) aBIT\""], ["proof (state)\nthis:\n  ys' = step ys q aBIT\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define b' where \"b' = flip (index init q) b\""], ["proof (state)\nthis:\n  b' = flip (index init q) b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define \\<Phi>\\<^sub>1 where \"\\<Phi>\\<^sub>1 = (\\<lambda>z:: 'a list\\<times> (bool list \\<times> 'a list) . (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if fst (snd z)!(index init y) then 2::real else 1)))\""], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 =\n  (\\<lambda>z.\n      \\<Sum>(x, y)\\<in>Inv ys xs'.\n        if fst (snd z) ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have xs''_step: \"xs'' = step xs (q) (free_A!n,paid_A!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs'' = step xs q (free_A ! n, paid_A ! n)", "unfolding xs'_def xs''_def xs_def step_def free_A_def paid_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (map fst acts ! n) q\n     (swaps (map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n)\n       (s_A n)) =\n    (let (k, sws) =\n           (map fst acts ! n,\n            map (filter (\\<lambda>x. Suc x < length init)) paid_A' ! n)\n     in mtf2 k q (swaps sws (s_A n)))", "by(auto simp: split_def)"], ["proof (state)\nthis:\n  xs'' = step xs q (free_A ! n, paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have gis2: \"(\\<Phi>\\<^sub>2 (ys,(b,init))) = (\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b'!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 (ys, b, init) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)", "apply(simp only: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 (ys, b, init) =\n    (\\<Sum>p\\<in>Inv ys' xs''. if b' ! index init (snd p) then 2 else 1)", "apply(simp only: xs''_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 (ys, b, init) =\n    (\\<Sum>p\\<in>Inv ys' (step xs q (free_A ! n, paid_A ! n)).\n       if b' ! index init (snd p) then 2 else 1)", "apply(simp only: \\<Phi>\\<^sub>2_def phi.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (ys, b, init) of\n     (s, is) \\<Rightarrow>\n       \\<Sum>(x, y)\n             \\<in>Inv (step s q\n                        (if fst is ! index (snd is) q then 0 else length s,\n                         []))\n                   (s_A (Suc n)).\n         if flip (index (snd is) q) (fst is) ! index init y then 2 else 1) =\n    (\\<Sum>p\\<in>Inv ys' (step xs q (free_A ! n, paid_A ! n)).\n       if b' ! index init (snd p) then 2 else 1)", "unfolding b'_def b_def ys'_def aBIT_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (ys, fst (snd x), init) of\n     (s, is) \\<Rightarrow>\n       \\<Sum>(x, y)\n             \\<in>Inv (step s (qs ! n)\n                        (if fst is ! index (snd is) (qs ! n) then 0\n                         else length s,\n                         []))\n                   (s_A (Suc n)).\n         if flip (index (snd is) (qs ! n)) (fst is) ! index init y then 2\n         else 1) =\n    (\\<Sum>p\\<in>Inv (step ys (qs ! n)\n                       (if fst (snd x) ! index (snd (snd x)) (qs ! n) then 0\n                        else length ys,\n                        []))\n                  (step xs (qs ! n) (free_A ! n, paid_A ! n)).\n       if flip (index init (qs ! n)) (fst (snd x)) ! index init (snd p)\n       then 2 else 1)", "unfolding s_A.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (ys, fst (snd x), init) of\n     (s, is) \\<Rightarrow>\n       \\<Sum>(x, y)\n             \\<in>Inv (step s (qs ! n)\n                        (if fst is ! index (snd is) (qs ! n) then 0\n                         else length s,\n                         []))\n                   (step (s_A n) (qs ! n) (free_A ! n, paid_A ! n)).\n         if flip (index (snd is) (qs ! n)) (fst is) ! index init y then 2\n         else 1) =\n    (\\<Sum>p\\<in>Inv (step ys (qs ! n)\n                       (if fst (snd x) ! index (snd (snd x)) (qs ! n) then 0\n                        else length ys,\n                        []))\n                  (step xs (qs ! n) (free_A ! n, paid_A ! n)).\n       if flip (index init (qs ! n)) (fst (snd x)) ! index init (snd p)\n       then 2 else 1)", "apply(simp only: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>Inv (step (fst (ys, fst (snd x), init)) (qs ! n)\n                       (if fst (snd (ys, fst (snd x), init)) !\n                           index (snd (snd (ys, fst (snd x), init)))\n                            (qs ! n)\n                        then 0 else length (fst (ys, fst (snd x), init)),\n                        []))\n                  (step (s_A n) (qs ! n) (free_A ! n, paid_A ! n)).\n       if flip (index (snd (snd (ys, fst (snd x), init))) (qs ! n))\n           (fst (snd (ys, fst (snd x), init))) !\n          index init (snd p)\n       then 2 else 1) =\n    (\\<Sum>p\\<in>Inv (step ys (qs ! n)\n                       (if fst (snd x) ! index (snd (snd x)) (qs ! n) then 0\n                        else length ys,\n                        []))\n                  (step xs (qs ! n) (free_A ! n, paid_A ! n)).\n       if flip (index init (qs ! n)) (fst (snd x)) ! index init (snd p)\n       then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  \\<Phi>\\<^sub>2 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)", "have gis: \"\\<Phi>\\<^sub>2 x = (\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b'!(index init y) then 2 else 1))\""], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>2 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)", "unfolding ys_def b_def"], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>2 (fst x, fst (snd x), init) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 x =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have his2: \"(\\<Phi>\\<^sub>0 (ys,(b,init))) = (\\<Sum>(x,y)\\<in>(Inv ys xs). (if b!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>0 (ys, b, init) =\n    (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)", "apply(simp only: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>0 (ys, b, init) =\n    (\\<Sum>p\\<in>Inv ys xs. if b ! index init (snd p) then 2 else 1)", "apply(simp only: \\<Phi>\\<^sub>0_def phi.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) =\n    (\\<Sum>p\\<in>Inv ys xs. if b ! index init (snd p) then 2 else 1)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>0 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  \\<Phi>\\<^sub>0 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)", "have his: \"(\\<Phi>\\<^sub>0 x) = (\\<Sum>(x,y)\\<in>(Inv ys xs). (if b!(index init y) then 2 else 1))\""], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>0 (ys, b, init) =\n  (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>0 x =\n    (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)", "by(auto simp: ys_def b_def split_def phi')"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>0 x =\n  (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have dis: \"\\<Phi>\\<^sub>1 x = (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if b!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x =\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)", "unfolding \\<Phi>\\<^sub>1_def b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys xs'.\n       if fst (snd x) ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys xs'.\n       if fst (snd x) ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 x =\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have \"ys' = mtf2 (fst aBIT) (q) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys' = mtf2 (fst aBIT) q ys", "by (simp add: step_def ys'_def)"], ["proof (state)\nthis:\n  ys' = mtf2 (fst aBIT) q ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "from config_rand_distinct[of BIT] config_rand_set[of BIT] xinD"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  x \\<in> set_pmf D", "have dp_ys_init[simp]: \"dist_perm ys init\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  x \\<in> set_pmf D\n\ngoal (1 subgoal):\n 1. dist_perm ys init", "unfolding D_def ys_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  x \\<in> set_pmf\n           (config'_rand BIT\n             (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take n qs))\n\ngoal (1 subgoal):\n 1. dist_perm (fst x) init", "by force"], ["proof (state)\nthis:\n  dist_perm ys init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have dp_ys'_init[simp]: \"dist_perm ys' init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm ys' init", "unfolding ys'_def step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm (let (k, sws) = aBIT in mtf2 k q (swaps sws ys)) init", "by (auto)"], ["proof (state)\nthis:\n  dist_perm ys' init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  dist_perm ys' init", "have lenys'[simp]: \"length ys' = length init\""], ["proof (prove)\nusing this:\n  dist_perm ys' init\n\ngoal (1 subgoal):\n 1. length ys' = length init", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length ys' = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have dp_xs'_init[simp]: \"dist_perm xs' init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm xs' init", "by auto"], ["proof (state)\nthis:\n  dist_perm xs' init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have gra: \"dist_perm ys xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm ys xs'", "by auto"], ["proof (state)\nthis:\n  dist_perm ys xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have leninitb[simp]: \"length b = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length b = length init", "using b_def config_n_fst_init_length2 xinD[unfolded]"], ["proof (prove)\nusing this:\n  b = fst (snd x)\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand BIT\n                    (fst BIT ?s0.0 \\<bind>\n                     (\\<lambda>is. return_pmf (?s0.0, is)))\n                    ?qs).\n     length (fst (snd x)) = length ?s0.0\n  x \\<in> set_pmf D\n\ngoal (1 subgoal):\n 1. length b = length init", "by auto"], ["proof (state)\nthis:\n  length b = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have leninitys[simp]: \"length ys = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length init", "using dp_ys_init"], ["proof (prove)\nusing this:\n  dist_perm ys init\n\ngoal (1 subgoal):\n 1. length ys = length init", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length ys = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "{"], ["proof (state)\nthis:\n  length ys = length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have \"dist_perm ys (s'_A n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm ys (s'_A n m)", "using dp_ys_init"], ["proof (prove)\nusing this:\n  dist_perm ys init\n\ngoal (1 subgoal):\n 1. dist_perm ys (s'_A n m)", "by auto"], ["proof (state)\nthis:\n  dist_perm ys (s'_A n m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "}"], ["proof (state)\nthis:\n  dist_perm ys (s'_A n ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "note dist=this"], ["proof (state)\nthis:\n  dist_perm ys (s'_A n ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "text \"Upper bound of the inversions created by paid exchanges of A\""], ["proof (state)\nthis:\n  dist_perm ys (s'_A n ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "(* ============================================\n\n          first we adress the paid exchanges \n          \n          paid cost of A: p_A *)"], ["proof (state)\nthis:\n  dist_perm ys (s'_A n ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "let ?paidUB=\"(\\<Sum>i<(length (paid_A!n)). (if b!(gebub n i) then 2::real else 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have paid_ub: \"\\<Phi>\\<^sub>1 x \\<le> \\<Phi>\\<^sub>0 x + ?paidUB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "have a: \"length (paid_A ! n) \\<le> length (paid_A ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (paid_A ! n) \\<le> length (paid_A ! n)", "by auto"], ["proof (state)\nthis:\n  length (paid_A ! n) \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "have b: \"xs' = (s'_A n (length (paid_A ! n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = s'_A n (length (paid_A ! n))", "using s'A_m"], ["proof (prove)\nusing this:\n  swaps (paid_A ! ?n) (s_A ?n) = s'_A ?n (length (paid_A ! ?n))\n\ngoal (1 subgoal):\n 1. xs' = s'_A n (length (paid_A ! n))", "by auto"], ["proof (state)\nthis:\n  xs' = s'_A n (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "{"], ["proof (state)\nthis:\n  xs' = s'_A n (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "have \"m\\<le>length (paid_A!n) \\<Longrightarrow> (\\<Sum>(x,y)\\<in>(Inv ys (s'_A n m)). (if b!(index init y) then 2::real else 1)) \\<le> (\\<Sum>(x,y)\\<in>(Inv ys xs). (if b!(index init y) then 2 else 1))\n                              + (\\<Sum>i<m. (if b!(gebub n i) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<m. if b ! gebub n i then 2 else 1)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  (\\<Sum>a\\<in>Inv ys (s'_A n m).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  (\\<Sum>a\\<in>Inv ys (s'_A n m).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n  Suc m \\<le> length (paid_A ! n)", "have m_bd2: \"m \\<le> length (paid_A ! n)\"\n                and m_bd: \"m < length (paid_A ! n)\""], ["proof (prove)\nusing this:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  (\\<Sum>a\\<in>Inv ys (s'_A n m).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n  Suc m \\<le> length (paid_A ! n)\n\ngoal (1 subgoal):\n 1. m \\<le> length (paid_A ! n) &&& m < length (paid_A ! n)", "by auto"], ["proof (state)\nthis:\n  m \\<le> length (paid_A ! n)\n  m < length (paid_A ! n)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "note yeah = Suc(1)[OF m_bd2]"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>Inv ys (s'_A n m).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "let ?revm=\"(length (paid_A ! n) - Suc m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "note ah=Inv_swap[of \"ys\" \"(s'_A n m)\" \"(paid_A ! n ! ?revm)\", OF dist]"], ["proof (state)\nthis:\n  Inv ys (swap (paid_A ! n ! (length (paid_A ! n) - Suc m)) (s'_A n m)) =\n  (if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n   then if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys\n        then Inv ys (s'_A n m) \\<union>\n             {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n        else Inv ys (s'_A n m) -\n             {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n   else Inv ys (s'_A n m))\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"(\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)). if b ! (index init y) then 2::real else 1)\n              = (\\<Sum>(xa, y)\\<in>Inv ys (swap (paid_A ! n ! ?revm) (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys\n                 (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                   (s'_A n m)).\n       if b ! index init y then 2 else 1)", "using s'_A.simps(2)"], ["proof (prove)\nusing this:\n  s'_A ?n (Suc ?m) =\n  swap (paid_A ! ?n ! (length (paid_A ! ?n) - Suc ?m)) (s'_A ?n ?m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys\n                 (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                   (s'_A n m)).\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys\n               (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                 (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys\n               (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                 (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>(if Suc (paid_A ! n ! ?revm) < length ys\n   then if s'_A n m ! (paid_A ! n ! ?revm) < s'_A n m ! Suc (paid_A ! n ! ?revm) in ys\n        then Inv ys (s'_A n m) \\<union> {(s'_A n m ! (paid_A ! n ! ?revm), s'_A n m ! Suc (paid_A ! n ! ?revm))}\n        else Inv ys (s'_A n m) - {(s'_A n m ! Suc (paid_A ! n ! ?revm), s'_A n m ! (paid_A ! n ! ?revm))}\n   else Inv ys (s'_A n m)). if b ! (index init y) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>Inv ys\n                 (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                   (s'_A n m)).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)", "by (simp only: ah)"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys\n               (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                 (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys\n               (swap (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                 (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"\\<dots> \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! (index init y) then 2::real else 1)\n                        + (if (b) ! (index init (s'_A n m ! Suc (paid_A ! n ! ?revm))) then 2::real else 1)\" (is \"?A \\<le> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "proof(cases \"Suc (paid_A ! n ! ?revm) < length ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "case False"], ["proof (state)\nthis:\n  \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "(* FIXME! can't occur! because it has already been filtered out! see:\n                 then have \"False\" using paidAnm_inbound apply(auto) using m_bd nqs by blast *)"], ["proof (state)\nthis:\n  \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys", "have \"?A = (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\nusing this:\n  \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> \\<le> (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1) +\n                        (if b ! (index init (s'_A n m ! Suc (paid_A ! n ! ?revm))) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (2 subgoals):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)", "show \"?A \\<le> ?B\""], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "case True"], ["proof (state)\nthis:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys", "have \"?A = (\\<Sum>(xa, y)\\<in>(if s'_A n m ! (paid_A ! n ! ?revm) < s'_A n m ! Suc (paid_A ! n ! ?revm) in ys\n                      then Inv ys (s'_A n m) \\<union> {(s'_A n m ! (paid_A ! n ! ?revm), s'_A n m ! Suc (paid_A ! n ! ?revm))}\n                      else Inv ys (s'_A n m) - {(s'_A n m ! Suc (paid_A ! n ! ?revm), s'_A n m ! (paid_A ! n ! ?revm))}\n                        ). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\nusing this:\n  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) < length ys\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> \\<le> ?B\" (is \"?A' \\<le> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "proof (cases \"s'_A n m ! (paid_A ! n ! ?revm) < s'_A n m ! Suc (paid_A ! n ! ?revm) in ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "case True"], ["proof (state)\nthis:\n  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "let ?neurein=\"(s'_A n m ! (paid_A ! n ! ?revm), s'_A n m ! Suc (paid_A ! n ! ?revm))\""], ["proof (state)\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "from True"], ["proof (chain)\npicking this:\n  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys", "have \"?A' = (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m) \\<union> {?neurein}\n                      ). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\nusing this:\n  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n  s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) \\<union>\n                {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) \\<union>\n              {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m !\n                Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) \\<union>\n              {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m !\n                Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>insert ?neurein (Inv ys (s'_A n m)\n                      ). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) \\<union>\n                {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) \\<union>\n              {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m !\n                Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) \\<union>\n              {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m !\n                Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> \\<le> (if b ! (index init (snd ?neurein)) then 2 else 1) \n                            + (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "proof (cases \"?neurein \\<in> Inv ys (s'_A n m)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "case True"], ["proof (state)\nthis:\n  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<in> Inv ys (s'_A n m)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<in> Inv ys (s'_A n m)", "have \"insert ?neurein (Inv ys (s'_A n m)) = (Inv ys (s'_A n m))\""], ["proof (prove)\nusing this:\n  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<in> Inv ys (s'_A n m)\n\ngoal (1 subgoal):\n 1. insert\n     (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n      s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     (Inv ys (s'_A n m)) =\n    Inv ys (s'_A n m)", "by auto"], ["proof (state)\nthis:\n  insert\n   (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   (Inv ys (s'_A n m)) =\n  Inv ys (s'_A n m)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  insert\n   (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   (Inv ys (s'_A n m)) =\n  Inv ys (s'_A n m)", "have \"(\\<Sum>(xa, y)\\<in>insert ?neurein (Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\n                        = (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\nusing this:\n  insert\n   (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   (Inv ys (s'_A n m)) =\n  Inv ys (s'_A n m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2::'b else (1::'b)) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n       if b ! index init y then 2::'b else (1::'b))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2::?'b1 else (1::?'b1)) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n     if b ! index init y then 2::?'b1 else (1::?'b1))\n\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2::?'b1 else (1::?'b1)) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n     if b ! index init y then 2::?'b1 else (1::?'b1))\n\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"\\<dots> \\<le> (if b ! (index init (snd ?neurein)) then 2::real else 1) \n                            + (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "case False"], ["proof (state)\nthis:\n  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<notin> Inv ys (s'_A n m)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"(\\<Sum>(xa, y)\\<in>insert ?neurein (Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\n                        = (\\<Sum>y\\<in>insert ?neurein (Inv ys (s'_A n m)). (\\<lambda>i. if b ! (index init (snd i)) then 2 else 1) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2::'b else (1::'b)) =\n    (\\<Sum>y\\<in>insert\n                  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                  (Inv ys (s'_A n m)).\n       if b ! index init (snd y) then 2::'b else (1::'b))", "by(auto simp: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2::?'b1 else (1::?'b1)) =\n  (\\<Sum>y\\<in>insert\n                (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                (Inv ys (s'_A n m)).\n     if b ! index init (snd y) then 2::?'b1 else (1::?'b1))\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2::?'b1 else (1::?'b1)) =\n  (\\<Sum>y\\<in>insert\n                (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                (Inv ys (s'_A n m)).\n     if b ! index init (snd y) then 2::?'b1 else (1::?'b1))\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"\\<dots> = (\\<lambda>i. if b ! (index init (snd i)) then 2 else 1) ?neurein\n                            + (\\<Sum>y\\<in>(Inv ys (s'_A n m)) - {?neurein}. (\\<lambda>i. if b ! (index init (snd i)) then 2 else 1) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>insert\n                  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                  (Inv ys (s'_A n m)).\n       if b ! index init (snd y) then 2::'b else (1::'b)) =\n    (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2::'b else (1::'b)) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n                 {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init (snd y) then 2::'b else (1::'b))", "apply(rule sum.insert_remove)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys (s'_A n m))", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert\n                (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                (Inv ys (s'_A n m)).\n     if b ! index init (snd y) then 2::?'b2 else (1::?'b2)) =\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2::?'b2 else (1::?'b2)) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n               {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init (snd y) then 2::?'b2 else (1::?'b2))\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert\n                (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                (Inv ys (s'_A n m)).\n     if b ! index init (snd y) then 2::?'b2 else (1::?'b2)) =\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2::?'b2 else (1::?'b2)) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n               {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init (snd y) then 2::?'b2 else (1::?'b2))\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"\\<dots> = (if b ! (index init (snd ?neurein)) then 2 else 1) \n                            + (\\<Sum>y\\<in>(Inv ys (s'_A n m)). (\\<lambda>i. if b ! (index init (snd i)) then 2::real else 1) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n                 {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init (snd y) then 2 else 1) =\n    (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)", "using False"], ["proof (prove)\nusing this:\n  (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<notin> Inv ys (s'_A n m)\n\ngoal (1 subgoal):\n 1. (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n                 {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init (snd y) then 2 else 1) =\n    (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n               {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init (snd y) then 2 else 1) =\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m) -\n               {(s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init (snd y) then 2 else 1) =\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"\\<dots> \\<le> (if b ! (index init (snd ?neurein)) then 2 else 1) \n                            + (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "by(simp only: split_def)"], ["proof (state)\nthis:\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>y\\<in>Inv ys (s'_A n m). if b ! index init (snd y) then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>insert\n                 (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n                 (Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (if b !\n              index init\n               (snd (s'_A n m !\n                     (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                     s'_A n m !\n                     Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n           then 2 else 1) +\n          (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>insert\n               (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n               (Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (if b !\n            index init\n             (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                   s'_A n m !\n                   Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n         then 2 else 1) +\n        (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! (index init y) then 2 else 1) +\n                        (if b ! (index init (s'_A n m ! Suc (paid_A ! n ! ?revm))) then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b !\n        index init\n         (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n     then 2 else 1) +\n    (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n       if b ! index init y then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (if b !\n      index init\n       (snd (s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n             s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))))\n   then 2 else 1) +\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1) +\n  (if b !\n      index init\n       (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   then 2 else 1)\n\ngoal (2 subgoals):\n 1. s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n    s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)\n 2. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "case False"], ["proof (state)\nthis:\n  \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n         s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n         s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys", "have \"?A' = (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m) - {(s'_A n m ! Suc (paid_A ! n ! ?revm), s'_A n m ! (paid_A ! n ! ?revm))}\n                        ). if b ! (index init y) then 2 else 1)\""], ["proof (prove)\nusing this:\n  \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n         s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)) in ys\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> \\<le> (\\<Sum>(xa, y)\\<in>(Inv ys (s'_A n m)). if b ! (index init y) then 2 else 1)\" (is \"(\\<Sum>(xa, y)\\<in>?X-{?x}. ?g y) \\<le> (\\<Sum>(xa, y)\\<in>?X. ?g y) \")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "proof (cases \"?x \\<in> ?X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "case True"], ["proof (state)\nthis:\n  (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n   s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n  \\<in> Inv ys (s'_A n m)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"(\\<Sum>(xa, y)\\<in>?X-{?x}. ?g y) \\<le> (%(xa,y). ?g y) ?x + (\\<Sum>(xa, y)\\<in>?X-{?x}. ?g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (case (s'_A n m !\n                 Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                 s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m))) of\n           (xa, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n          (\\<Sum>(xa, y)\n                 \\<in>Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n             if b ! index init y then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (case (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m))) of\n         (xa, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>(xa, y)\n               \\<in>Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (case (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n               s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m))) of\n         (xa, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>(xa, y)\n               \\<in>Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>?X. ?g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n           s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m))) of\n     (xa, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)", "apply(rule sum.remove[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (Inv ys (s'_A n m))\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m)", "apply(fact)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (case (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n         s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m))) of\n   (xa, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<in> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)\n 2. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n     s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n    \\<notin> Inv ys (s'_A n m) \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>Inv ys (s'_A n m) -\n                {(s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                  s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1)", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>Inv ys (s'_A n m) -\n              {(s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)))}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "have \"\\<dots> \\<le> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n           s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n           in ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if s'_A n m !\n                    (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                    s'_A n m !\n                    Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    in ys\n                 then Inv ys (s'_A n m) \\<union>\n                      {(s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m) -\n                      {(s'_A n m !\n                        Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                        s'_A n m !\n                        (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if s'_A n m ! (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                  s'_A n m !\n                  Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  in ys\n               then Inv ys (s'_A n m) \\<union>\n                    {(s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m) -\n                    {(s'_A n m !\n                      Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                      s'_A n m !\n                      (paid_A ! n ! (length (paid_A ! n) - Suc m)))}).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n    < length ys \\<Longrightarrow>\n    (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)", "show \"?A \\<le> ?B\""], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\n           \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                    < length ys\n                 then if s'_A n m !\n                         (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                         s'_A n m !\n                         Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                         in ys\n                      then Inv ys (s'_A n m) \\<union>\n                           {(s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)))}\n                      else Inv ys (s'_A n m) -\n                           {(s'_A n m !\n                             Suc (paid_A ! n !\n                                  (length (paid_A ! n) - Suc m)),\n                             s'_A n m !\n                             (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n                 else Inv ys (s'_A n m)).\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n             if b ! index init y then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\n         \\<in>(if Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                  < length ys\n               then if s'_A n m !\n                       (paid_A ! n ! (length (paid_A ! n) - Suc m)) <\n                       s'_A n m !\n                       Suc (paid_A ! n ! (length (paid_A ! n) - Suc m))\n                       in ys\n                    then Inv ys (s'_A n m) \\<union>\n                         {(s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           Suc (paid_A ! n !\n                                (length (paid_A ! n) - Suc m)))}\n                    else Inv ys (s'_A n m) -\n                         {(s'_A n m !\n                           Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)),\n                           s'_A n m !\n                           (paid_A ! n ! (length (paid_A ! n) - Suc m)))}\n               else Inv ys (s'_A n m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n           if b ! index init y then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"\\<dots> \n              \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! (index init y) then 2::real else 1) + (\\<Sum>i<m. if b ! gebub n i then 2::real else 1)\n                        + (if (b) ! (index init (s'_A n m ! Suc (paid_A ! n ! ?revm))) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n       if b ! index init y then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n             if b ! index init y then 2 else 1) +\n          (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "using yeah"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>Inv ys (s'_A n m).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m).\n       if b ! index init y then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1)\n    \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n             if b ! index init y then 2 else 1) +\n          (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n          (if b !\n              index init\n               (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n           then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1) +\n  (if b !\n      index init\n       (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n           if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1) +\n  (if b !\n      index init\n       (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n           if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n        (if b !\n            index init\n             (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n         then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! (index init y) then 2::real else 1) + (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n                        + (if (b) ! gebub n m then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n    (if b ! gebub n m then 2 else 1)", "unfolding gebub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<m.\n        if b !\n           index init\n            (s'_A n i ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc i)))\n        then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<m.\n        if b !\n           index init\n            (s'_A n i ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc i)))\n        then 2 else 1) +\n    (if b !\n        index init\n         (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n     then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n  (if b !\n      index init\n       (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n  (if b ! gebub n m then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n  (if b !\n      index init\n       (s'_A n m ! Suc (paid_A ! n ! (length (paid_A ! n) - Suc m)))\n   then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n  (if b ! gebub n m then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "have \"\\<dots> = (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! (index init y) then 2::real else 1) + (\\<Sum>i<(Suc m). if b ! gebub n i then 2 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n    (if b ! gebub n m then 2 else 1) =\n    (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n    (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<m. if b ! gebub n i then 2 else 1) +\n  (if b ! gebub n m then 2 else 1) =\n  (\\<Sum>(xa, y)\\<in>Inv ys (s_A n). if b ! index init y then 2 else 1) +\n  (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length (paid_A ! n) \\<Longrightarrow>\n                (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m).\n                   if b ! index init y then 2 else 1)\n                \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                         if b ! index init y then 2 else 1) +\n                      (\\<Sum>i<m. if b ! gebub n i then 2 else 1);\n        Suc m \\<le> length (paid_A ! n)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (Suc m)).\n                            if b ! index init y then 2 else 1)\n                         \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs.\n                                  if b ! index init y then 2 else 1) +\n                               (\\<Sum>i<Suc m.\n                                   if b ! gebub n i then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n           if b ! index init y then 2 else 1) +\n        (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (Suc m)).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(xa, y)\\<in>Inv ys (s_A n).\n           if b ! index init y then 2 else 1) +\n        (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>Inv ys (s'_A n (Suc m)).\n       case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>a\\<in>Inv ys xs.\n             case a of\n             (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n          (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>Inv ys (s'_A n (Suc m)).\n     case a of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>a\\<in>Inv ys xs.\n           case a of\n           (x, y) \\<Rightarrow> if b ! index init y then 2 else 1) +\n        (\\<Sum>i<Suc m. if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (paid_A ! n) \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys (s'_A n 0). if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<0. if b ! gebub n i then 2 else 1)", "qed (simp add: split_def)"], ["proof (state)\nthis:\n  m \\<le> length (paid_A ! n) \\<Longrightarrow>\n  (\\<Sum>(x, y)\\<in>Inv ys (s'_A n m). if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n        (\\<Sum>i<m. if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "}"], ["proof (state)\nthis:\n  ?m2 \\<le> length (paid_A ! n) \\<Longrightarrow>\n  (\\<Sum>(x, y)\\<in>Inv ys (s'_A n ?m2). if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n        (\\<Sum>i<?m2. if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "note x = this[OF a]"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (length (paid_A ! n))).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "unfolding \\<Phi>\\<^sub>1_def his"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys xs'.\n       if fst (snd x) ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "apply(simp only: b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (length (paid_A ! n))).\n       if fst (snd x) ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "using x b_def"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>Inv ys (s'_A n (length (paid_A ! n))).\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n  b = fst (snd x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(xa, y)\\<in>Inv ys (s'_A n (length (paid_A ! n))).\n       if fst (snd x) ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs. if b ! index init y then 2 else 1) +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "text \"Upper bound for the costs of BIT\""], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define inI where [simp]: \"inI = InvOf (q) ys xs'\""], ["proof (state)\nthis:\n  inI = {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define I where [simp]: \"I = card(InvOf (q) ys xs')\""], ["proof (state)\nthis:\n  I = card {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "(* ys is BITs list, xs' is A's list after paid exchanges *)"], ["proof (state)\nthis:\n  I = card {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have ub_cost_BIT:  \"(cost x) \\<le> k + 1 + I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost x \\<le> k + 1 + I", "proof (cases \"(q) \\<in> set init\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "case False"], ["proof (state)\nthis:\n  q \\<notin> set init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "(* cannot occur! ! ! OBSOLETE *)"], ["proof (state)\nthis:\n  q \\<notin> set init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "from False"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have 4: \"I = 0\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. I = 0", "by(auto simp: before_in_def)"], ["proof (state)\nthis:\n  I = 0\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "have \"(cost x) = 1 + index ys (q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost x = 1 + index ys q", "by (auto simp: ys_def t_def split_def)"], ["proof (state)\nthis:\n  cost x = 1 + index ys q\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "also"], ["proof (state)\nthis:\n  cost x = 1 + index ys q\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "have \"\\<dots> = 1 + length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + index ys q = 1 + length init", "using False"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. 1 + index ys q = 1 + length init", "by auto"], ["proof (state)\nthis:\n  1 + index ys q = 1 + length init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "also"], ["proof (state)\nthis:\n  1 + index ys q = 1 + length init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "have \"\\<dots> = 1 + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length init = 1 + k", "using False"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. 1 + length init = 1 + k", "by auto"], ["proof (state)\nthis:\n  1 + length init = 1 + k\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I\n 2. q \\<notin> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "finally"], ["proof (chain)\npicking this:\n  cost x = 1 + k", "show ?thesis"], ["proof (prove)\nusing this:\n  cost x = 1 + k\n\ngoal (1 subgoal):\n 1. cost x \\<le> k + 1 + I", "using 4"], ["proof (prove)\nusing this:\n  cost x = 1 + k\n  I = 0\n\ngoal (1 subgoal):\n 1. cost x \\<le> k + 1 + I", "by auto"], ["proof (state)\nthis:\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "case True"], ["proof (state)\nthis:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "then"], ["proof (chain)\npicking this:\n  q \\<in> set init", "have gra2: \"(q) \\<in> set ys\""], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set ys", "using dp_ys_init"], ["proof (prove)\nusing this:\n  q \\<in> set init\n  dist_perm ys init\n\ngoal (1 subgoal):\n 1. q \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  q \\<in> set ys\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "have \"(cost x) = 1 + index ys (q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost x = 1 + index ys q", "by(auto simp:  ys_def t_def split_def)"], ["proof (state)\nthis:\n  cost x = 1 + index ys q\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "also"], ["proof (state)\nthis:\n  cost x = 1 + index ys q\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "have \"\\<dots> \\<le> k + 1 + I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + index ys q \\<le> k + 1 + I", "using numberofIsbeschr[OF gra gra2]"], ["proof (prove)\nusing this:\n  index ys q\n  \\<le> index xs' q + card {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. 1 + index ys q \\<le> k + 1 + I", "by auto"], ["proof (state)\nthis:\n  1 + index ys q \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow> cost x \\<le> k + 1 + I", "finally"], ["proof (chain)\npicking this:\n  cost x \\<le> k + 1 + I", "show\"(cost x) \\<le> k + 1 + I\""], ["proof (prove)\nusing this:\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. cost x \\<le> k + 1 + I", "."], ["proof (state)\nthis:\n  cost x \\<le> k + 1 + I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "text \"Upper bound for inversions generated by free exchanges\""], ["proof (state)\nthis:\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "(* ================================================ *)\n      (* ================================================ *)\n\n      (* second part: FREE EXCHANGES *)"], ["proof (state)\nthis:\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "define ub_free\n        where \"ub_free =\n          (if (q \\<in> set init)\n           then (if b!(index init q) then  k-k' else (\\<Sum>j<k'. (if (b)!(index init (xs'!j)) then 2::real else 1) ))\n           else 0)\""], ["proof (state)\nthis:\n  ub_free =\n  (if q \\<in> set init\n   then if b ! index init q then real (k - k')\n        else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "let ?ub2 = \"- I + ub_free\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have free_ub: \"(\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b' !(index init y) then 2 else 1 ) )\n                - (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if b!(index init y) then 2 else 1) ) \\<le> ?ub2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "proof (cases \"(q) \\<in> set init\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "case False"], ["proof (state)\nthis:\n  q \\<notin> set init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from False"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have 1: \"ys' = ys\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. ys' = ys", "unfolding ys'_def step_def mtf2_def"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. (let (k, sws) = aBIT\n     in if q \\<in> set (swaps sws ys)\n        then swaps [index (swaps sws ys) q - k..<index (swaps sws ys) q]\n              (swaps sws ys)\n        else swaps sws ys) =\n    ys", "by(simp)"], ["proof (state)\nthis:\n  ys' = ys\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from False"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have 2: \"xs' = xs''\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. xs' = xs''", "unfolding xs''_def mtf2_def"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. xs' =\n    (if q \\<in> set xs'\n     then swaps [index xs' q - free_A ! n..<index xs' q] xs' else xs')", "by(simp)"], ["proof (state)\nthis:\n  xs' = xs''\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from False"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have \"(index init q) \\<ge> length b\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. length b \\<le> index init q", "using setinit"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. length b \\<le> index init q", "by auto"], ["proof (state)\nthis:\n  length b \\<le> index init q\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "then"], ["proof (chain)\npicking this:\n  length b \\<le> index init q", "have 3: \"b' = b\""], ["proof (prove)\nusing this:\n  length b \\<le> index init q\n\ngoal (1 subgoal):\n 1. b' = b", "unfolding b'_def"], ["proof (prove)\nusing this:\n  length b \\<le> index init q\n\ngoal (1 subgoal):\n 1. flip (index init q) b = b", "using flip_out_of_bounds"], ["proof (prove)\nusing this:\n  length b \\<le> index init q\n  length ?X \\<le> ?y \\<Longrightarrow> flip ?y ?X = ?X\n\ngoal (1 subgoal):\n 1. flip (index init q) b = b", "by auto"], ["proof (state)\nthis:\n  b' = b\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from False"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have 4: \"I = 0\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. I = 0", "unfolding I_def before_in_def"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. card\n     {(x, q) |x.\n      (index ys x < index ys q \\<and> q \\<in> set ys) \\<and>\n      index xs' q < index xs' x \\<and> x \\<in> set xs'} =\n    0", "by(auto)"], ["proof (state)\nthis:\n  I = 0\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "note ubnn=False"], ["proof (state)\nthis:\n  q \\<notin> set init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have nn: \"k-k'\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> k - k'", "unfolding k_def k'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> index xs' q - max 0 (index xs' q - free_A ! n)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> k - k'\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from 1 2 3 4"], ["proof (chain)\npicking this:\n  ys' = ys\n  xs' = xs''\n  b' = b\n  I = 0", "have \"(\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b'!(index init y) then 2::real else 1))\n                - (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if b!(index init y) then 2 else 1)) = -I\""], ["proof (prove)\nusing this:\n  ys' = ys\n  xs' = xs''\n  b' = b\n  I = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n    real_of_int (- int I)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  real_of_int (- int I)\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free\n 2. q \\<notin> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "with ubnn"], ["proof (chain)\npicking this:\n  q \\<notin> set init\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  real_of_int (- int I)", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "unfolding ub_free_def"], ["proof (prove)\nusing this:\n  q \\<notin> set init\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) +\n          (if q \\<in> set init\n           then if b ! index init q then real (k - k')\n                else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1\n           else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "case True"], ["proof (state)\nthis:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "note queryinlist=this"], ["proof (state)\nthis:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "then"], ["proof (chain)\npicking this:\n  q \\<in> set init", "have gra2: \"q \\<in> set ys\""], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set ys", "using dp_ys_init"], ["proof (prove)\nusing this:\n  q \\<in> set init\n  dist_perm ys init\n\ngoal (1 subgoal):\n 1. q \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  q \\<in> set ys\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have k_inbounds: \"k < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length init", "using index_less_size_conv  queryinlist"], ["proof (prove)\nusing this:\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. k < length init", "by (simp)"], ["proof (state)\nthis:\n  k < length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "{"], ["proof (state)\nthis:\n  k < length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "fix y  e"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "fix X::\"bool list\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "assume rd: \"e < length X\""], ["proof (state)\nthis:\n  e < length X\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have \"y < length X \\<Longrightarrow> (if flip e X ! y then 2::real else 1) - (if X ! y then 2 else 1)\n              = (if e=y then (if X ! y then -1 else 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < length X \\<Longrightarrow>\n    (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if e = y then if X ! y then - 1 else 1 else 0)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)\n 2. \\<lbrakk>y < length X; \\<not> ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "assume \"y < length X\" and ey: \"e=y\""], ["proof (state)\nthis:\n  y < length X\n  e = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)\n 2. \\<lbrakk>y < length X; \\<not> ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "then"], ["proof (chain)\npicking this:\n  y < length X\n  e = y", "have \"(if flip e X ! y then 2::real else 1) - (if X ! y then 2 else 1)\n                      = (if X ! y then 1::real else 2) - (if X ! y then 2 else 1)\""], ["proof (prove)\nusing this:\n  y < length X\n  e = y\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if X ! y then 1 else 2) - (if X ! y then 2 else 1)", "using flip_itself"], ["proof (prove)\nusing this:\n  y < length X\n  e = y\n  ?y < length ?X \\<Longrightarrow> flip ?y ?X ! ?y = (\\<not> ?X ! ?y)\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if X ! y then 1 else 2) - (if X ! y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then 1 else 2) - (if X ! y then 2 else 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)\n 2. \\<lbrakk>y < length X; \\<not> ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "also"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then 1 else 2) - (if X ! y then 2 else 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)\n 2. \\<lbrakk>y < length X; \\<not> ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "have \"\\<dots> = (if X ! y then -1::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if X ! y then 1 else 2) - (if X ! y then 2 else 1) =\n    (if X ! y then - 1 else 1)", "by auto"], ["proof (state)\nthis:\n  (if X ! y then 1 else 2) - (if X ! y then 2 else 1) =\n  (if X ! y then - 1 else 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y < length X; ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)\n 2. \\<lbrakk>y < length X; \\<not> ?P\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then - 1 else 1)", "show \"(if flip e X ! y then 2::real else 1) - (if X ! y then 2 else 1)\n              = (if e=y then (if X ! y then -1 else 1) else 0)\""], ["proof (prove)\nusing this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then - 1 else 1)\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if e = y then if X ! y then - 1 else 1 else 0)", "using ey"], ["proof (prove)\nusing this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then - 1 else 1)\n  e = y\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if e = y then if X ! y then - 1 else 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if e = y then if X ! y then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "assume len: \"y < length X\" and eny: \"e\\<noteq>y\""], ["proof (state)\nthis:\n  y < length X\n  e \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "then"], ["proof (chain)\npicking this:\n  y < length X\n  e \\<noteq> y", "have \"(if flip e X ! y then 2::real else 1) - (if X ! y then 2 else 1)\n                      = (if X ! y then 2::real else 1) - (if X ! y then 2 else 1)\""], ["proof (prove)\nusing this:\n  y < length X\n  e \\<noteq> y\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if X ! y then 2 else 1) - (if X ! y then 2 else 1)", "using flip_other[OF len rd eny]"], ["proof (prove)\nusing this:\n  y < length X\n  e \\<noteq> y\n  flip e X ! y = X ! y\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if X ! y then 2 else 1) - (if X ! y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then 2 else 1) - (if X ! y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "also"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if X ! y then 2 else 1) - (if X ! y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if X ! y then 2 else 1) - (if X ! y then 2 else 1) = 0", "by auto"], ["proof (state)\nthis:\n  (if X ! y then 2 else 1) - (if X ! y then 2 else 1) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y < length X; e \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (if flip e X ! y then 2 else 1) -\n                      (if X ! y then 2 else 1) =\n                      (if e = y then if X ! y then - 1 else 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) = 0", "show \"(if flip e X ! y then 2::real else 1) - (if X ! y then 2 else 1)\n              = (if e=y then (if X ! y then -1 else 1) else 0)\""], ["proof (prove)\nusing this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) = 0\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if e = y then if X ! y then - 1 else 1 else 0)", "using eny"], ["proof (prove)\nusing this:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) = 0\n  e \\<noteq> y\n\ngoal (1 subgoal):\n 1. (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n    (if e = y then if X ! y then - 1 else 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if e = y then if X ! y then - 1 else 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y < length X \\<Longrightarrow>\n  (if flip e X ! y then 2 else 1) - (if X ! y then 2 else 1) =\n  (if e = y then if X ! y then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?e2 < length ?X2; ?y2 < length ?X2\\<rbrakk>\n  \\<Longrightarrow> (if flip ?e2 ?X2 ! ?y2 then 2 else 1) -\n                    (if ?X2 ! ?y2 then 2 else 1) =\n                    (if ?e2 = ?y2 then if ?X2 ! ?y2 then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "note flipstyle=this"], ["proof (state)\nthis:\n  \\<lbrakk>?e2 < length ?X2; ?y2 < length ?X2\\<rbrakk>\n  \\<Longrightarrow> (if flip ?e2 ?X2 ! ?y2 then 2 else 1) -\n                    (if ?X2 ! ?y2 then 2 else 1) =\n                    (if ?e2 = ?y2 then if ?X2 ! ?y2 then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "from queryinlist setinit"], ["proof (chain)\npicking this:\n  q \\<in> set init\n  index init ` set init = {0..<length init}", "have qsfst: \"(index init q) < length b\""], ["proof (prove)\nusing this:\n  q \\<in> set init\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init q < length b", "by simp"], ["proof (state)\nthis:\n  index init q < length b\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have fA: \"finite (Inv ys' xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys' xs'')", "by auto"], ["proof (state)\nthis:\n  finite (Inv ys' xs'')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have fB: \"finite (Inv ys xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys xs')", "by auto"], ["proof (state)\nthis:\n  finite (Inv ys xs')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "define \\<Delta> where [simp]: \"\\<Delta> = (\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b'!(index init y) then 2::real else 1))\n                - (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if b!(index init y) then 2 else 1))\""], ["proof (state)\nthis:\n  \\<Delta> =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "define C where [simp]: \"C = (\\<Sum>(x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys xs'). (if b'!(index init y) then 2::real else 1)\n                        - (if b!(index init y) then 2 else 1))\""], ["proof (state)\nthis:\n  C =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "define A where [simp]: \"A = (\\<Sum>(x,y)\\<in>(Inv ys' xs'')-(Inv ys xs'). (if b'!(index init y) then 2::real else 1))\""], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "define B where [simp]: \"B = (\\<Sum>(x,y)\\<in>(Inv ys xs')-(Inv ys' xs''). (if b!(index init y) then 2::real else 1))\""], ["proof (state)\nthis:\n  B =\n  (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have teilen: \"\\<Delta> = C + A - B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> = C + A - B", "(* C A B *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> = C + A - B", "unfolding \\<Delta>_def A_def B_def C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) +\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1)", "using sum_my[OF fA fB]"], ["proof (prove)\nusing this:\n  sum ?f (Inv ys' xs'') - sum ?g (Inv ys xs') =\n  (\\<Sum>x\\<in>Inv ys' xs'' \\<inter> Inv ys xs'. ?f x - ?g x) +\n  sum ?f (Inv ys' xs'' - Inv ys xs') -\n  sum ?g (Inv ys xs' - Inv ys' xs'')\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) +\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1)", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  \\<Delta> = C + A - B\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "then"], ["proof (chain)\npicking this:\n  \\<Delta> = C + A - B", "have \"\\<Delta> = A - B + C\""], ["proof (prove)\nusing this:\n  \\<Delta> = C + A - B\n\ngoal (1 subgoal):\n 1. \\<Delta> = A - B + C", "by auto"], ["proof (state)\nthis:\n  \\<Delta> = A - B + C\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "then"], ["proof (chain)\npicking this:\n  \\<Delta> = A - B + C", "have teilen2: \"\\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>1 x  = A - B + C\""], ["proof (prove)\nusing this:\n  \\<Delta> = A - B + C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>1 x = A - B + C", "unfolding \\<Delta>_def"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  A - B + C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>1 x = A - B + C", "using dis gis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1) =\n  A - B + C\n  \\<Phi>\\<^sub>1 x =\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<Phi>\\<^sub>2 x =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>1 x = A - B + C", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>1 x = A - B + C\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have setys': \"(index init) ` (set ys') = {0..<length ys'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "have \"(index init) ` (set ys') = (index init) ` (set init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init ` set ys' = index init ` set init", "by auto"], ["proof (state)\nthis:\n  index init ` set ys' = index init ` set init\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "also"], ["proof (state)\nthis:\n  index init ` set ys' = index init ` set init\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "have \"\\<dots> = {0..<length init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index init ` set init = {0..<length init}", "using setinit"], ["proof (prove)\nusing this:\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init ` set init = {0..<length init}", "by auto"], ["proof (state)\nthis:\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "also"], ["proof (state)\nthis:\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "have \"\\<dots> = {0..<length ys'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<length init} = {0..<length ys'}", "using lenys'"], ["proof (prove)\nusing this:\n  length ys' = length init\n\ngoal (1 subgoal):\n 1. {0..<length init} = {0..<length ys'}", "by auto"], ["proof (state)\nthis:\n  {0..<length init} = {0..<length ys'}\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "finally"], ["proof (chain)\npicking this:\n  index init ` set ys' = {0..<length ys'}", "show ?thesis"], ["proof (prove)\nusing this:\n  index init ` set ys' = {0..<length ys'}\n\ngoal (1 subgoal):\n 1. index init ` set ys' = {0..<length ys'}", "."], ["proof (state)\nthis:\n  index init ` set ys' = {0..<length ys'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index init ` set ys' = {0..<length ys'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have BC_absch: \"C - B \\<le> -I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C - B \\<le> real_of_int (- int I)", "proof (cases \"b!(index init q)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "(* case distinction on whether the bit of the requested element is set *)"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "case True"], ["proof (state)\nthis:\n  b ! index init q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  b ! index init q", "have samesame: \"ys' = ys\""], ["proof (prove)\nusing this:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. ys' = ys", "unfolding ys'_def step_def"], ["proof (prove)\nusing this:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. (let (k, sws) = aBIT in mtf2 k q (swaps sws ys)) = ys", "by auto"], ["proof (state)\nthis:\n  ys' = ys\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  ys' = ys", "have puh: \"(Inv ys' xs') = (Inv ys xs')\""], ["proof (prove)\nusing this:\n  ys' = ys\n\ngoal (1 subgoal):\n 1. Inv ys' xs' = Inv ys xs'", "by auto"], ["proof (state)\nthis:\n  Inv ys' xs' = Inv ys xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "{"], ["proof (state)\nthis:\n  Inv ys' xs' = Inv ys xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "fix \\<alpha> \\<beta>"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "assume \"(\\<alpha>,\\<beta>)\\<in>(Inv ys' xs'') \\<inter> (Inv ys' xs')\""], ["proof (state)\nthis:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs'", "have \"(\\<alpha>,\\<beta>)\\<in>(Inv ys' xs'')\""], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs'\n\ngoal (1 subgoal):\n 1. (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''", "by auto"], ["proof (state)\nthis:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''", "have \"(\\<alpha>< \\<beta> in ys')\""], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> in ys'", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> {(x, y). x < y in ys' \\<and> y < x in xs''}\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> in ys'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> < \\<beta> in ys'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<beta> in ys'", "have 1: \"\\<beta> \\<in> set ys'\""], ["proof (prove)\nusing this:\n  \\<alpha> < \\<beta> in ys'\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set ys'", "by (simp only: before_in_setD2)"], ["proof (state)\nthis:\n  \\<beta> \\<in> set ys'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> set ys'", "have  \"index init \\<beta> < length ys'\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length ys'", "using setys'"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n  index init ` set ys' = {0..<length ys'}\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length ys'", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length ys'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  index init \\<beta> < length ys'", "have  \"index init \\<beta> < length init\""], ["proof (prove)\nusing this:\n  index init \\<beta> < length ys'\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length init", "using lenys'"], ["proof (prove)\nusing this:\n  index init \\<beta> < length ys'\n  length ys' = length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length init", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length init\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  index init \\<beta> < length init", "have puzzel: \"index init \\<beta> < length b\""], ["proof (prove)\nusing this:\n  index init \\<beta> < length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length b", "using leninitb"], ["proof (prove)\nusing this:\n  index init \\<beta> < length init\n  length b = length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length b", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length b\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have betainit: \"\\<beta> \\<in> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set init", "using 1"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set init", "by auto"], ["proof (state)\nthis:\n  \\<beta> \\<in> set init\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have aha: \"(q=\\<beta>) = (index init q = index init \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = \\<beta>) = (index init q = index init \\<beta>)", "using betainit"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set init\n\ngoal (1 subgoal):\n 1. (q = \\<beta>) = (index init q = index init \\<beta>)", "by simp"], ["proof (state)\nthis:\n  (q = \\<beta>) = (index init q = index init \\<beta>)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"(if b'!(index init \\<beta>) then 2::real else 1) - (if b!(index init \\<beta>) then 2 else 1)\n                = (if (index init q) = (index init \\<beta>) then if b !(index init \\<beta>) then - 1 else 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b' ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0)", "unfolding b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if flip (index init q) b ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0)", "apply(rule flipstyle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init q < length b\n 2. index init \\<beta> < length b", "by(fact)+"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (if (index init q) = (index init \\<beta>) then if b ! (index init q) then - 1 else 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0) =\n    (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0) =\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0) =\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (if q = \\<beta> then - 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0) =\n    (if q = \\<beta> then - 1 else 0)", "using aha True"], ["proof (prove)\nusing this:\n  (q = \\<beta>) = (index init q = index init \\<beta>)\n  b ! index init q\n\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0) =\n    (if q = \\<beta> then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0) =\n  (if q = \\<beta> then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then - 1 else 0)", "have \"(if b'!(index init \\<beta>) then 2::real else 1) - (if b!(index init \\<beta>) then 2 else 1)\n                = (if (q) = \\<beta> then -1::real else 0)\""], ["proof (prove)\nusing this:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then - 1 else 0)\n\ngoal (1 subgoal):\n 1. (if b' ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if q = \\<beta> then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "}"], ["proof (state)\nthis:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then - 1 else 0)", "have grreeeaa: \"\\<forall>x\\<in>(Inv ys' xs'') \\<inter> (Inv ys' xs').\n              (\\<lambda>x. (if b'! (index init (snd x)) then 2::real else 1) - (if b! (index init (snd x)) then 2 else 1)) x\n                = (\\<lambda>x. (if (q) = snd x then -1::real else 0)) x\""], ["proof (prove)\nusing this:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then - 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       (if b' ! index init (snd x) then 2 else 1) -\n       (if b ! index init (snd x) then 2 else 1) =\n       (if q = snd x then - 1 else 0)", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init (snd x) then 2 else 1) -\n     (if b ! index init (snd x) then 2 else 1) =\n     (if q = snd x then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "let ?fin=\"(Inv ys' xs'') \\<inter> (Inv ys' xs')\""], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have ttt: \"{(x,y). (x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys' xs')\n                          \\<and> y = (q)} \\<union> {(x,y). (x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys' xs')\n                          \\<and> y \\<noteq> (q)} = (Inv ys' xs'') \\<inter> (Inv ys' xs')\" (is \"?split1 \\<union> ?split2 = ?easy\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} \\<union>\n    {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q} =\n    Inv ys' xs'' \\<inter> Inv ys' xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} \\<union>\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q} =\n  Inv ys' xs'' \\<inter> Inv ys' xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have interem: \"?split1 \\<inter> ?split2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} \\<inter>\n    {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} \\<inter>\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q} =\n  {}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split1subs: \"?split1 \\<subseteq> ?fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n  \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split2subs: \"?split2 \\<subseteq> ?fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n  \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs1: \"finite ?split1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}", "apply(rule finite_subset[where B=\"?fin\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'\n 2. finite (Inv ys' xs'' \\<inter> Inv ys' xs')", "apply(rule split1subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys' xs'' \\<inter> Inv ys' xs')", "by(auto)"], ["proof (state)\nthis:\n  finite\n   {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs2: \"finite ?split2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(x, y).\n      (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}", "apply(rule finite_subset[where B=\"?fin\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys' xs'\n 2. finite (Inv ys' xs'' \\<inter> Inv ys' xs')", "apply(rule split2subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys' xs'' \\<inter> Inv ys' xs')", "by(auto)"], ["proof (state)\nthis:\n  finite\n   {(x, y).\n    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"k - k' \\<le> (free_A!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - k' \\<le> free_A ! n", "by auto"], ["proof (state)\nthis:\n  k - k' \\<le> free_A ! n\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have g: \"InvOf (q) ys' xs'' \\<supseteq> InvOf (q) ys' xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n    \\<subseteq> {(x, q) |x. x < q in ys' \\<and> q < x in xs''}", "using True"], ["proof (prove)\nusing this:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n    \\<subseteq> {(x, q) |x. x < q in ys' \\<and> q < x in xs''}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b ! index init q; x < q in ys';\n        q < x in swaps (paid_A ! n) (s_A n)\\<rbrakk>\n       \\<Longrightarrow> q < x\n                         in mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))", "apply(rule mtf2_mono[of \"swaps (paid_A ! n) (s_A n)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>b ! index init q; x < q in ys';\n        q < x in swaps (paid_A ! n) (s_A n)\\<rbrakk>\n       \\<Longrightarrow> distinct (swaps (paid_A ! n) (s_A n))\n 2. \\<And>x.\n       \\<lbrakk>b ! index init q; x < q in ys';\n        q < x in swaps (paid_A ! n) (s_A n)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (swaps (paid_A ! n) (s_A n))\n 3. \\<And>x.\n       \\<lbrakk>b ! index init q; x < q in ys';\n        q < x in swaps (paid_A ! n) (s_A n)\\<rbrakk>\n       \\<Longrightarrow> q < x in swaps (paid_A ! n) (s_A n)", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n  \\<subseteq> {(x, q) |x. x < q in ys' \\<and> q < x in xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have h: \"?split1 = (InvOf (q) ys' xs'') \\<inter> (InvOf (q) ys' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs'}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y)\n     \\<in> {(x, y). x < y in ys' \\<and> y < x in xs''} \\<inter>\n           {(x, y). x < y in ys' \\<and> y < x in xs'} \\<and>\n     y = q} =\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs'}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from g"], ["proof (chain)\npicking this:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n  \\<subseteq> {(x, q) |x. x < q in ys' \\<and> q < x in xs''}", "have \"\\<dots> = InvOf (q) ys' xs'\""], ["proof (prove)\nusing this:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n  \\<subseteq> {(x, q) |x. x < q in ys' \\<and> q < x in xs''}\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs'} =\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs'}", "by force"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from samesame"], ["proof (chain)\npicking this:\n  ys' = ys", "have \"\\<dots> = InvOf (q) ys  xs'\""], ["proof (prove)\nusing this:\n  ys' = ys\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs'} =\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'}", "by simp"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs'} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}", "have \"?split1 = inI\""], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n    inI", "unfolding inI_def"], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'}", "."], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  inI\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  inI", "have cardsp1isI: \"card ?split1 = I\""], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  inI\n\ngoal (1 subgoal):\n 1. card\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n    I", "by auto"], ["proof (state)\nthis:\n  card\n   {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  I\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "{"], ["proof (state)\nthis:\n  card\n   {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  I\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "assume \"(a,b)\\<in>?split1\""], ["proof (state)\nthis:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}", "have \"b = (q)\""], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}\n\ngoal (1 subgoal):\n 1. b = q", "by auto"], ["proof (state)\nthis:\n  b = q\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  b = q", "have \"(if (q) = b then (-1::real) else 0) = (-1::real)\""], ["proof (prove)\nusing this:\n  b = q\n\ngoal (1 subgoal):\n 1. (if q = b then - 1 else 0) = - 1", "by auto"], ["proof (state)\nthis:\n  (if q = b then - 1 else 0) = - 1\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "}"], ["proof (state)\nthis:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y = q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = - 1\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y = q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = - 1", "have split1easy: \"\\<forall>x\\<in>?split1.\n              (\\<lambda>x. (if (q) = snd x then (-1::real) else 0)) x = (\\<lambda>x. (-1::real)) x\""], ["proof (prove)\nusing this:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y = q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                    y = q}.\n       (if q = snd x then - 1 else 0) = - 1", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                  y = q}.\n     (if q = snd x then - 1 else 0) = - 1\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "{"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                  y = q}.\n     (if q = snd x then - 1 else 0) = - 1\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "assume \"(a,b)\\<in>?split2\""], ["proof (state)\nthis:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}", "have \"~ b = (q)\""], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y \\<noteq> q}\n\ngoal (1 subgoal):\n 1. b \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> q\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> q", "have \"(if (q) = b then (-1::real) else 0) = 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> q\n\ngoal (1 subgoal):\n 1. (if q = b then - 1 else 0) = 0", "by auto"], ["proof (state)\nthis:\n  (if q = b then - 1 else 0) = 0\n\ngoal (2 subgoals):\n 1. b__ ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b__ ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "}"], ["proof (state)\nthis:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y \\<noteq> q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = 0\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y \\<noteq> q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = 0", "have split2easy: \"\\<forall>x\\<in>?split2.\n              (\\<lambda>x. (if (q) = snd x then (-1::real) else 0)) x = (\\<lambda>x. 0::real) x\""], ["proof (prove)\nusing this:\n  (?a2, ?ba2)\n  \\<in> {(x, y).\n         (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n         y \\<noteq> q} \\<Longrightarrow>\n  (if q = ?ba2 then - 1 else 0) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                    y \\<noteq> q}.\n       (if q = snd x then - 1 else 0) = 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                  y \\<noteq> q}.\n     (if q = snd x then - 1 else 0) = 0\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E0: \"C =\n              (\\<Sum>(x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys xs'). \n                      (if b'!(index init y) then 2::real else 1) - (if b!(index init y) then 2 else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1))", "by auto"], ["proof (state)\nthis:\n  C =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  C =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from puh"], ["proof (chain)\npicking this:\n  Inv ys' xs' = Inv ys xs'", "have E1: \"... =\n              (\\<Sum>(x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys' xs'). \n                      (if b'!(index init y) then 2::real else 1) - (if b!(index init y) then 2 else 1))\""], ["proof (prove)\nusing this:\n  Inv ys' xs' = Inv ys xs'\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1)) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1)) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E2: \"\\<dots> = (\\<Sum>(x,y)\\<in>?easy. \n                      (if (q) = y then (-1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       if q = y then - 1 else 0)", "using sum_my2[OF grreeeaa]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init (snd x) then 2 else 1) -\n     (if b ! index init (snd x) then 2 else 1)) =\n  (\\<Sum>x\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     if q = snd x then - 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       if q = y then - 1 else 0)", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1)) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     (if b' ! index init y then 2 else 1) -\n     (if b ! index init y then 2 else 1)) =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E3: \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1 \\<union> ?split2. \n                      (if (q) = y then (-1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n       if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0)", "by(simp only: ttt)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys' xs'.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if (q) = y then (-1::real) else 0))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if (q) = y then (-1::real) else 0))\n                    - (\\<Sum>(x,y)\\<in>?split1 \\<inter> ?split2. (if (q) = y then (-1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0)", "by(rule sum_Un[OF fs1 fs2])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if (q) = y then (-1::real) else 0))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if (q) = y then (-1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0)", "apply(simp only: interem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) -\n    (\\<Sum>(x, y)\\<in>{}. if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E4: \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (-1::real) )\n                    + (\\<Sum>(x,y)\\<in>?split2. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       - 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       0)", "using sum_my2[OF split1easy]sum_my2[OF split2easy]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                y = q}.\n     if q = snd x then - 1 else 0) =\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                y = q}.\n     - 1)\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                y \\<noteq> q}.\n     if q = snd x then - 1 else 0) =\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                y \\<noteq> q}.\n     0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       if q = y then - 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then - 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       - 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       0)", "by(simp only: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     if q = y then - 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then - 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     0)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (-1::real) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       - 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y \\<noteq> q}.\n       0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       - 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y \\<noteq> q}.\n     0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E5: \"\\<dots> = - card ?split1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n                 y = q}.\n       - 1) =\n    real_of_int\n     (- int (card\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) =\n  real_of_int\n   (- int (card\n            {(x, y).\n             (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}.\n     - 1) =\n  real_of_int\n   (- int (card\n            {(x, y).\n             (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q}))\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have E6: \"\\<dots> = - I \""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (- int (card\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q})) =\n    real_of_int (- int I)", "using cardsp1isI"], ["proof (prove)\nusing this:\n  card\n   {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and> y = q} =\n  I\n\ngoal (1 subgoal):\n 1. real_of_int\n     (- int (card\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n               y = q})) =\n    real_of_int (- int I)", "by auto"], ["proof (state)\nthis:\n  real_of_int\n   (- int (card\n            {(x, y).\n             (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys' xs' \\<and>\n             y = q})) =\n  real_of_int (- int I)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  C = real_of_int (- int I)", "have abschC: \"C = -I\""], ["proof (prove)\nusing this:\n  C = real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. C = real_of_int (- int I)", "."], ["proof (state)\nthis:\n  C = real_of_int (- int I)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have abschB: \"B \\<ge> (0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n               if b ! index init y then 2 else 1)", "apply(rule sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Inv ys xs' - Inv ys' xs'' \\<Longrightarrow>\n       0 \\<le> (case x of\n                (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> B\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow> C - B \\<le> real_of_int (- int I)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from abschB abschC"], ["proof (chain)\npicking this:\n  0 \\<le> B\n  C = real_of_int (- int I)", "show \"C - B \\<le> -I\""], ["proof (prove)\nusing this:\n  0 \\<le> B\n  C = real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. C - B \\<le> real_of_int (- int I)", "by simp"], ["proof (state)\nthis:\n  C - B \\<le> real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "case False"], ["proof (state)\nthis:\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from leninitys False"], ["proof (chain)\npicking this:\n  length ys = length init\n  \\<not> b ! index init q", "have ya: \"ys' = mtf2 (length ys) q ys\""], ["proof (prove)\nusing this:\n  length ys = length init\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. ys' = mtf2 (length ys) q ys", "unfolding step_def ys'_def"], ["proof (prove)\nusing this:\n  length ys = length init\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. (let (k, sws) = aBIT in mtf2 k q (swaps sws ys)) = mtf2 (length ys) q ys", "by(auto)"], ["proof (state)\nthis:\n  ys' = mtf2 (length ys) q ys\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"index ys' q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index ys' q = 0", "unfolding ya"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 (length ys) q ys) q = 0", "apply(rule mtf2_moves_to_front)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct ys\n 2. q \\<in> set ys", "using gra2"], ["proof (prove)\nusing this:\n  q \\<in> set ys\n\ngoal (2 subgoals):\n 1. distinct ys\n 2. q \\<in> set ys", "by simp_all"], ["proof (state)\nthis:\n  index ys' q = 0\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  index ys' q = 0", "have nixbefore: \"before q ys' = {}\""], ["proof (prove)\nusing this:\n  index ys' q = 0\n\ngoal (1 subgoal):\n 1. before q ys' = {}", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index ys' q = 0\n\ngoal (1 subgoal):\n 1. {y. index ys' y < index ys' q \\<and> q \\<in> set ys'} = {}", "by auto"], ["proof (state)\nthis:\n  before q ys' = {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "{"], ["proof (state)\nthis:\n  before q ys' = {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "fix \\<alpha> \\<beta>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "assume \"(\\<alpha>,\\<beta>)\\<in>(Inv ys' xs'') \\<inter> (Inv ys xs')\""], ["proof (state)\nthis:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys xs'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys xs'", "have \"(\\<alpha>,\\<beta>)\\<in>(Inv ys' xs'')\""], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs'' \\<inter> Inv ys xs'\n\ngoal (1 subgoal):\n 1. (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''", "by auto"], ["proof (state)\nthis:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''", "have \"(\\<alpha>< \\<beta> in ys')\""], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> in ys'", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  (\\<alpha>, \\<beta>) \\<in> {(x, y). x < y in ys' \\<and> y < x in xs''}\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> in ys'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> < \\<beta> in ys'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<beta> in ys'", "have 1: \"\\<beta> \\<in> set ys'\""], ["proof (prove)\nusing this:\n  \\<alpha> < \\<beta> in ys'\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set ys'", "by (simp only: before_in_setD2)"], ["proof (state)\nthis:\n  \\<beta> \\<in> set ys'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> set ys'", "have  \"(index init \\<beta>) < length ys'\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length ys'", "using setys'"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n  index init ` set ys' = {0..<length ys'}\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length ys'", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length ys'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  index init \\<beta> < length ys'", "have  \"(index init \\<beta>) < length init\""], ["proof (prove)\nusing this:\n  index init \\<beta> < length ys'\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length init", "using lenys'"], ["proof (prove)\nusing this:\n  index init \\<beta> < length ys'\n  length ys' = length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length init", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length init\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  index init \\<beta> < length init", "have puzzel: \"(index init \\<beta>) < length b\""], ["proof (prove)\nusing this:\n  index init \\<beta> < length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length b", "using leninitb"], ["proof (prove)\nusing this:\n  index init \\<beta> < length init\n  length b = length init\n\ngoal (1 subgoal):\n 1. index init \\<beta> < length b", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> < length b\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have betainit: \"\\<beta> \\<in> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set init", "using 1"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set ys'\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> set init", "by auto"], ["proof (state)\nthis:\n  \\<beta> \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have aha: \"(q=\\<beta>) = (index init q = index init \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = \\<beta>) = (index init q = index init \\<beta>)", "using betainit"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> set init\n\ngoal (1 subgoal):\n 1. (q = \\<beta>) = (index init q = index init \\<beta>)", "by simp"], ["proof (state)\nthis:\n  (q = \\<beta>) = (index init q = index init \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"(if b'!(index init \\<beta>) then 2::real else 1) - (if b!(index init \\<beta>) then 2 else 1)\n                = (if (index init q) = (index init \\<beta>) then if b ! (index init \\<beta>) then - 1 else 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b' ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0)", "unfolding b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if flip (index init q) b ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0)", "apply(rule flipstyle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init q < length b\n 2. index init \\<beta> < length b", "by(fact)+"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (if (index init q) = (index init \\<beta>) then if b ! (index init q) then - 1 else 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init \\<beta> then - 1 else 1 else 0) =\n    (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0) =\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init \\<beta> then - 1 else 1 else 0) =\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (if (q) = \\<beta> then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0) =\n    (if q = \\<beta> then 1 else 0)", "using False aha"], ["proof (prove)\nusing this:\n  \\<not> b ! index init q\n  (q = \\<beta>) = (index init q = index init \\<beta>)\n\ngoal (1 subgoal):\n 1. (if index init q = index init \\<beta>\n     then if b ! index init q then - 1 else 1 else 0) =\n    (if q = \\<beta> then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if index init q = index init \\<beta>\n   then if b ! index init q then - 1 else 1 else 0) =\n  (if q = \\<beta> then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then 1 else 0)", "have \"(if b'!(index init \\<beta>) then 2::real else 1) - (if b!(index init \\<beta>) then 2 else 1)\n                = (if (q) = \\<beta> then 1::real else 0)\""], ["proof (prove)\nusing this:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then 1 else 0)\n\ngoal (1 subgoal):\n 1. (if b' ! index init \\<beta> then 2 else 1) -\n    (if b ! index init \\<beta> then 2 else 1) =\n    (if q = \\<beta> then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (if b' ! index init \\<beta> then 2 else 1) -\n  (if b ! index init \\<beta> then 2 else 1) =\n  (if q = \\<beta> then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "}"], ["proof (state)\nthis:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "then"], ["proof (chain)\npicking this:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then 1 else 0)", "have grreeeaa2: \"\\<forall>x\\<in>(Inv ys' xs'') \\<inter> (Inv ys xs').\n              (\\<lambda>x. (if b'! (index init (snd x)) then 2::real else 1) - (if b! (index init (snd x)) then 2 else 1)) x\n                = (\\<lambda>x. (if (q) = snd x then 1::real else 0)) x\""], ["proof (prove)\nusing this:\n  (?\\<alpha>2, ?\\<beta>2)\n  \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<Longrightarrow>\n  (if b' ! index init ?\\<beta>2 then 2 else 1) -\n  (if b ! index init ?\\<beta>2 then 2 else 1) =\n  (if q = ?\\<beta>2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init (snd x) then 2 else 1) -\n       (if b ! index init (snd x) then 2 else 1) =\n       (if q = snd x then 1 else 0)", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     (if b' ! index init (snd x) then 2 else 1) -\n     (if b ! index init (snd x) then 2 else 1) =\n     (if q = snd x then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "let ?fin=\"(Inv ys' xs'') \\<inter> (Inv ys xs')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have ttt: \"{(x,y). (x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys  xs')\n                          \\<and> y = (q)} \\<union> {(x,y). (x,y)\\<in>(Inv ys' xs'') \\<inter> (Inv ys  xs')\n                          \\<and> y \\<noteq> (q)} = (Inv ys' xs'') \\<inter> (Inv ys  xs')\" (is \"?split1 \\<union> ?split2 = ?easy\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} \\<union>\n    {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q} =\n    Inv ys' xs'' \\<inter> Inv ys xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} \\<union>\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q} =\n  Inv ys' xs'' \\<inter> Inv ys xs'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have interem: \"?split1 \\<inter> ?split2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} \\<inter>\n    {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} \\<inter>\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split1subs: \"?split1 \\<subseteq> ?fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}\n  \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split2subs: \"?split2 \\<subseteq> ?fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q}\n  \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs1: \"finite ?split1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}", "apply(rule finite_subset[where B=\"?fin\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'\n 2. finite (Inv ys' xs'' \\<inter> Inv ys xs')", "apply(rule split1subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys' xs'' \\<inter> Inv ys xs')", "by(auto)"], ["proof (state)\nthis:\n  finite\n   {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs2: \"finite ?split2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(x, y).\n      (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q}", "apply(rule finite_subset[where B=\"?fin\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y).\n     (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys' xs'' \\<inter> Inv ys xs'\n 2. finite (Inv ys' xs'' \\<inter> Inv ys xs')", "apply(rule split2subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys' xs'' \\<inter> Inv ys xs')", "by(auto)"], ["proof (state)\nthis:\n  finite\n   {(x, y).\n    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y \\<noteq> q}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split1easy : \"\\<forall>x\\<in>?split1.\n              (\\<lambda>x. (if (q) = snd x then (1::real) else 0)) x = (\\<lambda>x. (1::real)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                    y = q}.\n       (if q = snd x then 1 else 0) = 1", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                  y = q}.\n     (if q = snd x then 1 else 0) = 1\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split2easy : \"\\<forall>x\\<in>?split2.\n              (\\<lambda>x. (if (q) = snd x then (1::real) else 0)) x = (\\<lambda>x. (0::real)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                    y \\<noteq> q}.\n       (if q = snd x then 1 else 0) = 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                  y \\<noteq> q}.\n     (if q = snd x then 1 else 0) = 0\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from nixbefore"], ["proof (chain)\npicking this:\n  before q ys' = {}", "have InvOfempty: \"InvOf q ys' xs'' = {}\""], ["proof (prove)\nusing this:\n  before q ys' = {}\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs''} = {}", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  before q ys' = {}\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs''} = {}", "by auto"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} = {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"?split1 = InvOf q ys' xs'' \\<inter> InvOf q ys xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} =\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y)\n     \\<in> {(x, y). x < y in ys' \\<and> y < x in xs''} \\<inter>\n           {(x, y). x < y in ys \\<and> y < x in xs'} \\<and>\n     y = q} =\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} =\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from InvOfempty"], ["proof (chain)\npicking this:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} = {}", "have \"\\<dots> = {}\""], ["proof (prove)\nusing this:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} = {}\n\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} \\<inter>\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} = {}", "have split1empty: \"?split1 = {}\""], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} = {}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} =\n    {}", "."], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q} = {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"C  = (\\<Sum>(x,y)\\<in>?easy. \n                      (if (q) = y then (1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       if q = y then 1 else 0)", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       if q = y then 1 else 0)", "by(simp only: split_def sum_my2[OF grreeeaa2])"], ["proof (state)\nthis:\n  C =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  C =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1 \\<union> ?split2. \n                      (if (q) = y then (1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0)", "by(simp only: ttt)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if (q) = y then (1::real) else 0))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if (q) = y then (1::real) else 0))\n                    - (\\<Sum>(x,y)\\<in>?split1 \\<inter> ?split2. (if (q) = y then (1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0)", "by(rule sum_Un[OF fs1 fs2])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if (q) = y then (1::real) else 0))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if (q) = y then (1::real) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0)", "apply(simp only: interem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) -\n    (\\<Sum>(x, y)\\<in>{}. if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (1::real) )\n                    + (\\<Sum>(x,y)\\<in>?split2. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       0)", "using sum_my2[OF split1easy] sum_my2[OF split2easy]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = snd x then 1 else 0) =\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1)\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                y \\<noteq> q}.\n     if q = snd x then 1 else 0) =\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                y \\<noteq> q}.\n     0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       if q = y then 1 else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       if q = y then 1 else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       0)", "by (simp only: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     if q = y then 1 else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     if q = y then 1 else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     0)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (1::real) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y \\<noteq> q}.\n       0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n               y \\<noteq> q}.\n     0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = card ?split1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and>\n                 y = q}.\n       1) =\n    real\n     (card\n       {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q})", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) =\n  real\n   (card\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q})\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}.\n     1) =\n  real\n   (card\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q})\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (card\n       {(x, y).\n        (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}) =\n    0", "apply(simp only: split1empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card {}) = 0", "by auto"], ["proof (state)\nthis:\n  real\n   (card\n     {(x, y). (x, y) \\<in> Inv ys' xs'' \\<inter> Inv ys xs' \\<and> y = q}) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  C = 0", "have abschC: \"C = (0::real)\""], ["proof (prove)\nusing this:\n  C = 0\n\ngoal (1 subgoal):\n 1. C = 0", "."], ["proof (state)\nthis:\n  C = 0\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "(* approx for B *)"], ["proof (state)\nthis:\n  C = 0\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have ttt2: \"{(x,y). (x,y)\\<in>(Inv ys  xs') - (Inv ys' xs'')\n                          \\<and> y = (q)} \\<union> {(x,y). (x,y)\\<in>(Inv ys  xs') - (Inv ys' xs'')\n                          \\<and> y \\<noteq> (q)} = (Inv ys  xs') - (Inv ys' xs'')\" (is \"?split1 \\<union> ?split2 = ?easy2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n    {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q} =\n    Inv ys xs' - Inv ys' xs''", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q} =\n  Inv ys xs' - Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have interem: \"?split1 \\<inter> ?split2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n    {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split1subs: \"?split1 \\<subseteq> ?easy2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}\n    \\<subseteq> Inv ys xs' - Inv ys' xs''", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}\n  \\<subseteq> Inv ys xs' - Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have split2subs: \"?split2 \\<subseteq> ?easy2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys xs' - Inv ys' xs''", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}\n  \\<subseteq> Inv ys xs' - Inv ys' xs''\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs1: \"finite ?split1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}", "apply(rule finite_subset[where B=\"?easy2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}\n    \\<subseteq> Inv ys xs' - Inv ys' xs''\n 2. finite (Inv ys xs' - Inv ys' xs'')", "apply(rule split1subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys xs' - Inv ys' xs'')", "by(auto)"], ["proof (state)\nthis:\n  finite {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have fs2: \"finite ?split2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}", "apply(rule finite_subset[where B=\"?easy2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}\n    \\<subseteq> Inv ys xs' - Inv ys' xs''\n 2. finite (Inv ys xs' - Inv ys' xs'')", "apply(rule split2subs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Inv ys xs' - Inv ys' xs'')", "by(auto)"], ["proof (state)\nthis:\n  finite\n   {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from False"], ["proof (chain)\npicking this:\n  \\<not> b ! index init q", "have split1easy2: \"\\<forall>x\\<in>?split1.\n              (\\<lambda>x. (if b! (index init (snd x)) then 2::real else 1)) x = (\\<lambda>x. (1::real)) x\""], ["proof (prove)\nusing this:\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       (if b ! index init (snd x) then 2 else 1) = 1", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(x, y).\n                  (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     (if b ! index init (snd x) then 2 else 1) = 1\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"?split1 = (InvOf q ys  xs') - (InvOf q ys' xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} =\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     (x, y)\n     \\<in> {(x, y). x < y in ys \\<and> y < x in xs'} -\n           {(x, y). x < y in ys' \\<and> y < x in xs''} \\<and>\n     y = q} =\n    {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} =\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''}\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> =  inI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n    {(x, q) |x. x < q in ys' \\<and> q < x in xs''} =\n    inI", "unfolding InvOfempty"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, q) |x. x < q in ys \\<and> q < x in xs'} - {} = inI", "by auto"], ["proof (state)\nthis:\n  {(x, q) |x. x < q in ys \\<and> q < x in xs'} -\n  {(x, q) |x. x < q in ys' \\<and> q < x in xs''} =\n  inI\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} = inI", "have splI: \"?split1 = inI\""], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} = inI\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} = inI", "."], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} = inI\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have abschaway: \"(\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>(x, y)\n                   \\<in>{(x, y).\n                         (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                         y \\<noteq> q}.\n               if b ! index init y then 2 else 1)", "apply(rule sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                y \\<noteq> q} \\<Longrightarrow>\n       0 \\<le> (case x of\n                (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                       y \\<noteq> q}.\n             if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"B  =  (\\<Sum>(x,y)\\<in>?split1 \\<union> ?split2. \n                      (if b!(index init y) then 2::real else 1) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by(simp only: ttt2)"], ["proof (state)\nthis:\n  B =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  B =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if b!(index init y) then 2::real else 1))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1))\n                    - (\\<Sum>(x,y)\\<in>?split1 \\<inter> ?split2. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y = q} \\<union>\n                {(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by(rule sum_Un[OF fs1 fs2])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<union>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. (if b!(index init y) then 2::real else 1))\n                    + (\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y = q} \\<inter>\n                {(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "apply(simp only: interem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>{}. if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} \\<inter>\n              {(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>?split1. 1)\n                    + (\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "using sum_my2[OF split1easy2]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init (snd x) then 2 else 1) =\n  (\\<Sum>x\\<in>{(x, y).\n                (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       if b ! index init y then 2 else 1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by (simp only: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     if b ! index init y then 2 else 1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = card ?split1\n                    + (\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n       1) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    real\n     (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  real\n   (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}.\n     1) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  real\n   (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> = I\n                    + (\\<Sum>(x,y)\\<in>?split2. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    real I +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "using splI"], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q} = inI\n\ngoal (1 subgoal):\n 1. real\n     (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1) =\n    real I +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                 y \\<noteq> q}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  real\n   (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  real I +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "also"], ["proof (state)\nthis:\n  real\n   (card {(x, y). (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y = q}) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1) =\n  real I +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and> y \\<noteq> q}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "have \"\\<dots> \\<ge> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real I\n    \\<le> real I +\n          (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                       y \\<noteq> q}.\n             if b ! index init y then 2 else 1)", "using abschaway"], ["proof (prove)\nusing this:\n  0 \\<le> (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                       y \\<noteq> q}.\n             if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. real I\n    \\<le> real I +\n          (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                       y \\<noteq> q}.\n             if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  real I\n  \\<le> real I +\n        (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     (x, y) \\<in> Inv ys xs' - Inv ys' xs'' \\<and>\n                     y \\<noteq> q}.\n           if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "finally"], ["proof (chain)\npicking this:\n  real I \\<le> B", "have abschB: \"B \\<ge> I\""], ["proof (prove)\nusing this:\n  real I \\<le> B\n\ngoal (1 subgoal):\n 1. real I \\<le> B", "."], ["proof (state)\nthis:\n  real I \\<le> B\n\ngoal (1 subgoal):\n 1. \\<not> b ! index init q \\<Longrightarrow>\n    C - B \\<le> real_of_int (- int I)", "from abschB abschC"], ["proof (chain)\npicking this:\n  real I \\<le> B\n  C = 0", "show \"C - B \\<le> -I\""], ["proof (prove)\nusing this:\n  real I \\<le> B\n  C = 0\n\ngoal (1 subgoal):\n 1. C - B \\<le> real_of_int (- int I)", "by auto"], ["proof (state)\nthis:\n  C - B \\<le> real_of_int (- int I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C - B \\<le> real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "(* ==========================================\n            central! calculations for A \n           ========================================== *)"], ["proof (state)\nthis:\n  C - B \\<le> real_of_int (- int I)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "have A_absch: \"A\n              \\<le> (if b!(index init q) then k-k' else (\\<Sum>j<k'. (if b!(index init (xs'!j)) then 2::real else 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "proof (cases \"b!(index init q)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "(* case distinction on whether the requested element's bit is set *)"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "case False"], ["proof (state)\nthis:\n  \\<not> b ! index init q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "from leninitys False"], ["proof (chain)\npicking this:\n  length ys = length init\n  \\<not> b ! index init q", "have ya: \"ys' = mtf2 (length ys) q ys\""], ["proof (prove)\nusing this:\n  length ys = length init\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. ys' = mtf2 (length ys) q ys", "(* BIT moves q to front *)"], ["proof (prove)\nusing this:\n  length ys = length init\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. ys' = mtf2 (length ys) q ys", "unfolding step_def ys'_def"], ["proof (prove)\nusing this:\n  length ys = length init\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. (let (k, sws) = aBIT in mtf2 k q (swaps sws ys)) = mtf2 (length ys) q ys", "by(auto)"], ["proof (state)\nthis:\n  ys' = mtf2 (length ys) q ys\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"index ys' q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index ys' q = 0", "unfolding ya"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 (length ys) q ys) q = 0", "apply(rule mtf2_moves_to_front)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct ys\n 2. q \\<in> set ys", "using gra2"], ["proof (prove)\nusing this:\n  q \\<in> set ys\n\ngoal (2 subgoals):\n 1. distinct ys\n 2. q \\<in> set ys", "by(simp_all)"], ["proof (state)\nthis:\n  index ys' q = 0\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  index ys' q = 0", "have nixbefore: \"before q ys' = {}\""], ["proof (prove)\nusing this:\n  index ys' q = 0\n\ngoal (1 subgoal):\n 1. before q ys' = {}", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index ys' q = 0\n\ngoal (1 subgoal):\n 1. {y. index ys' y < index ys' q \\<and> q \\<in> set ys'} = {}", "by auto"], ["proof (state)\nthis:\n  before q ys' = {}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"A = (\\<Sum>(x,y)\\<in>(Inv ys' xs'')-(Inv ys xs'). (if b'!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"index (mtf2 (free_A ! n) (q) (swaps (paid_A ! n) (s_A n))) (q)\n              = (index (swaps (paid_A ! n) (s_A n)) (q) - free_A ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) q =\n    index (swaps (paid_A ! n) (s_A n)) q - free_A ! n", "apply(rule mtf2_q_after)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (swaps (paid_A ! n) (s_A n))\n 2. q \\<in> set (swaps (paid_A ! n) (s_A n))", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (2 subgoals):\n 1. distinct (swaps (paid_A ! n) (s_A n))\n 2. q \\<in> set (swaps (paid_A ! n) (s_A n))", "by auto"], ["proof (state)\nthis:\n  index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) q =\n  index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) q =\n  index (swaps (paid_A ! n) (s_A n)) q - free_A ! n", "have whatisk': \"k' = index xs'' q\""], ["proof (prove)\nusing this:\n  index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) q =\n  index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. k' = index xs'' q", "by auto"], ["proof (state)\nthis:\n  k' = index xs'' q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have ss: \"set ys' = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys' = set ys", "by auto"], ["proof (state)\nthis:\n  set ys' = set ys\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have ss2: \"set xs' = set xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs' = set xs''", "by auto"], ["proof (state)\nthis:\n  set xs' = set xs''\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have di: \"distinct init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init", "by auto"], ["proof (state)\nthis:\n  distinct init\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have dys: \"distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ys", "by auto"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"(Inv ys' xs'')-(Inv ys xs')\n              = {(x,y). x < y in ys' \\<and> y < x in xs'' \\<and> (~x < y in ys \\<or> ~ y < x in xs')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv ys' xs'' - Inv ys xs' =\n    {(x, y).\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x < y in ys' \\<and> y < x in xs''} -\n    {(x, y). x < y in ys \\<and> y < x in xs'} =\n    {(x, y).\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}", "by auto"], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs' =\n  {(x, y).\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs' =\n  {(x, y).\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> (~x < y in ys \\<or> ~ y < x in xs') }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n    {(x, y).\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}", "using nixbefore"], ["proof (prove)\nusing this:\n  before q ys' = {}\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n    {(x, y).\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}", "by blast"], ["proof (state)\nthis:\n  {(x, y).\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> (~x < y in ys \\<or> ~ y < x in xs') }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     y \\<noteq> q \\<and>\n     (index ys' x < index ys' y \\<and> y \\<in> set ys') \\<and>\n     (index xs'' y < index xs'' x \\<and> x \\<in> set xs'') \\<and>\n     (\\<not> (index ys x < index ys y \\<and> y \\<in> set ys) \\<or>\n      \\<not> (index xs' y < index xs' x \\<and> x \\<in> set xs'))} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     (index ys' x < index ys' y \\<and> y \\<in> set ys') \\<and>\n     (index xs'' y < index xs'' x \\<and> x \\<in> set xs'') \\<and>\n     (\\<not> (index ys x < index ys y \\<and> y \\<in> set ys) \\<or>\n      \\<not> (index xs' y < index xs' x \\<and> x \\<in> set xs'))}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> ~x < y in ys }\n            \\<union> {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and>  ~ y < x in xs' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and>\n     y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "by force"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and>\n   y < x in xs'' \\<and> (\\<not> x < y in ys \\<or> \\<not> y < x in xs')} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys }\n            \\<union> {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and>  ~ y < x in xs' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "using  before_in_setD1[where xs=\"ys'\"] before_in_setD2[where xs=\"ys'\"] not_before_in ss"], ["proof (prove)\nusing this:\n  ?x < ?y in ys' \\<Longrightarrow> ?x \\<in> set ys'\n  ?x < ?y in ys' \\<Longrightarrow> ?y \\<in> set ys'\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  set ys' = set ys\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "by metis"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> x < y in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys }\n            \\<union> {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and>  x < y in xs' }\" (is \"?S1 \\<union> ?S2 = ?S1 \\<union> ?S2'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "have \"?S2 = ?S2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> False", "proof (goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> False", "case (2 a b)"], ["proof (state)\nthis:\n  a \\<noteq> b\n  b \\<noteq> q\n  a < b in ys'\n  b < a in xs''\n  a < b in xs'\n  b < a in xs'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> False", "from 2(5)"], ["proof (chain)\npicking this:\n  a < b in xs'", "have \"~ b < a in xs'\""], ["proof (prove)\nusing this:\n  a < b in xs'\n\ngoal (1 subgoal):\n 1. \\<not> b < a in xs'", "by auto"], ["proof (state)\nthis:\n  \\<not> b < a in xs'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> False", "with 2(6)"], ["proof (chain)\npicking this:\n  b < a in xs'\n  \\<not> b < a in xs'", "show \"False\""], ["proof (prove)\nusing this:\n  b < a in xs'\n  \\<not> b < a in xs'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'", "case (1 a b)"], ["proof (state)\nthis:\n  a \\<noteq> b\n  b \\<noteq> q\n  a < b in ys'\n  b < a in xs''\n  \\<not> b < a in xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'", "from 1(4)"], ["proof (chain)\npicking this:\n  b < a in xs''", "have \"a \\<in> set xs'\" \"b \\<in> set xs'\""], ["proof (prove)\nusing this:\n  b < a in xs''\n\ngoal (1 subgoal):\n 1. a \\<in> set xs' &&& b \\<in> set xs'", "using  before_in_setD1[where xs=\"xs''\"]\n                     before_in_setD2[where xs=\"xs''\"] ss2"], ["proof (prove)\nusing this:\n  b < a in xs''\n  ?x < ?y in xs'' \\<Longrightarrow> ?x \\<in> set xs''\n  ?x < ?y in xs'' \\<Longrightarrow> ?y \\<in> set xs''\n  set xs' = set xs''\n\ngoal (1 subgoal):\n 1. a \\<in> set xs' &&& b \\<in> set xs'", "by auto"], ["proof (state)\nthis:\n  a \\<in> set xs'\n  b \\<in> set xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'", "with not_before_in 1(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> b < a in xs'\n  a \\<in> set xs'\n  b \\<in> set xs'", "have \"(a < b in xs' \\<or> a = b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> b < a in xs'\n  a \\<in> set xs'\n  b \\<in> set xs'\n\ngoal (1 subgoal):\n 1. a < b in xs' \\<or> a = b", "by metis"], ["proof (state)\nthis:\n  a < b in xs' \\<or> a = b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> a < b in xs'", "with 1(1)"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  a < b in xs' \\<or> a = b", "show \"a < b in xs'\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a < b in xs' \\<or> a = b\n\ngoal (1 subgoal):\n 1. a < b in xs'", "by auto"], ["proof (state)\nthis:\n  a < b in xs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "then"], ["proof (chain)\npicking this:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys }\n            \\<union> {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> ~ x < y in xs'' \\<and>  x < y in xs' }\" (is \"?S1 \\<union> ?S2 = ?S1 \\<union> ?S2'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "have \"?S2 = ?S2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; a < b in xs''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "proof (goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; a < b in xs''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "case (1 a b)"], ["proof (state)\nthis:\n  a \\<noteq> b\n  b \\<noteq> q\n  a < b in ys'\n  b < a in xs''\n  a < b in xs'\n  a < b in xs''\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; a < b in xs''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "from 1(4)"], ["proof (chain)\npicking this:\n  b < a in xs''", "have \"~ a < b in xs''\""], ["proof (prove)\nusing this:\n  b < a in xs''\n\ngoal (1 subgoal):\n 1. \\<not> a < b in xs''", "by auto"], ["proof (state)\nthis:\n  \\<not> a < b in xs''\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys'; b < a in xs'';\n        a < b in xs'; a < b in xs''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "with 1(6)"], ["proof (chain)\npicking this:\n  a < b in xs''\n  \\<not> a < b in xs''", "show \"False\""], ["proof (prove)\nusing this:\n  a < b in xs''\n  \\<not> a < b in xs''\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "case (2 a b)"], ["proof (state)\nthis:\n  a \\<noteq> b\n  b \\<noteq> q\n  a < b in ys'\n  \\<not> a < b in xs''\n  a < b in xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "from 2(5)"], ["proof (chain)\npicking this:\n  a < b in xs'", "have \"a \\<in> set xs''\" \"b \\<in> set xs''\""], ["proof (prove)\nusing this:\n  a < b in xs'\n\ngoal (1 subgoal):\n 1. a \\<in> set xs'' &&& b \\<in> set xs''", "using  before_in_setD1[where xs=\"xs'\"]\n                     before_in_setD2[where xs=\"xs'\"] ss2"], ["proof (prove)\nusing this:\n  a < b in xs'\n  ?x < ?y in xs' \\<Longrightarrow> ?x \\<in> set xs'\n  ?x < ?y in xs' \\<Longrightarrow> ?y \\<in> set xs'\n  set xs' = set xs''\n\ngoal (1 subgoal):\n 1. a \\<in> set xs'' &&& b \\<in> set xs''", "by auto"], ["proof (state)\nthis:\n  a \\<in> set xs''\n  b \\<in> set xs''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "with not_before_in 2(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> a < b in xs''\n  a \\<in> set xs''\n  b \\<in> set xs''", "have \"(b < a in xs'' \\<or> a = b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> a < b in xs''\n  a \\<in> set xs''\n  b \\<in> set xs''\n\ngoal (1 subgoal):\n 1. b < a in xs'' \\<or> a = b", "by metis"], ["proof (state)\nthis:\n  b < a in xs'' \\<or> a = b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> b; b \\<noteq> q; a < b in ys';\n        \\<not> a < b in xs''; a < b in xs'\\<rbrakk>\n       \\<Longrightarrow> b < a in xs''", "with 2(1)"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  b < a in xs'' \\<or> a = b", "show \"b < a in xs''\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  b < a in xs'' \\<or> a = b\n\ngoal (1 subgoal):\n 1. b < a in xs''", "by auto"], ["proof (state)\nthis:\n  b < a in xs''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "then"], ["proof (chain)\npicking this:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n              {(x,y). x\\<noteq>y \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys }\n              \\<union> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {}", "using x_stays_before_y_if_y_not_moved_to_front[where xs=\"xs'\" and q=\"q\"] \n                    before_in_setD1[where xs=\"xs'\"] before_in_setD2[where xs=\"xs'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<in> set xs'; distinct xs'; ?x \\<in> set xs';\n   ?y \\<in> set xs'; ?y \\<noteq> q; ?x < ?y in xs'\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in mtf2 ?n q xs'\n  ?x < ?y in xs' \\<Longrightarrow> ?x \\<in> set xs'\n  ?x < ?y in xs' \\<Longrightarrow> ?y \\<in> set xs'\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {}", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> \\<not> x < y in xs'' \\<and> x < y in xs'} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n              {(x,y). x\\<noteq>y \\<and> x=q \\<and> y\\<noteq>q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n    {} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}", "apply(simp only: ya)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in mtf2 (length ys) q ys \\<and>\n     y < x in xs'' \\<and> y < x in ys} \\<union>\n    {} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     x < y in mtf2 (length ys) q ys \\<and> y < x in xs'' \\<and> y < x in ys}", "using swapped_by_mtf2[where xs=\"ys\" and q=\"q\" and n=\"(length ys)\"]  dys\n                  before_in_setD1[where xs=\"ys\"] before_in_setD2[where xs=\"ys\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<in> set ys; distinct ys; ?x \\<in> set ys; ?y \\<in> set ys;\n   ?x < ?y in ys; ?y < ?x in mtf2 (length ys) q ys\\<rbrakk>\n  \\<Longrightarrow> ?y = q\n  distinct ys\n  ?x < ?y in ys \\<Longrightarrow> ?x \\<in> set ys\n  ?x < ?y in ys \\<Longrightarrow> ?y \\<in> set ys\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     y \\<noteq> q \\<and>\n     x < y in mtf2 (length ys) q ys \\<and>\n     y < x in xs'' \\<and> y < x in ys} \\<union>\n    {} =\n    {(x, y).\n     x \\<noteq> y \\<and>\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     x < y in mtf2 (length ys) q ys \\<and> y < x in xs'' \\<and> y < x in ys}", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   x = q \\<and>\n   y \\<noteq> q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   y \\<noteq> q \\<and>\n   x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys} \\<union>\n  {} =\n  {(x, y).\n   x \\<noteq> y \\<and>\n   x = q \\<and>\n   y \\<noteq> q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  \\<subseteq> \n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> q < y in ys' \\<and> y < q in xs''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> y \\<and>\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}\n    \\<subseteq> {(x, y).\n                 x = q \\<and>\n                 y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''}", "by force"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   x = q \\<and>\n   y \\<noteq> q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}\n  \\<subseteq> {(x, y).\n               x = q \\<and>\n               y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<noteq> y \\<and>\n   x = q \\<and>\n   y \\<noteq> q \\<and> x < y in ys' \\<and> y < x in xs'' \\<and> y < x in ys}\n  \\<subseteq> {(x, y).\n               x = q \\<and>\n               y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = \n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and> y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''}", "using before_in_setD1"], ["proof (prove)\nusing this:\n  ?x < ?y in ?xs \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and> y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''}", "by metis"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and> y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and> y \\<noteq> q \\<and> q < y in ys' \\<and> y < q in xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> q < y in ys' \\<and> index xs'' y < index xs'' q \\<and> q \\<in> set xs'' \\<and> y \\<in> set xs''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs'' q \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     (index ys' q < index ys' y \\<and> y \\<in> set ys') \\<and>\n     (index xs'' y < index xs'' q \\<and> q \\<in> set xs'') \\<and>\n     y \\<in> set xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     (index ys' q < index ys' y \\<and> y \\<in> set ys') \\<and>\n     index xs'' y < index xs'' q \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs'' q \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and> y < q in xs'' \\<and> y \\<in> set xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs'' q \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  = \n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> q < y in ys' \\<and> index xs'' y < index xs' q - (free_A ! n) \\<and> q \\<in> set xs'' \\<and> y \\<in> set xs''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs'' q \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs' q - free_A ! n \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}", "using mtf2_q_after[where A=\"xs'\" and q=\"q\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs'; q \\<in> set xs'\\<rbrakk>\n  \\<Longrightarrow> index (mtf2 ?n q xs') q = index xs' q - ?n\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs'' q \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''} =\n    {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs' q - free_A ! n \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}", "by force"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs'' q \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs' q - free_A ! n \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs'' q \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''} =\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs' q - free_A ! n \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots>  \\<subseteq> \n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> index xs' y < index xs' q - (free_A ! n) \\<and> y \\<in> set xs''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs' q - free_A ! n \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}\n    \\<subseteq> {(x, y).\n                 x = q \\<and>\n                 y \\<noteq> q \\<and>\n                 index xs' y < index xs' q - free_A ! n \\<and>\n                 y \\<in> set xs''}", "using mtf2_backwards_effect4'[where xs=\"xs'\" and q=\"q\" and n=\"(free_A ! n)\", simplified ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<in> set init;\n   index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) ?x\n   < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n;\n   ?x \\<in> set init\\<rbrakk>\n  \\<Longrightarrow> index (swaps (paid_A ! n) (s_A n)) ?x\n                    < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     q < y in ys' \\<and>\n     index xs'' y < index xs' q - free_A ! n \\<and>\n     q \\<in> set xs'' \\<and> y \\<in> set xs''}\n    \\<subseteq> {(x, y).\n                 x = q \\<and>\n                 y \\<noteq> q \\<and>\n                 index xs' y < index xs' q - free_A ! n \\<and>\n                 y \\<in> set xs''}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs' q - free_A ! n \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n  \\<subseteq> {(x, y).\n               x = q \\<and>\n               y \\<noteq> q \\<and>\n               index xs' y < index xs' q - free_A ! n \\<and>\n               y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   q < y in ys' \\<and>\n   index xs'' y < index xs' q - free_A ! n \\<and>\n   q \\<in> set xs'' \\<and> y \\<in> set xs''}\n  \\<subseteq> {(x, y).\n               x = q \\<and>\n               y \\<noteq> q \\<and>\n               index xs' y < index xs' q - free_A ! n \\<and>\n               y \\<in> set xs''}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> \\<subseteq>\n            {(x,y). x=q \\<and> y\\<noteq>q \\<and> index xs' y < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     index xs' y < index xs' q - free_A ! n \\<and> y \\<in> set xs''}\n    \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}", "using mtf2_q_after[where A=\"xs'\" and q=\"q\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs'; q \\<in> set xs'\\<rbrakk>\n  \\<Longrightarrow> index (mtf2 ?n q xs') q = index xs' q - ?n\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x = q \\<and>\n     y \\<noteq> q \\<and>\n     index xs' y < index xs' q - free_A ! n \\<and> y \\<in> set xs''}\n    \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x = q \\<and>\n   y \\<noteq> q \\<and>\n   index xs' y < index xs' q - free_A ! n \\<and> y \\<in> set xs''}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  Inv ys' xs'' - Inv ys xs'\n  \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}", "have subsa: \"(Inv ys' xs'')-(Inv ys xs')\n              \\<subseteq> {(x,y). x=q \\<and> y\\<noteq>q \\<and> index xs' y < k'}\""], ["proof (prove)\nusing this:\n  Inv ys' xs'' - Inv ys xs'\n  \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}\n\ngoal (1 subgoal):\n 1. Inv ys' xs'' - Inv ys xs'\n    \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}", "."], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs'\n  \\<subseteq> {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have k'xs': \"k' < length xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < length xs''", "unfolding whatisk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs'' q < length xs''", "apply(rule index_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<in> set xs''\n 2. length xs'' \\<le> length xs''", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  k' < length xs''\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  k' < length xs''", "have k'xs': \"k' < length xs'\""], ["proof (prove)\nusing this:\n  k' < length xs''\n\ngoal (1 subgoal):\n 1. k' < length xs'", "by auto"], ["proof (state)\nthis:\n  k' < length xs'\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"{(x,y). x=q \\<and> index xs' y < k'}\n              \\<subseteq> {(x,y). x=q  \\<and> index xs' y < length xs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x = q \\<and> index xs' y < k'}\n    \\<subseteq> {(x, y). x = q \\<and> index xs' y < length xs'}", "using k'xs'"], ["proof (prove)\nusing this:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. {(x, y). x = q \\<and> index xs' y < k'}\n    \\<subseteq> {(x, y). x = q \\<and> index xs' y < length xs'}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> index xs' y < length xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> index xs' y < length xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = {(x,y). x=q \\<and>  y \\<in> set xs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x = q \\<and> index xs' y < length xs'} =\n    {(x, y). x = q \\<and> y \\<in> set xs'}", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. {(x, y). x = q \\<and> index xs' y < length xs'} =\n    {(x, y). x = q \\<and> y \\<in> set xs'}", "by fast"], ["proof (state)\nthis:\n  {(x, y). x = q \\<and> index xs' y < length xs'} =\n  {(x, y). x = q \\<and> y \\<in> set xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}", "have \"{(x,y). x=q \\<and> index xs' y < k'} \\<subseteq> {(x,y). x=q \\<and> y \\<in> set xs'}\""], ["proof (prove)\nusing this:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}\n\ngoal (1 subgoal):\n 1. {(x, y). x = q \\<and> index xs' y < k'}\n    \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}", "."], ["proof (state)\nthis:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}", "have finia2: \"finite {(x,y). x=q \\<and> index xs' y < k'}\""], ["proof (prove)\nusing this:\n  {(x, y). x = q \\<and> index xs' y < k'}\n  \\<subseteq> {(x, y). x = q \\<and> y \\<in> set xs'}\n\ngoal (1 subgoal):\n 1. finite {(x, y). x = q \\<and> index xs' y < k'}", "apply(rule finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x = q \\<and> y \\<in> set xs'}", "by(simp)"], ["proof (state)\nthis:\n  finite {(x, y). x = q \\<and> index xs' y < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have lulae: \"{(a,b). a=q \\<and> index xs' b < k'}\n              = {(q,b)|b.  index xs' b < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). a = q \\<and> index xs' b < k'} = {(q, b) |b. index xs' b < k'}", "by auto"], ["proof (state)\nthis:\n  {(a, b). a = q \\<and> index xs' b < k'} = {(q, b) |b. index xs' b < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have k'b: \"k' < length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < length b", "using whatisk'"], ["proof (prove)\nusing this:\n  k' = index xs'' q\n\ngoal (1 subgoal):\n 1. k' < length b", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  k' < length b\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have asdasd: \"{(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> \\<beta>\\<noteq>q \\<and> index xs' \\<beta> < k'} \n            = {(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> \\<beta>\\<noteq>q \\<and> index xs' \\<beta> < k' \\<and>  (index init \\<beta>) < length b }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "case (1 b)"], ["proof (state)\nthis:\n  b \\<noteq> q\n  index (swaps (paid_A ! n) (s_A n)) b\n  < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "from 1(2)"], ["proof (chain)\npicking this:\n  index (swaps (paid_A ! n) (s_A n)) b\n  < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n", "have \"index xs' b < index xs' (q)\""], ["proof (prove)\nusing this:\n  index (swaps (paid_A ! n) (s_A n)) b\n  < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. index xs' b < index xs' q", "by auto"], ["proof (state)\nthis:\n  index xs' b < index xs' q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "also"], ["proof (state)\nthis:\n  index xs' b < index xs' q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "have \"\\<dots> < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs' q < length xs'", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  index xs' q < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "finally"], ["proof (chain)\npicking this:\n  index xs' b < length xs'", "have \"b \\<in> set xs'\""], ["proof (prove)\nusing this:\n  index xs' b < length xs'\n\ngoal (1 subgoal):\n 1. b \\<in> set xs'", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  index xs' b < length xs'\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. b \\<in> set xs'", "by metis"], ["proof (state)\nthis:\n  b \\<in> set xs'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<noteq> q;\n        index (swaps (paid_A ! n) (s_A n)) b\n        < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\\<rbrakk>\n       \\<Longrightarrow> index init b < length init", "then"], ["proof (chain)\npicking this:\n  b \\<in> set xs'", "show ?case"], ["proof (prove)\nusing this:\n  b \\<in> set xs'\n\ngoal (1 subgoal):\n 1. index init b < length init", "using setinit"], ["proof (prove)\nusing this:\n  b \\<in> set xs'\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init b < length init", "by auto"], ["proof (state)\nthis:\n  index init b < length init\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'} =\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and>\n   \\<beta> \\<noteq> q \\<and>\n   index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "{"], ["proof (state)\nthis:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'} =\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and>\n   \\<beta> \\<noteq> q \\<and>\n   index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "fix \\<beta>"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<beta>\\<noteq>q \\<Longrightarrow>  (index init \\<beta>)\\<noteq>(index init q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> q \\<Longrightarrow>\n    index init \\<beta> \\<noteq> index init q", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> q \\<Longrightarrow>\n    index init \\<beta> \\<noteq> index init q", "by auto"], ["proof (state)\nthis:\n  \\<beta> \\<noteq> q \\<Longrightarrow>\n  index init \\<beta> \\<noteq> index init q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "}"], ["proof (state)\nthis:\n  ?\\<beta>2 \\<noteq> q \\<Longrightarrow>\n  index init ?\\<beta>2 \\<noteq> index init q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "note ij=this"], ["proof (state)\nthis:\n  ?\\<beta>2 \\<noteq> q \\<Longrightarrow>\n  index init ?\\<beta>2 \\<noteq> index init q\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have subsa2: \"{(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> \\<beta>\\<noteq>q \\<and> index xs' \\<beta> < k'}  \\<subseteq>\n            {(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> index xs' \\<beta> < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'}\n    \\<subseteq> {(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and> index xs' \\<beta> < k'}", "by auto"], ["proof (state)\nthis:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'}\n  \\<subseteq> {(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and> index xs' \\<beta> < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'}\n  \\<subseteq> {(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and> index xs' \\<beta> < k'}", "have finia: \"finite {(x,y). x=q \\<and> y\\<noteq>q \\<and> index xs' y < k'}\""], ["proof (prove)\nusing this:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'}\n  \\<subseteq> {(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and> index xs' \\<beta> < k'}\n\ngoal (1 subgoal):\n 1. finite {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}", "apply(rule finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x = q \\<and> index xs' y < k'}", "using finia2"], ["proof (prove)\nusing this:\n  finite {(x, y). x = q \\<and> index xs' y < k'}\n\ngoal (1 subgoal):\n 1. finite {(x, y). x = q \\<and> index xs' y < k'}", "by auto"], ["proof (state)\nthis:\n  finite {(x, y). x = q \\<and> y \\<noteq> q \\<and> index xs' y < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E0: \"A = (\\<Sum>(x,y)\\<in>(Inv ys' xs'')-(Inv ys xs'). (if b'!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E1: \"\\<dots> \\<le> (\\<Sum>(x,y)\\<in>{(a,b). a=q \\<and> b\\<noteq>q \\<and> index xs' b < k'}. (if b'!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\n                 \\<in>{(a, b).\n                       a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n             if b' ! index init y then 2 else 1)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\n                 \\<in>{(a, b).\n                       a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n             if b' ! index init y then 2 else 1)", "apply(rule sum_mono2[OF finia subsa])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'} -\n               (Inv ys' xs'' - Inv ys xs') \\<Longrightarrow>\n       0 \\<le> (case b of\n                (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(a, b).\n                     a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n           if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(a, b).\n                     a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n           if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> \\<beta>\\<noteq>q \\<and> index xs' \\<beta> < k'\n                          \\<and>   (index init \\<beta>) < length b }. (if b'!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n       if b' ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b' ! index init y then 2 else 1)", "using asdasd"], ["proof (prove)\nusing this:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'} =\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and>\n   \\<beta> \\<noteq> q \\<and>\n   index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n       if b' ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b' ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b' ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b' ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b' ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(\\<alpha>,\\<beta>). \\<alpha>=q \\<and> \\<beta>\\<noteq>q \\<and> index xs' \\<beta> < k' \n                          \\<and>  (index init \\<beta>) < length b }. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b' ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b ! index init y then 2 else 1)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n 2. \\<And>x.\n       x \\<in> {(\\<alpha>, \\<beta>).\n                \\<alpha> = q \\<and>\n                \\<beta> \\<noteq> q \\<and>\n                index xs' \\<beta> < k' \\<and>\n                index init \\<beta> < length b} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n       (case x of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> {(\\<alpha>, \\<beta>).\n           \\<alpha> = q \\<and>\n           \\<beta> \\<noteq> q \\<and>\n           index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (2 subgoals):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n 2. \\<And>x.\n       x \\<in> {(\\<alpha>, \\<beta>).\n                \\<alpha> = q \\<and>\n                \\<beta> \\<noteq> q \\<and>\n                index xs' \\<beta> < k' \\<and>\n                index init \\<beta> < length b} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n       (case x of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  z \\<in> {(\\<alpha>, \\<beta>).\n           \\<alpha> = q \\<and>\n           \\<beta> \\<noteq> q \\<and>\n           index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}", "obtain \\<alpha> \\<beta> where zab: \"z=(\\<alpha>, \\<beta>)\" and \"\\<alpha> = q\" and diff: \"\\<beta> \\<noteq> q\" and \"index xs' \\<beta> < k'\" and i: \"index init \\<beta> < length b\""], ["proof (prove)\nusing this:\n  z \\<in> {(\\<alpha>, \\<beta>).\n           \\<alpha> = q \\<and>\n           \\<beta> \\<noteq> q \\<and>\n           index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>z = (\\<alpha>, \\<beta>); \\<alpha> = q; \\<beta> \\<noteq> q;\n         index xs' \\<beta> < k'; index init \\<beta> < length b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = (\\<alpha>, \\<beta>)\n  \\<alpha> = q\n  \\<beta> \\<noteq> q\n  index xs' \\<beta> < k'\n  index init \\<beta> < length b\n\ngoal (2 subgoals):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n 2. \\<And>x.\n       x \\<in> {(\\<alpha>, \\<beta>).\n                \\<alpha> = q \\<and>\n                \\<beta> \\<noteq> q \\<and>\n                index xs' \\<beta> < k' \\<and>\n                index init \\<beta> < length b} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n       (case x of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "from diff ij"], ["proof (chain)\npicking this:\n  \\<beta> \\<noteq> q\n  ?\\<beta>2 \\<noteq> q \\<Longrightarrow>\n  index init ?\\<beta>2 \\<noteq> index init q", "have \"index init \\<beta> \\<noteq> index init q\""], ["proof (prove)\nusing this:\n  \\<beta> \\<noteq> q\n  ?\\<beta>2 \\<noteq> q \\<Longrightarrow>\n  index init ?\\<beta>2 \\<noteq> index init q\n\ngoal (1 subgoal):\n 1. index init \\<beta> \\<noteq> index init q", "by auto"], ["proof (state)\nthis:\n  index init \\<beta> \\<noteq> index init q\n\ngoal (2 subgoals):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n 2. \\<And>x.\n       x \\<in> {(\\<alpha>, \\<beta>).\n                \\<alpha> = q \\<and>\n                \\<beta> \\<noteq> q \\<and>\n                index xs' \\<beta> < k' \\<and>\n                index init \\<beta> < length b} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n       (case x of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "with flip_other qsfst i"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  index init q < length b\n  index init \\<beta> < length b\n  index init \\<beta> \\<noteq> index init q", "have \"b' ! index init \\<beta> =  b ! index init \\<beta>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  index init q < length b\n  index init \\<beta> < length b\n  index init \\<beta> \\<noteq> index init q\n\ngoal (1 subgoal):\n 1. b' ! index init \\<beta> = b ! index init \\<beta>", "unfolding b'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < length ?X; ?z < length ?X; ?z \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> flip ?z ?X ! ?y = ?X ! ?y\n  index init q < length b\n  index init \\<beta> < length b\n  index init \\<beta> \\<noteq> index init q\n\ngoal (1 subgoal):\n 1. flip (index init q) b ! index init \\<beta> = b ! index init \\<beta>", "by auto"], ["proof (state)\nthis:\n  b' ! index init \\<beta> = b ! index init \\<beta>\n\ngoal (2 subgoals):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n 2. \\<And>x.\n       x \\<in> {(\\<alpha>, \\<beta>).\n                \\<alpha> = q \\<and>\n                \\<beta> \\<noteq> q \\<and>\n                index xs' \\<beta> < k' \\<and>\n                index init \\<beta> < length b} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n       (case x of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "with zab"], ["proof (chain)\npicking this:\n  z = (\\<alpha>, \\<beta>)\n  b' ! index init \\<beta> = b ! index init \\<beta>", "show ?case"], ["proof (prove)\nusing this:\n  z = (\\<alpha>, \\<beta>)\n  b' ! index init \\<beta> = b ! index init \\<beta>\n\ngoal (1 subgoal):\n 1. (case z of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n    (case z of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "by(auto simp add:  split_def)"], ["proof (state)\nthis:\n  (case z of (x, y) \\<Rightarrow> if b' ! index init y then 2 else 1) =\n  (case z of (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b} =\n    {(\\<alpha>, \\<beta>).\n     \\<alpha> = q \\<and>\n     \\<beta> \\<noteq> q \\<and>\n     index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b' ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b' ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E1a: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(a,b). a=q \\<and> b\\<noteq>q \\<and> index xs' b < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n       if b ! index init y then 2 else 1)", "using asdasd"], ["proof (prove)\nusing this:\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and> \\<beta> \\<noteq> q \\<and> index xs' \\<beta> < k'} =\n  {(\\<alpha>, \\<beta>).\n   \\<alpha> = q \\<and>\n   \\<beta> \\<noteq> q \\<and>\n   index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(\\<alpha>, \\<beta>).\n                 \\<alpha> = q \\<and>\n                 \\<beta> \\<noteq> q \\<and>\n                 index xs' \\<beta> < k' \\<and>\n                 index init \\<beta> < length b}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\n           \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n       if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(\\<alpha>, \\<beta>).\n               \\<alpha> = q \\<and>\n               \\<beta> \\<noteq> q \\<and>\n               index xs' \\<beta> < k' \\<and> index init \\<beta> < length b}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> \\<le> (\\<Sum>(x,y)\\<in>{(a,b). a=q \\<and> index xs' b < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n       if b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(x, y)\\<in>{(a, b). a = q \\<and> index xs' b < k'}.\n             if b ! index init y then 2 else 1)", "apply(rule sum_mono2[OF finia2 subsa2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       ba \\<in> {(a, b). a = q \\<and> index xs' b < k'} -\n                {(a, b).\n                 a = q \\<and>\n                 b \\<noteq> q \\<and> index xs' b < k'} \\<Longrightarrow>\n       0 \\<le> (case ba of\n                (x, y) \\<Rightarrow> if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>{(a, b). a = q \\<and> index xs' b < k'}.\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(a, b). a = q \\<and> b \\<noteq> q \\<and> index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(x, y)\\<in>{(a, b). a = q \\<and> index xs' b < k'}.\n           if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E2: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(q,b)|b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(a, b). a = q \\<and> index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1)", "by (simp only: lulae[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(a, b). a = q \\<and> index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  A \\<le> (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n             if b ! index init y then 2 else 1)", "have aa: \"A \\<le> (\\<Sum>(x,y)\\<in>{(q,b)|b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\nusing this:\n  A \\<le> (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n             if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. A \\<le> (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n               if b ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  A \\<le> (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n             if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have sameset: \"{y. index xs' y < k'} = {xs'!i | i. i < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. index xs' y < k'} = {xs' ! i |i. i < k'}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       index xs' x < k' \\<Longrightarrow>\n       \\<exists>i. x = xs' ! i \\<and> i < k'\n 2. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "case (1 z)"], ["proof (state)\nthis:\n  index xs' z < k'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       index xs' x < k' \\<Longrightarrow>\n       \\<exists>i. x = xs' ! i \\<and> i < k'\n 2. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. z = xs' ! i \\<and> i < k'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "from 1(1)"], ["proof (chain)\npicking this:\n  index xs' z < k'", "have \"index xs' z < index (swaps (paid_A ! n) (s_A n)) (q)\""], ["proof (prove)\nusing this:\n  index xs' z < k'\n\ngoal (1 subgoal):\n 1. index xs' z < index (swaps (paid_A ! n) (s_A n)) q", "by auto"], ["proof (state)\nthis:\n  index xs' z < index (swaps (paid_A ! n) (s_A n)) q\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "also"], ["proof (state)\nthis:\n  index xs' z < index (swaps (paid_A ! n) (s_A n)) q\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "have \"\\<dots> < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q < length xs'", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q < length xs'", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  index (swaps (paid_A ! n) (s_A n)) q < length xs'\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "finally"], ["proof (chain)\npicking this:\n  index xs' z < length xs'", "have \"index xs' z  < length xs'\""], ["proof (prove)\nusing this:\n  index xs' z < length xs'\n\ngoal (1 subgoal):\n 1. index xs' z < length xs'", "."], ["proof (state)\nthis:\n  index xs' z < length xs'\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "then"], ["proof (chain)\npicking this:\n  index xs' z < length xs'", "have zset: \"z \\<in> set xs'\""], ["proof (prove)\nusing this:\n  index xs' z < length xs'\n\ngoal (1 subgoal):\n 1. z \\<in> set xs'", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  index xs' z < length xs'\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. z \\<in> set xs'", "by metis"], ["proof (state)\nthis:\n  z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "have f1: \"xs' ! (index xs' z) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' ! index xs' z = z", "apply(rule nth_index)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set xs'", "using zset"], ["proof (prove)\nusing this:\n  z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. z \\<in> set xs'", "by auto"], ["proof (state)\nthis:\n  xs' ! index xs' z = z\n\ngoal (1 subgoal):\n 1. z = xs' ! ?i \\<and> ?i < k'", "show \"z = xs' ! (index xs' z) \\<and> (index xs' z) < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = xs' ! index xs' z \\<and> index xs' z < k'", "using f1 1(1)"], ["proof (prove)\nusing this:\n  xs' ! index xs' z = z\n  index xs' z < k'\n\ngoal (1 subgoal):\n 1. z = xs' ! index xs' z \\<and> index xs' z < k'", "by auto"], ["proof (state)\nthis:\n  z = xs' ! index xs' z \\<and> index xs' z < k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. z = xs' ! i \\<and> i < k'\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "case (2 k i)"], ["proof (state)\nthis:\n  i < k'\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "from 2(1)"], ["proof (chain)\npicking this:\n  i < k'", "have \"i < index (swaps (paid_A ! n) (s_A n)) (q)\""], ["proof (prove)\nusing this:\n  i < k'\n\ngoal (1 subgoal):\n 1. i < index (swaps (paid_A ! n) (s_A n)) q", "by auto"], ["proof (state)\nthis:\n  i < index (swaps (paid_A ! n) (s_A n)) q\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "also"], ["proof (state)\nthis:\n  i < index (swaps (paid_A ! n) (s_A n)) q\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "have \"\\<dots> < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q < length xs'", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q < length xs'", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  index (swaps (paid_A ! n) (s_A n)) q < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "finally"], ["proof (chain)\npicking this:\n  i < length xs'", "have iset: \"i < length xs'\""], ["proof (prove)\nusing this:\n  i < length xs'\n\ngoal (1 subgoal):\n 1. i < length xs'", "."], ["proof (state)\nthis:\n  i < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "have \"index xs' (xs' ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs' (xs' ! i) = i", "apply(rule index_nth_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs'\n 2. i < length xs'", "using iset"], ["proof (prove)\nusing this:\n  i < length xs'\n\ngoal (2 subgoals):\n 1. distinct xs'\n 2. i < length xs'", "by(auto)"], ["proof (state)\nthis:\n  index xs' (xs' ! i) = i\n\ngoal (1 subgoal):\n 1. \\<And>x i. i < k' \\<Longrightarrow> index xs' (xs' ! i) < k'", "with 2"], ["proof (chain)\npicking this:\n  i < k'\n  index xs' (xs' ! i) = i", "show ?case"], ["proof (prove)\nusing this:\n  i < k'\n  index xs' (xs' ! i) = i\n\ngoal (1 subgoal):\n 1. index xs' (xs' ! i) < k'", "by auto"], ["proof (state)\nthis:\n  index xs' (xs' ! i) < k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {y. index xs' y < k'} = {xs' ! i |i. i < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have aaa23: \"inj_on (\\<lambda>i. xs'!i) {i. i < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((!) xs') {i. i < k'}", "apply(rule inj_on_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs'\n 2. \\<forall>i\\<in>{i. i < k'}. i < length xs'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < k'}. i < length xs'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<index (swaps (paid_A ! n) (s_A n)) q - free_A ! n.\n       i < length init", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "case (1 i)"], ["proof (state)\nthis:\n  i < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "then"], ["proof (chain)\npicking this:\n  i < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n", "have \"i < index xs' (q)\""], ["proof (prove)\nusing this:\n  i < index (swaps (paid_A ! n) (s_A n)) q - free_A ! n\n\ngoal (1 subgoal):\n 1. i < index xs' q", "by auto"], ["proof (state)\nthis:\n  i < index xs' q\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "also"], ["proof (state)\nthis:\n  i < index xs' q\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "have \"\\<dots> < length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs' q < length xs'", "using index_less_size_conv"], ["proof (prove)\nusing this:\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. index xs' q < length xs'", "by (auto simp: queryinlist)"], ["proof (state)\nthis:\n  index xs' q < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "also"], ["proof (state)\nthis:\n  index xs' q < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "have \"\\<dots> = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs' = length init", "by auto"], ["proof (state)\nthis:\n  length xs' = length init\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < index (swaps (paid_A ! n) (s_A n)) q -\n           free_A ! n \\<Longrightarrow>\n       i < length init", "finally"], ["proof (chain)\npicking this:\n  i < length init", "show \" i < length init\""], ["proof (prove)\nusing this:\n  i < length init\n\ngoal (1 subgoal):\n 1. i < length init", "."], ["proof (state)\nthis:\n  i < length init\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on ((!) xs') {i. i < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have aa3: \"{xs'!i | i. i < k'} = (\\<lambda>i. xs'!i) ` {i. i < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs' ! i |i. i < k'} = (!) xs' ` {i. i < k'}", "by auto"], ["proof (state)\nthis:\n  {xs' ! i |i. i < k'} = (!) xs' ` {i. i < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have aa4: \"{(q,b)|b. index xs' b < k'} = (\\<lambda>b. (q,b)) ` {b. index xs' b < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(q, b) |b. index xs' b < k'} = Pair q ` {b. index xs' b < k'}", "by auto"], ["proof (state)\nthis:\n  {(q, b) |b. index xs' b < k'} = Pair q ` {b. index xs' b < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have unbelievable: \"{i::nat. i < k'} = {..<k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < k'} = {..<k'}", "by auto"], ["proof (state)\nthis:\n  {i. i < k'} = {..<k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have aadad: \"inj_on (\\<lambda>b. (q,b)) {b. index xs' b < k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Pair q) {b. index xs' b < k'}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{b. index xs' b < k'}.\n       \\<forall>y\\<in>{b. index xs' b < k'}.\n          (q, x) = (q, y) \\<longrightarrow> x = y", "by(simp)"], ["proof (state)\nthis:\n  inj_on (Pair q) {b. index xs' b < k'}\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"(\\<Sum>(x,y)\\<in>{(q,b)|b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\n                = (\\<Sum>y\\<in>{y. index xs' y < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "have \"(\\<Sum>(x,y)\\<in>{(q,b)|b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\n                    = (\\<Sum>(x,y)\\<in> (\\<lambda>b. (q,b)) ` {b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n       if b ! index init y then 2 else 1)", "using aa4"], ["proof (prove)\nusing this:\n  {(q, b) |b. index xs' b < k'} = Pair q ` {b. index xs' b < k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n       if b ! index init y then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "have \"\\<dots> = (\\<Sum>z\\<in> (\\<lambda>b. (q,b)) ` {b. index xs' b < k'}. (if b!(index init (snd z)) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n       if b ! index init (snd z) then 2 else 1)", "by (simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init (snd z) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init (snd z) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "have \"\\<dots> = (\\<Sum>z\\<in>{b. index xs' b < k'}. (if b!(index init (snd ((\\<lambda>b. (q,b)) z))) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n       if b ! index init (snd z) then 2 else 1) =\n    (\\<Sum>z\\<in>{b. index xs' b < k'}.\n       if b ! index init (snd (q, z)) then 2 else 1)", "apply(simp only: sum.reindex[OF aadad])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>z. if b ! index init (snd z) then 2 else 1) \\<circ>\n         Pair q)\n     {b. index xs' b < k'} =\n    (\\<Sum>z\\<in>{b. index xs' b < k'}.\n       if b ! index init (snd (q, z)) then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init (snd z) then 2 else 1) =\n  (\\<Sum>z\\<in>{b. index xs' b < k'}.\n     if b ! index init (snd (q, z)) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>Pair q ` {b. index xs' b < k'}.\n     if b ! index init (snd z) then 2 else 1) =\n  (\\<Sum>z\\<in>{b. index xs' b < k'}.\n     if b ! index init (snd (q, z)) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "have \"\\<dots> = (\\<Sum>y\\<in>{y. index xs' y < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{b. index xs' b < k'}.\n       if b ! index init (snd (q, z)) then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{b. index xs' b < k'}.\n     if b ! index init (snd (q, z)) then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>y\\<in>{xs'!i | i. i < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1)", "using sameset"], ["proof (prove)\nusing this:\n  {y. index xs' y < k'} = {xs' ! i |i. i < k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y | index xs' y < k'. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>y\\<in>(\\<lambda>i. xs'!i) ` {i. i < k'}. (if b!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1)", "using aa3"], ["proof (prove)\nusing this:\n  {xs' ! i |i. i < k'} = (!) xs' ` {i. i < k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{xs' ! i |i. i < k'}. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>y\\<in>{i::nat. i < k'}. (if b!(index init (xs'!y)) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1)", "using sum.reindex[OF aaa23]"], ["proof (prove)\nusing this:\n  sum ?g ((!) xs' ` {i. i < k'}) = sum (?g \\<circ> (!) xs') {i. i < k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1) =\n    (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>(!) xs' ` {i. i < k'}. if b ! index init y then 2 else 1) =\n  (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E3: \"\\<dots> = (\\<Sum>j::nat<k'. (if b!(index init (xs'!j)) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1) =\n    (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "using unbelievable"], ["proof (prove)\nusing this:\n  {i. i < k'} = {..<k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1) =\n    (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{i. i < k'}. if b ! index init (xs' ! y) then 2 else 1) =\n  (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have bb: \"(\\<Sum>(x,y)\\<in>{(q,b)|b. index xs' b < k'}. (if b!(index init y) then 2::real else 1))\n              = (\\<Sum>j<k'. (if b!(index init (xs'!j)) then 2::real else 1))\""], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n       if b ! index init y then 2 else 1) =\n    (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"A \\<le> (\\<Sum>j<k'. (if b!(index init (xs'!j)) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "using aa bb"], ["proof (prove)\nusing this:\n  A \\<le> (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n             if b ! index init y then 2 else 1)\n  (\\<Sum>(x, y)\\<in>{(q, b) |b. index xs' b < k'}.\n     if b ! index init y then 2 else 1) =\n  (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "by linarith"], ["proof (state)\nthis:\n  A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (2 subgoals):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n 2. \\<not> b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "show \"A\n              \\<le> (if b!(index init q) then k-k' else (\\<Sum>j<k'. (if b!(index init (xs'!j)) then 2::real else 1)))\""], ["proof (prove)\nusing this:\n  A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "using False"], ["proof (prove)\nusing this:\n  A \\<le> (\\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n  \\<not> b ! index init q\n\ngoal (1 subgoal):\n 1. A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  A \\<le> (if b ! index init q then real (k - k')\n           else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "case True"], ["proof (state)\nthis:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  b ! index init q", "have samesame: \"ys' = ys\""], ["proof (prove)\nusing this:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. ys' = ys", "unfolding ys'_def step_def"], ["proof (prove)\nusing this:\n  b ! index init q\n\ngoal (1 subgoal):\n 1. (let (k, sws) = aBIT in mtf2 k q (swaps sws ys)) = ys", "by auto"], ["proof (state)\nthis:\n  ys' = ys\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "(* BIT does nothing *)"], ["proof (state)\nthis:\n  ys' = ys\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have setxsbleibt: \"set xs'' = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs'' = set init", "by auto"], ["proof (state)\nthis:\n  set xs'' = set init\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have whatisk': \"k' = index xs'' q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' = index xs'' q", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q - free_A ! n =\n    index (mtf2 (free_A ! n) q (swaps (paid_A ! n) (s_A n))) q", "apply(rule mtf2_q_after[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (swaps (paid_A ! n) (s_A n))\n 2. q \\<in> set (swaps (paid_A ! n) (s_A n))", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (2 subgoals):\n 1. distinct (swaps (paid_A ! n) (s_A n))\n 2. q \\<in> set (swaps (paid_A ! n) (s_A n))", "by auto"], ["proof (state)\nthis:\n  k' = index xs'' q\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"(Inv ys' xs'')-(Inv ys xs')\n              = {(x,y). x < y in ys  \\<and> y < x in xs'' \\<and>  ~ y < x in xs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv ys' xs'' - Inv ys xs' =\n    {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x < y in ys' \\<and> y < x in xs''} -\n    {(x, y). x < y in ys \\<and> y < x in xs'} =\n    {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "using samesame"], ["proof (prove)\nusing this:\n  ys' = ys\n\ngoal (1 subgoal):\n 1. {(x, y). x < y in ys' \\<and> y < x in xs''} -\n    {(x, y). x < y in ys \\<and> y < x in xs'} =\n    {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}", "by auto"], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs' =\n  {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs' =\n  {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \n            \"\\<dots> \\<subseteq>  {(xs'!i,q)|i. i\\<in>{k'..<k}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n    \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (a, b) = (xs' ! i, q) \\<and> i \\<in> {k'..<k}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "assume 1: \"a < b in ys\"\n                and 2: \"b < a in xs''\"\n                and 3: \"\\<not> b < a in xs'\""], ["proof (state)\nthis:\n  a < b in ys\n  b < a in xs''\n  \\<not> b < a in xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "then"], ["proof (chain)\npicking this:\n  a < b in ys\n  b < a in xs''\n  \\<not> b < a in xs'", "have anb: \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  a < b in ys\n  b < a in xs''\n  \\<not> b < a in xs'\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "using no_before_inI"], ["proof (prove)\nusing this:\n  a < b in ys\n  b < a in xs''\n  \\<not> b < a in xs'\n  ?x < ?y in ?xs \\<Longrightarrow> (\\<not> ?y < ?x in ?xs) = True\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by(force)"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "have a: \"a \\<in> set init\"\n                  and b: \"b \\<in> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set init &&& b \\<in> set init", "using  before_in_setD1[OF 1] before_in_setD2[OF 1]"], ["proof (prove)\nusing this:\n  a \\<in> set ys\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. a \\<in> set init &&& b \\<in> set init", "by auto"], ["proof (state)\nthis:\n  a \\<in> set init\n  b \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "with anb 3"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  \\<not> b < a in xs'\n  a \\<in> set init\n  b \\<in> set init", "have 3: \"a < b in xs'\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  \\<not> b < a in xs'\n  a \\<in> set init\n  b \\<in> set init\n\ngoal (1 subgoal):\n 1. a < b in xs'", "by (simp add: not_before_in)"], ["proof (state)\nthis:\n  a < b in xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "note all= anb 1 2 3 a b"], ["proof (state)\nthis:\n  a \\<noteq> b\n  a < b in ys\n  b < a in xs''\n  a < b in xs'\n  a \\<in> set init\n  b \\<in> set init\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "have bq: \"b=q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = q", "apply(rule swapped_by_mtf2[where xs=\"xs'\" and x=a])"], ["proof (prove)\ngoal (6 subgoals):\n 1. q \\<in> set xs'\n 2. distinct xs'\n 3. a \\<in> set xs'\n 4. b \\<in> set xs'\n 5. a < b in xs'\n 6. b < a in mtf2 ?n q xs'", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (6 subgoals):\n 1. q \\<in> set xs'\n 2. distinct xs'\n 3. a \\<in> set xs'\n 4. b \\<in> set xs'\n 5. a < b in xs'\n 6. b < a in mtf2 ?n q xs'", "apply(simp_all add: all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> a < b in swaps (paid_A ! n) (s_A n)\n 2. q \\<in> set init \\<Longrightarrow>\n    b < a in mtf2 ?n q (swaps (paid_A ! n) (s_A n))", "using all(4)"], ["proof (prove)\nusing this:\n  a < b in xs'\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow> a < b in swaps (paid_A ! n) (s_A n)\n 2. q \\<in> set init \\<Longrightarrow>\n    b < a in mtf2 ?n q (swaps (paid_A ! n) (s_A n))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    b < a in mtf2 ?n q (swaps (paid_A ! n) (s_A n))", "using all(3)"], ["proof (prove)\nusing this:\n  b < a in xs''\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    b < a in mtf2 ?n q (swaps (paid_A ! n) (s_A n))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b = q\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "note mine=mtf2_backwards_effect3[THEN conjunct1]"], ["proof (state)\nthis:\n  \\<lbrakk>index ?xs1 ?q1 < length ?xs1; ?q1 \\<in> set ?xs1; distinct ?xs1;\n   index ?xs1 ?q1 - ?n1 < index (mtf2 ?n1 ?q1 ?xs1) (?xs1 ! ?i1) \\<and>\n   index (mtf2 ?n1 ?q1 ?xs1) (?xs1 ! ?i1) \\<le> index ?xs1 ?q1;\n   ?i1 < length ?xs1\\<rbrakk>\n  \\<Longrightarrow> index ?xs1 ?q1 - ?n1 \\<le> ?i1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "from bq"], ["proof (chain)\npicking this:\n  b = q", "have \"q < a in xs''\""], ["proof (prove)\nusing this:\n  b = q\n\ngoal (1 subgoal):\n 1. q < a in xs''", "using 2"], ["proof (prove)\nusing this:\n  b = q\n  b < a in xs''\n\ngoal (1 subgoal):\n 1. q < a in xs''", "by auto"], ["proof (state)\nthis:\n  q < a in xs''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "then"], ["proof (chain)\npicking this:\n  q < a in xs''", "have \"(k' < index xs'' a \\<and> a \\<in> set xs'')\""], ["proof (prove)\nusing this:\n  q < a in xs''\n\ngoal (1 subgoal):\n 1. k' < index xs'' a \\<and> a \\<in> set xs''", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs'' q < index xs'' a \\<and> a \\<in> set xs''\n\ngoal (1 subgoal):\n 1. k' < index xs'' a \\<and> a \\<in> set xs''", "using  whatisk'"], ["proof (prove)\nusing this:\n  index xs'' q < index xs'' a \\<and> a \\<in> set xs''\n  k' = index xs'' q\n\ngoal (1 subgoal):\n 1. k' < index xs'' a \\<and> a \\<in> set xs''", "by auto"], ["proof (state)\nthis:\n  k' < index xs'' a \\<and> a \\<in> set xs''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "then"], ["proof (chain)\npicking this:\n  k' < index xs'' a \\<and> a \\<in> set xs''", "have low : \"k' \\<le> index xs' a\""], ["proof (prove)\nusing this:\n  k' < index xs'' a \\<and> a \\<in> set xs''\n\ngoal (1 subgoal):\n 1. k' \\<le> index xs' a", "unfolding whatisk'"], ["proof (prove)\nusing this:\n  index xs'' q < index xs'' a \\<and> a \\<in> set xs''\n\ngoal (1 subgoal):\n 1. index xs'' q \\<le> index xs' a", "unfolding xs''_def"], ["proof (prove)\nusing this:\n  index (mtf2 (free_A ! n) q xs') q\n  < index (mtf2 (free_A ! n) q xs') a \\<and>\n  a \\<in> set (mtf2 (free_A ! n) q xs')\n\ngoal (1 subgoal):\n 1. index (mtf2 (free_A ! n) q xs') q \\<le> index xs' a", "apply(subst mtf2_q_after)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    distinct xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 3. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n \\<le> index xs' a", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n \\<le> index xs' a", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (2 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n \\<le> index xs' a", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n \\<le> index xs' a", "apply(rule mine)"], ["proof (prove)\ngoal (5 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q < length xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 3. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    distinct xs'\n 4. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n\n    < index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<and>\n    index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<le> index xs' q\n 5. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "apply (simp add: queryinlist)"], ["proof (prove)\ngoal (4 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    distinct xs'\n 3. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n\n    < index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<and>\n    index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<le> index xs' q\n 4. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "using bq b"], ["proof (prove)\nusing this:\n  b = q\n  b \\<in> set init\n\ngoal (4 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    q \\<in> set xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    distinct xs'\n 3. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n\n    < index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<and>\n    index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<le> index xs' q\n 4. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    distinct xs'\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n\n    < index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<and>\n    index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<le> index xs' q\n 3. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' q - free_A ! n\n    < index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<and>\n    index (mtf2 (free_A ! n) q xs') (xs' ! index xs' a) \\<le> index xs' q\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "apply(simp del: xs'_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set init \\<Longrightarrow>\n    index xs' q - free_A ! n < index (mtf2 (free_A ! n) q xs') a \\<and>\n    index (mtf2 (free_A ! n) q xs') a \\<le> index xs' q\n 2. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "apply (metis \"3\" a before_in_def bq dp_xs'_init k'_def k_def max_0L mtf2_forward_beforeq nth_index whatisk' xs''_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "using a"], ["proof (prove)\nusing this:\n  a \\<in> set init\n\ngoal (1 subgoal):\n 1. index (mtf2 (free_A ! n) q xs') q\n    < index (mtf2 (free_A ! n) q xs') a \\<and>\n    a \\<in> set (mtf2 (free_A ! n) q xs') \\<Longrightarrow>\n    index xs' a < length xs'", "by(simp)"], ["proof (state)\nthis:\n  k' \\<le> index xs' a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "(* \n\n                 unfolding xs'_def xs_def\n                sledgehammer TODO: make this step readable  \nby (metis \"3\" mtf2_q_after a before_in_def bq dp_xs'_init index_less_size_conv mtf2_forward_beforeq nth_index whatisk' xs''_def xs'_def xs_def)\n *)"], ["proof (state)\nthis:\n  k' \\<le> index xs' a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "from bq"], ["proof (chain)\npicking this:\n  b = q", "have \"a < q in xs'\""], ["proof (prove)\nusing this:\n  b = q\n\ngoal (1 subgoal):\n 1. a < q in xs'", "using 3"], ["proof (prove)\nusing this:\n  b = q\n  a < b in xs'\n\ngoal (1 subgoal):\n 1. a < q in xs'", "by auto"], ["proof (state)\nthis:\n  a < q in xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "then"], ["proof (chain)\npicking this:\n  a < q in xs'", "have up: \"(index xs' a < k )\""], ["proof (prove)\nusing this:\n  a < q in xs'\n\ngoal (1 subgoal):\n 1. index xs' a < k", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index xs' a < index xs' q \\<and> q \\<in> set xs'\n\ngoal (1 subgoal):\n 1. index xs' a < k", "by auto"], ["proof (state)\nthis:\n  index xs' a < k\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set init", "have \"a \\<in> set xs'\""], ["proof (prove)\nusing this:\n  a \\<in> set init\n\ngoal (1 subgoal):\n 1. a \\<in> set xs'", "by simp"], ["proof (state)\nthis:\n  a \\<in> set xs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "then"], ["proof (chain)\npicking this:\n  a \\<in> set xs'", "have aa: \"a = xs'!index xs' a\""], ["proof (prove)\nusing this:\n  a \\<in> set xs'\n\ngoal (1 subgoal):\n 1. a = xs' ! index xs' a", "using nth_index"], ["proof (prove)\nusing this:\n  a \\<in> set xs'\n  ?x \\<in> set ?xs \\<Longrightarrow> ?xs ! index ?xs ?x = ?x\n\ngoal (1 subgoal):\n 1. a = xs' ! index xs' a", "by simp"], ["proof (state)\nthis:\n  a = xs' ! index xs' a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "have inset: \"index xs' a \\<in> {k'..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs' a \\<in> {k'..<k}", "using low up"], ["proof (prove)\nusing this:\n  k' \\<le> index xs' a\n  index xs' a < k\n\ngoal (1 subgoal):\n 1. index xs' a \\<in> {k'..<k}", "by fastforce"], ["proof (state)\nthis:\n  index xs' a \\<in> {k'..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < b in ys; b < a in xs''; \\<not> b < a in xs'\\<rbrakk>\n       \\<Longrightarrow> (a, b) = (xs' ! ?i5 a b, q) \\<and>\n                         ?i5 a b \\<in> {k'..<k}", "from bq aa"], ["proof (chain)\npicking this:\n  b = q\n  a = xs' ! index xs' a", "show \"(a, b) = (xs' ! index xs' a, q) \\<and> index xs' a \\<in> {k'..<k}\""], ["proof (prove)\nusing this:\n  b = q\n  a = xs' ! index xs' a\n\ngoal (1 subgoal):\n 1. (a, b) = (xs' ! index xs' a, q) \\<and> index xs' a \\<in> {k'..<k}", "using inset"], ["proof (prove)\nusing this:\n  b = q\n  a = xs' ! index xs' a\n  index xs' a \\<in> {k'..<k}\n\ngoal (1 subgoal):\n 1. (a, b) = (xs' ! index xs' a, q) \\<and> index xs' a \\<in> {k'..<k}", "by simp"], ["proof (state)\nthis:\n  (a, b) = (xs' ! index xs' a, q) \\<and> index xs' a \\<in> {k'..<k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y). x < y in ys \\<and> y < x in xs'' \\<and> \\<not> y < x in xs'}\n  \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  Inv ys' xs'' - Inv ys xs' \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "have a: \"(Inv ys' xs'')-(Inv ys xs') \\<subseteq> {(xs'!i,q)|i. i\\<in>{k'..<k}}\" (is \"?M \\<subseteq> ?UB\")"], ["proof (prove)\nusing this:\n  Inv ys' xs'' - Inv ys xs' \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}\n\ngoal (1 subgoal):\n 1. Inv ys' xs'' - Inv ys xs'\n    \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "."], ["proof (state)\nthis:\n  Inv ys' xs'' - Inv ys xs' \\<subseteq> {(xs' ! i, q) |i. i \\<in> {k'..<k}}\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have card_of_UB: \"card {(xs'!i,q)|i. i\\<in>{k'..<k}} = k-k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "have e: \"fst ` ?UB = (%i. xs' ! i) ` {k'..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}} = (!) xs' ` {k'..<k}", "by force"], ["proof (state)\nthis:\n  fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}} = (!) xs' ` {k'..<k}\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "have \"card ?UB = card (fst ` ?UB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} =\n    card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}})", "apply(rule card_image[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "using inj_on_def"], ["proof (prove)\nusing this:\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on fst {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "by fastforce"], ["proof (state)\nthis:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} =\n  card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}})\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "also"], ["proof (state)\nthis:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} =\n  card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}})\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "have \"\\<dots> = card ((%i. xs' ! i) ` {k'..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}}) =\n    card ((!) xs' ` {k'..<k})", "by (simp only: e)"], ["proof (state)\nthis:\n  card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}}) =\n  card ((!) xs' ` {k'..<k})\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "also"], ["proof (state)\nthis:\n  card (fst ` {(xs' ! i, q) |i. i \\<in> {k'..<k}}) =\n  card ((!) xs' ` {k'..<k})\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "have \"\\<dots> = card {k'..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((!) xs' ` {k'..<k}) = card {k'..<k}", "apply(rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((!) xs') {k'..<k}", "apply(rule inj_on_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs'\n 2. \\<forall>i\\<in>{k'..<k}. i < length xs'", "using k_inbounds"], ["proof (prove)\nusing this:\n  k < length init\n\ngoal (2 subgoals):\n 1. distinct xs'\n 2. \\<forall>i\\<in>{k'..<k}. i < length xs'", "by simp_all"], ["proof (state)\nthis:\n  card ((!) xs' ` {k'..<k}) = card {k'..<k}\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "also"], ["proof (state)\nthis:\n  card ((!) xs' ` {k'..<k}) = card {k'..<k}\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "have \"\\<dots> = k-k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {k'..<k} = k - k'", "by auto"], ["proof (state)\nthis:\n  card {k'..<k} = k - k'\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "finally"], ["proof (chain)\npicking this:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "show ?thesis"], ["proof (prove)\nusing this:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'\n\ngoal (1 subgoal):\n 1. card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'", "."], ["proof (state)\nthis:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {(xs' ! i, q) |i. i \\<in> {k'..<k}} = k - k'\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have flipit: \"flip (index init q) b ! (index init q) =  (~ (b) ! (index init q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (index init q) b ! index init q = (\\<not> b ! index init q)", "apply(rule flip_itself)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index init q < length b", "using queryinlist setinit"], ["proof (prove)\nusing this:\n  q \\<in> set init\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init q < length b", "by auto"], ["proof (state)\nthis:\n  flip (index init q) b ! index init q = (\\<not> b ! index init q)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have q: \"{x\\<in>?UB. snd x=q} = ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q} =\n    {(xs' ! i, q) |i. i \\<in> {k'..<k}}", "by auto"], ["proof (state)\nthis:\n  {x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q} =\n  {(xs' ! i, q) |i. i \\<in> {k'..<k}}\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E0: \"A = (\\<Sum>(x,y)\\<in>(Inv ys' xs'')-(Inv ys xs'). (if b'!(index init y) then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  A =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E1: \"\\<dots> \\<le> (\\<Sum>(z,y)\\<in>?UB. if flip (index init q) (b) ! (index init y) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n             if flip (index init q) b ! index init y then 2 else 1)", "unfolding b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if flip (index init q) b ! index init y then 2 else 1)\n    \\<le> (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n             if flip (index init q) b ! index init y then 2 else 1)", "apply(rule sum_mono2[OF _ a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {(xs' ! i, q) |i. i \\<in> {k'..<k}}\n 2. \\<And>ba.\n       ba \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}} -\n                (Inv ys' xs'' - Inv ys xs') \\<Longrightarrow>\n       0 \\<le> (case ba of\n                (x, y) \\<Rightarrow>\n                  if flip (index init q) b ! index init y then 2 else 1)", "by(simp_all add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n           if flip (index init q) b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n     if b' ! index init y then 2 else 1)\n  \\<le> (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n           if flip (index init q) b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>(z,y)\\<in>{x\\<in>?UB. snd x=q}. if flip (index init q) (b) ! (index init y) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n       if flip (index init q) b ! index init y then 2 else 1) =\n    (\\<Sum>(z, y)\n           \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init y then 2 else 1)", "by(simp only: q)"], ["proof (state)\nthis:\n  (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init y then 2 else 1) =\n  (\\<Sum>(z, y)\n         \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(z, y)\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init y then 2 else 1) =\n  (\\<Sum>(z, y)\n         \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>z\\<in>{x\\<in>?UB. snd x=q}. if flip (index init q) (b) ! (index init (snd z)) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(z, y)\n           \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init y then 2 else 1) =\n    (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init (snd z) then 2 else 1)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(z, y)\n         \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init y then 2 else 1) =\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init (snd z) then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(z, y)\n         \\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init y then 2 else 1) =\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init (snd z) then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have \"\\<dots> = (\\<Sum>z\\<in>{x\\<in>?UB. snd x=q}. if flip (index init q) (b) ! (index init q) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init (snd z) then 2 else 1) =\n    (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init q then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init (snd z) then 2 else 1) =\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init q then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init (snd z) then 2 else 1) =\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init q then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E2: \"\\<dots> = (\\<Sum>z\\<in>?UB. if flip (index init q) (b) ! (index init q) then 2::real else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n       if flip (index init q) b ! index init q then 2 else 1) =\n    (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n       if flip (index init q) b ! index init q then 2 else 1)", "by(simp only: q)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init q then 2 else 1) =\n  (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init q then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{x \\<in> {(xs' ! i, q) |i. i \\<in> {k'..<k}}. snd x = q}.\n     if flip (index init q) b ! index init q then 2 else 1) =\n  (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init q then 2 else 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E3: \"\\<dots> = (\\<Sum>y\\<in>?UB. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n       if flip (index init q) b ! index init q then 2 else 1) =\n    (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1)", "using flipit True"], ["proof (prove)\nusing this:\n  flip (index init q) b ! index init q = (\\<not> b ! index init q)\n  b ! index init q\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n       if flip (index init q) b ! index init q then 2 else 1) =\n    (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init q then 2 else 1) =\n  (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}.\n     if flip (index init q) b ! index init q then 2 else 1) =\n  (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1)\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "have E4: \"\\<dots> = k-k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1) = real (k - k')", "by(simp only: real_of_card[symmetric] card_of_UB)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{(xs' ! i, q) |i. i \\<in> {k'..<k}}. 1) = real (k - k')\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "finally"], ["proof (chain)\npicking this:\n  A \\<le> real (k - k')", "have result: \"A \\<le>  k-k'\""], ["proof (prove)\nusing this:\n  A \\<le> real (k - k')\n\ngoal (1 subgoal):\n 1. A \\<le> real (k - k')", "."], ["proof (state)\nthis:\n  A \\<le> real (k - k')\n\ngoal (1 subgoal):\n 1. b ! index init q \\<Longrightarrow>\n    A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "with True"], ["proof (chain)\npicking this:\n  b ! index init q\n  A \\<le> real (k - k')", "show ?thesis"], ["proof (prove)\nusing this:\n  b ! index init q\n  A \\<le> real (k - k')\n\ngoal (1 subgoal):\n 1. A \\<le> (if b ! index init q then real (k - k')\n             else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  A \\<le> (if b ! index init q then real (k - k')\n           else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<le> (if b ! index init q then real (k - k')\n           else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "show \"(\\<Sum>(x,y)\\<in>(Inv ys' xs''). (if b'!(index init y) then 2::real else 1)) - (\\<Sum>(x,y)\\<in>(Inv ys xs'). (if b!(index init y) then 2::real else 1)) \\<le> ?ub2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) + ub_free", "unfolding ub_free_def teilen[unfolded \\<Delta>_def A_def B_def C_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) +\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) +\n          (if q \\<in> set init\n           then if b ! index init q then real (k - k')\n                else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1\n           else 0)", "using BC_absch A_absch"], ["proof (prove)\nusing this:\n  C - B \\<le> real_of_int (- int I)\n  A \\<le> (if b ! index init q then real (k - k')\n           else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) +\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) +\n          (if q \\<in> set init\n           then if b ! index init q then real (k - k')\n                else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1\n           else 0)", "using True"], ["proof (prove)\nusing this:\n  C - B \\<le> real_of_int (- int I)\n  A \\<le> (if b ! index init q then real (k - k')\n           else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1)\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>Inv ys' xs'' \\<inter> Inv ys xs'.\n       (if b' ! index init y then 2 else 1) -\n       (if b ! index init y then 2 else 1)) +\n    (\\<Sum>(x, y)\\<in>Inv ys' xs'' - Inv ys xs'.\n       if b' ! index init y then 2 else 1) -\n    (\\<Sum>(x, y)\\<in>Inv ys xs' - Inv ys' xs''.\n       if b ! index init y then 2 else 1)\n    \\<le> real_of_int (- int I) +\n          (if q \\<in> set init\n           then if b ! index init q then real (k - k')\n                else \\<Sum>j<k'. if b ! index init (xs' ! j) then 2 else 1\n           else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "from paid_ub"], ["proof (chain)\npicking this:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "have kl: \"\\<Phi>\\<^sub>1 x \\<le> \\<Phi>\\<^sub>0 x + ?paidUB\""], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>1 x\n    \\<le> \\<Phi>\\<^sub>0 x +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "from free_ub"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free", "have kl2: \"\\<Phi>\\<^sub>2 x -  ?ub2 \\<le> \\<Phi>\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - (real_of_int (- int I) + ub_free)\n    \\<le> \\<Phi>\\<^sub>1 x", "using gis dis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1) -\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n  \\<le> real_of_int (- int I) + ub_free\n  \\<Phi>\\<^sub>2 x =\n  (\\<Sum>(x, y)\\<in>Inv ys' xs''. if b' ! index init y then 2 else 1)\n  \\<Phi>\\<^sub>1 x =\n  (\\<Sum>(x, y)\\<in>Inv ys xs'. if b ! index init y then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - (real_of_int (- int I) + ub_free)\n    \\<le> \\<Phi>\\<^sub>1 x", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 x - (real_of_int (- int I) + ub_free)\n  \\<le> \\<Phi>\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "have iub_free: \"I + ?ub2 =  ub_free\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real I + (real_of_int (- int I) + ub_free) = ub_free", "by auto"], ["proof (state)\nthis:\n  real I + (real_of_int (- int I) + ub_free) = ub_free\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "from kl kl2"], ["proof (chain)\npicking this:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n  \\<Phi>\\<^sub>2 x - (real_of_int (- int I) + ub_free)\n  \\<le> \\<Phi>\\<^sub>1 x", "have \"\\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x \\<le> ?ub2 + ?paidUB\""], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>1 x\n  \\<le> \\<Phi>\\<^sub>0 x +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n  \\<Phi>\\<^sub>2 x - (real_of_int (- int I) + ub_free)\n  \\<le> \\<Phi>\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n    \\<le> real_of_int (- int I) + ub_free +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real_of_int (- int I) + ub_free +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real_of_int (- int I) + ub_free +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "have \"(cost x) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x) \\<le> k + 1 + I + ?ub2 + ?paidUB\""], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real_of_int (- int I) + ub_free +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n    \\<le> real (k + 1 + I) + (real_of_int (- int I) + ub_free) +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "using ub_cost_BIT"], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real_of_int (- int I) + ub_free +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n  cost x \\<le> k + 1 + I\n\ngoal (1 subgoal):\n 1. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n    \\<le> real (k + 1 + I) + (real_of_int (- int I) + ub_free) +\n          (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real (k + 1 + I) + (real_of_int (- int I) + ub_free) +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf D \\<Longrightarrow>\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "then"], ["proof (chain)\npicking this:\n  real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real (k + 1 + I) + (real_of_int (- int I) + ub_free) +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)", "show ?case"], ["proof (prove)\nusing this:\n  real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real (k + 1 + I) + (real_of_int (- int I) + ub_free) +\n        (\\<Sum>i<length (paid_A ! n). if b ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n    \\<le> real (k + 1) +\n          (if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0) +\n          (\\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)", "unfolding ub_free_def b_def"], ["proof (prove)\nusing this:\n  real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real (k + 1 + I) +\n        (real_of_int (- int I) +\n         (if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)) +\n        (\\<Sum>i<length (paid_A ! n).\n            if fst (snd x) ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n    \\<le> real (k + 1) +\n          (if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0) +\n          (\\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n  \\<le> real (k + 1) +\n        (if q \\<in> set init\n         then if fst (snd x) ! index init q then real (k - k')\n              else \\<Sum>j<k'.\n                      if fst (snd x) ! index init (xs' ! j) then 2 else 1\n         else 0) +\n        (\\<Sum>i<length (paid_A ! n).\n            if fst (snd x) ! gebub n i then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf D.\n     real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n     \\<le> real (k + 1) +\n           (if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0) +\n           (\\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "text \"Approximation of the Term for Free exchanges\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf D.\n     real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n     \\<le> real (k + 1) +\n           (if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0) +\n           (\\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have free_absch: \"E(map_pmf (\\<lambda>x. (if (q) \\<in> set init then (if (fst (snd x))!(index init q) then k-k' \n                else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1))) else 0)) D)\n          \\<le> 3/4 * k\" (is \"?EA \\<le> ?absche\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "proof (cases \"(q) \\<in> set init\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k\n 2. q \\<notin> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "case False"], ["proof (state)\nthis:\n  q \\<notin> set init\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k\n 2. q \\<notin> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  q \\<notin> set init", "have \"?EA = 0\""], ["proof (prove)\nusing this:\n  q \\<notin> set init\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D) =\n    0", "by auto"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D) =\n  0\n\ngoal (2 subgoals):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k\n 2. q \\<notin> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D) =\n  0\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "by auto"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "case True"], ["proof (state)\nthis:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "note queryinlist=this"], ["proof (state)\nthis:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"k-k' \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - k' \\<le> k", "by auto"], ["proof (state)\nthis:\n  k - k' \\<le> k\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"k' \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<le> k", "by auto"], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "text \"Transformation of the first term\""], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have qsn: \"{index init q} \\<union> {} \\<subseteq> {0..<?l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {index init q} \\<union> {} \\<subseteq> {0..<length init}", "using setinit queryinlist"], ["proof (prove)\nusing this:\n  index init ` set init = {0..<length init}\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. {index init q} \\<union> {} \\<subseteq> {0..<length init}", "by auto"], ["proof (state)\nthis:\n  {index init q} \\<union> {} \\<subseteq> {0..<length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"{l::bool list. length l = ?l \\<and> l!(index init q)}\n          = {xs. Ball {(index init q)} ((!) xs) \\<and> (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = ?l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = length init \\<and> l ! index init q} =\n    {xs.\n     Ball {index init q} ((!) xs) \\<and>\n     (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}", "by auto"], ["proof (state)\nthis:\n  {l. length l = length init \\<and> l ! index init q} =\n  {xs.\n   Ball {index init q} ((!) xs) \\<and>\n   (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  {l. length l = length init \\<and> l ! index init q} =\n  {xs.\n   Ball {index init q} ((!) xs) \\<and>\n   (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}", "have \"card {l::bool list. length l = ?l \\<and> l!(index init q)}\n          = card {xs. Ball {index init q} ((!) xs) \\<and> (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init} \""], ["proof (prove)\nusing this:\n  {l. length l = length init \\<and> l ! index init q} =\n  {xs.\n   Ball {index init q} ((!) xs) \\<and>\n   (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}\n\ngoal (1 subgoal):\n 1. card {l. length l = length init \\<and> l ! index init q} =\n    card\n     {xs.\n      Ball {index init q} ((!) xs) \\<and>\n      (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}", "by auto"], ["proof (state)\nthis:\n  card {l. length l = length init \\<and> l ! index init q} =\n  card\n   {xs.\n    Ball {index init q} ((!) xs) \\<and>\n    (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  card {l. length l = length init \\<and> l ! index init q} =\n  card\n   {xs.\n    Ball {index init q} ((!) xs) \\<and>\n    (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = 2^(length init - card {index init q} - card {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {xs.\n      Ball {index init q} ((!) xs) \\<and>\n      (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init} =\n    2 ^ (length init - card {index init q} - card {})", "apply(subst card2[of \"{(index init q)}\" \"{}\" \"?l\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite {index init q}\n 2. finite {}\n 3. {index init q} \\<inter> {} = {}\n 4. {index init q} \\<union> {} \\<subseteq> {0..<length init}\n 5. 2 ^ (length init - card {index init q} - card {}) =\n    2 ^ (length init - card {index init q} - card {})", "using qsn"], ["proof (prove)\nusing this:\n  {index init q} \\<union> {} \\<subseteq> {0..<length init}\n\ngoal (5 subgoals):\n 1. finite {index init q}\n 2. finite {}\n 3. {index init q} \\<inter> {} = {}\n 4. {index init q} \\<union> {} \\<subseteq> {0..<length init}\n 5. 2 ^ (length init - card {index init q} - card {}) =\n    2 ^ (length init - card {index init q} - card {})", "by auto"], ["proof (state)\nthis:\n  card\n   {xs.\n    Ball {index init q} ((!) xs) \\<and>\n    (\\<forall>i\\<in>{}. \\<not> xs ! i) \\<and> length xs = length init} =\n  2 ^ (length init - card {index init q} - card {})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - card {index init q} - card {})", "have lulu: \"card {l::bool list. length l = ?l \\<and> l!(index init q)} = 2^(?l-1)\""], ["proof (prove)\nusing this:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - card {index init q} - card {})\n\ngoal (1 subgoal):\n 1. card {l. length l = length init \\<and> l ! index init q} =\n    2 ^ (length init - 1)", "by auto"], ["proof (state)\nthis:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"(\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. real(k-k'))\n            = (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. k-k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n       real (k - k')) =\n    real\n     (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        k - k')", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}. k - k')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}. k - k')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (k-k')*2^(?l-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        k - k') =\n    real ((k - k') * 2 ^ (length init - 1))", "using lulu"], ["proof (prove)\nusing this:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. real\n     (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        k - k') =\n    real ((k - k') * 2 ^ (length init - 1))", "by simp"], ["proof (state)\nthis:\n  real\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      k - k') =\n  real ((k - k') * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real ((k - k') * 2 ^ (length init - 1))", "have absch1stterm:  \"(\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. real(k-k'))\n                              = real((k-k')*2^(?l-1))\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real ((k - k') * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n       real (k - k')) =\n    real ((k - k') * 2 ^ (length init - 1))", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real ((k - k') * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "text \"Transformation of the second term\""], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n     real (k - k')) =\n  real ((k - k') * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "let ?S=\"{(xs'!j)|j. j<k'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "from queryinlist"], ["proof (chain)\npicking this:\n  q \\<in> set init", "have \"q \\<in> set (swaps (paid_A ! n) (s_A n))\""], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set (swaps (paid_A ! n) (s_A n))", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (swaps (paid_A ! n) (s_A n))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  q \\<in> set (swaps (paid_A ! n) (s_A n))", "have \"index (swaps (paid_A ! n) (s_A n)) q < length xs'\""], ["proof (prove)\nusing this:\n  q \\<in> set (swaps (paid_A ! n) (s_A n))\n\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q < length xs'", "by auto"], ["proof (state)\nthis:\n  index (swaps (paid_A ! n) (s_A n)) q < length xs'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  index (swaps (paid_A ! n) (s_A n)) q < length xs'", "have k'inbound: \"k' < length xs'\""], ["proof (prove)\nusing this:\n  index (swaps (paid_A ! n) (s_A n)) q < length xs'\n\ngoal (1 subgoal):\n 1. k' < length xs'", "by auto"], ["proof (state)\nthis:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "{"], ["proof (state)\nthis:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have a: \"{..<k'} = {j. j<k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<k'} = {j. j < k'}", "by auto"], ["proof (state)\nthis:\n  {..<k'} = {j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have b: \"?S = ((%j. xs'!j) ` {j. j<k'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = (!) xs' ` {j. j < k'}", "by auto"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} = (!) xs' ` {j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"(\\<Sum>j<k'. (\\<lambda>t. (if x!(index init t) then 2::real else 1)) (xs'!j))\n            = sum ((\\<lambda>t. (if x!(index init t) then 2::real else 1)) o (%j. xs'!j)) {..<k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n     {..<k'}", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {..<k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {..<k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = sum ((\\<lambda>t. (if x!(index init t) then 2::real else 1)) o (%j. xs'!j)) {j. j<k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n     {..<k'} =\n    sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n     {j. j < k'}", "by (simp only: a)"], ["proof (state)\nthis:\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {..<k'} =\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {..<k'} =\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = sum (\\<lambda>t. (if x!(index init t) then 2::real else 1)) ((%j. xs'!j) ` {j. j<k'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n     {j. j < k'} =\n    (\\<Sum>t\\<in>(!) xs' ` {j. j < k'}. if x ! index init t then 2 else 1)", "apply(rule sum.reindex[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((!) xs') {j. j < k'}", "apply(rule inj_on_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct xs'\n 2. \\<forall>i\\<in>{j. j < k'}. i < length xs'", "using k'inbound"], ["proof (prove)\nusing this:\n  k' < length xs'\n\ngoal (2 subgoals):\n 1. distinct xs'\n 2. \\<forall>i\\<in>{j. j < k'}. i < length xs'", "by(simp_all)"], ["proof (state)\nthis:\n  sum ((\\<lambda>t. if x ! index init t then 2 else 1) \\<circ> (!) xs')\n   {j. j < k'} =\n  (\\<Sum>t\\<in>(!) xs' ` {j. j < k'}. if x ! index init t then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>t\\<in>(!) xs' ` {j. j < k'}. if x ! index init t then 2 else 1)", "have \"(\\<Sum>j<k'. (\\<lambda>t. (if x!(index init t) then 2::real else 1)) (xs'!j))                   \n                  = (\\<Sum>j\\<in>?S. (\\<lambda>t. (if x!(index init t) then 2 else 1)) j)\""], ["proof (prove)\nusing this:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>t\\<in>(!) xs' ` {j. j < k'}. if x ! index init t then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "using b"], ["proof (prove)\nusing this:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>t\\<in>(!) xs' ` {j. j < k'}. if x ! index init t then 2 else 1)\n  {xs' ! j |j. j < k'} = (!) xs' ` {j. j < k'}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "}"], ["proof (state)\nthis:\n  (\\<Sum>j<k'. if ?x3 ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if ?x3 ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "note reindex=this"], ["proof (state)\nthis:\n  (\\<Sum>j<k'. if ?x3 ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if ?x3 ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have identS: \"?S = set (take k' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "have \"index (swaps (paid_A ! n) (s_A n)) (q) \\<le> length (swaps (paid_A ! n) (s_A n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (paid_A ! n) (s_A n)) q\n    \\<le> length (swaps (paid_A ! n) (s_A n))", "by (rule index_le_size)"], ["proof (state)\nthis:\n  index (swaps (paid_A ! n) (s_A n)) q\n  \\<le> length (swaps (paid_A ! n) (s_A n))\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "then"], ["proof (chain)\npicking this:\n  index (swaps (paid_A ! n) (s_A n)) q\n  \\<le> length (swaps (paid_A ! n) (s_A n))", "have kxs': \"k' \\<le> length xs'\""], ["proof (prove)\nusing this:\n  index (swaps (paid_A ! n) (s_A n)) q\n  \\<le> length (swaps (paid_A ! n) (s_A n))\n\ngoal (1 subgoal):\n 1. k' \\<le> length xs'", "by simp"], ["proof (state)\nthis:\n  k' \\<le> length xs'\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "have \"?S = (!) xs' ` {0..<k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = (!) xs' ` {0..<k'}", "by force"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} = (!) xs' ` {0..<k'}\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "also"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} = (!) xs' ` {0..<k'}\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "have \"\\<dots> = set (take k' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) xs' ` {0..<k'} = set (take k' xs')", "apply(rule nth_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<le> length xs'", "by(rule kxs')"], ["proof (state)\nthis:\n  (!) xs' ` {0..<k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "finally"], ["proof (chain)\npicking this:\n  {xs' ! j |j. j < k'} = set (take k' xs')", "show \"?S = set (take k' xs')\""], ["proof (prove)\nusing this:\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} = set (take k' xs')", "."], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have distinctS: \"distinct (take k' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (take k' xs')", "using distinct_take identS"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> distinct (take ?i ?xs)\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. distinct (take k' xs')", "by simp"], ["proof (state)\nthis:\n  distinct (take k' xs')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have lengthS: \"length (take k' xs') = k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take k' xs') = k'", "using length_take k'inbound"], ["proof (prove)\nusing this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. length (take k' xs') = k'", "by simp"], ["proof (state)\nthis:\n  length (take k' xs') = k'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "from distinct_card[OF distinctS] lengthS"], ["proof (chain)\npicking this:\n  card (set (take k' xs')) = length (take k' xs')\n  length (take k' xs') = k'", "have \"card (set (take k' xs')) = k'\""], ["proof (prove)\nusing this:\n  card (set (take k' xs')) = length (take k' xs')\n  length (take k' xs') = k'\n\ngoal (1 subgoal):\n 1. card (set (take k' xs')) = k'", "by simp"], ["proof (state)\nthis:\n  card (set (take k' xs')) = k'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  card (set (take k' xs')) = k'", "have cardS: \"card ?S = k'\""], ["proof (prove)\nusing this:\n  card (set (take k' xs')) = k'\n\ngoal (1 subgoal):\n 1. card {xs' ! j |j. j < k'} = k'", "using identS"], ["proof (prove)\nusing this:\n  card (set (take k' xs')) = k'\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. card {xs' ! j |j. j < k'} = k'", "by simp"], ["proof (state)\nthis:\n  card {xs' ! j |j. j < k'} = k'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have a: \"?S \\<subseteq> set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} \\<subseteq> set xs'", "using set_take_subset identS"], ["proof (prove)\nusing this:\n  set (take ?n ?xs) \\<subseteq> set ?xs\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} \\<subseteq> set xs'", "by metis"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'", "have Ssubso: \"(index init) ` ?S \\<subseteq> {0..<?l}\""], ["proof (prove)\nusing this:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. index init ` {xs' ! j |j. j < k'} \\<subseteq> {0..<length init}", "using setinit"], ["proof (prove)\nusing this:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'\n  index init ` set init = {0..<length init}\n\ngoal (1 subgoal):\n 1. index init ` {xs' ! j |j. j < k'} \\<subseteq> {0..<length init}", "by auto"], ["proof (state)\nthis:\n  index init ` {xs' ! j |j. j < k'} \\<subseteq> {0..<length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "from a"], ["proof (chain)\npicking this:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'", "have s_subst_init: \"?S \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  {xs' ! j |j. j < k'} \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. {xs' ! j |j. j < k'} \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  {xs' ! j |j. j < k'} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "note index_inj_on_S=subset_inj_on[OF inj_on_index[of \"init\"] s_subst_init]"], ["proof (state)\nthis:\n  inj_on (index init) {xs' ! j |j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have l: \"xs'!k = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' ! k = q", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' ! index xs' q = q", "apply(rule nth_index)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set xs'", "using queryinlist"], ["proof (prove)\nusing this:\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. q \\<in> set xs'", "by(auto)"], ["proof (state)\nthis:\n  xs' ! k = q\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"xs'!k \\<notin> set (take k' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' ! k \\<notin> set (take k' xs')", "apply(rule index_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<le> index xs' (xs' ! k)", "using l"], ["proof (prove)\nusing this:\n  xs' ! k = q\n\ngoal (1 subgoal):\n 1. k' \\<le> index xs' (xs' ! k)", "by simp"], ["proof (state)\nthis:\n  xs' ! k \\<notin> set (take k' xs')\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  xs' ! k \\<notin> set (take k' xs')", "have requestnotinS: \"(q) \\<notin> ?S\""], ["proof (prove)\nusing this:\n  xs' ! k \\<notin> set (take k' xs')\n\ngoal (1 subgoal):\n 1. q \\<notin> {xs' ! j |j. j < k'}", "using l identS"], ["proof (prove)\nusing this:\n  xs' ! k \\<notin> set (take k' xs')\n  xs' ! k = q\n  {xs' ! j |j. j < k'} = set (take k' xs')\n\ngoal (1 subgoal):\n 1. q \\<notin> {xs' ! j |j. j < k'}", "by simp"], ["proof (state)\nthis:\n  q \\<notin> {xs' ! j |j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "then"], ["proof (chain)\npicking this:\n  q \\<notin> {xs' ! j |j. j < k'}", "have indexnotin: \"index init q \\<notin> (index init) ` ?S\""], ["proof (prove)\nusing this:\n  q \\<notin> {xs' ! j |j. j < k'}\n\ngoal (1 subgoal):\n 1. index init q \\<notin> index init ` {xs' ! j |j. j < k'}", "using index_inj_on_S s_subst_init"], ["proof (prove)\nusing this:\n  q \\<notin> {xs' ! j |j. j < k'}\n  inj_on (index init) {xs' ! j |j. j < k'}\n  {xs' ! j |j. j < k'} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. index init q \\<notin> index init ` {xs' ! j |j. j < k'}", "by auto"], ["proof (state)\nthis:\n  index init q \\<notin> index init ` {xs' ! j |j. j < k'}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have lua: \"{l. length l = ?l \\<and> ~l!(index init q)}\n            = {xs. (\\<forall>i\\<in>{}. xs ! i) \\<and> (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and> length xs = ?l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = length init \\<and> \\<not> l ! index init q} =\n    {xs.\n     (\\<forall>i\\<in>{}. xs ! i) \\<and>\n     (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n     length xs = length init}", "by auto"], ["proof (state)\nthis:\n  {l. length l = length init \\<and> \\<not> l ! index init q} =\n  {xs.\n   (\\<forall>i\\<in>{}. xs ! i) \\<and>\n   (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n   length xs = length init}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "from k'inbound"], ["proof (chain)\npicking this:\n  k' < length xs'", "have k'inbound2: \"Suc k' \\<le> length init\""], ["proof (prove)\nusing this:\n  k' < length xs'\n\ngoal (1 subgoal):\n 1. Suc k' \\<le> length init", "using Suc_le_eq"], ["proof (prove)\nusing this:\n  k' < length xs'\n  (Suc ?m \\<le> ?n) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. Suc k' \\<le> length init", "by auto"], ["proof (state)\nthis:\n  Suc k' \\<le> length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* rewrite from sum over indices of the list \n            to sum over elements (thus indices of the bit vector) *)"], ["proof (state)\nthis:\n  Suc k' \\<le> length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"(\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. (\\<Sum>j<k'. (if x!(index init (xs'!j)) then 2::real else 1)))\n                     \n                = (\\<Sum>x\\<in>{l. length l = ?l \\<and> ~l!(index init q)}. (\\<Sum>j\\<in>?S. (\\<lambda>t. (if x!(index init t) then 2 else 1)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "using reindex"], ["proof (prove)\nusing this:\n  (\\<Sum>j<k'. if ?x3 ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}. if ?x3 ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* rewrite to conform the syntax of  Expactation2or1 *)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (\\<Sum>x\\<in>{xs. (\\<forall>i\\<in>{}. xs ! i) \\<and> (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and> length xs = ?l}. (\\<Sum>j\\<in>?S. (\\<lambda>t. (if x!(index init t) then 2 else 1)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "using lua"], ["proof (prove)\nusing this:\n  {l. length l = length init \\<and> \\<not> l ! index init q} =\n  {xs.\n   (\\<forall>i\\<in>{}. xs ! i) \\<and>\n   (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n   length xs = length init}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (\\<Sum>x\\<in>{xs. (\\<forall>i\\<in>{}. xs ! i) \\<and> (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and> length xs = ?l}. (\\<Sum>j\\<in>(index init) ` ?S. (\\<lambda>t. (if x!t then 2 else 1)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "have \"(\\<Sum>j\\<in>?S. (\\<lambda>t. (if x!(index init t) then 2 else 1)) j)\n              = (\\<Sum>j\\<in>(index init) ` ?S. (\\<lambda>t. (if x!t then 2 else 1)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n       if x ! index init j then 2::'b else (1::'b)) =\n    (\\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n       if x ! j then 2::'b else (1::'b))", "apply(simp only: sum.reindex[OF index_inj_on_S, where g=\"(%j. if x ! j then 2 else 1)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n       if x ! index init j then 2::'b else (1::'b)) =\n    sum ((\\<lambda>j. if x ! j then 2::'b else (1::'b)) \\<circ> index init)\n     {xs' ! j |j. j < k'}", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n     if x ! index init j then 2::?'b2 else (1::?'b2)) =\n  (\\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n     if x ! j then 2::?'b2 else (1::?'b2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "}"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n     if ?x5 ! index init j then 2::?'b2 else (1::?'b2)) =\n  (\\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n     if ?x5 ! j then 2::?'b2 else (1::?'b2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "note a=this"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n     if ?x5 ! index init j then 2::?'b2 else (1::?'b2)) =\n  (\\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n     if ?x5 ! j then 2::?'b2 else (1::?'b2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>{xs' ! j |j. j < k'}.\n         if x ! index init j then 2 else 1) =\n    (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1)", "by(simp only: a)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}. if x ! j then 2 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}. if x ! j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* use  Expactation2or1, and solve all the conditions *)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}. if x ! j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>{xs' ! j |j. j < k'}. if x ! index init j then 2 else 1) =\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}. if x ! j then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = 3 / 2 * real (card ?S) * 2 ^ (?l - card {} - card {q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{xs.\n                  (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                  (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                  length xs = length init}.\n       \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n         if x ! j then 2 else 1) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(subst Expactation2or1)"], ["proof (prove)\ngoal (8 subgoals):\n 1. finite (index init ` {xs' ! j |j. j < k'})\n 2. finite {}\n 3. finite {index init q}\n 4. card {} + card {index init q} + card (index init ` {xs' ! j |j. j < k'})\n    \\<le> length init\n 5. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 6. {} \\<inter> {index init q} = {}\n 7. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 8. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. finite {}\n 2. finite {index init q}\n 3. card {} + card {index init q} + card (index init ` {xs' ! j |j. j < k'})\n    \\<le> length init\n 4. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 5. {} \\<inter> {index init q} = {}\n 6. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 7. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. finite {index init q}\n 2. card {} + card {index init q} + card (index init ` {xs' ! j |j. j < k'})\n    \\<le> length init\n 3. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 4. {} \\<inter> {index init q} = {}\n 5. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 6. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. card {} + card {index init q} + card (index init ` {xs' ! j |j. j < k'})\n    \\<le> length init\n 2. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 3. {} \\<inter> {index init q} = {}\n 4. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 5. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp only: card_image index_inj_on_S cardS )"], ["proof (prove)\ngoal (5 subgoals):\n 1. card {} + card {index init q} + k' \\<le> length init\n 2. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 3. {} \\<inter> {index init q} = {}\n 4. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 5. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp add: k'inbound2 del: k'_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 2. {} \\<inter> {index init q} = {}\n 3. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 4. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "using indexnotin"], ["proof (prove)\nusing this:\n  index init q \\<notin> index init ` {xs' ! j |j. j < k'}\n\ngoal (4 subgoals):\n 1. index init ` {xs' ! j |j. j < k'} \\<inter>\n    ({} \\<union> {index init q}) =\n    {}\n 2. {} \\<inter> {index init q} = {}\n 3. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 4. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp add: )"], ["proof (prove)\ngoal (3 subgoals):\n 1. {} \\<inter> {index init q} = {}\n 2. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 3. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 2. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "using Ssubso queryinlist"], ["proof (prove)\nusing this:\n  index init ` {xs' ! j |j. j < k'} \\<subseteq> {0..<length init}\n  q \\<in> set init\n\ngoal (2 subgoals):\n 1. index init ` {xs' ! j |j. j < k'} \\<union> {} \\<union> {index init q}\n    \\<subseteq> {0..<length init}\n 2. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 / 2 * real (card (index init ` {xs' ! j |j. j < k'})) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "apply(simp only: card_image[OF index_inj_on_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {index init q}) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{xs.\n                (\\<forall>i\\<in>{}. xs ! i) \\<and>\n                (\\<forall>i\\<in>{index init q}. \\<not> xs ! i) \\<and>\n                length xs = length init}.\n     \\<Sum>j\\<in>index init ` {xs' ! j |j. j < k'}.\n       if x ! j then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})", "have \"(\\<Sum>x\\<in>{l. length l = ?l \\<and> \\<not> l ! (index init q)}. \\<Sum>j<k'. if x ! (index init (xs' ! j)) then 2 else 1)\n        = 3 / 2 *  real (card ?S) * 2 ^ (?l - card {} - card {q}) \""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q})", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* insert the cardinality of S*)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"3 / 2 *  real (card ?S) *  2 ^ (?l - card {} - card {q}) = (3/2) * (real (k')) *  2 ^ (?l - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q}) =\n    3 / 2 * real k' * 2 ^ (length init - 1)", "using cardS"], ["proof (prove)\nusing this:\n  card {xs' ! j |j. j < k'} = k'\n\ngoal (1 subgoal):\n 1. 3 / 2 * real (card {xs' ! j |j. j < k'}) *\n    2 ^ (length init - card {} - card {q}) =\n    3 / 2 * real k' * 2 ^ (length init - 1)", "by auto"], ["proof (state)\nthis:\n  3 / 2 * real (card {xs' ! j |j. j < k'}) *\n  2 ^ (length init - card {} - card {q}) =\n  3 / 2 * real k' * 2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real k' * 2 ^ (length init - 1)", "have absch2ndterm: \" (\\<Sum>x\\<in>{l. length l = ?l \\<and>  \\<not> l ! (index init q)}.\n                              \\<Sum>j<k'. if x !(index init (xs' ! j)) then 2 else 1) =\n                              3 / 2 * real (k') * 2 ^ (?l - 1) \""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real k' * 2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n       \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    3 / 2 * real k' * 2 ^ (length init - 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real k' * 2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "text \"Equational transformations to the goal\""], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n     \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  3 / 2 * real k' * 2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have cardonebitset: \"card {l::bool list. length l = ?l \\<and> l!(index init q)} = 2^(?l-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {l. length l = length init \\<and> l ! index init q} =\n    2 ^ (length init - 1)", "using lulu"], ["proof (prove)\nusing this:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. card {l. length l = length init \\<and> l ! index init q} =\n    2 ^ (length init - 1)", "by auto"], ["proof (state)\nthis:\n  card {l. length l = length init \\<and> l ! index init q} =\n  2 ^ (length init - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have splitie: \"{l::bool list. length l = ?l}\n            = {l::bool list. length l = ?l \\<and> l!(index init q)} \\<union> {l::bool list. length l = ?l \\<and> ~l!(index init q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = length init} =\n    {l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q}", "by auto"], ["proof (state)\nthis:\n  {l. length l = length init} =\n  {l. length l = length init \\<and> l ! index init q} \\<union>\n  {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have interempty: \"{l::bool list. length l = ?l \\<and> l!(index init q)} \\<inter> {l::bool list. length l = ?l \\<and> ~l!(index init q)}\n            = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = length init \\<and> l ! index init q} \\<inter>\n    {l. length l = length init \\<and> \\<not> l ! index init q} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {l. length l = length init \\<and> l ! index init q} \\<inter>\n  {l. length l = length init \\<and> \\<not> l ! index init q} =\n  {}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have fa: \"finite {l::bool list. length l = ?l \\<and> l!(index init q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. length l = length init \\<and> l ! index init q}", "using bitstrings_finite"], ["proof (prove)\nusing this:\n  finite {xs. length xs = ?m}\n\ngoal (1 subgoal):\n 1. finite {l. length l = length init \\<and> l ! index init q}", "by auto"], ["proof (state)\nthis:\n  finite {l. length l = length init \\<and> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have fb: \"finite {l::bool list. length l = ?l \\<and> ~l!(index init q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. length l = length init \\<and> \\<not> l ! index init q}", "using bitstrings_finite"], ["proof (prove)\nusing this:\n  finite {xs. length xs = ?m}\n\ngoal (1 subgoal):\n 1. finite {l. length l = length init \\<and> \\<not> l ! index init q}", "by auto"], ["proof (state)\nthis:\n  finite {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "{"], ["proof (state)\nthis:\n  finite {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "fix f :: \"bool list \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"(\\<Sum>x\\<in>{l::bool list. length l = ?l}. f x)\n        = (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)} \\<union> {l::bool list. length l = ?l \\<and> ~l!(index init q)}. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {l. length l = length init} =\n    sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<union>\n      {l. length l = length init \\<and> \\<not> l ! index init q})", "by(simp only: splitie)"], ["proof (state)\nthis:\n  sum f {l. length l = length init} =\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  sum f {l. length l = length init} =\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots>\n            =     (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. f x)\n                              + (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. f x)\n                              - (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)} \\<inter> {l::bool list. length l = ?l \\<and> ~l!(index init q)}. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<union>\n      {l. length l = length init \\<and> \\<not> l ! index init q}) =\n    sum f {l. length l = length init \\<and> l ! index init q} +\n    sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n    sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<inter>\n      {l. length l = length init \\<and> \\<not> l ! index init q})", "using sum_Un[OF fa fb, of \"f\"]"], ["proof (prove)\nusing this:\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q}) =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<inter>\n    {l. length l = length init \\<and> \\<not> l ! index init q})\n\ngoal (1 subgoal):\n 1. sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<union>\n      {l. length l = length init \\<and> \\<not> l ! index init q}) =\n    sum f {l. length l = length init \\<and> l ! index init q} +\n    sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n    sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<inter>\n      {l. length l = length init \\<and> \\<not> l ! index init q})", "by simp"], ["proof (state)\nthis:\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q}) =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<inter>\n    {l. length l = length init \\<and> \\<not> l ! index init q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<union>\n    {l. length l = length init \\<and> \\<not> l ! index init q}) =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<inter>\n    {l. length l = length init \\<and> \\<not> l ! index init q})\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. f x)\n                              + (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {l. length l = length init \\<and> l ! index init q} +\n    sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n    sum f\n     ({l. length l = length init \\<and> l ! index init q} \\<inter>\n      {l. length l = length init \\<and> \\<not> l ! index init q}) =\n    sum f {l. length l = length init \\<and> l ! index init q} +\n    sum f {l. length l = length init \\<and> \\<not> l ! index init q}", "by(simp add: interempty)"], ["proof (state)\nthis:\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q} -\n  sum f\n   ({l. length l = length init \\<and> l ! index init q} \\<inter>\n    {l. length l = length init \\<and> \\<not> l ! index init q}) =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  sum f {l. length l = length init} =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q}", "have \"sum f {l. length l = length init} =\n  sum f {l. length l = length init \\<and> l ! (index init q)} + sum f {l. length l = length init \\<and> \\<not> l ! (index init q)}\""], ["proof (prove)\nusing this:\n  sum f {l. length l = length init} =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. sum f {l. length l = length init} =\n    sum f {l. length l = length init \\<and> l ! index init q} +\n    sum f {l. length l = length init \\<and> \\<not> l ! index init q}", "."], ["proof (state)\nthis:\n  sum f {l. length l = length init} =\n  sum f {l. length l = length init \\<and> l ! index init q} +\n  sum f {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "}"], ["proof (state)\nthis:\n  sum ?f6 {l. length l = length init} =\n  sum ?f6 {l. length l = length init \\<and> l ! index init q} +\n  sum ?f6 {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "note darfstsplitten=this"], ["proof (state)\nthis:\n  sum ?f6 {l. length l = length init} =\n  sum ?f6 {l. length l = length init \\<and> l ! index init q} +\n  sum ?f6 {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E1: \"E(map_pmf (\\<lambda>x. (if (fst (snd x))!(index init q) then real(k-k') else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1)))) D)\n          = E(map_pmf (\\<lambda>x. (if x!(index init q) then real(k-k') else (\\<Sum>j<k'. (if x!(index init (xs'!j)) then 2::real else 1)))) (map_pmf (fst \\<circ> snd) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "have triv: \"\\<And>x. (fst \\<circ> snd) x = fst (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (fst \\<circ> snd) x = fst (snd x)", "by simp"], ["proof (state)\nthis:\n  (fst \\<circ> snd) ?x4 = fst (snd ?x4)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "have \"E((map_pmf (\\<lambda>x. (if (fst (snd x))!(index init q) then real(k-k') else (\\<Sum>j<k'. (if (fst (snd x))!index init (xs'!j) then 2::real else 1))))) D)\n                = E(map_pmf (\\<lambda>x. ((\\<lambda>y. (if y!(index init q) then real(k-k') else (\\<Sum>j<k'. (if y!index init (xs'!j) then 2::real else 1)))) \\<circ> (fst \\<circ> snd)) x) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        ((\\<lambda>y.\n             if y ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n         (fst \\<circ> snd))\n        D)", "apply(auto simp: comp_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        (config'_rand BIT\n          (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if (fst \\<circ> snd) x ! index init (xs' ! j) then 2\n                    else 1)\n        (config'_rand BIT\n          (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by (simp only: triv)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      ((\\<lambda>y.\n           if y ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n       (fst \\<circ> snd))\n      D)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      ((\\<lambda>y.\n           if y ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n       (fst \\<circ> snd))\n      D)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "have \"\\<dots> = E((map_pmf (\\<lambda>x. (if x!(index init q) then real(k-k') else (\\<Sum>j<k'. (if x!index init (xs'!j) then 2::real else 1)))) \\<circ> (map_pmf (fst \\<circ> snd))) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        ((\\<lambda>y.\n             if y ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n         (fst \\<circ> snd))\n        D) =\n    E ((map_pmf\n         (\\<lambda>x.\n             if x ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n        map_pmf (fst \\<circ> snd))\n        D)", "using map_pmf_compose"], ["proof (prove)\nusing this:\n  map_pmf (?f \\<circ> ?g) = map_pmf ?f \\<circ> map_pmf ?g\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        ((\\<lambda>y.\n             if y ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n         (fst \\<circ> snd))\n        D) =\n    E ((map_pmf\n         (\\<lambda>x.\n             if x ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n        map_pmf (fst \\<circ> snd))\n        D)", "by metis"], ["proof (state)\nthis:\n  E (map_pmf\n      ((\\<lambda>y.\n           if y ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n       (fst \\<circ> snd))\n      D) =\n  E ((map_pmf\n       (\\<lambda>x.\n           if x ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n      map_pmf (fst \\<circ> snd))\n      D)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      ((\\<lambda>y.\n           if y ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if y ! index init (xs' ! j) then 2 else 1) \\<circ>\n       (fst \\<circ> snd))\n      D) =\n  E ((map_pmf\n       (\\<lambda>x.\n           if x ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n      map_pmf (fst \\<circ> snd))\n      D)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "have \"\\<dots> = E(map_pmf (\\<lambda>x. (if x!(index init q) then real(k-k') else (\\<Sum>j<k'. (if x!index init (xs'!j) then 2::real else 1)))) (map_pmf (fst \\<circ> snd) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E ((map_pmf\n         (\\<lambda>x.\n             if x ! index init q then real (k - k')\n             else \\<Sum>j<k'.\n                     if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n        map_pmf (fst \\<circ> snd))\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "by auto"], ["proof (state)\nthis:\n  E ((map_pmf\n       (\\<lambda>x.\n           if x ! index init q then real (k - k')\n           else \\<Sum>j<k'.\n                   if x ! index init (xs' ! j) then 2 else 1) \\<circ>\n      map_pmf (fst \\<circ> snd))\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "finally"], ["proof (chain)\npicking this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))", "show ?thesis"], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D))", "."], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E2:  \"\\<dots> = E(map_pmf (\\<lambda>x. (if x!(index init q) then real(k-k') else (\\<Sum>j<k'. (if x!(index init (xs'!j)) then 2::real else 1)))) (bv ?l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D)) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (bv (length init)))", "using config_n_bv[of init _]"], ["proof (prove)\nusing this:\n  map_pmf (fst \\<circ> snd)\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs) =\n  bv (length init)\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (map_pmf (fst \\<circ> snd) D)) =\n    E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (bv (length init)))", "by auto"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D)) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (bv (length init)))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (map_pmf (fst \\<circ> snd) D)) =\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (bv (length init)))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "let ?insf=\"(\\<lambda>x. (if x!(index init q) then k-k' else (\\<Sum>j<k'. (if x!(index init (xs'!j)) then 2::real else 1))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E3: \"\\<dots> = (\\<Sum>x\\<in>(set_pmf (bv ?l)). (?insf x) * pmf (bv ?l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if x ! index init q then real (k - k')\n            else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n        (bv (length init))) =\n    (\\<Sum>x\\<in>set_pmf (bv (length init)).\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x)", "by (subst E_finite_sum_fun) (auto simp: bv_finite mult_ac)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (bv (length init))) =\n  (\\<Sum>x\\<in>set_pmf (bv (length init)).\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if x ! index init q then real (k - k')\n          else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n      (bv (length init))) =\n  (\\<Sum>x\\<in>set_pmf (bv (length init)).\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (\\<Sum>x\\<in>{l::bool list. length l = ?l}. (?insf x) * pmf (bv ?l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_pmf (bv (length init)).\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x) =\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x)", "using bv_set"], ["proof (prove)\nusing this:\n  set_pmf (bv ?n) = {x. length x = ?n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_pmf (bv (length init)).\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x) =\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_pmf (bv (length init)).\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_pmf (bv (length init)).\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E4: \"\\<dots> = (\\<Sum>x\\<in>{l::bool list. length l = ?l}. (?insf x) * (1/2)^?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init}.\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       pmf (bv (length init)) x) =\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       (1 / 2) ^ length init)", "by (simp add: list_pmf)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     (1 / 2) ^ length init)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     pmf (bv (length init)) x) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     (1 / 2) ^ length init)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (\\<Sum>x\\<in>{l::bool list. length l = ?l}. (?insf x)) * ((1/2)^?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init}.\n       (if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n       (1 / 2) ^ length init) =\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       if x ! index init q then real (k - k')\n       else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n    (1 / 2) ^ length init", "by(simp only: sum_distrib_right[where r=\"(1/2)^?l\"])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     (1 / 2) ^ length init) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n  (1 / 2) ^ length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     (if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n     (1 / 2) ^ length init) =\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n  (1 / 2) ^ length init\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E5: \"\\<dots> = ((1/2)^?l) *(\\<Sum>x\\<in>{l::bool list. length l = ?l}. (?insf x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{l. length l = length init}.\n       if x ! index init q then real (k - k')\n       else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n    (1 / 2) ^ length init =\n    (1 / 2) ^ length init *\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       if x ! index init q then real (k - k')\n       else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n  (1 / 2) ^ length init =\n  (1 / 2) ^ length init *\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) *\n  (1 / 2) ^ length init =\n  (1 / 2) ^ length init *\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E6: \"\\<dots> = ((1/2)^?l) * (  (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. ?insf x)\n                              + (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. ?insf x)\n                             )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       if x ! index init q then real (k - k')\n       else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))", "using darfstsplitten"], ["proof (prove)\nusing this:\n  sum ?f6 {l. length l = length init} =\n  sum ?f6 {l. length l = length init \\<and> l ! index init q} +\n  sum ?f6 {l. length l = length init \\<and> \\<not> l ! index init q}\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    (\\<Sum>x\\<in>{l. length l = length init}.\n       if x ! index init q then real (k - k')\n       else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n    (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  (\\<Sum>x\\<in>{l. length l = length init}.\n     if x ! index init q then real (k - k')\n     else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E7: \"\\<dots> = ((1/2)^?l) * (  (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. ((\\<lambda>x. real(k-k'))) x)\n                              + (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. ((\\<lambda>x. (\\<Sum>j<k'. (if x!index init (xs'!j) then 2::real else 1)))) x)\n                             )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        if x ! index init q then real (k - k')\n        else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)) =\n    (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        real (k - k')) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      if x ! index init q then real (k - k')\n      else \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))", "have \"E(map_pmf (\\<lambda>x. (if (fst (snd x))!(index init q) then real(k-k') else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1)))) D)\n            = ((1/2)^?l) * (  (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. ((\\<lambda>x. real(k-k'))) x)\n                              + (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> ~l!(index init q)}. ((\\<lambda>x. (\\<Sum>j<k'. (if x!(index init (xs'!j)) then 2::real else 1)))) x)\n                             )\""], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if fst (snd x) ! index init q then real (k - k')\n            else \\<Sum>j<k'.\n                    if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n        D) =\n    (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        real (k - k')) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))", "."], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = ((1/2)^?l) * (  (\\<Sum>x\\<in>{l::bool list. length l = ?l \\<and> l!(index init q)}. real(k-k'))\n                              + (3/2)*(real (k'))*2^(?l-1)\n                             )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        real (k - k')) +\n     (\\<Sum>x\\<in>{l. length l = length init \\<and>\n                      \\<not> l ! index init q}.\n        \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)) =\n    (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        real (k - k')) +\n     3 / 2 * real k' * 2 ^ (length init - 1))", "by(simp only: absch2ndterm)"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   3 / 2 * real k' * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   (\\<Sum>x\\<in>{l. length l = length init \\<and> \\<not> l ! index init q}.\n      \\<Sum>j<k'. if x ! index init (xs' ! j) then 2 else 1)) =\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   3 / 2 * real k' * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E8: \"\\<dots> = ((1/2)^?l) * ( real((k-k')*2^(?l-1)) + (3/2)*(real (k'))*2^(?l-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n        real (k - k')) +\n     3 / 2 * real k' * 2 ^ (length init - 1)) =\n    (1 / 2) ^ length init *\n    (real ((k - k') * 2 ^ (length init - 1)) +\n     3 / 2 * real k' * 2 ^ (length init - 1))", "by(simp only: absch1stterm)"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   3 / 2 * real k' * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init *\n  (real ((k - k') * 2 ^ (length init - 1)) +\n   3 / 2 * real k' * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* from here it is only arithmetic ... *)"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   3 / 2 * real k' * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init *\n  (real ((k - k') * 2 ^ (length init - 1)) +\n   3 / 2 * real k' * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((\\<Sum>x\\<in>{l. length l = length init \\<and> l ! index init q}.\n      real (k - k')) +\n   3 / 2 * real k' * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init *\n  (real ((k - k') * 2 ^ (length init - 1)) +\n   3 / 2 * real k' * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = ((1/2)^?l) * ( (  (k-k') + (k')*(3/2)  ) * 2^(?l-1) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    (real ((k - k') * 2 ^ (length init - 1)) +\n     3 / 2 * real k' * 2 ^ (length init - 1)) =\n    (1 / 2) ^ length init *\n    ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1))", "apply(simp only: distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    (real ((k - k') * 2 ^ (length init - 1)) +\n     3 / 2 * real k' * 2 ^ (length init - 1)) =\n    (1 / 2) ^ length init *\n    (real (k - k') * 2 ^ (length init - 1) +\n     real k' * (3 / 2) * 2 ^ (length init - 1))", "by simp"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  (real ((k - k') * 2 ^ (length init - 1)) +\n   3 / 2 * real k' * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init *\n  ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  (real ((k - k') * 2 ^ (length init - 1)) +\n   3 / 2 * real k' * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init *\n  ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = ((1/2)^?l) * 2^(?l-1) * (   (k-k') + (k')*(3/2)    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init *\n    ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1)) =\n    (1 / 2) ^ length init * 2 ^ (length init - 1) *\n    (real (k - k') + real k' * (3 / 2))", "by simp"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init * 2 ^ (length init - 1) *\n  (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init *\n  ((real (k - k') + real k' * (3 / 2)) * 2 ^ (length init - 1)) =\n  (1 / 2) ^ length init * 2 ^ (length init - 1) *\n  (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (((1::real)/2)^(Suc l')) * 2^(l') * (   real(k-k') + (k')*(3/2)    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init * 2 ^ (length init - 1) *\n    (real (k - k') + real k' * (3 / 2)) =\n    (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2))", "using lSuc"], ["proof (prove)\nusing this:\n  length init = Suc l'\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ length init * 2 ^ (length init - 1) *\n    (real (k - k') + real k' * (3 / 2)) =\n    (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2))", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ length init * 2 ^ (length init - 1) *\n  (real (k - k') + real k' * (3 / 2)) =\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* REFACTOR: the only place where I use lSuc , can I avoid it? \n                yes, if ?l=0 then k=k'<?l impossible, perhaps I can insert that\n                  somehow ? \n              *)"], ["proof (state)\nthis:\n  (1 / 2) ^ length init * 2 ^ (length init - 1) *\n  (real (k - k') + real k' * (3 / 2)) =\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ length init * 2 ^ (length init - 1) *\n  (real (k - k') + real k' * (3 / 2)) =\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E9: \"\\<dots> = (1/2) *   (   real(k-k') + (k')*(3/2)    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "have \"((1::real)/2)^l' * 2^l'  = ((1::real)/2 * 2)^l' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ l' * 2 ^ l' = (1 / 2 * 2) ^ l'", "by(rule power_mult_distrib[symmetric])"], ["proof (state)\nthis:\n  (1 / 2) ^ l' * 2 ^ l' = (1 / 2 * 2) ^ l'\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ l' * 2 ^ l' = (1 / 2 * 2) ^ l'\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "have \"...   = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2 * 2) ^ l' = 1", "by auto"], ["proof (state)\nthis:\n  (1 / 2 * 2) ^ l' = 1\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "finally"], ["proof (chain)\npicking this:\n  (1 / 2) ^ l' * 2 ^ l' = 1", "have \"(((1::real)/2)^(Suc l'))* 2^l'=(1/2)\""], ["proof (prove)\nusing this:\n  (1 / 2) ^ l' * 2 ^ l' = 1\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' = 1 / 2", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ Suc l' * 2 ^ l' = 1 / 2\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "then"], ["proof (chain)\npicking this:\n  (1 / 2) ^ Suc l' * 2 ^ l' = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 / 2) ^ Suc l' * 2 ^ l' = 1 / 2\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (real (k - k') + real k' * (3 / 2))", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  (1 / 2) ^ Suc l' * 2 ^ l' * (real (k - k') + real k' * (3 / 2)) =\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E10: \"\\<dots> \\<le> (1/2) * (  (3/2)*(k-k') + (k')*(3/2)  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (real (k - k') + real k' * (3 / 2))\n    \\<le> 1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2))", "by auto"], ["proof (state)\nthis:\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n  \\<le> 1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "(* and one inequality *)"], ["proof (state)\nthis:\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n  \\<le> 1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  1 / 2 * (real (k - k') + real k' * (3 / 2))\n  \\<le> 1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (1/2) * (  (3/2)*(k-k'+(k'))  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2)) =\n    1 / 2 * (3 / 2 * real (k - k' + k'))", "by auto"], ["proof (state)\nthis:\n  1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2)) =\n  1 / 2 * (3 / 2 * real (k - k' + k'))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  1 / 2 * (3 / 2 * real (k - k') + real k' * (3 / 2)) =\n  1 / 2 * (3 / 2 * real (k - k' + k'))\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have \"\\<dots> = (1/2) * (  (3/2)*(k)  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (3 / 2 * real (k - k' + k')) = 1 / 2 * (3 / 2 * real k)", "by auto"], ["proof (state)\nthis:\n  1 / 2 * (3 / 2 * real (k - k' + k')) = 1 / 2 * (3 / 2 * real k)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "also"], ["proof (state)\nthis:\n  1 / 2 * (3 / 2 * real (k - k' + k')) = 1 / 2 * (3 / 2 * real k)\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "have E11: \"\\<dots> = (3/4)*(k )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (3 / 2 * real k) = 3 / 4 * real k", "by auto"], ["proof (state)\nthis:\n  1 / 2 * (3 / 2 * real k) = 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. q \\<in> set init \\<Longrightarrow>\n    E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "finally"], ["proof (chain)\npicking this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D)\n  \\<le> 3 / 4 * real k", "show \"E(map_pmf (\\<lambda>x. (if q \\<in> set init then (if (fst (snd x))!(index init q) then real( k-k' ) else (\\<Sum>j<k'. (if (fst (snd x))!index init (xs'!j) then 2::real else 1))) else 0 )) D)\n          \\<le> 3/4 * k \""], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "using True"], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          if fst (snd x) ! index init q then real (k - k')\n          else \\<Sum>j<k'.\n                  if fst (snd x) ! index init (xs' ! j) then 2 else 1)\n      D)\n  \\<le> 3 / 4 * real k\n  q \\<in> set init\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            if q \\<in> set init\n            then if fst (snd x) ! index init q then real (k - k')\n                 else \\<Sum>j<k'.\n                         if fst (snd x) ! index init (xs' ! j) then 2 else 1\n            else 0)\n        D)\n    \\<le> 3 / 4 * real k", "by simp"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* free_absch *)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "text \"Transformation of the Term for Paid Exchanges\""], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have paid_absch: \"E(map_pmf (\\<lambda>x. (\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2::real else 1) )) D) = 3/2 * (length (paid_A!n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "assume inbound: \"(index init i) < length init\""], ["proof (state)\nthis:\n  index init i < length init\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"map_pmf (\\<lambda>xx. if fst (snd xx) ! (index init i) then 2::real else 1) D =\n                  bind_pmf (map_pmf (fst \\<circ> snd) D) (\\<lambda>b. return_pmf (if b! index init i then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n    map_pmf (fst \\<circ> snd) D \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))", "unfolding map_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<bind>\n    (\\<lambda>x. return_pmf (if fst (snd x) ! index init i then 2 else 1)) =\n    D \\<bind> (\\<lambda>x. return_pmf ((fst \\<circ> snd) x)) \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))", "by(simp add: bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n  map_pmf (fst \\<circ> snd) D \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n  map_pmf (fst \\<circ> snd) D \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"\\<dots> = bind_pmf (bv (length init)) (\\<lambda>b. return_pmf (if b! index init i then 2::real else 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd) D \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n    bv (length init) \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))", "using config_n_bv[of init \"take n qs\"]"], ["proof (prove)\nusing this:\n  map_pmf (fst \\<circ> snd)\n   (config'_rand BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n     (take n qs)) =\n  bv (length init)\n\ngoal (1 subgoal):\n 1. map_pmf (fst \\<circ> snd) D \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n    bv (length init) \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))", "by simp"], ["proof (state)\nthis:\n  map_pmf (fst \\<circ> snd) D \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n  bv (length init) \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "also"], ["proof (state)\nthis:\n  map_pmf (fst \\<circ> snd) D \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n  bv (length init) \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"\\<dots> = map_pmf (\\<lambda>yy. (if yy then 2 else 1)) ( map_pmf (\\<lambda>y. y!(index init i)) (bv (length init)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv (length init) \\<bind>\n    (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n    map_pmf (\\<lambda>yy. if yy then 2 else 1)\n     (map_pmf (\\<lambda>y. y ! index init i) (bv (length init)))", "by (simp add: map_pmf_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  bv (length init) \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1)\n   (map_pmf (\\<lambda>y. y ! index init i) (bv (length init)))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "also"], ["proof (state)\nthis:\n  bv (length init) \\<bind>\n  (\\<lambda>b. return_pmf (if b ! index init i then 2 else 1)) =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1)\n   (map_pmf (\\<lambda>y. y ! index init i) (bv (length init)))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"\\<dots> = map_pmf (\\<lambda>yy. (if yy then 2 else 1)) (bernoulli_pmf (5 / 10))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>yy. if yy then 2 else 1)\n     (map_pmf (\\<lambda>y. y ! index init i) (bv (length init))) =\n    map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))", "by (auto simp add:  bv_comp_bernoulli[OF inbound])"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>yy. if yy then 2 else 1)\n   (map_pmf (\\<lambda>y. y ! index init i) (bv (length init))) =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "finally"], ["proof (chain)\npicking this:\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))", "have \"map_pmf (\\<lambda>xx. if fst (snd xx) ! (index init i) then 2::real else 1) D =\n                      map_pmf (\\<lambda>yy. if yy then 2::real else 1) (bernoulli_pmf (5 / 10)) \""], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n    map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))", "."], ["proof (state)\nthis:\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init i then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "}"], ["proof (state)\nthis:\n  index init ?i2 < length init \\<Longrightarrow>\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init ?i2 then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "note umform = this"], ["proof (state)\nthis:\n  index init ?i2 < length init \\<Longrightarrow>\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init ?i2 then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"E(map_pmf (\\<lambda>x. (\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2::real else 1))) D) = \n          (\\<Sum>i<(length (paid_A!n)). E(map_pmf ((\\<lambda>xx. (if (fst (snd xx))!(gebub n i) then 2::real else 1))) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n            D))", "apply(subst E_linear_sum2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf D)\n 2. (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>x. if fst (snd x) ! gebub n i then 2 else 1)\n            D)) =\n    (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n            D))", "using finite_config_BIT[OF dist_init]"], ["proof (prove)\nusing this:\n  finite\n   (set_pmf\n     (config'_rand BIT\n       (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs))\n\ngoal (2 subgoals):\n 1. finite (set_pmf D)\n 2. (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>x. if fst (snd x) ! gebub n i then 2 else 1)\n            D)) =\n    (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n            D))", "by(simp_all)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n          D))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n          D))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"\\<dots> =  (\\<Sum>i<(length (paid_A!n)). E(map_pmf (\\<lambda>y. if y then 2::real else 1) (bernoulli_pmf (5 / 10))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n            D)) =\n    (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>y. if y then 2 else 1)\n            (bernoulli_pmf (5 / 10))))", "using umform gebub_def gebub_inBound[OF 31]"], ["proof (prove)\nusing this:\n  index init ?i2 < length init \\<Longrightarrow>\n  map_pmf (\\<lambda>xx. if fst (snd xx) ! index init ?i2 then 2 else 1) D =\n  map_pmf (\\<lambda>yy. if yy then 2 else 1) (bernoulli_pmf (5 / 10))\n  gebub ?n ?m =\n  index init\n   (s'_A ?n ?m ! Suc (paid_A ! ?n ! (length (paid_A ! ?n) - Suc ?m)))\n  ?m < length (paid_A ! n) \\<Longrightarrow> gebub n ?m < length init\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n            D)) =\n    (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>y. if y then 2 else 1)\n            (bernoulli_pmf (5 / 10))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n          D)) =\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>y. if y then 2 else 1) (bernoulli_pmf (5 / 10))))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>xx. if fst (snd xx) ! gebub n i then 2 else 1)\n          D)) =\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>y. if y then 2 else 1) (bernoulli_pmf (5 / 10))))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "have \"\\<dots> =  3/2 * (length (paid_A!n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (paid_A ! n).\n        E (map_pmf (\\<lambda>y. if y then 2 else 1)\n            (bernoulli_pmf (5 / 10)))) =\n    3 / 2 * real (length (paid_A ! n))", "by(simp add: E_bernoulli)"], ["proof (state)\nthis:\n  (\\<Sum>i<length (paid_A ! n).\n      E (map_pmf (\\<lambda>y. if y then 2 else 1)\n          (bernoulli_pmf (5 / 10)))) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "finally"], ["proof (chain)\npicking this:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))", "show \"E(map_pmf (\\<lambda>x. (\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2::real else 1))) D) = 3/2 * (length (paid_A!n))\""], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            \\<Sum>i<length (paid_A ! n).\n               if fst (snd x) ! gebub n i then 2 else 1)\n        D) =\n    3 / 2 * real (length (paid_A ! n))", "."], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "text \"Combine the Results\""], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* cost of A *)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have costA_absch: \"k+(length (paid_A!n)) + 1 = t_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (k + length (paid_A ! n) + 1) = t_A n", "unfolding k_def q_def c_A_def p_A_def t_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (index xs' (qs ! n) + length (paid_A ! n) + 1) =\n    int (index (swaps (paid_A ! n) (s_A n)) (qs ! n) + 1) +\n    int (length (paid_A ! n))", "by (auto)"], ["proof (state)\nthis:\n  int (k + length (paid_A ! n) + 1) = t_A n\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* combine *)"], ["proof (state)\nthis:\n  int (k + length (paid_A ! n) + 1) = t_A n\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "let  ?yo= \"(\\<lambda>x. (cost x) + (\\<Phi>\\<^sub>2 x) - (\\<Phi>\\<^sub>0 x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "let ?yo2=\" (\\<lambda>x. (k + 1) + (if (q)\\<in>set init then (if (fst (snd x))!(index init q) then k-k' \n                                              else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1)) ) else 0)\n                                                  +(\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2 else 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E0: \"t_BIT n + Phi(n+1) - Phi n = E (map_pmf ?yo D) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "using inEreinziehn"], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n    E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)", "by auto"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n =\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> \\<le> E(map_pmf ?yo2 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n    \\<le> E (map_pmf\n              (\\<lambda>x.\n                  real (k + 1) +\n                  (if q \\<in> set init\n                   then if fst (snd x) ! index init q then real (k - k')\n                        else \\<Sum>j<k'.\n                                if fst (snd x) ! index init (xs' ! j) then 2\n                                else 1\n                   else 0) +\n                  (\\<Sum>i<length (paid_A ! n).\n                      if fst (snd x) ! gebub n i then 2 else 1))\n              D)", "apply(rule E_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set_pmf D)\n 2. \\<forall>x\\<in>set_pmf D.\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "unfolding D_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (set_pmf\n       (config'_rand BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n         (take n qs)))\n 2. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "apply(fact finite_config_BIT[OF dist_init])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand BIT\n                      (fst BIT init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      (take n qs)).\n       real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x\n       \\<le> real (k + 1) +\n             (if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)", "apply(fact ub_cost[unfolded D_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n  \\<le> E (map_pmf\n            (\\<lambda>x.\n                real (k + 1) +\n                (if q \\<in> set init\n                 then if fst (snd x) ! index init q then real (k - k')\n                      else \\<Sum>j<k'.\n                              if fst (snd x) ! index init (xs' ! j) then 2\n                              else 1\n                 else 0) +\n                (\\<Sum>i<length (paid_A ! n).\n                    if fst (snd x) ! gebub n i then 2 else 1))\n            D)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x. real (cost x) + \\<Phi>\\<^sub>2 x - \\<Phi>\\<^sub>0 x) D)\n  \\<le> E (map_pmf\n            (\\<lambda>x.\n                real (k + 1) +\n                (if q \\<in> set init\n                 then if fst (snd x) ! index init q then real (k - k')\n                      else \\<Sum>j<k'.\n                              if fst (snd x) ! index init (xs' ! j) then 2\n                              else 1\n                 else 0) +\n                (\\<Sum>i<length (paid_A ! n).\n                    if fst (snd x) ! gebub n i then 2 else 1))\n            D)\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E2: \"\\<dots> = E(map_pmf (\\<lambda>x. k + 1::real) D)\n            + (E(map_pmf (\\<lambda>x. (if (q)\\<in>set init then (if (fst (snd x))!(index init q) then real(k-k') else (\\<Sum>j<k'. (if (fst (snd x))!(index init (xs'!j)) then 2::real else 1)))else 0)) D)\n            + E(map_pmf (\\<lambda>x. (\\<Sum>i<(length (paid_A!n)). (if (fst (snd x))!(gebub n i) then 2::real else 1))) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            real (k + 1) +\n            (if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0) +\n            (\\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1))\n        D) =\n    E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n    (E (map_pmf\n         (\\<lambda>x.\n             if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0)\n         D) +\n     E (map_pmf\n         (\\<lambda>x.\n             \\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1)\n         D))", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            real (k + 1) +\n            (if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0) +\n            (\\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf (\\<lambda>x. real (k + 1))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) +\n    (E (map_pmf\n         (\\<lambda>x.\n             if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0)\n         (config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take n qs))) +\n     E (map_pmf\n         (\\<lambda>x.\n             \\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1)\n         (config'_rand BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take n qs))))", "apply(simp only: E_linear_plus2[OF finite_config_BIT[OF dist_init]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf\n        (\\<lambda>x.\n            real (k + 1) +\n            (if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0) +\n            (\\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs))) =\n    E (map_pmf\n        (\\<lambda>x.\n            real (k + 1) +\n            ((if q \\<in> set init\n              then if fst (snd x) ! index init q then real (k - k')\n                   else \\<Sum>j<k'.\n                           if fst (snd x) ! index init (xs' ! j) then 2\n                           else 1\n              else 0) +\n             (\\<Sum>i<length (paid_A ! n).\n                 if fst (snd x) ! gebub n i then 2 else 1)))\n        (config'_rand BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take n qs)))", "by(auto simp: add.assoc)"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          real (k + 1) +\n          (if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0) +\n          (\\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1))\n      D) =\n  E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n  (E (map_pmf\n       (\\<lambda>x.\n           if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0)\n       D) +\n   E (map_pmf\n       (\\<lambda>x.\n           \\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)\n       D))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  E (map_pmf\n      (\\<lambda>x.\n          real (k + 1) +\n          (if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0) +\n          (\\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1))\n      D) =\n  E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n  (E (map_pmf\n       (\\<lambda>x.\n           if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0)\n       D) +\n   E (map_pmf\n       (\\<lambda>x.\n           \\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)\n       D))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E3: \"\\<dots> \\<le>  k + 1 + (3/4 * (real (k)) + (3/2 * real (length (paid_A!n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n    (E (map_pmf\n         (\\<lambda>x.\n             if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0)\n         D) +\n     E (map_pmf\n         (\\<lambda>x.\n             \\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1)\n         D))\n    \\<le> real (k + 1) +\n          (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n)))", "using paid_absch free_absch"], ["proof (prove)\nusing this:\n  E (map_pmf\n      (\\<lambda>x.\n          \\<Sum>i<length (paid_A ! n).\n             if fst (snd x) ! gebub n i then 2 else 1)\n      D) =\n  3 / 2 * real (length (paid_A ! n))\n  E (map_pmf\n      (\\<lambda>x.\n          if q \\<in> set init\n          then if fst (snd x) ! index init q then real (k - k')\n               else \\<Sum>j<k'.\n                       if fst (snd x) ! index init (xs' ! j) then 2 else 1\n          else 0)\n      D)\n  \\<le> 3 / 4 * real k\n\ngoal (1 subgoal):\n 1. E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n    (E (map_pmf\n         (\\<lambda>x.\n             if q \\<in> set init\n             then if fst (snd x) ! index init q then real (k - k')\n                  else \\<Sum>j<k'.\n                          if fst (snd x) ! index init (xs' ! j) then 2\n                          else 1\n             else 0)\n         D) +\n     E (map_pmf\n         (\\<lambda>x.\n             \\<Sum>i<length (paid_A ! n).\n                if fst (snd x) ! gebub n i then 2 else 1)\n         D))\n    \\<le> real (k + 1) +\n          (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n)))", "by auto"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n  (E (map_pmf\n       (\\<lambda>x.\n           if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0)\n       D) +\n   E (map_pmf\n       (\\<lambda>x.\n           \\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)\n       D))\n  \\<le> real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n)))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  E (map_pmf (\\<lambda>x. real (k + 1)) D) +\n  (E (map_pmf\n       (\\<lambda>x.\n           if q \\<in> set init\n           then if fst (snd x) ! index init q then real (k - k')\n                else \\<Sum>j<k'.\n                        if fst (snd x) ! index init (xs' ! j) then 2 else 1\n           else 0)\n       D) +\n   E (map_pmf\n       (\\<lambda>x.\n           \\<Sum>i<length (paid_A ! n).\n              if fst (snd x) ! gebub n i then 2 else 1)\n       D))\n  \\<le> real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n)))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> = k + (3/4 * (real k)) + 1  + 3/2 *(length (paid_A!n)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n))) =\n    real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n))", "by auto"], ["proof (state)\nthis:\n  real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n))) =\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* arithmetic! *)"], ["proof (state)\nthis:\n  real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n))) =\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  real (k + 1) + (3 / 4 * real k + 3 / 2 * real (length (paid_A ! n))) =\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> = (1+3/4) * (real k) + 1  + 3/2 *(length (paid_A!n)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n    (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n))", "by auto"], ["proof (state)\nthis:\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* arithmetic! *)"], ["proof (state)\nthis:\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  real k + 3 / 4 * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n))\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E4: \"\\<dots> = 7/4*(real k) + 3/2 *(length (paid_A!n)) + 1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n    7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1", "by auto"], ["proof (state)\nthis:\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* arithmetic! *)"], ["proof (state)\nthis:\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  (1 + 3 / 4) * real k + 1 + 3 / 2 * real (length (paid_A ! n)) =\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> \\<le> 7/4*(real k) + 7/4 *(length (paid_A!n)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n    \\<le> 7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1", "by auto"], ["proof (state)\nthis:\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n  \\<le> 7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "(* arithmetic! *)"], ["proof (state)\nthis:\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n  \\<le> 7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  7 / 4 * real k + 3 / 2 * real (length (paid_A ! n)) + 1\n  \\<le> 7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E5:\"\\<dots> = 7/4*(k+(length (paid_A!n))) + 1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1 =\n    7 / 4 * real (k + length (paid_A ! n)) + 1", "by auto"], ["proof (state)\nthis:\n  7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1 =\n  7 / 4 * real (k + length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  7 / 4 * real k + 7 / 4 * real (length (paid_A ! n)) + 1 =\n  7 / 4 * real (k + length (paid_A ! n)) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E6:\"\\<dots> = 7/4*(t_A n - (1::real)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real (k + length (paid_A ! n)) + 1 =\n    7 / 4 * (real_of_int (t_A n) - 1) + 1", "using costA_absch"], ["proof (prove)\nusing this:\n  int (k + length (paid_A ! n) + 1) = t_A n\n\ngoal (1 subgoal):\n 1. 7 / 4 * real (k + length (paid_A ! n)) + 1 =\n    7 / 4 * (real_of_int (t_A n) - 1) + 1", "by auto"], ["proof (state)\nthis:\n  7 / 4 * real (k + length (paid_A ! n)) + 1 =\n  7 / 4 * (real_of_int (t_A n) - 1) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  7 / 4 * real (k + length (paid_A ! n)) + 1 =\n  7 / 4 * (real_of_int (t_A n) - 1) + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have \"\\<dots> = 7/4*(t_A n) - 7/4 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * (real_of_int (t_A n) - 1) + 1 =\n    7 / 4 * real_of_int (t_A n) - 7 / 4 + 1", "by algebra"], ["proof (state)\nthis:\n  7 / 4 * (real_of_int (t_A n) - 1) + 1 =\n  7 / 4 * real_of_int (t_A n) - 7 / 4 + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "also"], ["proof (state)\nthis:\n  7 / 4 * (real_of_int (t_A n) - 1) + 1 =\n  7 / 4 * real_of_int (t_A n) - 7 / 4 + 1\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "have E7: \"\\<dots> = 7/4*(t_A n)- 3/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real_of_int (t_A n) - 7 / 4 + 1 =\n    7 / 4 * real_of_int (t_A n) - 3 / 4", "by auto"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (t_A n) - 7 / 4 + 1 =\n  7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. 0 < length init \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "finally"], ["proof (chain)\npicking this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "show \"t_BIT n + Phi(n+1) - Phi n \\<le> (7 / 4) * t_A n - 3/4\""], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "."], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "then"], ["proof (chain)\npicking this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "show \"t_BIT n + Phi(n + 1) - Phi n \\<le> (7 / 4) * t_A n - 3/4\""], ["proof (prove)\nusing this:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal (1 subgoal):\n 1. t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n    \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4", "."], ["proof (state)\nthis:\n  t_BIT n + \\<Phi> (n + 1) - \\<Phi> n\n  \\<le> 7 / 4 * real_of_int (t_A n) - 3 / 4\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Lift the Result to the Whole Request List\""], ["", "lemma T_BIT_absch_le: assumes nqs: \"n \\<le> length qs\"\n  shows \"T_BIT n \\<le> (7 / 4) * T_A n - 3/4*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT n \\<le> 7 / 4 * real_of_int (T_A n) - 3 / 4 * real n", "unfolding T_BIT_def T_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "from potential2[of \"Phi\", OF phi0 phi_pos myub] nqs"], ["proof (chain)\npicking this:\n  (\\<And>m. m < ?n \\<Longrightarrow> m < length qs) \\<Longrightarrow>\n  sum t_BIT {..<?n} \\<le> (\\<Sum>i<?n. 7 / 4 * real_of_int (t_A i) - 3 / 4)\n  n \\<le> length qs", "have\n      \"sum t_BIT {..<n} \\<le> (\\<Sum>i<n. 7 / 4 *   (t_A i) - 3 / 4)\""], ["proof (prove)\nusing this:\n  (\\<And>m. m < ?n \\<Longrightarrow> m < length qs) \\<Longrightarrow>\n  sum t_BIT {..<?n} \\<le> (\\<Sum>i<?n. 7 / 4 * real_of_int (t_A i) - 3 / 4)\n  n \\<le> length qs\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n} \\<le> (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4)", "by auto"], ["proof (state)\nthis:\n  sum t_BIT {..<n} \\<le> (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "also"], ["proof (state)\nthis:\n  sum t_BIT {..<n} \\<le> (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "have \"\\<dots> = (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. (3/4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4) =\n    (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4)", "by (rule sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i) - 3 / 4) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "have \"\\<dots> = (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (3/4)*(\\<Sum>i<n. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4) =\n    (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - (\\<Sum>i<n. 3 / 4) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1)\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "have \"\\<dots> = (\\<Sum>i<n. (7 / 4) * real_of_int (t_A i)) - (3/4)*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1) =\n    (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * (\\<Sum>i<n. 1) =\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "have \"\\<dots> =  (7 / 4) * (\\<Sum>i<n. real_of_int (t_A i))  - (3/4)*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n =\n    7 / 4 * (\\<Sum>i<n. real_of_int (t_A i)) - 3 / 4 * real n", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n =\n  7 / 4 * (\\<Sum>i<n. real_of_int (t_A i)) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 7 / 4 * real_of_int (t_A i)) - 3 / 4 * real n =\n  7 / 4 * (\\<Sum>i<n. real_of_int (t_A i)) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "have \"\\<dots> = (7 / 4) * real_of_int (\\<Sum>i<n.(t_A i))  - (3/4)*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * (\\<Sum>i<n. real_of_int (t_A i)) - 3 / 4 * real n =\n    7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "by auto"], ["proof (state)\nthis:\n  7 / 4 * (\\<Sum>i<n. real_of_int (t_A i)) - 3 / 4 * real n =\n  7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "finally"], ["proof (chain)\npicking this:\n  sum t_BIT {..<n}\n  \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "show \"sum t_BIT {..<n} \\<le> 7 / 4 * real_of_int (sum t_A {..<n})  - (3/4)*n\""], ["proof (prove)\nusing this:\n  sum t_BIT {..<n}\n  \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<n}\n    \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n", "by auto"], ["proof (state)\nthis:\n  sum t_BIT {..<n}\n  \\<le> 7 / 4 * real_of_int (sum t_A {..<n}) - 3 / 4 * real n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_BIT_absch: assumes nqs: \"n \\<le> length qs\"\n  shows \"T_BIT n \\<le> (7 / 4) * T_A' n - 3/4*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n", "using nqs T_BIT_absch_le[of n] T_A_A'_leq[of n]"], ["proof (prove)\nusing this:\n  n \\<le> length qs\n  n \\<le> length qs \\<Longrightarrow>\n  T_BIT n \\<le> 7 / 4 * real_of_int (T_A n) - 3 / 4 * real n\n  n \\<le> length paid_A' \\<Longrightarrow> T_A n \\<le> T_A' n\n\ngoal (1 subgoal):\n 1. T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n", "by auto"], ["", "lemma T_A_nneg: \"0 \\<le> T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_A n", "by(auto simp add: sum_nonneg T_A_def t_A_def c_A_def p_A_def)"], ["", "lemma T_BIT_eq: \"T_BIT (length qs) = T_on_rand BIT init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT (length qs) =\n    T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs", "unfolding T_BIT_def T_on_rand_as_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_BIT {..<length qs} =\n    sum (T_on_rand'_n BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs}", "using t_BIT_def"], ["proof (prove)\nusing this:\n  t_BIT ?n =\n  T_on_rand'_n BIT\n   (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs ?n\n\ngoal (1 subgoal):\n 1. sum t_BIT {..<length qs} =\n    sum (T_on_rand'_n BIT\n          (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs}", "by auto"], ["", "corollary T_BIT_competitive: assumes \"n \\<le> length qs\" and \"init \\<noteq> []\" and \"\\<forall>i<n. qs!i \\<in> set init\"\nshows \"T_BIT n \\<le> ((7 / 4) - 3/(4 * size init)) * T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "assume 0: \"real_of_int(T_A' n) \\<le> n * (size init)\""], ["proof (state)\nthis:\n  real_of_int (T_A' n) \\<le> real (n * length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "then"], ["proof (chain)\npicking this:\n  real_of_int (T_A' n) \\<le> real (n * length init)", "have 1: \"3/4*real_of_int(T_A' n) \\<le> 3/4*(n * (size init))\""], ["proof (prove)\nusing this:\n  real_of_int (T_A' n) \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. 3 / 4 * real_of_int (T_A' n) \\<le> 3 / 4 * real (n * length init)", "by auto"], ["proof (state)\nthis:\n  3 / 4 * real_of_int (T_A' n) \\<le> 3 / 4 * real (n * length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"T_BIT n \\<le> (7 / 4) * T_A' n - 3/4*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n", "using T_BIT_absch[OF assms(1)]"], ["proof (prove)\nusing this:\n  T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n\n\ngoal (1 subgoal):\n 1. T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n", "by auto"], ["proof (state)\nthis:\n  T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  T_BIT n \\<le> 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> = ((7 / 4) * real_of_int(T_A' n)) - (3/4*(n * size init)) / size init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n =\n    7 / 4 * real_of_int (T_A' n) -\n    3 / 4 * real (n * length init) / real (length init)", "using assms(2)"], ["proof (prove)\nusing this:\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. 7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n =\n    7 / 4 * real_of_int (T_A' n) -\n    3 / 4 * real (n * length init) / real (length init)", "by simp"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n =\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real (n * length init) / real (length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) - 3 / 4 * real n =\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real (n * length init) / real (length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> \\<le> ((7 / 4) * real_of_int(T_A' n)) - 3/4*T_A' n / size init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real_of_int (T_A' n) -\n    3 / 4 * real (n * length init) / real (length init)\n    \\<le> 7 / 4 * real_of_int (T_A' n) -\n          3 / 4 * real_of_int (T_A' n) / real (length init)", "by(rule diff_left_mono[OF  divide_right_mono[OF 1]]) simp"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real (n * length init) / real (length init)\n  \\<le> 7 / 4 * real_of_int (T_A' n) -\n        3 / 4 * real_of_int (T_A' n) / real (length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real (n * length init) / real (length init)\n  \\<le> 7 / 4 * real_of_int (T_A' n) -\n        3 / 4 * real_of_int (T_A' n) / real (length init)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> = ((7 / 4) - 3/4 / size init) * T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 / 4 * real_of_int (T_A' n) -\n    3 / 4 * real_of_int (T_A' n) / real (length init) =\n    (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)", "by algebra"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real_of_int (T_A' n) / real (length init) =\n  (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  7 / 4 * real_of_int (T_A' n) -\n  3 / 4 * real_of_int (T_A' n) / real (length init) =\n  (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> = ((7 / 4) - 3/(4 * size init)) * T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n) =\n    (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "by simp"], ["proof (state)\nthis:\n  (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n) =\n  (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n 2. \\<not> ?P \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "finally"], ["proof (chain)\npicking this:\n  T_BIT n \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "show ?thesis"], ["proof (prove)\nusing this:\n  T_BIT n \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "."], ["proof (state)\nthis:\n  T_BIT n \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "assume 0: \"\\<not> real_of_int(T_A' n) \\<le> n * (size init)\""], ["proof (state)\nthis:\n  \\<not> real_of_int (T_A' n) \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have T_A'_nneg: \"0 \\<le> T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_A' n", "using T_A_nneg[of n] T_A_A'_leq[of n] assms(1)"], ["proof (prove)\nusing this:\n  0 \\<le> T_A n\n  n \\<le> length paid_A' \\<Longrightarrow> T_A n \\<le> T_A' n\n  n \\<le> length qs\n\ngoal (1 subgoal):\n 1. 0 \\<le> T_A' n", "by auto"], ["proof (state)\nthis:\n  0 \\<le> T_A' n\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"2 - 1 / size init \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 2 - 1 / real (length init)", "using assms(2)"], ["proof (prove)\nusing this:\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> 2 - 1 / real (length init)", "by (auto simp add: field_simps neq_Nil_conv)"], ["proof (state)\nthis:\n  1 \\<le> 2 - 1 / real (length init)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \" T_BIT n  \\<le> n * size init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_BIT n \\<le> real (n * length init)", "using T_BIT_ub[OF assms(3)]"], ["proof (prove)\nusing this:\n  T_BIT n \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. T_BIT n \\<le> real (n * length init)", "by linarith"], ["proof (state)\nthis:\n  T_BIT n \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  T_BIT n \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> < real_of_int(T_A' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n * length init) < real_of_int (T_A' n)", "using 0"], ["proof (prove)\nusing this:\n  \\<not> real_of_int (T_A' n) \\<le> real (n * length init)\n\ngoal (1 subgoal):\n 1. real (n * length init) < real_of_int (T_A' n)", "by linarith"], ["proof (state)\nthis:\n  real (n * length init) < real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "also"], ["proof (state)\nthis:\n  real (n * length init) < real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "have \"\\<dots> \\<le> ((7 / 4) - 3/4 / size init) * T_A' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_A' n)\n    \\<le> (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)", "using assms(2) T_A'_nneg"], ["proof (prove)\nusing this:\n  init \\<noteq> []\n  0 \\<le> T_A' n\n\ngoal (1 subgoal):\n 1. real_of_int (T_A' n)\n    \\<le> (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)", "by(auto simp add: mult_le_cancel_right1 field_simps neq_Nil_conv)"], ["proof (state)\nthis:\n  real_of_int (T_A' n)\n  \\<le> (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A' n)\n           \\<le> real (n * length init) \\<Longrightarrow>\n    T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "finally"], ["proof (chain)\npicking this:\n  T_BIT n < (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)", "show ?thesis"], ["proof (prove)\nusing this:\n  T_BIT n < (7 / 4 - 3 / 4 / real (length init)) * real_of_int (T_A' n)\n\ngoal (1 subgoal):\n 1. T_BIT n\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)", "by simp"], ["proof (state)\nthis:\n  T_BIT n \\<le> (7 / 4 - 3 / real (4 * length init)) * real_of_int (T_A' n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_A'_t: \"n < length qs \\<Longrightarrow> t_A' n = int (t (s_A' n) (qs!n) (acts ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length qs \\<Longrightarrow>\n    t_A' n = int (t (s_A' n) (qs ! n) (acts ! n))", "by (simp add: t_A'_def t_def c_A'_def p_A'_def paid_A'_def len_acts split: prod.split)"], ["", "lemma T_A'_eq_lem: \"(\\<Sum>i=0..<length qs. t_A' i) =\n  T (s_A' 0) (drop 0 qs) (drop 0 acts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A' {0..<length qs} = int (T (s_A' 0) (drop 0 qs) (drop 0 acts))", "proof(induction rule: zero_induct[of _ \"size qs\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. sum t_A' {length qs..<length qs} =\n    int (T (s_A' (length qs)) (drop (length qs) qs) (drop (length qs) acts))\n 2. \\<And>n.\n       sum t_A' {Suc n..<length qs} =\n       int (T (s_A' (Suc n)) (drop (Suc n) qs)\n             (drop (Suc n) acts)) \\<Longrightarrow>\n       sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum t_A' {length qs..<length qs} =\n    int (T (s_A' (length qs)) (drop (length qs) qs) (drop (length qs) acts))\n 2. \\<And>n.\n       sum t_A' {Suc n..<length qs} =\n       int (T (s_A' (Suc n)) (drop (Suc n) qs)\n             (drop (Suc n) acts)) \\<Longrightarrow>\n       sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A' {length qs..<length qs} =\n    int (T (s_A' (length qs)) (drop (length qs) qs) (drop (length qs) acts))", "by (simp add: len_acts)"], ["proof (state)\nthis:\n  sum t_A' {length qs..<length qs} =\n  int (T (s_A' (length qs)) (drop (length qs) qs) (drop (length qs) acts))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A' {Suc n..<length qs} =\n       int (T (s_A' (Suc n)) (drop (Suc n) qs)\n             (drop (Suc n) acts)) \\<Longrightarrow>\n       sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A' {Suc n..<length qs} =\n       int (T (s_A' (Suc n)) (drop (Suc n) qs)\n             (drop (Suc n) acts)) \\<Longrightarrow>\n       sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "case (2 n)"], ["proof (state)\nthis:\n  sum t_A' {Suc n..<length qs} =\n  int (T (s_A' (Suc n)) (drop (Suc n) qs) (drop (Suc n) acts))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A' {Suc n..<length qs} =\n       int (T (s_A' (Suc n)) (drop (Suc n) qs)\n             (drop (Suc n) acts)) \\<Longrightarrow>\n       sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "assume \"n < length qs\""], ["proof (state)\nthis:\n  n < length qs\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "thus ?case"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "using 2"], ["proof (prove)\nusing this:\n  n < length qs\n  sum t_A' {Suc n..<length qs} =\n  int (T (s_A' (Suc n)) (drop (Suc n) qs) (drop (Suc n) acts))\n\ngoal (1 subgoal):\n 1. sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "by(simp add: Cons_nth_drop_Suc[symmetric,where i=n] len_acts sum.atLeast_Suc_lessThan\n      t_A'_t free_A_def paid_A'_def)"], ["proof (state)\nthis:\n  sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))\n\ngoal (1 subgoal):\n 1. \\<not> n < length qs \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length qs \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "assume \"\\<not> n < length qs\""], ["proof (state)\nthis:\n  \\<not> n < length qs\n\ngoal (1 subgoal):\n 1. \\<not> n < length qs \\<Longrightarrow>\n    sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> n < length qs\n\ngoal (1 subgoal):\n 1. sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))", "by (simp add: len_acts)"], ["proof (state)\nthis:\n  sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum t_A' {n..<length qs} = int (T (s_A' n) (drop n qs) (drop n acts))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_A'_eq: \"T_A' (length qs) = T init qs acts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_A' (length qs) = int (T init qs acts)", "using T_A'_eq_lem"], ["proof (prove)\nusing this:\n  sum t_A' {0..<length qs} = int (T (s_A' 0) (drop 0 qs) (drop 0 acts))\n\ngoal (1 subgoal):\n 1. T_A' (length qs) = int (T init qs acts)", "by(simp add: T_A'_def atLeast0LessThan)"], ["", "corollary BIT_competitive3: \"init \\<noteq> [] \\<Longrightarrow> \\<forall>i<length qs. qs!i \\<in> set init \\<Longrightarrow>\n  T_BIT (length qs) \\<le> ( (7/4) - 3 / (4 * length init)) * T init qs acts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init \\<noteq> [];\n     \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n    \\<Longrightarrow> T_BIT (length qs)\n                      \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                            real (T init qs acts)", "using order.refl T_BIT_competitive[of \"length qs\"] T_A'_eq"], ["proof (prove)\nusing this:\n  ?a \\<le> ?a\n  \\<lbrakk>length qs \\<le> length qs; init \\<noteq> [];\n   \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n  \\<Longrightarrow> T_BIT (length qs)\n                    \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                          real_of_int (T_A' (length qs))\n  T_A' (length qs) = int (T init qs acts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>init \\<noteq> [];\n     \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n    \\<Longrightarrow> T_BIT (length qs)\n                      \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                            real (T init qs acts)", "by (simp add: of_int_of_nat_eq)"], ["", "corollary BIT_competitive2: \"init \\<noteq> [] \\<Longrightarrow> \\<forall>i<length qs. qs!i \\<in> set init \\<Longrightarrow>\n  T_on_rand BIT init qs \\<le> ( (7/4) - 3 / (4 * length init)) * T init qs acts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init \\<noteq> [];\n     \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n    \\<Longrightarrow> T_on_rand' BIT\n                       (fst BIT init \\<bind>\n                        (\\<lambda>is. return_pmf (init, is)))\n                       qs\n                      \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                            real (T init qs acts)", "using BIT_competitive3 T_BIT_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>init \\<noteq> [];\n   \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n  \\<Longrightarrow> T_BIT (length qs)\n                    \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                          real (T init qs acts)\n  T_BIT (length qs) =\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>init \\<noteq> [];\n     \\<forall>i<length qs. qs ! i \\<in> set init\\<rbrakk>\n    \\<Longrightarrow> T_on_rand' BIT\n                       (fst BIT init \\<bind>\n                        (\\<lambda>is. return_pmf (init, is)))\n                       qs\n                      \\<le> (7 / 4 - 3 / real (4 * length init)) *\n                            real (T init qs acts)", "by auto"], ["", "corollary BIT_absch_le: \"init \\<noteq> [] \\<Longrightarrow>\n  T_on_rand BIT init qs \\<le> (7 / 4) * (T init qs acts) - 3/4 * length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<noteq> [] \\<Longrightarrow>\n    T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T init qs acts) - 3 / 4 * real (length qs)", "using T_BIT_absch[of \"length qs\", unfolded T_A'_eq T_BIT_eq]"], ["proof (prove)\nusing this:\n  length qs \\<le> length qs \\<Longrightarrow>\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> 7 / 4 * real_of_int (int (T init qs acts)) -\n        3 / 4 * real (length qs)\n\ngoal (1 subgoal):\n 1. init \\<noteq> [] \\<Longrightarrow>\n    T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T init qs acts) - 3 / 4 * real (length qs)", "by auto"], ["", "end"], ["", "subsubsection \"Generalize Competitivness of BIT\""], ["", "lemma setdi: \"set xs = {0..<length xs} \\<Longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = {0..<length xs} \\<Longrightarrow> distinct xs", "apply(rule card_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = {0..<length xs} \\<Longrightarrow> card (set xs) = length xs", "by auto"], ["", "theorem compet_BIT: assumes \"init \\<noteq> []\" \"distinct init\" \"set qs \\<subseteq> set init\"  \nshows \"T_on_rand BIT init qs \\<le> ( (7/4) - 3 / (4 * length init)) * T_opt init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "from assms(3)"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init", "have 1: \"\\<forall>i < length qs. qs!i \\<in> set init\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<forall>i<length qs. qs ! i \\<in> set init", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length qs. qs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "{"], ["proof (state)\nthis:\n  \\<forall>i<length qs. qs ! i \\<in> set init\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "fix acts :: \"answer list\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "assume len: \"length acts = length qs\""], ["proof (state)\nthis:\n  length acts = length qs\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "interpret BIT_Off acts qs init"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_Off acts qs init", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct init\n 2. length acts = length qs", "qed (auto simp: assms(2) len)"], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "from BIT_competitive2[OF assms(1) 1] assms(1)"], ["proof (chain)\npicking this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T init qs acts)\n  init \\<noteq> []", "have \"T_on_rand BIT init qs / ( (7/4) - 3 / (4 * length init)) \\<le> real(T init qs acts)\""], ["proof (prove)\nusing this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T init qs acts)\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n    (7 / 4 - 3 / real (4 * length init))\n    \\<le> real (T init qs acts)", "by(simp add: field_simps length_greater_0_conv[symmetric]\n        del: length_greater_0_conv)"], ["proof (state)\nthis:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T init qs acts)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "}"], ["proof (state)\nthis:\n  length ?acts2 = length qs \\<Longrightarrow>\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T init qs ?acts2)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "hence \"T_on_rand BIT init qs / ( (7/4) - 3 / (4 * length init)) \\<le> T_opt init qs\""], ["proof (prove)\nusing this:\n  length ?acts2 = length qs \\<Longrightarrow>\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T init qs ?acts2)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n    (7 / 4 - 3 / real (4 * length init))\n    \\<le> real (T_opt init qs)", "apply(simp add: T_opt_def Inf_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n        (7 / 4 - 3 / (4 * real (length init)))\n        \\<le> real (T init qs acts)) \\<Longrightarrow>\n    T_on_rand' BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n    (7 / 4 - 3 / (4 * real (length init)))\n    \\<le> real\n           (LEAST n.\n               \\<exists>as. n = T init qs as \\<and> length as = length qs)", "apply(rule LeastI2_wellorder)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n        (7 / 4 - 3 / (4 * real (length init)))\n        \\<le> real (T init qs acts)) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T init qs as \\<and> length as = length qs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs /\n                   (7 / 4 - 3 / (4 * real (length init)))\n                   \\<le> real (T init qs acts);\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs /\n                         (7 / 4 - 3 / (4 * real (length init)))\n                         \\<le> real a", "using length_replicate[of \"length qs\" undefined]"], ["proof (prove)\nusing this:\n  length (replicate (length qs) undefined) = length qs\n\ngoal (2 subgoals):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs /\n        (7 / 4 - 3 / (4 * real (length init)))\n        \\<le> real (T init qs acts)) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T init qs as \\<and> length as = length qs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs /\n                   (7 / 4 - 3 / (4 * real (length init)))\n                   \\<le> real (T init qs acts);\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs /\n                         (7 / 4 - 3 / (4 * real (length init)))\n                         \\<le> real a", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs /\n                   (7 / 4 - 3 / (4 * real (length init)))\n                   \\<le> real (T init qs acts);\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs /\n                         (7 / 4 - 3 / (4 * real (length init)))\n                         \\<le> real a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "using assms"], ["proof (prove)\nusing this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs /\n  (7 / 4 - 3 / real (4 * length init))\n  \\<le> real (T_opt init qs)\n  init \\<noteq> []\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)", "by(simp add: field_simps\n    length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (state)\nthis:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> (7 / 4 - 3 / real (4 * length init)) * real (T_opt init qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compet_BIT4: assumes \"init \\<noteq> []\" \"distinct init\"   \nshows \"T_on_rand BIT init qs \\<le> 7/4 * T_opt init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "fix acts :: \"answer list\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "assume len: \"length acts = length qs\""], ["proof (state)\nthis:\n  length acts = length qs\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "interpret BIT_Off acts qs init"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_Off acts qs init", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct init\n 2. length acts = length qs", "qed (auto simp: assms(2) len)"], ["proof (state)\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "from BIT_absch_le[OF assms(1)] assms(1)"], ["proof (chain)\npicking this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> 7 / 4 * real (T init qs acts) - 3 / 4 * real (length qs)\n  init \\<noteq> []", "have \"(T_on_rand BIT init qs + 3 / 4 * length qs)/ (7/4) \\<le> real(T init qs acts)\""], ["proof (prove)\nusing this:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> 7 / 4 * real (T init qs acts) - 3 / 4 * real (length qs)\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. (T_on_rand' BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n     3 / 4 * real (length qs)) /\n    (7 / 4)\n    \\<le> real (T init qs acts)", "by(simp add: field_simps length_greater_0_conv[symmetric]\n        del: length_greater_0_conv)"], ["proof (state)\nthis:\n  (T_on_rand' BIT\n    (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n   3 / 4 * real (length qs)) /\n  (7 / 4)\n  \\<le> real (T init qs acts)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "}"], ["proof (state)\nthis:\n  length ?acts2 = length qs \\<Longrightarrow>\n  (T_on_rand' BIT\n    (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n   3 / 4 * real (length qs)) /\n  (7 / 4)\n  \\<le> real (T init qs ?acts2)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "hence \"(T_on_rand BIT init qs + 3 / 4 * length qs)/ (7/4) \\<le> T_opt init qs\""], ["proof (prove)\nusing this:\n  length ?acts2 = length qs \\<Longrightarrow>\n  (T_on_rand' BIT\n    (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n   3 / 4 * real (length qs)) /\n  (7 / 4)\n  \\<le> real (T init qs ?acts2)\n\ngoal (1 subgoal):\n 1. (T_on_rand' BIT\n      (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n     3 / 4 * real (length qs)) /\n    (7 / 4)\n    \\<le> real (T_opt init qs)", "apply(simp add: T_opt_def Inf_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs *\n        4 +\n        3 * real (length qs)\n        \\<le> real (T init qs acts) * 7) \\<Longrightarrow>\n    T_on_rand' BIT\n     (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs *\n    4 +\n    3 * real (length qs)\n    \\<le> real\n           (LEAST n.\n               \\<exists>as. n = T init qs as \\<and> length as = length qs) *\n          7", "apply(rule LeastI2_wellorder)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs *\n        4 +\n        3 * real (length qs)\n        \\<le> real (T init qs acts) * 7) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T init qs as \\<and> length as = length qs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs *\n                   4 +\n                   3 * real (length qs)\n                   \\<le> real (T init qs acts) * 7;\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs *\n                         4 +\n                         3 * real (length qs)\n                         \\<le> real a * 7", "using length_replicate[of \"length qs\" undefined]"], ["proof (prove)\nusing this:\n  length (replicate (length qs) undefined) = length qs\n\ngoal (2 subgoals):\n 1. (\\<And>acts.\n        length acts = length qs \\<Longrightarrow>\n        T_on_rand' BIT\n         (BIT_init init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs *\n        4 +\n        3 * real (length qs)\n        \\<le> real (T init qs acts) * 7) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T init qs as \\<and> length as = length qs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs *\n                   4 +\n                   3 * real (length qs)\n                   \\<le> real (T init qs acts) * 7;\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs *\n                         4 +\n                         3 * real (length qs)\n                         \\<le> real a * 7", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>acts.\n                   length acts = length qs \\<Longrightarrow>\n                   T_on_rand' BIT\n                    (BIT_init init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    qs *\n                   4 +\n                   3 * real (length qs)\n                   \\<le> real (T init qs acts) * 7;\n        \\<exists>as. a = T init qs as \\<and> length as = length qs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T init qs as \\<and>\n               length as = length qs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> T_on_rand' BIT\n                          (BIT_init init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          qs *\n                         4 +\n                         3 * real (length qs)\n                         \\<le> real a * 7", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (T_on_rand' BIT\n    (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n   3 / 4 * real (length qs)) /\n  (7 / 4)\n  \\<le> real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (T_on_rand' BIT\n    (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs +\n   3 / 4 * real (length qs)) /\n  (7 / 4)\n  \\<le> real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "by(simp add: field_simps\n    length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (state)\nthis:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> 7 / 4 * real (T_opt init qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compet_BIT_2:\n \"compet_rand BIT (7/4) {init. init \\<noteq> [] \\<and> distinct init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compet_rand BIT (7 / 4) {init. init \\<noteq> [] \\<and> distinct init}", "unfolding compet_rand_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{init. init \\<noteq> [] \\<and> distinct init}.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "fix init"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "assume \"init \\<in> {init. init \\<noteq> [] \\<and> distinct init }\""], ["proof (state)\nthis:\n  init \\<in> {init. init \\<noteq> [] \\<and> distinct init}\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "then"], ["proof (chain)\npicking this:\n  init \\<in> {init. init \\<noteq> [] \\<and> distinct init}", "have ne: \"init \\<noteq> []\" and  a: \"distinct init\""], ["proof (prove)\nusing this:\n  init \\<in> {init. init \\<noteq> [] \\<and> distinct init}\n\ngoal (1 subgoal):\n 1. init \\<noteq> [] &&& distinct init", "by auto"], ["proof (state)\nthis:\n  init \\<noteq> []\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "{"], ["proof (state)\nthis:\n  init \\<noteq> []\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "fix qs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "assume \"init \\<noteq> []\" and a: \"distinct init\""], ["proof (state)\nthis:\n  init \\<noteq> []\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "then"], ["proof (chain)\npicking this:\n  init \\<noteq> []\n  distinct init", "have \"T_on_rand BIT init qs \\<le> 7/4 * T_opt init qs\""], ["proof (prove)\nusing this:\n  init \\<noteq> []\n  distinct init\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "using compet_BIT4[of init qs]"], ["proof (prove)\nusing this:\n  init \\<noteq> []\n  distinct init\n  \\<lbrakk>init \\<noteq> []; distinct init\\<rbrakk>\n  \\<Longrightarrow> T_on_rand' BIT\n                     (fst BIT init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     qs\n                    \\<le> 7 / 4 * real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. T_on_rand' BIT\n     (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> 7 / 4 * real (T_opt init qs)", "by simp"], ["proof (state)\nthis:\n  T_on_rand' BIT (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n   qs\n  \\<le> 7 / 4 * real (T_opt init qs)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "}"], ["proof (state)\nthis:\n  \\<lbrakk>init \\<noteq> []; distinct init\\<rbrakk>\n  \\<Longrightarrow> T_on_rand' BIT\n                     (fst BIT init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     ?qs2\n                    \\<le> 7 / 4 * real (T_opt init ?qs2)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> {init.\n                init \\<noteq> [] \\<and> distinct init} \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             T_on_rand' BIT\n              (fst BIT s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> 7 / 4 * real (T_opt s rs) + b", "with a ne"], ["proof (chain)\npicking this:\n  distinct init\n  init \\<noteq> []\n  \\<lbrakk>init \\<noteq> []; distinct init\\<rbrakk>\n  \\<Longrightarrow> T_on_rand' BIT\n                     (fst BIT init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     ?qs2\n                    \\<le> 7 / 4 * real (T_opt init ?qs2)", "show \"\\<exists>b\\<ge>0. \\<forall>qs. static init qs \\<longrightarrow> T_on_rand BIT init qs  \\<le>  (7 / 4) * (T_opt init qs) + b\""], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n  \\<lbrakk>init \\<noteq> []; distinct init\\<rbrakk>\n  \\<Longrightarrow> T_on_rand' BIT\n                     (fst BIT init \\<bind>\n                      (\\<lambda>is. return_pmf (init, is)))\n                     ?qs2\n                    \\<le> 7 / 4 * real (T_opt init ?qs2)\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs.\n          static init qs \\<longrightarrow>\n          T_on_rand' BIT\n           (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n          \\<le> 7 / 4 * real (T_opt init qs) + b", "by auto"], ["proof (state)\nthis:\n  \\<exists>b\\<ge>0.\n     \\<forall>qs.\n        static init qs \\<longrightarrow>\n        T_on_rand' BIT\n         (fst BIT init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n        \\<le> 7 / 4 * real (T_opt init qs) + b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}