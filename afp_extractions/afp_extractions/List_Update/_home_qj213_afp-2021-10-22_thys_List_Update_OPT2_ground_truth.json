{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/OPT2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma \"(N::nat set) \\<noteq> {} \\<Longrightarrow> Inf N : N\"", "lemma nn_contains_Inf:\n  fixes S :: \"nat set\"\n  assumes nn: \"S \\<noteq> {}\"\n  shows \"Inf S \\<in> S\"", "lemma OPT2_length: \"length (OPT2 \\<sigma> [x, y]) = length \\<sigma>\"", "lemma OPT2x: \"OPT2 (x#\\<sigma>') [x,y] = (0,[])#(OPT2 \\<sigma>' [x,y])\"", "lemma swapOpt: \"T\\<^sub>p_opt [x,y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y,x] \\<sigma>\"", "lemma tt: \"a \\<in> {x,y} \\<Longrightarrow> OPT2 (rest1) (step [x,y] a (hd (OPT2 (a # rest1) [x, y])))\n       = tl (OPT2 (a # rest1) [x, y])\"", "lemma splitqsallg: \"Strat \\<noteq> [] \\<Longrightarrow> a \\<in> {x,y} \\<Longrightarrow>\n         t\\<^sub>p [x, y] a (hd (Strat)) +\n          (let L=step [x,y] a (hd (Strat)) \n              in T\\<^sub>p L (rest1) (tl Strat)) =  T\\<^sub>p [x, y] (a # rest1) Strat\"", "lemma splitqs: \"a \\<in> {x,y} \\<Longrightarrow> T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y])\n        =  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n          (let L=step [x,y] a (hd (OPT2 (a # rest1) [x, y])) \n              in T\\<^sub>p L (rest1) (OPT2 (rest1) L))\"", "lemma tpx: \"t\\<^sub>p [x, y] x (hd (OPT2 (x # rest1) [x, y])) = 0\"", "lemma yup: \"T\\<^sub>p [x, y] (x # rest1) (OPT2 (x # rest1) [x, y])\n        = (let L=step [x,y] x (hd (OPT2 (x # rest1) [x, y])) \n              in T\\<^sub>p L (rest1) (OPT2 (rest1) L))\"", "lemma swapsxy: \"A \\<in> { [x,y], [y,x]} \\<Longrightarrow> swaps sws A \\<in> { [x,y], [y,x]}\"", "lemma mtf2xy: \"A \\<in> { [x,y], [y,x]} \\<Longrightarrow> r\\<in>{x,y} \\<Longrightarrow> mtf2 a r A \\<in> { [x,y], [y,x]}\"", "lemma stepxy: assumes \"q \\<in> {x,y}\" \"A \\<in> { [x,y], [y,x]}\" \n    shows \"step A q a \\<in> { [x,y], [y,x]}\"", "lemma OPT2_is_lb: \"set \\<sigma> \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y]) \\<le> T\\<^sub>p_opt [x,y] \\<sigma>\"", "lemma OPT2_is_ub: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \\<ge> T\\<^sub>p_opt [x,y] qs\"", "lemma OPT2_is_opt: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = T\\<^sub>p_opt [x,y] qs\"", "lemma OPT2_A: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = 1\"", "lemma OPT2_A': assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = 1\"", "lemma OPT2_B: assumes \"x \\<noteq> y\" \"qs=u@v\" \"u=[] \\<or> u=[x]\" \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v div 2)\"", "lemma OPT2_B1: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = length qs / 2\"", "lemma OPT2_B2: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = ((length qs - 1) / 2)\"", "lemma OPT2_C: assumes \"x \\<noteq> y\" \"qs=u@v\" \"u=[] \\<or> u=[x]\" \n  and \"v \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v div 2)\"", "lemma OPT2_C1: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = (length qs - 1) / 2\"", "lemma OPT2_C2: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = ((length qs - 2) / 2)\"", "lemma OPT2_ub: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \\<le> length qs\"", "lemma OPT2_padded: \"R\\<in>{[x,y],[y,x]} \\<Longrightarrow> set qs \\<subseteq> {x,y} \n      \\<Longrightarrow>  T\\<^sub>p R (qs@[x,x]) (OPT2 (qs@[x,x]) R)\n              \\<le> T\\<^sub>p R (qs@[x]) (OPT2 (qs@[x]) R) + 1\"", "lemma  OPT2_split11:\n  assumes xy: \"x\\<noteq>y\"\n  shows \"R\\<in>{[x,y],[y,x]} \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow> OPT2 (xs@[x,x]@ys) R = OPT2 (xs@[x,x]) R @ OPT2 ys [x,y]\"", "lemma steps_append: \"length qs = length as \\<Longrightarrow> steps s (qs@[q]) (as@[a]) = step (steps s qs as) q a\""], "translations": [["", "lemma \"(N::nat set) \\<noteq> {} \\<Longrightarrow> Inf N : N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> {} \\<Longrightarrow> \\<Sqinter> N \\<in> N", "unfolding Inf_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> {} \\<Longrightarrow> (LEAST n. n \\<in> N) \\<in> N", "using LeastI[of \"%x. x : N\"]"], ["proof (prove)\nusing this:\n  ?k \\<in> N \\<Longrightarrow> (LEAST x. x \\<in> N) \\<in> N\n\ngoal (1 subgoal):\n 1. N \\<noteq> {} \\<Longrightarrow> (LEAST n. n \\<in> N) \\<in> N", "by force"], ["", "lemma nn_contains_Inf:\n  fixes S :: \"nat set\"\n  assumes nn: \"S \\<noteq> {}\"\n  shows \"Inf S \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> S \\<in> S", "using assms Inf_nat_def LeastI"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n  \\<Sqinter> ?X = (LEAST n. n \\<in> ?X)\n  ?P ?k \\<Longrightarrow> ?P (LEAST x. ?P x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> S \\<in> S", "by force"], ["", "subsection \"Definition\""], ["", "fun OPT2 :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> (nat * nat list) list\" where\n  \"OPT2 [] [x,y] = []\"\n| \"OPT2 [a] [x,y] = [(0,[])]\"\n| \"OPT2 (a#b#\\<sigma>') [x,y] =  (if a=x then (0,[]) # (OPT2 (b#\\<sigma>') [x,y])\n                                  else (if b=x then (0,[])# (OPT2 (b#\\<sigma>') [x,y])\n                                               else (1,[])# (OPT2 (b#\\<sigma>') [y,x])))\""], ["", "lemma OPT2_length: \"length (OPT2 \\<sigma> [x, y]) = length \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (OPT2 \\<sigma> [x, y]) = length \\<sigma>", "apply(induct \\<sigma> arbitrary: x y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. length (OPT2 [] [x, y]) = length []\n 2. \\<And>a \\<sigma> x y.\n       (\\<And>x y.\n           length (OPT2 \\<sigma> [x, y]) =\n           length \\<sigma>) \\<Longrightarrow>\n       length (OPT2 (a # \\<sigma>) [x, y]) = length (a # \\<sigma>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a \\<sigma> x y.\n       (\\<And>x y.\n           length (OPT2 \\<sigma> [x, y]) =\n           length \\<sigma>) \\<Longrightarrow>\n       length (OPT2 (a # \\<sigma>) [x, y]) = length (a # \\<sigma>)", "apply(case_tac \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a \\<sigma> x y.\n       \\<lbrakk>\\<And>x y. length (OPT2 \\<sigma> [x, y]) = length \\<sigma>;\n        \\<sigma> = []\\<rbrakk>\n       \\<Longrightarrow> length (OPT2 (a # \\<sigma>) [x, y]) =\n                         length (a # \\<sigma>)\n 2. \\<And>a \\<sigma> x y aa list.\n       \\<lbrakk>\\<And>x y. length (OPT2 \\<sigma> [x, y]) = length \\<sigma>;\n        \\<sigma> = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (OPT2 (a # \\<sigma>) [x, y]) =\n                         length (a # \\<sigma>)", "by(auto)"], ["", "lemma OPT2x: \"OPT2 (x#\\<sigma>') [x,y] = (0,[])#(OPT2 \\<sigma>' [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OPT2 (x # \\<sigma>') [x, y] = (0, []) # OPT2 \\<sigma>' [x, y]", "apply(cases \\<sigma>')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<sigma>' = [] \\<Longrightarrow>\n    OPT2 (x # \\<sigma>') [x, y] = (0, []) # OPT2 \\<sigma>' [x, y]\n 2. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       OPT2 (x # \\<sigma>') [x, y] = (0, []) # OPT2 \\<sigma>' [x, y]", "by (simp_all)"], ["", "lemma swapOpt: \"T\\<^sub>p_opt [x,y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y,x] \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "proof (cases \"length \\<sigma> > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "case True"], ["proof (state)\nthis:\n  0 < length \\<sigma>\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have \"T\\<^sub>p_opt [y,x] \\<sigma> \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [y, x] \\<sigma>\n    \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [y, x] \\<sigma> as |as.\n                length as = length \\<sigma>}\n    \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}", "apply(rule nn_contains_Inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>} \\<noteq>\n    {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. length as = length \\<sigma>", "by (rule Ex_list_of_length)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [y, x] \\<sigma>\n  \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt [y, x] \\<sigma>\n  \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}", "obtain asyx where costyx: \"T\\<^sub>p [y,x] \\<sigma> asyx = T\\<^sub>p_opt [y,x] \\<sigma>\"\n                       and lenyx: \"length asyx = length \\<sigma>\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [y, x] \\<sigma>\n  \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>asyx.\n        \\<lbrakk>T\\<^sub>p [y, x] \\<sigma> asyx =\n                 T\\<^sub>p_opt [y, x] \\<sigma>;\n         length asyx = length \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding T_opt_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}\n  \\<in> {T\\<^sub>p [y, x] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>asyx.\n        \\<lbrakk>T\\<^sub>p [y, x] \\<sigma> asyx =\n                 \\<Sqinter> {T\\<^sub>p [y, x] \\<sigma> as |as.\n                             length as = length \\<sigma>};\n         length asyx = length \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [y, x] \\<sigma> asyx = T\\<^sub>p_opt [y, x] \\<sigma>\n  length asyx = length \\<sigma>\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "from True lenyx"], ["proof (chain)\npicking this:\n  0 < length \\<sigma>\n  length asyx = length \\<sigma>", "have \"length asyx > 0\""], ["proof (prove)\nusing this:\n  0 < length \\<sigma>\n  length asyx = length \\<sigma>\n\ngoal (1 subgoal):\n 1. 0 < length asyx", "by auto"], ["proof (state)\nthis:\n  0 < length asyx\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  0 < length asyx", "obtain A asyx' where aa: \"asyx = A # asyx'\""], ["proof (prove)\nusing this:\n  0 < length asyx\n\ngoal (1 subgoal):\n 1. (\\<And>A asyx'.\n        asyx = A # asyx' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust"], ["proof (prove)\nusing this:\n  0 < length asyx\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>A asyx'.\n        asyx = A # asyx' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asyx = A # asyx'\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  asyx = A # asyx'", "obtain m1 a1 where AA: \"A = (m1,a1)\""], ["proof (prove)\nusing this:\n  asyx = A # asyx'\n\ngoal (1 subgoal):\n 1. (\\<And>m1 a1. A = (m1, a1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  A = (m1, a1)\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "let ?asxy = \"(m1,a1@[0]) # asyx'\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "from True"], ["proof (chain)\npicking this:\n  0 < length \\<sigma>", "obtain q \\<sigma>' where qq: \"\\<sigma> = q # \\<sigma>'\""], ["proof (prove)\nusing this:\n  0 < length \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>q \\<sigma>'.\n        \\<sigma> = q # \\<sigma>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust"], ["proof (prove)\nusing this:\n  0 < length \\<sigma>\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q \\<sigma>'.\n        \\<sigma> = q # \\<sigma>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> = q # \\<sigma>'\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have t: \"t\\<^sub>p [x, y] q (m1, a1@[0]) = Suc (t\\<^sub>p [y, x] q (m1, a1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] q (m1, a1 @ [0]) = Suc (t\\<^sub>p [y, x] q (m1, a1))", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (mf, sws) = (m1, a1 @ [0])\n     in index (swaps sws [x, y]) q + length sws) =\n    Suc (let (mf, sws) = (m1, a1)\n         in index (swaps sws [y, x]) q + length sws)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps a1 (swap 0 [x, y])) q = index (swaps a1 [y, x]) q", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     (foldr\n       (\\<lambda>n xs.\n           if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n]\n           else xs)\n       a1 (if Suc 0 < length [x, y]\n           then [x, y][0 := [x, y] ! Suc 0, Suc 0 := [x, y] ! 0]\n           else [x, y]))\n     q =\n    index\n     (foldr\n       (\\<lambda>n xs.\n           if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n]\n           else xs)\n       a1 [y, x])\n     q", "by (simp)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] q (m1, a1 @ [0]) = Suc (t\\<^sub>p [y, x] q (m1, a1))\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have s: \"step [x, y] q (m1, a1 @ [0]) = step [y, x] q (m1, a1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] q (m1, a1 @ [0]) = step [y, x] q (m1, a1)", "unfolding step_def mtf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) = (m1, a1 @ [0])\n     in if q \\<in> set (swaps sws [x, y])\n        then swaps\n              [index (swaps sws [x, y]) q - k..<index (swaps sws [x, y]) q]\n              (swaps sws [x, y])\n        else swaps sws [x, y]) =\n    (let (k, sws) = (m1, a1)\n     in if q \\<in> set (swaps sws [y, x])\n        then swaps\n              [index (swaps sws [y, x]) q - k..<index (swaps sws [y, x]) q]\n              (swaps sws [y, x])\n        else swaps sws [y, x])", "by(simp add: swap_def)"], ["proof (state)\nthis:\n  step [x, y] q (m1, a1 @ [0]) = step [y, x] q (m1, a1)\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have T: \"T\\<^sub>p [x,y] \\<sigma> ?asxy = 1 + T\\<^sub>p [y,x] \\<sigma> asyx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx') =\n    1 + T\\<^sub>p [y, x] \\<sigma> asyx", "unfolding qq aa AA"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # \\<sigma>') ((m1, a1 @ [0]) # asyx') =\n    1 + T\\<^sub>p [y, x] (q # \\<sigma>') ((m1, a1) # asyx')", "by(auto simp add: s t)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx') =\n  1 + T\\<^sub>p [y, x] \\<sigma> asyx\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have l: \"1 + T\\<^sub>p_opt [y,x] \\<sigma> = T\\<^sub>p [x, y] \\<sigma> ?asxy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] \\<sigma> =\n    T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')", "using T costyx"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx') =\n  1 + T\\<^sub>p [y, x] \\<sigma> asyx\n  T\\<^sub>p [y, x] \\<sigma> asyx = T\\<^sub>p_opt [y, x] \\<sigma>\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] \\<sigma> =\n    T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')", "by simp"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] \\<sigma> =\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "have \"length ?asxy = length \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((m1, a1 @ [0]) # asyx') = length \\<sigma>", "using lenyx aa"], ["proof (prove)\nusing this:\n  length asyx = length \\<sigma>\n  asyx = A # asyx'\n\ngoal (1 subgoal):\n 1. length ((m1, a1 @ [0]) # asyx') = length \\<sigma>", "by auto"], ["proof (state)\nthis:\n  length ((m1, a1 @ [0]) # asyx') = length \\<sigma>\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  length ((m1, a1 @ [0]) # asyx') = length \\<sigma>", "have inside: \"?asxy \\<in> {as. size as = size \\<sigma>}\""], ["proof (prove)\nusing this:\n  length ((m1, a1 @ [0]) # asyx') = length \\<sigma>\n\ngoal (1 subgoal):\n 1. (m1, a1 @ [0]) # asyx' \\<in> {as. length as = length \\<sigma>}", "by force"], ["proof (state)\nthis:\n  (m1, a1 @ [0]) # asyx' \\<in> {as. length as = length \\<sigma>}\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  (m1, a1 @ [0]) # asyx' \\<in> {as. length as = length \\<sigma>}", "have b: \"T\\<^sub>p [x, y] \\<sigma> ?asxy \\<in> {T\\<^sub>p [x, y] \\<sigma> as | as. size as = size \\<sigma>}\""], ["proof (prove)\nusing this:\n  (m1, a1 @ [0]) # asyx' \\<in> {as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n    \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n  \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (2 subgoals):\n 1. 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n 2. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n  \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n  \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "unfolding l"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n  \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>\n    \\<le> T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')", "unfolding T_opt_def"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')\n  \\<in> {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [x, y] \\<sigma> as |as.\n                length as = length \\<sigma>}\n    \\<le> T\\<^sub>p [x, y] \\<sigma> ((m1, a1 @ [0]) # asyx')", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_below\n     {T\\<^sub>p [x, y] \\<sigma> as |as. length as = length \\<sigma>}", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> 0 < length \\<sigma> \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>", "qed (simp add: T_opt_def)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma> \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tt: \"a \\<in> {x,y} \\<Longrightarrow> OPT2 (rest1) (step [x,y] a (hd (OPT2 (a # rest1) [x, y])))\n       = tl (OPT2 (a # rest1) [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))) =\n    tl (OPT2 (a # rest1) [x, y])", "apply(cases rest1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> {x, y}; rest1 = []\\<rbrakk>\n    \\<Longrightarrow> OPT2 rest1\n                       (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))) =\n                      tl (OPT2 (a # rest1) [x, y])\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> {x, y}; rest1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 rest1\n                          (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))) =\n                         tl (OPT2 (a # rest1) [x, y])", "by(auto simp add: step_def mtf2_def swap_def)"], ["", "lemma splitqsallg: \"Strat \\<noteq> [] \\<Longrightarrow> a \\<in> {x,y} \\<Longrightarrow>\n         t\\<^sub>p [x, y] a (hd (Strat)) +\n          (let L=step [x,y] a (hd (Strat)) \n              in T\\<^sub>p L (rest1) (tl Strat)) =  T\\<^sub>p [x, y] (a # rest1) Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "assume ne: \"Strat \\<noteq> []\""], ["proof (state)\nthis:\n  Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "assume axy: \"a \\<in> {x,y}\""], ["proof (state)\nthis:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "(* not needed *)"], ["proof (state)\nthis:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "have \"T\\<^sub>p [x, y] (a # rest1) (Strat) \n        = T\\<^sub>p [x, y] (a # rest1) ((hd (Strat)) # (tl (Strat)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # rest1) Strat =\n    T\\<^sub>p [x, y] (a # rest1) (hd Strat # tl Strat)", "by(simp only: List.list.collapse[OF ne])"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1) Strat =\n  T\\<^sub>p [x, y] (a # rest1) (hd Strat # tl Strat)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Strat \\<noteq> []; a \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p [x, y] a (hd Strat) +\n                      (let L = step [x, y] a (hd Strat)\n                       in T\\<^sub>p L rest1 (tl Strat)) =\n                      T\\<^sub>p [x, y] (a # rest1) Strat", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (a # rest1) Strat =\n  T\\<^sub>p [x, y] (a # rest1) (hd Strat # tl Strat)", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (a # rest1) Strat =\n  T\\<^sub>p [x, y] (a # rest1) (hd Strat # tl Strat)\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] a (hd Strat) +\n    (let L = step [x, y] a (hd Strat) in T\\<^sub>p L rest1 (tl Strat)) =\n    T\\<^sub>p [x, y] (a # rest1) Strat", "by auto"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] a (hd Strat) +\n  (let L = step [x, y] a (hd Strat) in T\\<^sub>p L rest1 (tl Strat)) =\n  T\\<^sub>p [x, y] (a # rest1) Strat\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitqs: \"a \\<in> {x,y} \\<Longrightarrow> T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y])\n        =  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n          (let L=step [x,y] a (hd (OPT2 (a # rest1) [x, y])) \n              in T\\<^sub>p L (rest1) (OPT2 (rest1) L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "assume axy: \"a \\<in> {x,y}\""], ["proof (state)\nthis:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "have ne: \"OPT2 (a # rest1) [x, y] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OPT2 (a # rest1) [x, y] \\<noteq> []", "apply(cases rest1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rest1 = [] \\<Longrightarrow> OPT2 (a # rest1) [x, y] \\<noteq> []\n 2. \\<And>aa list.\n       rest1 = aa # list \\<Longrightarrow>\n       OPT2 (a # rest1) [x, y] \\<noteq> []", "by(simp_all)"], ["proof (state)\nthis:\n  OPT2 (a # rest1) [x, y] \\<noteq> []\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "have \"T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) \n        = T\\<^sub>p [x, y] (a # rest1) ((hd (OPT2 (a # rest1) [x, y])) # (tl (OPT2 (a # rest1) [x, y])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    T\\<^sub>p [x, y] (a # rest1)\n     (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y]))", "by(simp only: List.list.collapse[OF ne])"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y]))\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y]))\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "have \"\\<dots> = T\\<^sub>p [x, y] (a # rest1) ((hd (OPT2 (a # rest1) [x, y])) # (OPT2 (rest1) (step [x,y] a (hd (OPT2 (a # rest1) [x, y])))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # rest1)\n     (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y])) =\n    T\\<^sub>p [x, y] (a # rest1)\n     (hd (OPT2 (a # rest1) [x, y]) #\n      OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))))", "by(simp only: tt[OF axy])"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y])) =\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) #\n    OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))))\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) # tl (OPT2 (a # rest1) [x, y])) =\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) #\n    OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y]))))\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "have \"\\<dots> =   t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n          (let L=step [x,y] a (hd (OPT2 (a # rest1) [x, y])) \n              in T\\<^sub>p L (rest1) (OPT2 (rest1) L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # rest1)\n     (hd (OPT2 (a # rest1) [x, y]) #\n      OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y])))) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "by(simp)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1)\n   (hd (OPT2 (a # rest1) [x, y]) #\n    OPT2 rest1 (step [x, y] a (hd (OPT2 (a # rest1) [x, y])))) =\n  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n  (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n   in T\\<^sub>p L rest1 (OPT2 rest1 L))\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n  (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n   in T\\<^sub>p L rest1 (OPT2 rest1 L))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n  (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n   in T\\<^sub>p L rest1 (OPT2 rest1 L))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n    t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n    (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # rest1) (OPT2 (a # rest1) [x, y]) =\n  t\\<^sub>p [x, y] a (hd (OPT2 (a # rest1) [x, y])) +\n  (let L = step [x, y] a (hd (OPT2 (a # rest1) [x, y]))\n   in T\\<^sub>p L rest1 (OPT2 rest1 L))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tpx: \"t\\<^sub>p [x, y] x (hd (OPT2 (x # rest1) [x, y])) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd (OPT2 (x # rest1) [x, y])) = 0", "by (simp add: OPT2x t\\<^sub>p_def)"], ["", "lemma yup: \"T\\<^sub>p [x, y] (x # rest1) (OPT2 (x # rest1) [x, y])\n        = (let L=step [x,y] x (hd (OPT2 (x # rest1) [x, y])) \n              in T\\<^sub>p L (rest1) (OPT2 (rest1) L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # rest1) (OPT2 (x # rest1) [x, y]) =\n    (let L = step [x, y] x (hd (OPT2 (x # rest1) [x, y]))\n     in T\\<^sub>p L rest1 (OPT2 rest1 L))", "by (simp add: splitqs tpx)"], ["", "lemma swapsxy: \"A \\<in> { [x,y], [y,x]} \\<Longrightarrow> swaps sws A \\<in> { [x,y], [y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {[x, y], [y, x]} \\<Longrightarrow>\n    swaps sws A \\<in> {[x, y], [y, x]}", "apply(induct sws)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<in> {[x, y], [y, x]} \\<Longrightarrow>\n    swaps [] A \\<in> {[x, y], [y, x]}\n 2. \\<And>a sws.\n       \\<lbrakk>A \\<in> {[x, y], [y, x]} \\<Longrightarrow>\n                swaps sws A \\<in> {[x, y], [y, x]};\n        A \\<in> {[x, y], [y, x]}\\<rbrakk>\n       \\<Longrightarrow> swaps (a # sws) A \\<in> {[x, y], [y, x]}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sws.\n       \\<lbrakk>A \\<in> {[x, y], [y, x]} \\<Longrightarrow>\n                swaps sws A \\<in> {[x, y], [y, x]};\n        A \\<in> {[x, y], [y, x]}\\<rbrakk>\n       \\<Longrightarrow> swaps (a # sws) A \\<in> {[x, y], [y, x]}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sws.\n       \\<lbrakk>swaps sws A = [x, y] \\<or> swaps sws A = [y, x];\n        A = [x, y] \\<or> A = [y, x]\\<rbrakk>\n       \\<Longrightarrow> swap a (swaps sws A) = [x, y] \\<or>\n                         swap a (swaps sws A) = [y, x]", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sws.\n       \\<lbrakk>foldr\n                 (\\<lambda>n xs.\n                     if Suc n < length xs\n                     then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                 sws A =\n                [x, y] \\<or>\n                foldr\n                 (\\<lambda>n xs.\n                     if Suc n < length xs\n                     then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                 sws A =\n                [y, x];\n        A = [x, y] \\<or> A = [y, x]\\<rbrakk>\n       \\<Longrightarrow> (if Suc a\n                             < length\n                                (foldr\n                                  (\\<lambda>n xs.\nif Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                                  sws A)\n                          then (foldr\n                                 (\\<lambda>n xs.\n                                     if Suc n < length xs\n                                     then xs\n    [n := xs ! Suc n, Suc n := xs ! n]\n                                     else xs)\n                                 sws A)\n                               [a := foldr\n(\\<lambda>n xs.\n    if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\nsws A !\n                                     Suc a,\n                                Suc a :=\n                                  foldr\n                                   (\\<lambda>n xs.\n if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                                   sws A !\n                                  a]\n                          else foldr\n                                (\\<lambda>n xs.\n                                    if Suc n < length xs\n                                    then xs\n   [n := xs ! Suc n, Suc n := xs ! n]\n                                    else xs)\n                                sws A) =\n                         [x, y] \\<or>\n                         (if Suc a\n                             < length\n                                (foldr\n                                  (\\<lambda>n xs.\nif Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                                  sws A)\n                          then (foldr\n                                 (\\<lambda>n xs.\n                                     if Suc n < length xs\n                                     then xs\n    [n := xs ! Suc n, Suc n := xs ! n]\n                                     else xs)\n                                 sws A)\n                               [a := foldr\n(\\<lambda>n xs.\n    if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\nsws A !\n                                     Suc a,\n                                Suc a :=\n                                  foldr\n                                   (\\<lambda>n xs.\n if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                                   sws A !\n                                  a]\n                          else foldr\n                                (\\<lambda>n xs.\n                                    if Suc n < length xs\n                                    then xs\n   [n := xs ! Suc n, Suc n := xs ! n]\n                                    else xs)\n                                sws A) =\n                         [y, x]", "by auto"], ["", "lemma mtf2xy: \"A \\<in> { [x,y], [y,x]} \\<Longrightarrow> r\\<in>{x,y} \\<Longrightarrow> mtf2 a r A \\<in> { [x,y], [y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> {[x, y], [y, x]}; r \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> mtf2 a r A \\<in> {[x, y], [y, x]}", "by (metis mtf2_def swapsxy)"], ["", "lemma stepxy: assumes \"q \\<in> {x,y}\" \"A \\<in> { [x,y], [y,x]}\" \n    shows \"step A q a \\<in> { [x,y], [y,x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step A q a \\<in> {[x, y], [y, x]}", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) = a in mtf2 k q (swaps sws A)) \\<in> {[x, y], [y, x]}", "apply(simp only: split_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (fst a) q (swaps (snd a) A) \\<in> {[x, y], [y, x]}", "apply(rule mtf2xy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. swaps (snd a) A \\<in> {[x, y], [y, x]}\n 2. q \\<in> {x, y}", "apply(rule swapsxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<in> {[x, y], [y, x]}\n 2. q \\<in> {x, y}", "by fact+"], ["", "subsection \"Proof of Optimality\""], ["", "lemma OPT2_is_lb: \"set \\<sigma> \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] \\<sigma> (OPT2 \\<sigma> [x,y]) \\<le> T\\<^sub>p_opt [x,y] \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set \\<sigma> \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n                      \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "proof (induct \"length \\<sigma>\" arbitrary: x y \\<sigma> rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x y.\n       \\<lbrakk>\\<And>\\<sigma>' x y.\n                   \\<lbrakk>length \\<sigma>' < length \\<sigma>;\n                    set \\<sigma>' \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p [x, y] \\<sigma>'\n(OPT2 \\<sigma>' [x, y])\n                                     \\<le> T\\<^sub>p_opt [x, y] \\<sigma>';\n        set \\<sigma> \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n                         \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "case (less)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>;\n   set ?\\<sigma> \\<subseteq> {?x, ?y}; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [?x, ?y] ?\\<sigma> (OPT2 ?\\<sigma> [?x, ?y])\n                    \\<le> T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  set \\<sigma> \\<subseteq> {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x y.\n       \\<lbrakk>\\<And>\\<sigma>' x y.\n                   \\<lbrakk>length \\<sigma>' < length \\<sigma>;\n                    set \\<sigma>' \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p [x, y] \\<sigma>'\n(OPT2 \\<sigma>' [x, y])\n                                     \\<le> T\\<^sub>p_opt [x, y] \\<sigma>';\n        set \\<sigma> \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n                         \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "proof (cases \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>\n 2. \\<And>a list.\n       \\<sigma> = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "case (Cons a \\<sigma>')"], ["proof (state)\nthis:\n  \\<sigma> = a # \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>\n 2. \\<And>a list.\n       \\<sigma> = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "note Cons1=Cons"], ["proof (state)\nthis:\n  \\<sigma> = a # \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>\n 2. \\<And>a list.\n       \\<sigma> = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "proof(cases \"a=x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "(* case that the element in front is requested *)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "case True"], ["proof (state)\nthis:\n  a = x\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "from True Cons"], ["proof (chain)\npicking this:\n  a = x\n  \\<sigma> = a # \\<sigma>'", "have qsform: \"\\<sigma> = x#\\<sigma>'\""], ["proof (prove)\nusing this:\n  a = x\n  \\<sigma> = a # \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma> = x # \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  \\<sigma> = x # \\<sigma>'\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "have up: \"T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n    \\<le> \\<Sqinter> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                      length as = length (x # \\<sigma>')}", "apply(rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n     length as = length (x # \\<sigma>')} \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "apply(simp add: Ex_list_of_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "fix el"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "assume \"el \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as. length as = length (x # \\<sigma>')}\""], ["proof (state)\nthis:\n  el \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n            length as = length (x # \\<sigma>')}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "then"], ["proof (chain)\npicking this:\n  el \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n            length as = length (x # \\<sigma>')}", "obtain Strat where lStrat: \"length Strat = length (x # \\<sigma>')\"\n                        and el: \"T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\""], ["proof (prove)\nusing this:\n  el \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n            length as = length (x # \\<sigma>')}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>length Strat = length (x # \\<sigma>');\n         T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length Strat = length (x # \\<sigma>')\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "then"], ["proof (chain)\npicking this:\n  length Strat = length (x # \\<sigma>')\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el", "have ne: \"Strat \\<noteq> []\""], ["proof (prove)\nusing this:\n  length Strat = length (x # \\<sigma>')\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\n\ngoal (1 subgoal):\n 1. Strat \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "let ?LA=\"step [x,y] x (hd (OPT2 (x # \\<sigma>') [x, y]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "have  E0:  \"T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n                            =T\\<^sub>p ?LA (\\<sigma>') (OPT2 (\\<sigma>') ?LA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) =\n    T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n     (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))))", "using yup"], ["proof (prove)\nusing this:\n  T\\<^sub>p [?x, ?y] (?x # ?rest1.0) (OPT2 (?x # ?rest1.0) [?x, ?y]) =\n  (let L = step [?x, ?y] ?x (hd (OPT2 (?x # ?rest1.0) [?x, ?y]))\n   in T\\<^sub>p L ?rest1.0 (OPT2 ?rest1.0 L))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) =\n    T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n     (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) =\n  T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n   (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) =\n  T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n   (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "have E1: \"\\<dots> = T\\<^sub>p [x,y] (\\<sigma>') (OPT2 (\\<sigma>') [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n     (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y])))) =\n    T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])", "by (simp add: OPT2x step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n   (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y])))) =\n  T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y]))) \\<sigma>'\n   (OPT2 \\<sigma>' (step [x, y] x (hd (OPT2 (x # \\<sigma>') [x, y])))) =\n  T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "have E2: \"\\<dots> \\<le>  T\\<^sub>p_opt [x,y] \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>'", "apply(rule less(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. length \\<sigma>' < length \\<sigma>\n 2. set \\<sigma>' \\<subseteq> {x, y}\n 3. x \\<noteq> y", "using Cons less(2,3)"], ["proof (prove)\nusing this:\n  \\<sigma> = a # \\<sigma>'\n  set \\<sigma> \\<subseteq> {x, y}\n  x \\<noteq> y\n\ngoal (3 subgoals):\n 1. length \\<sigma>' < length \\<sigma>\n 2. set \\<sigma>' \\<subseteq> {x, y}\n 3. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma>' (OPT2 \\<sigma>' [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "have \"\\<dots> \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "proof (cases \"(step [x, y] x (hd Strat)) = [x,y]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "case True"], ["proof (state)\nthis:\n  step [x, y] x (hd Strat) = [x, y]\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have aha: \"T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] \\<sigma>' (tl Strat)", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [x, y] \\<sigma>' as |as.\n                length as = length \\<sigma>'}\n    \\<le> T\\<^sub>p [x, y] \\<sigma>' (tl Strat)", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n    \\<in> {T\\<^sub>p [x, y] \\<sigma>' as |as. length as = length \\<sigma>'}\n 2. bdd_below\n     {T\\<^sub>p [x, y] \\<sigma>' as |as. length as = length \\<sigma>'}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       T\\<^sub>p [x, y] \\<sigma>' (tl Strat) =\n       T\\<^sub>p [x, y] \\<sigma>' as \\<and>\n       length as = length \\<sigma>'", "apply(rule exI[where x=\"tl Strat\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] \\<sigma>' (tl Strat) \\<and>\n    length (tl Strat) = length \\<sigma>'", "using lStrat"], ["proof (prove)\nusing this:\n  length Strat = length (x # \\<sigma>')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] \\<sigma>' (tl Strat) \\<and>\n    length (tl Strat) = length \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E4: \"\\<dots> \\<le> t\\<^sub>p [x, y] x (hd Strat) + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n    \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n          T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n    \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n          T\\<^sub>p [x, y] \\<sigma>' (tl Strat)", "by(simp)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n  \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n        T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma>' (tl Strat)\n  \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n        T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E5: \"\\<dots> = T\\<^sub>p [x, y] (x # \\<sigma>') Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd Strat) +\n    T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "using splitqsallg[of Strat x x y \\<sigma>', OF ne, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] x (hd Strat) +\n  T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd Strat) +\n    T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "by (auto)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (hd Strat) +\n  T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (2 subgoals):\n 1. step [x, y] x (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n 2. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "case False"], ["proof (state)\nthis:\n  step [x, y] x (hd Strat) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have tp1: \"t\\<^sub>p [x, y] x (hd Strat) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t\\<^sub>p [x, y] x (hd Strat)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "let ?a = \"hd Strat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "assume \"\\<not> 1 \\<le> t\\<^sub>p [x, y] x ?a\""], ["proof (state)\nthis:\n  \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat)\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat)", "have tp0: \"t\\<^sub>p [x, y] x ?a = 0\""], ["proof (prove)\nusing this:\n  \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat)\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd Strat) = 0", "by auto"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (hd Strat) = 0\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t\\<^sub>p [x, y] x (hd Strat) = 0", "have \"size (snd ?a) = 0\""], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] x (hd Strat) = 0\n\ngoal (1 subgoal):\n 1. length (snd (hd Strat)) = 0", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  (let (mf, sws) = hd Strat in index (swaps sws [x, y]) x + length sws) = 0\n\ngoal (1 subgoal):\n 1. length (snd (hd Strat)) = 0", "by(simp add: split_def)"], ["proof (state)\nthis:\n  length (snd (hd Strat)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  length (snd (hd Strat)) = 0", "have nopaid: \"(snd ?a) = []\""], ["proof (prove)\nusing this:\n  length (snd (hd Strat)) = 0\n\ngoal (1 subgoal):\n 1. snd (hd Strat) = []", "by auto"], ["proof (state)\nthis:\n  snd (hd Strat) = []\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "have \"step [x, y] x ?a = [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) = [x, y]", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) = hd Strat in mtf2 k x (swaps sws [x, y])) = [x, y]", "apply(simp add: split_def nopaid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (fst (hd Strat)) x [x, y] = [x, y]", "unfolding mtf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> set [x, y]\n     then swaps [index [x, y] x - fst (hd Strat)..<index [x, y] x] [x, y]\n     else [x, y]) =\n    [x, y]", "by(simp)"], ["proof (state)\nthis:\n  step [x, y] x (hd Strat) = [x, y]\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> t\\<^sub>p [x, y] x (hd Strat) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  step [x, y] x (hd Strat) = [x, y]", "show \"False\""], ["proof (prove)\nusing this:\n  step [x, y] x (hd Strat) = [x, y]\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  step [x, y] x (hd Strat) = [x, y]\n  step [x, y] x (hd Strat) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> t\\<^sub>p [x, y] x (hd Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "from False"], ["proof (chain)\npicking this:\n  step [x, y] x (hd Strat) \\<noteq> [x, y]", "have yx: \"step [x, y] x (hd Strat) = [y, x]\""], ["proof (prove)\nusing this:\n  step [x, y] x (hd Strat) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) = [y, x]", "using stepxy[where x=x and y=y and a=\"hd Strat\"]"], ["proof (prove)\nusing this:\n  step [x, y] x (hd Strat) \\<noteq> [x, y]\n  \\<lbrakk>?q \\<in> {x, y}; ?A \\<in> {[x, y], [y, x]}\\<rbrakk>\n  \\<Longrightarrow> step ?A ?q (hd Strat) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) = [y, x]", "by auto"], ["proof (state)\nthis:\n  step [x, y] x (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E3: \"T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>'", "using swapOpt"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  \\<le> 1 + T\\<^sub>p_opt [?y, ?x] ?\\<sigma>\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>'\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>' \\<le> 1 + T\\<^sub>p_opt [y, x] \\<sigma>'\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E4: \"\\<dots> \\<le> 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] \\<sigma>'\n    \\<le> 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [y, x] \\<sigma>'\n    \\<le> T\\<^sub>p [y, x] \\<sigma>' (tl Strat)", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [y, x] \\<sigma>' as |as.\n                length as = length \\<sigma>'}\n    \\<le> T\\<^sub>p [y, x] \\<sigma>' (tl Strat)", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [y, x] \\<sigma>' (tl Strat)\n    \\<in> {T\\<^sub>p [y, x] \\<sigma>' as |as. length as = length \\<sigma>'}\n 2. bdd_below\n     {T\\<^sub>p [y, x] \\<sigma>' as |as. length as = length \\<sigma>'}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n       T\\<^sub>p [y, x] \\<sigma>' as \\<and>\n       length as = length \\<sigma>'", "apply(rule exI[where x=\"tl Strat\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n    T\\<^sub>p [y, x] \\<sigma>' (tl Strat) \\<and>\n    length (tl Strat) = length \\<sigma>'", "using lStrat"], ["proof (prove)\nusing this:\n  length Strat = length (x # \\<sigma>')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n    T\\<^sub>p [y, x] \\<sigma>' (tl Strat) \\<and>\n    length (tl Strat) = length \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] \\<sigma>'\n  \\<le> 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] \\<sigma>'\n  \\<le> 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E5: \"\\<dots> = 1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n    1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)", "using yx"], ["proof (prove)\nusing this:\n  step [x, y] x (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n    1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n  1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [y, x] \\<sigma>' (tl Strat) =\n  1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E6: \"\\<dots> \\<le> t\\<^sub>p [x, y] x (hd Strat) + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n    \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n          T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)", "using tp1"], ["proof (prove)\nusing this:\n  1 \\<le> t\\<^sub>p [x, y] x (hd Strat)\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n    \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n          T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n  \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n        T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n  \\<le> t\\<^sub>p [x, y] x (hd Strat) +\n        T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "have E7: \"\\<dots> = T\\<^sub>p [x, y] (x # \\<sigma>') Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd Strat) +\n    T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "using splitqsallg[of Strat x x y \\<sigma>', OF ne, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] x (hd Strat) +\n  T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (hd Strat) +\n    T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n    T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "by (auto)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (hd Strat) +\n  T\\<^sub>p (step [x, y] x (hd Strat)) \\<sigma>' (tl Strat) =\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. step [x, y] x (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] \\<sigma>'\n    \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] \\<sigma>'\n  \\<le> T\\<^sub>p [x, y] (x # \\<sigma>') Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "have \"\\<dots> = el\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el", "using True el"], ["proof (prove)\nusing this:\n  a = x\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # \\<sigma>') Strat = el\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (x # \\<sigma>') as |as.\n                length as = length (x # \\<sigma>')} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n       \\<le> x", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> el", "show \"T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> el\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> el\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> el", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y]) \\<le> el\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')", "show \"T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y]) \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "using True"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (x # \\<sigma>') (OPT2 (x # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (x # \\<sigma>')\n  a = x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "case False"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "(* case 2: element at back is requested first *)"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "with less Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>;\n   set ?\\<sigma> \\<subseteq> {?x, ?y}; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [?x, ?y] ?\\<sigma> (OPT2 ?\\<sigma> [?x, ?y])\n                    \\<le> T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  set \\<sigma> \\<subseteq> {x, y}\n  x \\<noteq> y\n  \\<sigma> = a # \\<sigma>'\n  a \\<noteq> x", "have ay: \"a=y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?\\<sigma> < length \\<sigma>;\n   set ?\\<sigma> \\<subseteq> {?x, ?y}; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [?x, ?y] ?\\<sigma> (OPT2 ?\\<sigma> [?x, ?y])\n                    \\<le> T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  set \\<sigma> \\<subseteq> {x, y}\n  x \\<noteq> y\n  \\<sigma> = a # \\<sigma>'\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. a = y", "by auto"], ["proof (state)\nthis:\n  a = y\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "show \"T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y]) \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')", "unfolding ay"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "proof(cases \\<sigma>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma>' = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\n 2. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "case Nil"], ["proof (state)\nthis:\n  \\<sigma>' = []\n\ngoal (2 subgoals):\n 1. \\<sigma>' = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\n 2. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "have up: \"T\\<^sub>p_opt [x, y] [y] \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> T\\<^sub>p_opt [x, y] [y]", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<Sqinter> {T\\<^sub>p [x, y] [y] as |as. length as = length [y]}", "apply(rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {T\\<^sub>p [x, y] [y] as |as. length as = length [y]} \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "apply(simp add: Ex_list_of_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "fix el"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "assume \"el \\<in> {T\\<^sub>p [x, y] [y] as |as. length as = length [y]}\""], ["proof (state)\nthis:\n  el \\<in> {T\\<^sub>p [x, y] [y] as |as. length as = length [y]}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "then"], ["proof (chain)\npicking this:\n  el \\<in> {T\\<^sub>p [x, y] [y] as |as. length as = length [y]}", "obtain Strat where Strat: \"length Strat = length [y]\" and\n                            el: \"el = T\\<^sub>p [x, y] [y] Strat \""], ["proof (prove)\nusing this:\n  el \\<in> {T\\<^sub>p [x, y] [y] as |as. length as = length [y]}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>length Strat = length [y];\n         el = T\\<^sub>p [x, y] [y] Strat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length Strat = length [y]\n  el = T\\<^sub>p [x, y] [y] Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "from Strat"], ["proof (chain)\npicking this:\n  length Strat = length [y]", "obtain a where a: \"Strat = [a]\""], ["proof (prove)\nusing this:\n  length Strat = length [y]\n\ngoal (1 subgoal):\n 1. (\\<And>a. Strat = [a] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis Suc_length_conv length_0_conv)"], ["proof (state)\nthis:\n  Strat = [a]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] [y] as |as.\n                length as = length [y]} \\<Longrightarrow>\n       1 \\<le> x", "show \"1 \\<le> el\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> el", "unfolding el a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> T\\<^sub>p [x, y] [y] [a]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> t\\<^sub>p [x, y] y a", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> (let (mf, sws) = a in index (swaps sws [x, y]) y + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> index (swaps (snd a) [x, y]) y + length (snd a)", "apply(cases \"snd a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd a = [] \\<Longrightarrow>\n    Suc 0 \\<le> index (swaps (snd a) [x, y]) y + length (snd a)\n 2. \\<And>a list.\n       snd a = a # list \\<Longrightarrow>\n       Suc 0 \\<le> index (swaps (snd a) [x, y]) y + length (snd a)", "apply(simp add: less(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       snd a = a # list \\<Longrightarrow>\n       Suc 0 \\<le> index (swaps (snd a) [x, y]) y + length (snd a)", "by(simp)"], ["proof (state)\nthis:\n  1 \\<le> el\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> T\\<^sub>p_opt [x, y] [y]\n\ngoal (2 subgoals):\n 1. \\<sigma>' = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\n 2. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "show \"T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y]) \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [y] (OPT2 [y] [x, y]) \\<le> T\\<^sub>p_opt [x, y] [y]", "apply(simp add: t\\<^sub>p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<longrightarrow> Suc 0 \\<le> T\\<^sub>p_opt [x, y] [y]", "using less(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<longrightarrow> Suc 0 \\<le> T\\<^sub>p_opt [x, y] [y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Suc 0 \\<le> T\\<^sub>p_opt [x, y] [y]", "using up"], ["proof (prove)\nusing this:\n  1 \\<le> T\\<^sub>p_opt [x, y] [y]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Suc 0 \\<le> T\\<^sub>p_opt [x, y] [y]", "by(simp)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "case (Cons b rest2)"], ["proof (state)\nthis:\n  \\<sigma>' = b # rest2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma>' = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n       \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "show up: \"T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y]) \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "proof (cases \"b=x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\n 2. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "case True"], ["proof (state)\nthis:\n  b = x\n\ngoal (2 subgoals):\n 1. b = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\n 2. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "show \"T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y]) \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # x # rest2)", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n    \\<le> \\<Sqinter> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                      length as = length (y # x # rest2)}", "apply(rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n     length as = length (y # x # rest2)} \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "apply(simp add: Ex_list_of_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "fix el"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "assume \"el \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as. length as = length (y # x # rest2)}\""], ["proof (state)\nthis:\n  el \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n            length as = length (y # x # rest2)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "then"], ["proof (chain)\npicking this:\n  el \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n            length as = length (y # x # rest2)}", "obtain Strat where lenStrat: \"length Strat = length (y # x # rest2)\" and\n                               Strat: \"el = T\\<^sub>p [x, y] (y # x # rest2) Strat\""], ["proof (prove)\nusing this:\n  el \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n            length as = length (y # x # rest2)}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>length Strat = length (y # x # rest2);\n         el = T\\<^sub>p [x, y] (y # x # rest2) Strat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length Strat = length (y # x # rest2)\n  el = T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have v: \" set rest2 \\<subseteq> {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rest2 \\<subseteq> {x, y}", "using less(2)[unfolded Cons1 Cons]"], ["proof (prove)\nusing this:\n  set (a # b # rest2) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set rest2 \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set rest2 \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "let ?L1 = \"(step [x, y] y (hd Strat))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "let ?L2 = \"(step ?L1 x (hd (tl Strat)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "(* lets work on how Strat can look like: *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "let ?a1 = \"hd Strat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "let ?a2 = \"hd (tl Strat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "let ?r = \"tl (tl Strat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have \"Strat = ?a1 # ?a2 # ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Strat = hd Strat # hd (tl Strat) # tl (tl Strat)", "by (metis Nitpick.size_list_simp(2) Suc_length_conv lenStrat list.collapse list.discI list.inject)"], ["proof (state)\nthis:\n  Strat = hd Strat # hd (tl Strat) # tl (tl Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have 1: \"T\\<^sub>p [x, y] (y # x # rest2) Strat\n                        = t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat))\n                            + T\\<^sub>p ?L2 rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have a: \"Strat \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Strat \\<noteq> []", "using lenStrat"], ["proof (prove)\nusing this:\n  length Strat = length (y # x # rest2)\n\ngoal (1 subgoal):\n 1. Strat \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have b: \"(tl Strat) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl Strat \\<noteq> []", "using lenStrat"], ["proof (prove)\nusing this:\n  length Strat = length (y # x # rest2)\n\ngoal (1 subgoal):\n 1. tl Strat \\<noteq> []", "by (metis Nitpick.size_list_simp(2) Suc_length_conv list.discI list.inject)"], ["proof (state)\nthis:\n  tl Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have 1: \"T\\<^sub>p [x, y] (y # x # rest2) Strat\n                                = t\\<^sub>p [x, y] y (hd Strat) + T\\<^sub>p ?L1 (x # rest2) (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat)", "using splitqsallg[OF a, where a=y and x=x and y=y, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) ?rest1.0 (tl Strat) =\n  T\\<^sub>p [x, y] (y # ?rest1.0) Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat)", "by (simp)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have tt: \"step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow> step [x, y] y (hd Strat) = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    step [x, y] y (hd Strat) = [y, x]", "using stepxy[where A=\"[x,y]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> {?x, ?y}; [x, y] \\<in> {[?x, ?y], [?y, ?x]}\\<rbrakk>\n  \\<Longrightarrow> step [x, y] ?q ?a \\<in> {[?x, ?y], [?y, ?x]}\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    step [x, y] y (hd Strat) = [y, x]", "by blast"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have 2: \"T\\<^sub>p ?L1 (x # rest2) (tl Strat) = t\\<^sub>p ?L1 x (hd (tl Strat)) +  T\\<^sub>p ?L2 (rest2) (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "apply(cases \"?L1=[x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "using splitqsallg[OF b, where a=x and x=x and y=y, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] x (hd (tl Strat)) +\n  T\\<^sub>p (step [x, y] x (hd (tl Strat))) ?rest1.0 (tl (tl Strat)) =\n  T\\<^sub>p [x, y] (x # ?rest1.0) (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>step [x, y] y (hd Strat) \\<noteq> [x, y];\n     \\<And>rest1.\n        t\\<^sub>p [x, y] x (hd (tl Strat)) +\n        T\\<^sub>p (step [x, y] x (hd (tl Strat))) rest1 (tl (tl Strat)) =\n        T\\<^sub>p [x, y] (x # rest1) (tl Strat)\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2)\n                       (tl Strat) =\n                      t\\<^sub>p (step [x, y] y (hd Strat)) x\n                       (hd (tl Strat)) +\n                      T\\<^sub>p\n                       (step (step [x, y] y (hd Strat)) x (hd (tl Strat)))\n                       rest2 (tl (tl Strat))", "using tt splitqsallg[OF b, where a=x and x=y and y=x, simplified]"], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n  step [x, y] y (hd Strat) = [y, x]\n  t\\<^sub>p [y, x] x (hd (tl Strat)) +\n  T\\<^sub>p (step [y, x] x (hd (tl Strat))) ?rest1.0 (tl (tl Strat)) =\n  T\\<^sub>p [y, x] (x # ?rest1.0) (tl Strat)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step [x, y] y (hd Strat) \\<noteq> [x, y];\n     \\<And>rest1.\n        t\\<^sub>p [x, y] x (hd (tl Strat)) +\n        T\\<^sub>p (step [x, y] x (hd (tl Strat))) rest1 (tl (tl Strat)) =\n        T\\<^sub>p [x, y] (x # rest1) (tl Strat)\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2)\n                       (tl Strat) =\n                      t\\<^sub>p (step [x, y] y (hd Strat)) x\n                       (hd (tl Strat)) +\n                      T\\<^sub>p\n                       (step (step [x, y] y (hd Strat)) x (hd (tl Strat)))\n                       rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "from 1 2"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat)\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat)\n  T\\<^sub>p (step [x, y] y (hd Strat)) (x # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n     (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have \" T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n                    =  1 +  T\\<^sub>p [x, y] (rest2) (OPT2 (rest2) [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) =\n    1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) =\n    1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])", "using less(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) =\n    1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])", "by(simp add: t\\<^sub>p_def step_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) =\n  1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) =\n  1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> \\<le> 1 +  T\\<^sub>p_opt [x, y] (rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n    \\<le> 1 + T\\<^sub>p_opt [x, y] rest2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] rest2", "apply(rule less(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. length rest2 < length \\<sigma>\n 2. set rest2 \\<subseteq> {x, y}\n 3. x \\<noteq> y", "apply(simp add: less(2) Cons1 Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set rest2 \\<subseteq> {x, y}\n 2. x \\<noteq> y", "apply(fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by fact"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n  \\<le> 1 + T\\<^sub>p_opt [x, y] rest2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] rest2 (OPT2 rest2 [x, y])\n  \\<le> 1 + T\\<^sub>p_opt [x, y] rest2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "proof (cases \"?L2 = [x,y]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) =\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "case True"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) =\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have 2: \"t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat))\n                            + T\\<^sub>p [x,y] rest2 (tl (tl Strat)) \\<ge> t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat))\n                            + T\\<^sub>p_opt [x,y] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p_opt [x, y] rest2\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n          T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] rest2 \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}\n    \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<in> {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}\n 2. bdd_below {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       T\\<^sub>p [x, y] rest2 (tl (tl Strat)) =\n       T\\<^sub>p [x, y] rest2 as \\<and>\n       length as = length rest2\n 2. bdd_below {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}", "apply(rule exI[where x=\"tl (tl Strat)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] rest2 (tl (tl Strat)) =\n    T\\<^sub>p [x, y] rest2 (tl (tl Strat)) \\<and>\n    length (tl (tl Strat)) = length rest2\n 2. bdd_below {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}", "by (auto simp: lenStrat)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) =\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have 3: \"t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat))\n                            + T\\<^sub>p_opt [x,y] rest2 \\<ge> 1 + T\\<^sub>p_opt [x,y] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n          T\\<^sub>p_opt [x, y] rest2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "have \"t\\<^sub>p [x, y] y (hd Strat) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t\\<^sub>p [x, y] y (hd Strat)", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (let (mf, sws) = hd Strat\n             in index (swaps sws [x, y]) y + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))", "apply(cases \"snd (hd Strat)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (hd Strat) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))\n 2. \\<And>a list.\n       snd (hd Strat) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd Strat)) [x, y]) y +\n             length (snd (hd Strat))", "by (simp_all add: less(3))"], ["proof (state)\nthis:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)", "show \"Suc 0 \\<le> t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "by auto"], ["proof (state)\nthis:\n  Suc 0\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p_opt [x, y] rest2\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) =\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "from 1 2 3 True"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p_opt [x, y] rest2\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n        T\\<^sub>p_opt [x, y] rest2\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "case False"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "note L2F=this"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have L1: \"?L1 \\<in> {[x, y], [y, x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<in> {x, y}\n 2. [x, y] \\<in> {[x, y], [y, x]}", "by simp_all"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"?L2 \\<in> {[x, y], [y, x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<in> {[x, y], [y, x]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {x, y}\n 2. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "using L1"], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n\ngoal (2 subgoals):\n 1. x \\<in> {x, y}\n 2. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "by simp_all"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "with False"], ["proof (chain)\npicking this:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<in> {[x, y], [y, x]}", "have 2: \"?L2 = [y,x]\""], ["proof (prove)\nusing this:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [y, x]", "by auto"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [y, x]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have k: \"T\\<^sub>p [x, y] (y # x # rest2) Strat\n                        =   t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat)) +\n                            T\\<^sub>p [y,x] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "using 1 2"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) x (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have l: \"t\\<^sub>p [x, y] y (hd Strat) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] y (hd Strat)", "using less(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] y (hd Strat)", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < (let (mf, sws) = hd Strat\n         in index (swaps sws [x, y]) y + length sws)", "apply(cases \"snd (hd Strat) = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; snd (hd Strat) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < (let (mf, sws) = hd Strat\n                           in index (swaps sws [x, y]) y + length sws)\n 2. \\<lbrakk>x \\<noteq> y; snd (hd Strat) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < (let (mf, sws) = hd Strat\n                           in index (swaps sws [x, y]) y + length sws)", "by (simp_all add: split_def)"], ["proof (state)\nthis:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have r: \"T\\<^sub>p [x, y] (y # x # rest2) Strat \\<ge> 2 + T\\<^sub>p [y,x] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "proof (cases \"?L1 = [x,y]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "case True"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "note T=this"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "then"], ["proof (chain)\npicking this:\n  step [x, y] y (hd Strat) = [x, y]", "have \"t\\<^sub>p ?L1 x (hd (tl Strat)) > 0\""], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "unfolding True"], ["proof (prove)\nusing this:\n  [x, y] = [x, y]\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "proof(cases \"snd (hd (tl Strat)) = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n 2. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "case True"], ["proof (state)\nthis:\n  snd (hd (tl Strat)) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n 2. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "have \"?L2 = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]", "unfolding T"], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] x (hd (tl Strat)) = [x, y]", "apply(simp add: split_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (fst (hd (tl Strat))) x (swaps (snd (hd (tl Strat))) [x, y]) =\n    [x, y]", "unfolding True mtf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> set (swaps [] [x, y])\n     then swaps\n           [index (swaps [] [x, y]) x - fst (hd (tl Strat))..<\n            index (swaps [] [x, y]) x]\n           (swaps [] [x, y])\n     else swaps [] [x, y]) =\n    [x, y]", "by(simp)"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n 2. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "with L2F"], ["proof (chain)\npicking this:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]", "have \"False\""], ["proof (prove)\nusing this:\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq> [x, y]\n  step (step [x, y] y (hd Strat)) x (hd (tl Strat)) = [x, y]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n 2. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  False", "show \"0 < t\\<^sub>p [x, y] x (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", ".."], ["proof (state)\nthis:\n  0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "case False"], ["proof (state)\nthis:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[x, y] = [x, y]; snd (hd (tl Strat)) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  snd (hd (tl Strat)) \\<noteq> []", "show \"0 < t\\<^sub>p [x, y] x (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] x (hd (tl Strat))", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < (let (mf, sws) = hd (tl Strat)\n         in index (swaps sws [x, y]) x + length sws)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  0 < t\\<^sub>p [x, y] x (hd (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "with l"], ["proof (chain)\npicking this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "have \" t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 x (hd (tl Strat)) \\<ge> 2\""], ["proof (prove)\nusing this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n            t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "by auto"], ["proof (state)\nthis:\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "with k"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "case False"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "from L1 False"], ["proof (chain)\npicking this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n  step [x, y] y (hd Strat) \\<noteq> [x, y]", "have 2: \"?L1 = [y,x]\""], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n  step [x, y] y (hd Strat) \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x]", "by auto"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "{"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "fix k sws T"], ["proof (state)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"T\\<in>{[x,y],[y,x]} \\<Longrightarrow> mtf2 k x T = [y,x] \\<Longrightarrow> T = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> {[x, y], [y, x]}; mtf2 k x T = [y, x]\\<rbrakk>\n    \\<Longrightarrow> T = [y, x]", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> {[x, y], [y, x]}; mtf2 k x T = [y, x];\n     T \\<noteq> [y, x]\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: less(3) mtf2_def)"], ["proof (state)\nthis:\n  \\<lbrakk>T \\<in> {[x, y], [y, x]}; mtf2 k x T = [y, x]\\<rbrakk>\n  \\<Longrightarrow> T = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?T2 \\<in> {[x, y], [y, x]}; mtf2 ?k2 x ?T2 = [y, x]\\<rbrakk>\n  \\<Longrightarrow> ?T2 = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have t1: \"t\\<^sub>p [x, y] y (hd Strat) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t\\<^sub>p [x, y] y (hd Strat)", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (let (mf, sws) = hd Strat\n             in index (swaps sws [x, y]) y + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))", "apply(cases \"(snd (hd Strat))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (hd Strat) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))\n 2. \\<And>a list.\n       snd (hd Strat) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd Strat)) [x, y]) y +\n             length (snd (hd Strat))", "using \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. snd (hd Strat) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))\n 2. \\<And>a list.\n       snd (hd Strat) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd Strat)) [x, y]) y +\n             length (snd (hd Strat))", "by auto"], ["proof (state)\nthis:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have t2: \"t\\<^sub>p [y,x] x (hd (tl Strat)) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t\\<^sub>p [y, x] x (hd (tl Strat))", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (let (mf, sws) = hd (tl Strat)\n             in index (swaps sws [y, x]) x + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> index (swaps (snd (hd (tl Strat))) [y, x]) x +\n          length (snd (hd (tl Strat)))", "apply(cases \"(snd (hd (tl Strat)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd (tl Strat))) [y, x]) x +\n          length (snd (hd (tl Strat)))\n 2. \\<And>a list.\n       snd (hd (tl Strat)) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd (tl Strat))) [y, x]) x +\n             length (snd (hd (tl Strat)))", "using \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd (tl Strat))) [y, x]) x +\n          length (snd (hd (tl Strat)))\n 2. \\<And>a list.\n       snd (hd (tl Strat)) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd (tl Strat))) [y, x]) x +\n             length (snd (hd (tl Strat)))", "by auto"], ["proof (state)\nthis:\n  1 \\<le> t\\<^sub>p [y, x] x (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"T\\<^sub>p [x, y] (y # x # rest2) Strat\n                          = t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n    T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "by(rule k)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "with t1 t2 2"], ["proof (chain)\npicking this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n  1 \\<le> t\\<^sub>p [y, x] x (hd (tl Strat))\n  step [x, y] y (hd Strat) = [y, x]\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n  1 \\<le> t\\<^sub>p [y, x] x (hd (tl Strat))\n  step [x, y] y (hd Strat) = [y, x]\n  T\\<^sub>p [x, y] (y # x # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) x (hd (tl Strat)) +\n  T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have t: \"T\\<^sub>p [y, x] rest2 (tl (tl Strat)) \\<ge> T\\<^sub>p_opt [y, x] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [y, x] rest2 \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}\n    \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<in> {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}\n 2. bdd_below {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       T\\<^sub>p [y, x] rest2 (tl (tl Strat)) =\n       T\\<^sub>p [y, x] rest2 as \\<and>\n       length as = length rest2", "apply(rule exI[where x=\"(tl (tl Strat))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [y, x] rest2 (tl (tl Strat)) =\n    T\\<^sub>p [y, x] rest2 (tl (tl Strat)) \\<and>\n    length (tl (tl Strat)) = length rest2", "by(simp add: lenStrat)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [y, x] rest2 \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) x (hd (tl Strat)) \\<noteq>\n    [x, y] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"1 + T\\<^sub>p_opt [x, y] rest2 \\<le> 2 + T\\<^sub>p_opt [y, x] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2 \\<le> 2 + T\\<^sub>p_opt [y, x] rest2", "using  swapOpt"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  \\<le> 1 + T\\<^sub>p_opt [?y, ?x] ?\\<sigma>\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2 \\<le> 2 + T\\<^sub>p_opt [y, x] rest2", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2 \\<le> 2 + T\\<^sub>p_opt [y, x] rest2\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2 \\<le> 2 + T\\<^sub>p_opt [y, x] rest2\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"\\<dots> \\<le> 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "using t"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [y, x] rest2 \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "also"], ["proof (state)\nthis:\n  2 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "have \"\\<dots> \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "using r"], ["proof (prove)\nusing this:\n  2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "finally"], ["proof (chain)\npicking this:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "show ?thesis"], ["proof (prove)\nusing this:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat", "."], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> = el\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat = el", "using Strat"], ["proof (prove)\nusing this:\n  el = T\\<^sub>p [x, y] (y # x # rest2) Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) Strat = el", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) Strat = el\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # x # rest2) as |as.\n                length as = length (y # x # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y])\n       \\<le> x", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) \\<le> el", "show \"T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) \\<le> el\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) \\<le> el\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) \\<le> el", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # rest2) (OPT2 (y # x # rest2) [x, y]) \\<le> el\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "with Cons1 Cons less(2)"], ["proof (chain)\npicking this:\n  \\<sigma> = a # \\<sigma>'\n  \\<sigma>' = b # rest2\n  set \\<sigma> \\<subseteq> {x, y}\n  b \\<noteq> x", "have bisy: \"b=y\""], ["proof (prove)\nusing this:\n  \\<sigma> = a # \\<sigma>'\n  \\<sigma>' = b # rest2\n  set \\<sigma> \\<subseteq> {x, y}\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. b = y", "by auto"], ["proof (state)\nthis:\n  b = y\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "with less(3)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  b = y", "have \"OPT2 (y # b # rest2) [x, y] = (1,[])# (OPT2 (b#rest2) [y,x])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  b = y\n\ngoal (1 subgoal):\n 1. OPT2 (y # b # rest2) [x, y] = (1, []) # OPT2 (b # rest2) [y, x]", "by simp"], ["proof (state)\nthis:\n  OPT2 (y # b # rest2) [x, y] = (1, []) # OPT2 (b # rest2) [y, x]\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "show \"T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y]) \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)", "unfolding bisy"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] (y # y # rest2)", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n    \\<le> \\<Sqinter> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                      length as = length (y # y # rest2)}", "apply(rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n     length as = length (y # y # rest2)} \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "apply(simp add: Ex_list_of_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "fix el"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "assume \"el \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as. length as = length (y # y # rest2)}\""], ["proof (state)\nthis:\n  el \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n            length as = length (y # y # rest2)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "then"], ["proof (chain)\npicking this:\n  el \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n            length as = length (y # y # rest2)}", "obtain Strat where lenStrat: \"length Strat = length (y # y # rest2)\" and\n                               Strat: \"el = T\\<^sub>p [x, y] (y # y # rest2) Strat\""], ["proof (prove)\nusing this:\n  el \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n            length as = length (y # y # rest2)}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>length Strat = length (y # y # rest2);\n         el = T\\<^sub>p [x, y] (y # y # rest2) Strat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length Strat = length (y # y # rest2)\n  el = T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have v: \" set rest2 \\<subseteq> {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rest2 \\<subseteq> {x, y}", "using less(2)[unfolded Cons1 Cons]"], ["proof (prove)\nusing this:\n  set (a # b # rest2) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set rest2 \\<subseteq> {x, y}", "by auto"], ["proof (state)\nthis:\n  set rest2 \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "let ?L1 = \"(step [x, y] y (hd Strat))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "let ?L2 = \"(step ?L1 y (hd (tl Strat)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "(* lets work on how Strat can look like: *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "let ?a1 = \"hd Strat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "let ?a2 = \"hd (tl Strat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "let ?r = \"tl (tl Strat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have \"Strat = ?a1 # ?a2 # ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Strat = hd Strat # hd (tl Strat) # tl (tl Strat)", "by (metis Nitpick.size_list_simp(2) Suc_length_conv lenStrat list.collapse list.discI list.inject)"], ["proof (state)\nthis:\n  Strat = hd Strat # hd (tl Strat) # tl (tl Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have 1: \"T\\<^sub>p [x, y] (y # y # rest2) Strat\n                        = t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat))\n                            + T\\<^sub>p ?L2 rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have a: \"Strat \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Strat \\<noteq> []", "using lenStrat"], ["proof (prove)\nusing this:\n  length Strat = length (y # y # rest2)\n\ngoal (1 subgoal):\n 1. Strat \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have b: \"(tl Strat) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl Strat \\<noteq> []", "using lenStrat"], ["proof (prove)\nusing this:\n  length Strat = length (y # y # rest2)\n\ngoal (1 subgoal):\n 1. tl Strat \\<noteq> []", "by (metis Nitpick.size_list_simp(2) Suc_length_conv list.discI list.inject)"], ["proof (state)\nthis:\n  tl Strat \\<noteq> []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have 1: \"T\\<^sub>p [x, y] (y # y # rest2) Strat\n                                = t\\<^sub>p [x, y] y (hd Strat) + T\\<^sub>p ?L1 (y # rest2) (tl Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat)", "using splitqsallg[OF a, where a=y and x=x and y=y, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) ?rest1.0 (tl Strat) =\n  T\\<^sub>p [x, y] (y # ?rest1.0) Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat)", "by (simp)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have tt: \"step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow> step [x, y] y (hd Strat) = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    step [x, y] y (hd Strat) = [y, x]", "using stepxy[where A=\"[x,y]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> {?x, ?y}; [x, y] \\<in> {[?x, ?y], [?y, ?x]}\\<rbrakk>\n  \\<Longrightarrow> step [x, y] ?q ?a \\<in> {[?x, ?y], [?y, ?x]}\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    step [x, y] y (hd Strat) = [y, x]", "by blast"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "have 2: \"T\\<^sub>p ?L1 (y # rest2) (tl Strat) = t\\<^sub>p ?L1 y (hd (tl Strat)) +  T\\<^sub>p ?L2 (rest2) (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "apply(cases \"?L1=[x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "using splitqsallg[OF b, where a=y and x=x and y=y, simplified]"], ["proof (prove)\nusing this:\n  t\\<^sub>p [x, y] y (hd (tl Strat)) +\n  T\\<^sub>p (step [x, y] y (hd (tl Strat))) ?rest1.0 (tl (tl Strat)) =\n  T\\<^sub>p [x, y] (y # ?rest1.0) (tl Strat)\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))\n 2. step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n    T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>step [x, y] y (hd Strat) \\<noteq> [x, y];\n     \\<And>rest1.\n        t\\<^sub>p [x, y] y (hd (tl Strat)) +\n        T\\<^sub>p (step [x, y] y (hd (tl Strat))) rest1 (tl (tl Strat)) =\n        T\\<^sub>p [x, y] (y # rest1) (tl Strat)\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2)\n                       (tl Strat) =\n                      t\\<^sub>p (step [x, y] y (hd Strat)) y\n                       (hd (tl Strat)) +\n                      T\\<^sub>p\n                       (step (step [x, y] y (hd Strat)) y (hd (tl Strat)))\n                       rest2 (tl (tl Strat))", "using tt splitqsallg[OF b, where a=y and x=y and y=x, simplified]"], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<noteq> [x, y] \\<Longrightarrow>\n  step [x, y] y (hd Strat) = [y, x]\n  t\\<^sub>p [y, x] y (hd (tl Strat)) +\n  T\\<^sub>p (step [y, x] y (hd (tl Strat))) ?rest1.0 (tl (tl Strat)) =\n  T\\<^sub>p [y, x] (y # ?rest1.0) (tl Strat)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step [x, y] y (hd Strat) \\<noteq> [x, y];\n     \\<And>rest1.\n        t\\<^sub>p [x, y] y (hd (tl Strat)) +\n        T\\<^sub>p (step [x, y] y (hd (tl Strat))) rest1 (tl (tl Strat)) =\n        T\\<^sub>p [x, y] (y # rest1) (tl Strat)\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2)\n                       (tl Strat) =\n                      t\\<^sub>p (step [x, y] y (hd Strat)) y\n                       (hd (tl Strat)) +\n                      T\\<^sub>p\n                       (step (step [x, y] y (hd Strat)) y (hd (tl Strat)))\n                       rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "from 1 2"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat)\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat)\n  T\\<^sub>p (step [x, y] y (hd Strat)) (y # rest2) (tl Strat) =\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n     (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have \" T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n                    =  1 +  T\\<^sub>p [y, x] (rest2) (OPT2 (rest2) [y, x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) =\n    1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])", "using less(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) =\n    1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])", "by(simp add: t\\<^sub>p_def step_def mtf2_def swap_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) =\n  1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) =\n  1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> \\<le> 1 +  T\\<^sub>p_opt [y, x] (rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n    \\<le> 1 + T\\<^sub>p_opt [y, x] rest2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n    \\<le> T\\<^sub>p_opt [y, x] rest2", "apply(rule less(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. length rest2 < length \\<sigma>\n 2. set rest2 \\<subseteq> {y, x}\n 3. y \\<noteq> x", "apply(simp add: less(2) Cons1 Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set rest2 \\<subseteq> {y, x}\n 2. y \\<noteq> x", "using v less(3)"], ["proof (prove)\nusing this:\n  set rest2 \\<subseteq> {x, y}\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. set rest2 \\<subseteq> {y, x}\n 2. y \\<noteq> x", "by(auto)"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n  \\<le> 1 + T\\<^sub>p_opt [y, x] rest2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [y, x] rest2 (OPT2 rest2 [y, x])\n  \\<le> 1 + T\\<^sub>p_opt [y, x] rest2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "proof (cases \"?L2 = [y,x]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) =\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "case True"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) =\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have 2: \"t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat))\n                            + T\\<^sub>p [y,x] rest2 (tl (tl Strat)) \\<ge> t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat))\n                            + T\\<^sub>p_opt [y,x] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p_opt [y, x] rest2\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n          T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [y, x] rest2 \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}\n    \\<le> T\\<^sub>p [y, x] rest2 (tl (tl Strat))", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n    \\<in> {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}\n 2. bdd_below {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       T\\<^sub>p [y, x] rest2 (tl (tl Strat)) =\n       T\\<^sub>p [y, x] rest2 as \\<and>\n       length as = length rest2\n 2. bdd_below {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}", "apply(rule exI[where x=\"tl (tl Strat)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [y, x] rest2 (tl (tl Strat)) =\n    T\\<^sub>p [y, x] rest2 (tl (tl Strat)) \\<and>\n    length (tl (tl Strat)) = length rest2\n 2. bdd_below {T\\<^sub>p [y, x] rest2 as |as. length as = length rest2}", "by (auto simp: lenStrat)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) =\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have 3: \"t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat))\n                            + T\\<^sub>p_opt [y,x] rest2 \\<ge> 1 + T\\<^sub>p_opt [y,x] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n          T\\<^sub>p_opt [y, x] rest2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "have \"t\\<^sub>p [x, y] y (hd Strat) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t\\<^sub>p [x, y] y (hd Strat)", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (let (mf, sws) = hd Strat\n             in index (swaps sws [x, y]) y + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))", "apply(cases \"snd (hd Strat)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (hd Strat) = [] \\<Longrightarrow>\n    Suc 0\n    \\<le> index (swaps (snd (hd Strat)) [x, y]) y + length (snd (hd Strat))\n 2. \\<And>a list.\n       snd (hd Strat) = a # list \\<Longrightarrow>\n       Suc 0\n       \\<le> index (swaps (snd (hd Strat)) [x, y]) y +\n             length (snd (hd Strat))", "by (simp_all add: less(3))"], ["proof (state)\nthis:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)", "show \"Suc 0 \\<le> t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  1 \\<le> t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "by auto"], ["proof (state)\nthis:\n  Suc 0\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p_opt [y, x] rest2\n\ngoal (2 subgoals):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) =\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "from 1 2 3 True"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p_opt [y, x] rest2\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p [y, x] rest2 (tl (tl Strat))\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n        t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n        T\\<^sub>p_opt [y, x] rest2\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "case False"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "note L2F=this"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have L1: \"?L1 \\<in> {[x, y], [y, x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<in> {x, y}\n 2. [x, y] \\<in> {[x, y], [y, x]}", "by simp_all"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have \"?L2 \\<in> {[x, y], [y, x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<in> {[x, y], [y, x]}", "apply(rule stepxy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<in> {x, y}\n 2. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "using L1"], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n\ngoal (2 subgoals):\n 1. y \\<in> {x, y}\n 2. step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}", "by simp_all"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "with False"], ["proof (chain)\npicking this:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<in> {[x, y], [y, x]}", "have 2: \"?L2 = [x,y]\""], ["proof (prove)\nusing this:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [x, y]", "by auto"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [x, y]\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have k: \"T\\<^sub>p [x, y] (y # y # rest2) Strat\n                        =   t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat)) +\n                            T\\<^sub>p [x,y] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "using 1 2"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p (step (step [x, y] y (hd Strat)) y (hd (tl Strat))) rest2\n   (tl (tl Strat))\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [x, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat =\n    t\\<^sub>p [x, y] y (hd Strat) +\n    t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n    T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have l: \"t\\<^sub>p [x, y] y (hd Strat) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] y (hd Strat)", "using less(3)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] y (hd Strat)", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < (let (mf, sws) = hd Strat\n         in index (swaps sws [x, y]) y + length sws)", "apply(cases \"snd (hd Strat) = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; snd (hd Strat) = []\\<rbrakk>\n    \\<Longrightarrow> 0 < (let (mf, sws) = hd Strat\n                           in index (swaps sws [x, y]) y + length sws)\n 2. \\<lbrakk>x \\<noteq> y; snd (hd Strat) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < (let (mf, sws) = hd Strat\n                           in index (swaps sws [x, y]) y + length sws)", "by (simp_all add: split_def)"], ["proof (state)\nthis:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have r: \"T\\<^sub>p [x, y] (y # y # rest2) Strat \\<ge> 2 + T\\<^sub>p [x,y] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "proof (cases \"?L1 = [y,x]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "case False"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) \\<noteq> [y, x]\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "from L1 False"], ["proof (chain)\npicking this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n  step [x, y] y (hd Strat) \\<noteq> [y, x]", "have \"?L1 = [x,y]\""], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) \\<in> {[x, y], [y, x]}\n  step [x, y] y (hd Strat) \\<noteq> [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [x, y]", "by auto"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "note T=this"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "then"], ["proof (chain)\npicking this:\n  step [x, y] y (hd Strat) = [x, y]", "have \"t\\<^sub>p ?L1 y (hd (tl Strat)) > 0\""], ["proof (prove)\nusing this:\n  step [x, y] y (hd Strat) = [x, y]\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "unfolding T"], ["proof (prove)\nusing this:\n  [x, y] = [x, y]\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [x, y] y (hd (tl Strat))", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  [x, y] = [x, y]\n\ngoal (1 subgoal):\n 1. 0 < (let (mf, sws) = hd (tl Strat)\n         in index (swaps sws [x, y]) y + length sws)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index (swaps (snd (hd (tl Strat))) [x, y]) y \\<or>\n    snd (hd (tl Strat)) \\<noteq> []", "apply(cases \"snd (hd (tl Strat)) = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < index (swaps (snd (hd (tl Strat))) [x, y]) y \\<or>\n    snd (hd (tl Strat)) \\<noteq> []\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < index (swaps (snd (hd (tl Strat))) [x, y]) y \\<or>\n    snd (hd (tl Strat)) \\<noteq> []", "using \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < index (swaps (snd (hd (tl Strat))) [x, y]) y \\<or>\n    snd (hd (tl Strat)) \\<noteq> []\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < index (swaps (snd (hd (tl Strat))) [x, y]) y \\<or>\n    snd (hd (tl Strat)) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (2 subgoals):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n 2. step [x, y] y (hd Strat) \\<noteq> [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "with l k"], ["proof (chain)\npicking this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "case True"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "note T=this"], ["proof (state)\nthis:\n  step [x, y] y (hd Strat) = [y, x]\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have \"t\\<^sub>p ?L1 y (hd (tl Strat)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "unfolding T"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "proof(cases \"snd (hd (tl Strat)) = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "case True"], ["proof (state)\nthis:\n  snd (hd (tl Strat)) = []\n\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "have \"?L2 = [y,x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]", "unfolding T"], ["proof (prove)\ngoal (1 subgoal):\n 1. step [y, x] y (hd (tl Strat)) = [y, x]", "apply(simp add: split_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 (fst (hd (tl Strat))) y (swaps (snd (hd (tl Strat))) [y, x]) =\n    [y, x]", "unfolding True mtf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y \\<in> set (swaps [] [y, x])\n     then swaps\n           [index (swaps [] [y, x]) y - fst (hd (tl Strat))..<\n            index (swaps [] [y, x]) y]\n           (swaps [] [y, x])\n     else swaps [] [y, x]) =\n    [y, x]", "by(simp)"], ["proof (state)\nthis:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]\n\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "with L2F"], ["proof (chain)\npicking this:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]", "have \"False\""], ["proof (prove)\nusing this:\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq> [y, x]\n  step (step [x, y] y (hd Strat)) y (hd (tl Strat)) = [y, x]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. snd (hd (tl Strat)) = [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n 2. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  False", "show \"0 < t\\<^sub>p [y, x] y (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [y, x] y (hd (tl Strat))", ".."], ["proof (state)\nthis:\n  0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "case False"], ["proof (state)\nthis:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (hd (tl Strat)) \\<noteq> [] \\<Longrightarrow>\n    0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "then"], ["proof (chain)\npicking this:\n  snd (hd (tl Strat)) \\<noteq> []", "show \"0 < t\\<^sub>p [y, x] y (hd (tl Strat))\""], ["proof (prove)\nusing this:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < t\\<^sub>p [y, x] y (hd (tl Strat))", "unfolding t\\<^sub>p_def"], ["proof (prove)\nusing this:\n  snd (hd (tl Strat)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < (let (mf, sws) = hd (tl Strat)\n         in index (swaps sws [y, x]) y + length sws)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  0 < t\\<^sub>p [y, x] y (hd (tl Strat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "with l"], ["proof (chain)\npicking this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "have \" t\\<^sub>p [x, y] y (hd Strat) + t\\<^sub>p ?L1 y (hd (tl Strat)) \\<ge> 2\""], ["proof (prove)\nusing this:\n  0 < t\\<^sub>p [x, y] y (hd Strat)\n  0 < t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n            t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "by auto"], ["proof (state)\nthis:\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. step [x, y] y (hd Strat) = [y, x] \\<Longrightarrow>\n    2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "with k"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat =\n  t\\<^sub>p [x, y] y (hd Strat) +\n  t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat)) +\n  T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  2 \\<le> t\\<^sub>p [x, y] y (hd Strat) +\n          t\\<^sub>p (step [x, y] y (hd Strat)) y (hd (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have t: \"T\\<^sub>p [x, y] rest2 (tl (tl Strat)) \\<ge> T\\<^sub>p_opt [x, y] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt [x, y] rest2 \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}\n    \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<in> {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}\n 2. bdd_below {T\\<^sub>p [x, y] rest2 as |as. length as = length rest2}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       T\\<^sub>p [x, y] rest2 (tl (tl Strat)) =\n       T\\<^sub>p [x, y] rest2 as \\<and>\n       length as = length rest2", "apply(rule exI[where x=\"(tl (tl Strat))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] rest2 (tl (tl Strat)) =\n    T\\<^sub>p [x, y] rest2 (tl (tl Strat)) \\<and>\n    length (tl (tl Strat)) = length rest2", "by(simp add: lenStrat)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt [x, y] rest2 \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. step (step [x, y] y (hd Strat)) y (hd (tl Strat)) \\<noteq>\n    [y, x] \\<Longrightarrow>\n    1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have \"1 + T\\<^sub>p_opt [y, x] rest2 \\<le> 2 + T\\<^sub>p_opt [x, y] rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2 \\<le> 2 + T\\<^sub>p_opt [x, y] rest2", "using  swapOpt"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [?x, ?y] ?\\<sigma>\n  \\<le> 1 + T\\<^sub>p_opt [?y, ?x] ?\\<sigma>\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2 \\<le> 2 + T\\<^sub>p_opt [x, y] rest2", "by auto"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2 \\<le> 2 + T\\<^sub>p_opt [x, y] rest2\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2 \\<le> 2 + T\\<^sub>p_opt [x, y] rest2\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have \"\\<dots> \\<le> 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "using t"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt [x, y] rest2 \\<le> T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p_opt [x, y] rest2\n    \\<le> 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "also"], ["proof (state)\nthis:\n  2 + T\\<^sub>p_opt [x, y] rest2\n  \\<le> 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "have \"\\<dots> \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "using r"], ["proof (prove)\nusing this:\n  2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. 2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "by auto"], ["proof (state)\nthis:\n  2 + T\\<^sub>p [x, y] rest2 (tl (tl Strat))\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "finally"], ["proof (chain)\npicking this:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "show ?thesis"], ["proof (prove)\nusing this:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p_opt [y, x] rest2\n    \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat", "."], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p_opt [y, x] rest2\n  \\<le> T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "have \"\\<dots> = el\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat = el", "using Strat"], ["proof (prove)\nusing this:\n  el = T\\<^sub>p [x, y] (y # y # rest2) Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) Strat = el", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) Strat = el\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {T\\<^sub>p [x, y] (y # y # rest2) as |as.\n                length as = length (y # y # rest2)} \\<Longrightarrow>\n       T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y])\n       \\<le> x", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) \\<le> el", "show \"T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) \\<le> el\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) \\<le> el\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) \\<le> el", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # rest2) (OPT2 (y # y # rest2) [x, y]) \\<le> el\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # b # rest2) (OPT2 (y # b # rest2) [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (y # b # rest2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # \\<sigma>') (OPT2 (y # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (y # \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (a # \\<sigma>') (OPT2 (a # \\<sigma>') [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] (a # \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n    \\<le> T\\<^sub>p_opt [x, y] \\<sigma>", "qed (simp add: T_opt_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] \\<sigma> (OPT2 \\<sigma> [x, y])\n  \\<le> T\\<^sub>p_opt [x, y] \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_is_ub: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \\<ge> T\\<^sub>p_opt [x,y] qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_opt [x, y] qs\n                      \\<le> T\\<^sub>p [x, y] qs (OPT2 qs [x, y])", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<Sqinter> {T\\<^sub>p [x, y] qs as |as.\n                                  length as = length qs}\n                      \\<le> T\\<^sub>p [x, y] qs (OPT2 qs [x, y])", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n                      \\<in> {T\\<^sub>p [x, y] qs as |as.\n                             length as = length qs}\n 2. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> bdd_below\n                       {T\\<^sub>p [x, y] qs as |as. length as = length qs}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as.\n                         T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) =\n                         T\\<^sub>p [x, y] qs as \\<and>\n                         length as = length qs\n 2. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> bdd_below\n                       {T\\<^sub>p [x, y] qs as |as. length as = length qs}", "apply(rule exI[where x=\"(OPT2 qs [x, y])\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) =\n                      T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<and>\n                      length (OPT2 qs [x, y]) = length qs\n 2. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> bdd_below\n                       {T\\<^sub>p [x, y] qs as |as. length as = length qs}", "by (auto simp add: OPT2_length)"], ["", "lemma OPT2_is_opt: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = T\\<^sub>p_opt [x,y] qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> {x, y}; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) =\n                      T\\<^sub>p_opt [x, y] qs", "by (simp add: OPT2_is_lb OPT2_is_ub antisym)"], ["", "subsection \"Performance on the four phase forms\""], ["", "lemma OPT2_A: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])", "obtain u v where qs: \"qs=u@v\" and u: \"u=[x] \\<or> u=[]\" and v: \"v = [y,y]\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>qs = u @ v; u = [x] \\<or> u = []; v = [y, y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  qs = u @ v\n  u = [x] \\<or> u = []\n  v = [y, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "from u"], ["proof (chain)\npicking this:\n  u = [x] \\<or> u = []", "have pref1: \"T\\<^sub>p [x,y] (u@v) (OPT2 (u@v) [x,y]) = T\\<^sub>p [x,y] v (OPT2 v [x,y])\""], ["proof (prove)\nusing this:\n  u = [x] \\<or> u = []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n    T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(cases \"u=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u = [x] \\<or> u = []; u = []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])\n 2. \\<lbrakk>u = [x] \\<or> u = []; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u = [x] \\<or> u = []; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "by(simp add: OPT2x t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "have ende: \"T\\<^sub>p [x,y] v (OPT2 v [x,y]) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] v (OPT2 v [x, y]) = 1", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [y, y] (OPT2 [y, y] [x, y]) = 1", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [y, y] (OPT2 [y, y] [x, y]) = 1", "by(simp add: mtf2_def swap_def t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) = 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "from pref1 ende qs"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) = 1\n  qs = u @ v", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) = 1\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_A': assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = 1", "using OPT2_A[OF assms]"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = 1", "by simp"], ["", "lemma OPT2_B: assumes \"x \\<noteq> y\" \"qs=u@v\" \"u=[] \\<or> u=[x]\" \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(3)"], ["proof (chain)\npicking this:\n  u = [] \\<or> u = [x]", "have pref1: \"T\\<^sub>p [x,y] (u@v) (OPT2 (u@v) [x,y]) = T\\<^sub>p [x,y] v (OPT2 v [x,y])\""], ["proof (prove)\nusing this:\n  u = [] \\<or> u = [x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n    T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(cases \"u=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u = [] \\<or> u = [x]; u = []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])\n 2. \\<lbrakk>u = [] \\<or> u = [x]; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u = [] \\<or> u = [x]; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "by(simp add: OPT2x t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(4)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "obtain a w where v: \"v=a@w\" and \"a\\<in>lang (Times (Atom y) (Atom x))\" and w: \"w\\<in>lang (seq[Star(Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>a w.\n        \\<lbrakk>v = a @ w; a \\<in> lang (Times (Atom y) (Atom x));\n         w \\<in> lang\n                  (seq [Star (Times (Atom y) (Atom x)), Atom y,\n                        Atom y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  v = a @ w\n  a \\<in> lang (Times (Atom y) (Atom x))\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from this(2)"], ["proof (chain)\npicking this:\n  a \\<in> lang (Times (Atom y) (Atom x))", "have aa: \"a=[y,x]\""], ["proof (prove)\nusing this:\n  a \\<in> lang (Times (Atom y) (Atom x))\n\ngoal (1 subgoal):\n 1. a = [y, x]", "by(simp add: conc_def)"], ["proof (state)\nthis:\n  a = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(1) this v"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  a = [y, x]\n  v = a @ w", "have pref2: \"T\\<^sub>p [x,y] v (OPT2 v [x,y]) = 1 + T\\<^sub>p [x,y] w (OPT2 w [x,y])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  a = [y, x]\n  v = a @ w\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n    1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])", "by(simp add: t\\<^sub>p_def step_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from w"], ["proof (chain)\npicking this:\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "obtain c d where w2: \"w=c@d\" and c: \"c \\<in> lang (Star (Times (Atom y) (Atom x)))\" and d: \"d \\<in> lang (Times (Atom y) (Atom y))\""], ["proof (prove)\nusing this:\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>w = c @ d; c \\<in> lang (Star (Times (Atom y) (Atom x)));\n         d \\<in> lang (Times (Atom y) (Atom y))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Times (Atom y) (Atom y))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "then"], ["proof (chain)\npicking this:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Times (Atom y) (Atom y))", "have dd: \"d=[y,y]\""], ["proof (prove)\nusing this:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Times (Atom y) (Atom y))\n\ngoal (1 subgoal):\n 1. d = [y, y]", "by auto"], ["proof (state)\nthis:\n  d = [y, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from c[simplified]"], ["proof (chain)\npicking this:\n  c \\<in> star ({[y]} @@ {[x]})", "have star: \"T\\<^sub>p [x,y] (c@d) (OPT2 (c@d) [x,y]) = (length c div 2) +  T\\<^sub>p [x,y] d (OPT2 d [x,y])\""], ["proof (prove)\nusing this:\n  c \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n    length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "proof(induct c rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "case (append r s)"], ["proof (state)\nthis:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "then"], ["proof (chain)\npicking this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "have r: \"r=[y,x]\""], ["proof (prove)\nusing this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. r = [y, x]", "by auto"], ["proof (state)\nthis:\n  r = [y, x]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "then"], ["proof (chain)\npicking this:\n  r = [y, x]", "have \"T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) = T\\<^sub>p [x, y] ([y,x] @ (s @ d)) (OPT2 ([y,x] @ (s @ d)) [x, y])\""], ["proof (prove)\nusing this:\n  r = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n    T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "have \"\\<dots> = 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n    1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n    1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])", "by(simp add: t\\<^sub>p_def step_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "have \"\\<dots> =  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n    1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "using append"], ["proof (prove)\nusing this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n    1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "by simp"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "have \"\\<dots> =  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "using r"], ["proof (prove)\nusing this:\n  r = [y, x]\n\ngoal (1 subgoal):\n 1. 1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "by auto"], ["proof (state)\nthis:\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y])", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "qed simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have ende: \"T\\<^sub>p [x,y] d (OPT2 d [x,y]) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 1", "unfolding dd"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [y, y] (OPT2 [y, y] [x, y]) = 1", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [y, y] (OPT2 [y, y] [x, y]) = 1", "by(simp add: mtf2_def swap_def t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have vv: \"v = [y,x]@c@[y,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = [y, x] @ c @ [y, y]", "using w2 dd v aa"], ["proof (prove)\nusing this:\n  w = c @ d\n  d = [y, y]\n  v = a @ w\n  a = [y, x]\n\ngoal (1 subgoal):\n 1. v = [y, x] @ c @ [y, y]", "by auto"], ["proof (state)\nthis:\n  v = [y, x] @ c @ [y, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from pref1 pref2 star w2 ende"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 1", "have\n    \"T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2 + 1\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2 + 1", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) = 1 + length c div 2 + 1", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2 + 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2 + 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have \"\\<dots> = (length v div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length c div 2 + 1 = length v div 2", "using vv"], ["proof (prove)\nusing this:\n  v = [y, x] @ c @ [y, y]\n\ngoal (1 subgoal):\n 1. 1 + length c div 2 + 1 = length v div 2", "by auto"], ["proof (state)\nthis:\n  1 + length c div 2 + 1 = length v div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_B1: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = length qs / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])", "have qs: \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                    Atom y, Atom y])", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2", "have \"(length qs) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])", "have \"qs \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "obtain p q r where pqr: \"qs=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>qs = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[y]} @@ {[y]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}", "have rr: \"p = [y,x]\" \"r=[y,y]\""], ["proof (prove)\nusing this:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [y, y]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "with pqr"], ["proof (chain)\npicking this:\n  qs = p @ q @ r\n  p = [y, x]\n  r = [y, y]", "have a: \"length qs = 4+length q\""], ["proof (prove)\nusing this:\n  qs = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length qs = 4 + length q", "by auto"], ["proof (state)\nthis:\n  length qs = 4 + length q\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "from a b"], ["proof (chain)\npicking this:\n  length qs = 4 + length q\n  length q mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length qs = 4 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 0", "by auto"], ["proof (state)\nthis:\n  length qs mod 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length qs mod 2 = 0\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2", "with OPT2_B[where u=\"[]\", OF assms(1) _ _ qs]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?qs = [] @ qs; [] = [] \\<or> [] = [x]\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) = length qs div 2\n  length qs mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?qs = [] @ qs; [] = [] \\<or> [] = [x]\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) = length qs div 2\n  length qs mod 2 = 0\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2", "by auto"], ["proof (state)\nthis:\n  real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_B2: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = ((length qs - 1) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])", "obtain v where\n      qsv: \"qs = [x]@v\" and vv: \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>qs = [x] @ v;\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y,\n                        Atom y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: conc_def)"], ["proof (state)\nthis:\n  qs = [x] @ v\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "have \"(length v) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[y]} @@ {[y]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}", "have rr: \"p = [y,x]\" \"r=[y,y]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [y, y]", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]", "have a: \"length v = 4+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v = 4 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 4 + length q\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from a b"], ["proof (chain)\npicking this:\n  length v = 4 + length q\n  length q mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length v = 4 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "with OPT2_B[where u=\"[x]\", OF assms(1) qsv _ vv] qsv"], ["proof (chain)\npicking this:\n  [x] = [] \\<or> [x] = [x] \\<Longrightarrow>\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  qs = [x] @ v\n  length v mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  [x] = [] \\<or> [x] = [x] \\<Longrightarrow>\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  qs = [x] @ v\n  length v mod 2 = 0\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "by(auto)"], ["proof (state)\nthis:\n  real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_C: assumes \"x \\<noteq> y\" \"qs=u@v\" \"u=[] \\<or> u=[x]\" \n  and \"v \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(3)"], ["proof (chain)\npicking this:\n  u = [] \\<or> u = [x]", "have pref1: \"T\\<^sub>p [x,y] (u@v) (OPT2 (u@v) [x,y]) = T\\<^sub>p [x,y] v (OPT2 v [x,y])\""], ["proof (prove)\nusing this:\n  u = [] \\<or> u = [x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n    T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(cases \"u=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u = [] \\<or> u = [x]; u = []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])\n 2. \\<lbrakk>u = [] \\<or> u = [x]; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u = [] \\<or> u = [x]; u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n                      T\\<^sub>p [x, y] v (OPT2 v [x, y])", "by(simp add: OPT2x t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(4)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "obtain a w where v: \"v=a@w\" and aa: \"a=[y,x]\" and w: \"w\\<in>lang (seq[Star(Times (Atom y) (Atom x)), Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>a w.\n        \\<lbrakk>v = a @ w; a = [y, x];\n         w \\<in> lang\n                  (seq [Star (Times (Atom y) (Atom x)), Atom x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: conc_def)"], ["proof (state)\nthis:\n  v = a @ w\n  a = [y, x]\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from assms(1) this v"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  v = a @ w\n  a = [y, x]\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom x])\n  v = a @ w", "have pref2: \"T\\<^sub>p [x,y] v (OPT2 v [x,y]) = 1 + T\\<^sub>p [x,y] w (OPT2 w [x,y])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  v = a @ w\n  a = [y, x]\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom x])\n  v = a @ w\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n    1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])", "by(simp add: t\\<^sub>p_def step_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from w"], ["proof (chain)\npicking this:\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom x])", "obtain c d where w2: \"w=c@d\" and c: \"c \\<in> lang (Star (Times (Atom y) (Atom x)))\" and d: \"d \\<in> lang (Atom x)\""], ["proof (prove)\nusing this:\n  w \\<in> lang (seq [Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>w = c @ d; c \\<in> lang (Star (Times (Atom y) (Atom x)));\n         d \\<in> lang (Atom x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Atom x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "then"], ["proof (chain)\npicking this:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Atom x)", "have dd: \"d=[x]\""], ["proof (prove)\nusing this:\n  w = c @ d\n  c \\<in> lang (Star (Times (Atom y) (Atom x)))\n  d \\<in> lang (Atom x)\n\ngoal (1 subgoal):\n 1. d = [x]", "by auto"], ["proof (state)\nthis:\n  d = [x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from c[simplified]"], ["proof (chain)\npicking this:\n  c \\<in> star ({[y]} @@ {[x]})", "have star: \"T\\<^sub>p [x,y] (c@d) (OPT2 (c@d) [x,y]) = (length c div 2) +  T\\<^sub>p [x,y] d (OPT2 d [x,y]) \\<and> (length c) mod 2 = 0\""], ["proof (prove)\nusing this:\n  c \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n    length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length c mod 2 = 0", "proof(induct c rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "case (append r s)"], ["proof (state)\nthis:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "from append"], ["proof (chain)\npicking this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0", "have mod: \"length s mod 2 = 0\""], ["proof (prove)\nusing this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0\n\ngoal (1 subgoal):\n 1. length s mod 2 = 0", "by simp"], ["proof (state)\nthis:\n  length s mod 2 = 0\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "from append"], ["proof (chain)\npicking this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0", "have r: \"r=[y,x]\""], ["proof (prove)\nusing this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0\n\ngoal (1 subgoal):\n 1. r = [y, x]", "by auto"], ["proof (state)\nthis:\n  r = [y, x]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  r = [y, x]", "have \"T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) = T\\<^sub>p [x, y] ([y,x] @ (s @ d)) (OPT2 ([y,x] @ (s @ d)) [x, y])\""], ["proof (prove)\nusing this:\n  r = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n    T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "have \"\\<dots> = 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n    1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n    1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])", "by(simp add: t\\<^sub>p_def step_def OPT2x)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ([y, x] @ s @ d) (OPT2 ([y, x] @ s @ d) [x, y]) =\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "have \"\\<dots> =  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n    1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "using append"], ["proof (prove)\nusing this:\n  r \\<in> {[y]} @@ {[x]}\n  s \\<in> star ({[y]} @@ {[x]})\n  T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length s mod 2 = 0\n\ngoal (1 subgoal):\n 1. 1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n    1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "by simp"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "also"], ["proof (state)\nthis:\n  1 + T\\<^sub>p [x, y] (s @ d) (OPT2 (s @ d) [x, y]) =\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "have \"\\<dots> =  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "using r"], ["proof (prove)\nusing this:\n  r = [y, x]\n\ngoal (1 subgoal):\n 1. 1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "by auto"], ["proof (state)\nthis:\n  1 + length s div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        T\\<^sub>p [x, y] (v @ d) (OPT2 (v @ d) [x, y]) =\n        length v div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] ((u @ v) @ d)\n                          (OPT2 ((u @ v) @ d) [x, y]) =\n                         length (u @ v) div 2 +\n                         T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n                         length (u @ v) mod 2 = 0", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n    length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length (r @ s) mod 2 = 0", "by(simp add: mod r)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] ((r @ s) @ d) (OPT2 ((r @ s) @ d) [x, y]) =\n  length (r @ s) div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length (r @ s) mod 2 = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] ([] @ d) (OPT2 ([] @ d) [x, y]) =\n    length [] div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n    length [] mod 2 = 0", "qed simp"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length c mod 2 = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have ende: \"T\\<^sub>p [x,y] d (OPT2 d [x,y]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 0", "unfolding dd"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [x] (OPT2 [x] [x, y]) = 0", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] [x] (OPT2 [x] [x, y]) = 0", "by(simp add: mtf2_def swap_def t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have vv: \"v = [y,x]@c@[x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = [y, x] @ c @ [x]", "using w2 dd v aa"], ["proof (prove)\nusing this:\n  w = c @ d\n  d = [x]\n  v = a @ w\n  a = [y, x]\n\ngoal (1 subgoal):\n 1. v = [y, x] @ c @ [x]", "by auto"], ["proof (state)\nthis:\n  v = [y, x] @ c @ [x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "from pref1 pref2 star w2 ende"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length c mod 2 = 0\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 0", "have\n    \"T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length c mod 2 = 0\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) =\n  T\\<^sub>p [x, y] v (OPT2 v [x, y])\n  T\\<^sub>p [x, y] v (OPT2 v [x, y]) =\n  1 + T\\<^sub>p [x, y] w (OPT2 w [x, y])\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length c mod 2 = 0\n  w = c @ d\n  T\\<^sub>p [x, y] d (OPT2 d [x, y]) = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (u @ v) (OPT2 (u @ v) [x, y]) = 1 + length c div 2", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1 + length c div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "have \"\\<dots> = (length v div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length c div 2 = length v div 2", "using vv star"], ["proof (prove)\nusing this:\n  v = [y, x] @ c @ [x]\n  T\\<^sub>p [x, y] (c @ d) (OPT2 (c @ d) [x, y]) =\n  length c div 2 + T\\<^sub>p [x, y] d (OPT2 d [x, y]) \\<and>\n  length c mod 2 = 0\n\ngoal (1 subgoal):\n 1. 1 + length c div 2 = length v div 2", "by auto"], ["proof (state)\nthis:\n  1 + length c div 2 = length v div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_C1: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"real (T\\<^sub>p [x,y] qs (OPT2 qs [x,y])) = (length qs - 1) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "have qs: \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "have \"(length qs) mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "have \"qs \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[x]}\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "then"], ["proof (chain)\npicking this:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "obtain p q r where pqr: \"qs=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[x]}\""], ["proof (prove)\nusing this:\n  qs \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>qs = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[x]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "then"], ["proof (chain)\npicking this:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}", "have rr: \"p = [y,x]\" \"r=[x]\""], ["proof (prove)\nusing this:\n  qs = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [x]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "with pqr"], ["proof (chain)\npicking this:\n  qs = p @ q @ r\n  p = [y, x]\n  r = [x]", "have a: \"length qs = 3+length q\""], ["proof (prove)\nusing this:\n  qs = p @ q @ r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length qs = 3 + length q", "by auto"], ["proof (state)\nthis:\n  length qs = 3 + length q\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "from a b"], ["proof (chain)\npicking this:\n  length qs = 3 + length q\n  length q mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length qs = 3 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length qs mod 2 = 1", "by auto"], ["proof (state)\nthis:\n  length qs mod 2 = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length qs mod 2 = 1\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "with OPT2_C[where u=\"[]\", OF assms(1) _ _ qs]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?qs = [] @ qs; [] = [] \\<or> [] = [x]\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) = length qs div 2\n  length qs mod 2 = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?qs = [] @ qs; [] = [] \\<or> [] = [x]\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p [x, y] ?qs (OPT2 ?qs [x, y]) = length qs div 2\n  length qs mod 2 = 1\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length qs div 2;\n     length qs mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> real (length qs div 2) * 2 = real (length qs - Suc 0)", "by (metis minus_mod_eq_div_mult [symmetric] of_nat_mult of_nat_numeral)"], ["proof (state)\nthis:\n  real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 1) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_C2: assumes \"x \\<noteq> y\" \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n  shows \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = ((length qs - 2) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2", "from assms(2)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])", "obtain v where\n      qsv: \"qs = [x]@v\" and vv: \"v \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>qs = [x] @ v;\n         v \\<in> lang\n                  (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                        Atom x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: conc_def)"], ["proof (state)\nthis:\n  qs = [x] @ v\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2", "have \"(length v) mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "have \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[x]}\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "by (simp add: conc_assoc)"], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[x]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[x]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}", "have rr: \"p = [y,x]\" \"r=[x]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [x]", "by(auto simp add: conc_def)"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]", "have a: \"length v = 3+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length v = 3 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 3 + length q\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "from a b"], ["proof (chain)\npicking this:\n  length v = 3 + length q\n  length q mod 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length v = 3 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 1\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2", "with OPT2_C[where u=\"[x]\", OF assms(1) qsv _ vv] qsv"], ["proof (chain)\npicking this:\n  [x] = [] \\<or> [x] = [x] \\<Longrightarrow>\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  qs = [x] @ v\n  length v mod 2 = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  [x] = [] \\<or> [x] = [x] \\<Longrightarrow>\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  qs = [x] @ v\n  length v mod 2 = 1\n\ngoal (1 subgoal):\n 1. real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p [x, y] (x # v) (OPT2 (x # v) [x, y]) =\n             length v div 2;\n     qs = x # v; length v mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> real (length v div 2) * 2 = real (length v - Suc 0)", "by (metis minus_mod_eq_div_mult [symmetric] of_nat_mult of_nat_numeral)"], ["proof (state)\nthis:\n  real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) = real (length qs - 2) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT2_ub: \"set qs \\<subseteq> {x,y} \\<Longrightarrow> T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \\<le> length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set qs \\<subseteq> {x, y} \\<Longrightarrow>\n    T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs", "proof(induct qs arbitrary: x y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       set [] \\<subseteq> {x, y} \\<Longrightarrow>\n       T\\<^sub>p [x, y] [] (OPT2 [] [x, y]) \\<le> length []\n 2. \\<And>a qs x y.\n       \\<lbrakk>\\<And>x y.\n                   set qs \\<subseteq> {x, y} \\<Longrightarrow>\n                   T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs;\n        set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] (a # qs) (OPT2 (a # qs) [x, y])\n                         \\<le> length (a # qs)", "case (Cons q qs)"], ["proof (state)\nthis:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       set [] \\<subseteq> {x, y} \\<Longrightarrow>\n       T\\<^sub>p [x, y] [] (OPT2 [] [x, y]) \\<le> length []\n 2. \\<And>a qs x y.\n       \\<lbrakk>\\<And>x y.\n                   set qs \\<subseteq> {x, y} \\<Longrightarrow>\n                   T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs;\n        set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] (a # qs) (OPT2 (a # qs) [x, y])\n                         \\<le> length (a # qs)", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}", "have \"set qs \\<subseteq> {x,y}\" \"q\\<in>{x,y}\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set qs \\<subseteq> {x, y} &&& q \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       set [] \\<subseteq> {x, y} \\<Longrightarrow>\n       T\\<^sub>p [x, y] [] (OPT2 [] [x, y]) \\<le> length []\n 2. \\<And>a qs x y.\n       \\<lbrakk>\\<And>x y.\n                   set qs \\<subseteq> {x, y} \\<Longrightarrow>\n                   T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs;\n        set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] (a # qs) (OPT2 (a # qs) [x, y])\n                         \\<le> length (a # qs)", "note Cons1=Cons this"], ["proof (state)\nthis:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       set [] \\<subseteq> {x, y} \\<Longrightarrow>\n       T\\<^sub>p [x, y] [] (OPT2 [] [x, y]) \\<le> length []\n 2. \\<And>a qs x y.\n       \\<lbrakk>\\<And>x y.\n                   set qs \\<subseteq> {x, y} \\<Longrightarrow>\n                   T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs;\n        set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [x, y] (a # qs) (OPT2 (a # qs) [x, y])\n                         \\<le> length (a # qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)", "proof (cases qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)\n 2. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "case Nil"], ["proof (state)\nthis:\n  qs = []\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)\n 2. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "with Cons1"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = []", "show \"T\\<^sub>p [x,y] (q # qs) (OPT2 (q # qs) [x,y]) \\<le> length (q # qs)\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)", "apply(simp add: t\\<^sub>p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                On_Off.T step\n                 (\\<lambda>a b (mf, sws).\n                     index (swaps sws a) b + length sws)\n                 [x, y] [] [] =\n                0;\n     q = x \\<or> q = y; qs = []\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> q \\<longrightarrow> x = q", "by blast"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "case (Cons q' qs')"], ["proof (state)\nthis:\n  qs = q' # qs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "with Cons1"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'", "have \"q'\\<in>{x,y}\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'\n\ngoal (1 subgoal):\n 1. q' \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "note Cons=Cons this"], ["proof (state)\nthis:\n  qs = q' # qs'\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "from Cons1 Cons"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'\n  q' \\<in> {x, y}", "have T: \"T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs\"\n                            \"T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs &&&\n    T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs\n  T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       qs = a # list \\<Longrightarrow>\n       T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y])\n       \\<le> length (q # qs)", "show \"T\\<^sub>p [x,y] (q # qs) (OPT2 (q # qs) [x,y]) \\<le> length (q # qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # q' # qs') (OPT2 (q # q' # qs') [x, y])\n    \\<le> length (q # q' # qs')", "apply(simp only: OPT2.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # q' # qs')\n     (if q = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n           else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "apply(split if_splits(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = x \\<longrightarrow>\n     T\\<^sub>p [x, y] (q # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n     \\<le> length (q # q' # qs')) \\<and>\n    (q \\<noteq> x \\<longrightarrow>\n     T\\<^sub>p [x, y] (q # q' # qs')\n      (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n       else (1, []) # OPT2 (q' # qs') [y, x])\n     \\<le> length (q # q' # qs'))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "proof (goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "case 1"], ["proof (state)\nthis:\n  q = x\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "have \"T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n                      = t\\<^sub>p [x, y] x (0,[]) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y]) =\n    t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])", "by(simp add: step_def Cons)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y]) =\n  t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y]) =\n  t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "have \"\\<dots> \\<le> t\\<^sub>p [x, y] x (0,[]) + length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<le> t\\<^sub>p [x, y] x (0, []) + length qs", "using T"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs\n  T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<le> t\\<^sub>p [x, y] x (0, []) + length qs", "by auto"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  \\<le> t\\<^sub>p [x, y] x (0, []) + length qs\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "also"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  \\<le> t\\<^sub>p [x, y] x (0, []) + length qs\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "have \"\\<dots> \\<le> length (x # q' # qs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (0, []) + length qs \\<le> length (x # q' # qs')", "using Cons"], ["proof (prove)\nusing this:\n  qs = q' # qs'\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] x (0, []) + length qs \\<le> length (x # q' # qs')", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] x (0, []) + length qs \\<le> length (x # q' # qs')\n\ngoal (2 subgoals):\n 1. q = x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')\n 2. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n  \\<le> length (x # q' # qs')", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n  \\<le> length (x # q' # qs')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n    \\<le> length (x # q' # qs')", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (x # q' # qs') ((0, []) # OPT2 (q' # qs') [x, y])\n  \\<le> length (x # q' # qs')\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "case 2"], ["proof (state)\nthis:\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. q \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "with Cons1 Cons"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'\n  q' \\<in> {x, y}\n  q \\<noteq> x", "show ?case"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] qs (OPT2 qs [?x, ?y]) \\<le> length qs\n  set (q # qs) \\<subseteq> {x, y}\n  set qs \\<subseteq> {x, y}\n  q \\<in> {x, y}\n  qs = q' # qs'\n  q' \\<in> {x, y}\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (q # q' # qs')\n     (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n      else (1, []) # OPT2 (q' # qs') [y, x])\n    \\<le> length (q # q' # qs')", "apply(split if_splits(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set qs \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs;\n     set (q # qs) \\<subseteq> {x, y}; set qs \\<subseteq> {x, y};\n     q \\<in> {x, y}; qs = q' # qs'; q' \\<in> {x, y}; q \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (q' = x \\<longrightarrow>\n                       T\\<^sub>p [x, y] (q # q' # qs')\n                        ((0, []) # OPT2 (q' # qs') [x, y])\n                       \\<le> length (q # q' # qs')) \\<and>\n                      (q' \\<noteq> x \\<longrightarrow>\n                       T\\<^sub>p [x, y] (q # q' # qs')\n                        ((1, []) # OPT2 (q' # qs') [y, x])\n                       \\<le> length (q # q' # qs'))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "proof (goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "case 1"], ["proof (state)\nthis:\n  set (x # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (x # qs') (OPT2 (x # qs') [?x, ?y])\n  \\<le> length (x # qs')\n  set (y # x # qs') \\<subseteq> {x, y}\n  set (x # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = x # qs'\n  q = y\n  q' = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "then"], ["proof (chain)\npicking this:\n  set (x # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (x # qs') (OPT2 (x # qs') [?x, ?y])\n  \\<le> length (x # qs')\n  set (y # x # qs') \\<subseteq> {x, y}\n  set (x # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = x # qs'\n  q = y\n  q' = x", "have \"T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y])\n                          = t\\<^sub>p [x, y] y (0,[]) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\nusing this:\n  set (x # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (x # qs') (OPT2 (x # qs') [?x, ?y])\n  \\<le> length (x # qs')\n  set (y # x # qs') \\<subseteq> {x, y}\n  set (x # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = x # qs'\n  q = y\n  q' = x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y]) =\n    t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])", "by(simp add: step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y]) =\n  t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y]) =\n  t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "have \"\\<dots> \\<le> t\\<^sub>p [x, y] y (0,[]) + length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<le> t\\<^sub>p [x, y] y (0, []) + length qs", "using T"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs\n  T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n    \\<le> t\\<^sub>p [x, y] y (0, []) + length qs", "by auto"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  \\<le> t\\<^sub>p [x, y] y (0, []) + length qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "also"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (0, []) + T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\n  \\<le> t\\<^sub>p [x, y] y (0, []) + length qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "have \"\\<dots> \\<le> length (y # x # qs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) + length qs \\<le> length (y # x # qs')", "using Cons"], ["proof (prove)\nusing this:\n  qs = q' # qs'\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (0, []) + length qs \\<le> length (y # x # qs')", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (0, []) + length qs \\<le> length (y # x # qs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                set (x # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (x # qs') (OPT2 (x # qs') [x, y])\n                \\<le> length (x # qs');\n     set (y # x # qs') \\<subseteq> {x, y}; set (x # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = x # qs'; q = y; q' = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # x # qs')\n                       ((0, []) # OPT2 (x # qs') [x, y])\n                      \\<le> length (y # x # qs')\n 2. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y])\n  \\<le> length (y # x # qs')", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y])\n  \\<le> length (y # x # qs')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y])\n    \\<le> length (y # x # qs')", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # x # qs') ((0, []) # OPT2 (x # qs') [x, y])\n  \\<le> length (y # x # qs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "case 2"], ["proof (state)\nthis:\n  set (y # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (y # qs') (OPT2 (y # qs') [?x, ?y])\n  \\<le> length (y # qs')\n  set (y # y # qs') \\<subseteq> {x, y}\n  set (y # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = y # qs'\n  q = y\n  q' = y\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "then"], ["proof (chain)\npicking this:\n  set (y # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (y # qs') (OPT2 (y # qs') [?x, ?y])\n  \\<le> length (y # qs')\n  set (y # y # qs') \\<subseteq> {x, y}\n  set (y # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = y # qs'\n  q = y\n  q' = y\n  y \\<noteq> x", "have \"T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x])\n                          = t\\<^sub>p [x, y] y (1,[]) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\""], ["proof (prove)\nusing this:\n  set (y # qs') \\<subseteq> {?x, ?y} \\<Longrightarrow>\n  T\\<^sub>p [?x, ?y] (y # qs') (OPT2 (y # qs') [?x, ?y])\n  \\<le> length (y # qs')\n  set (y # y # qs') \\<subseteq> {x, y}\n  set (y # qs') \\<subseteq> {x, y}\n  y \\<noteq> x\n  qs = y # qs'\n  q = y\n  q' = y\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x]) =\n    t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])", "by(simp add: step_def mtf2_def swap_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x]) =\n  t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "also"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x]) =\n  t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "have \"\\<dots> \\<le> t\\<^sub>p [x, y] y (1,[]) + length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n    \\<le> t\\<^sub>p [x, y] y (1, []) + length qs", "using T"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) \\<le> length qs\n  T\\<^sub>p [y, x] qs (OPT2 qs [y, x]) \\<le> length qs\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n    \\<le> t\\<^sub>p [x, y] y (1, []) + length qs", "by auto"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n  \\<le> t\\<^sub>p [x, y] y (1, []) + length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "also"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (1, []) + T\\<^sub>p [y, x] qs (OPT2 qs [y, x])\n  \\<le> t\\<^sub>p [x, y] y (1, []) + length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "have \"\\<dots> \\<le> length (y # y # qs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (1, []) + length qs \\<le> length (y # y # qs')", "using Cons"], ["proof (prove)\nusing this:\n  qs = q' # qs'\n  q' \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. t\\<^sub>p [x, y] y (1, []) + length qs \\<le> length (y # y # qs')", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  t\\<^sub>p [x, y] y (1, []) + length qs \\<le> length (y # y # qs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                set (y # qs') \\<subseteq> {x, y} \\<Longrightarrow>\n                T\\<^sub>p [x, y] (y # qs') (OPT2 (y # qs') [x, y])\n                \\<le> length (y # qs');\n     set (y # y # qs') \\<subseteq> {x, y}; set (y # qs') \\<subseteq> {x, y};\n     y \\<noteq> x; qs = y # qs'; q = y; q' = y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (y # y # qs')\n                       ((1, []) # OPT2 (y # qs') [y, x])\n                      \\<le> length (y # y # qs')", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x])\n  \\<le> length (y # y # qs')", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x])\n  \\<le> length (y # y # qs')\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x])\n    \\<le> length (y # y # qs')", "."], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (y # y # qs') ((1, []) # OPT2 (y # qs') [y, x])\n  \\<le> length (y # y # qs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (q # q' # qs')\n   (if q' = x then (0, []) # OPT2 (q' # qs') [x, y]\n    else (1, []) # OPT2 (q' # qs') [y, x])\n  \\<le> length (q # q' # qs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] (q # qs) (OPT2 (q # qs) [x, y]) \\<le> length (q # qs)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       set [] \\<subseteq> {x, y} \\<Longrightarrow>\n       T\\<^sub>p [x, y] [] (OPT2 [] [x, y]) \\<le> length []", "qed simp"], ["", "lemma OPT2_padded: \"R\\<in>{[x,y],[y,x]} \\<Longrightarrow> set qs \\<subseteq> {x,y} \n      \\<Longrightarrow>  T\\<^sub>p R (qs@[x,x]) (OPT2 (qs@[x,x]) R)\n              \\<le> T\\<^sub>p R (qs@[x]) (OPT2 (qs@[x]) R) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x]) (OPT2 (qs @ [x, x]) R)\n                      \\<le> T\\<^sub>p R (qs @ [x]) (OPT2 (qs @ [x]) R) + 1", "apply(induct qs arbitrary: R)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ([] @ [x, x]) (OPT2 ([] @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ([] @ [x]) (OPT2 ([] @ [x]) R) +\n                               1\n 2. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R.\n       R = [x, y] \\<or> R = [y, x] \\<Longrightarrow>\n       T\\<^sub>p R [x, x] (OPT2 [x, x] R)\n       \\<le> Suc (T\\<^sub>p R [x] (OPT2 [x] R))\n 2. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(case_tac \"R=[x,y]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; R = [x, y]\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R [x, x] (OPT2 [x, x] R)\n                         \\<le> Suc (T\\<^sub>p R [x] (OPT2 [x] R))\n 2. \\<And>R.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; R \\<noteq> [x, y]\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R [x, x] (OPT2 [x, x] R)\n                         \\<le> Suc (T\\<^sub>p R [x] (OPT2 [x] R))\n 3. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def t\\<^sub>p_def )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; R \\<noteq> [x, y]\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R [x, x] (OPT2 [x, x] R)\n                         \\<le> Suc (T\\<^sub>p R [x] (OPT2 [x] R))\n 2. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def mtf2_def swap_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "case (1 a qs R)"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}", "have a: \"a \\<in> {x,y}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. a \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a qs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n  a \\<in> {x, y}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(cases qs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(cases \"a=x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a = x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a = x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 4. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def mtf2_def swap_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                 set qs \\<subseteq> {x, y}\\<rbrakk>\n                \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n                                   (OPT2 (qs @ [x, x]) R)\n                                  \\<le> T\\<^sub>p R (qs @ [x])\n   (OPT2 (qs @ [x]) R) +\n  1;\n     R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n     a \\<in> {x, y}; qs = []; a \\<noteq> x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "apply(simp add: step_def mtf2_def swap_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "case (1 p ps)"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n  a \\<in> {x, y}\n  qs = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set qs \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> T\\<^sub>p R (qs @ [x, x])\n(OPT2 (qs @ [x, x]) R)\n                                     \\<le> T\\<^sub>p R (qs @ [x])\n      (OPT2 (qs @ [x]) R) +\n     1;\n        R \\<in> {[x, y], [y, x]}; set (a # qs) \\<subseteq> {x, y};\n        a \\<in> {x, y}; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                          (OPT2 ((a # qs) @ [x, x]) R)\n                         \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                                (OPT2 ((a # qs) @ [x]) R) +\n                               1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(cases \"a=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. \\<lbrakk>a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(simp add: OPT2x step_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (qs @ [x, x])\n                       (OPT2 (qs @ [x, x]) [x, y])\n                      \\<le> Suc (T\\<^sub>p [x, y] (qs @ [x])\n                                  (OPT2 (qs @ [x]) [x, y]))\n 2. \\<lbrakk>a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n  a \\<in> {x, y}\n  qs = p # ps\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; R = [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [x, y] (qs @ [x, x])\n                       (OPT2 (qs @ [x, x]) [x, y])\n                      \\<le> Suc (T\\<^sub>p [x, y] (qs @ [x])\n                                  (OPT2 (qs @ [x]) [x, y]))\n 2. \\<lbrakk>a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 3. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "using 1(2)"], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; R \\<noteq> [x, y]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p R ((a # qs) @ [x, x])\n                       (OPT2 ((a # qs) @ [x, x]) R)\n                      \\<le> T\\<^sub>p R ((a # qs) @ [x])\n                             (OPT2 ((a # qs) @ [x]) R) +\n                            1\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; y \\<noteq> x; R = [y, x]\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [y, x] (x # qs @ [x, x])\n                       (OPT2 (x # qs @ [x, x]) [y, x])\n                      \\<le> Suc (T\\<^sub>p [y, x] (x # qs @ [x])\n                                  (OPT2 (x # qs @ [x]) [y, x]))\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(cases qs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; y \\<noteq> x; R = [y, x]; qs = []\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p [y, x] (x # qs @ [x, x])\n                       (OPT2 (x # qs @ [x, x]) [y, x])\n                      \\<le> Suc (T\\<^sub>p [y, x] (x # qs @ [x])\n                                  (OPT2 (x # qs @ [x]) [y, x]))\n 2. \\<And>aa list.\n       \\<lbrakk>a = x; y \\<noteq> x; R = [y, x]; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [y, x] (x # qs @ [x, x])\n                          (OPT2 (x # qs @ [x, x]) [y, x])\n                         \\<le> Suc (T\\<^sub>p [y, x] (x # qs @ [x])\n                                     (OPT2 (x # qs @ [x]) [y, x]))\n 3. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "apply(simp add: step_def mtf2_def swap_def t\\<^sub>p_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>a = x; y \\<noteq> x; R = [y, x]; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [y, x] (x # qs @ [x, x])\n                          (OPT2 (x # qs @ [x, x]) [y, x])\n                         \\<le> Suc (T\\<^sub>p [y, x] (x # qs @ [x])\n                                     (OPT2 (x # qs @ [x]) [y, x]))\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set qs \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p ?R (qs @ [x, x]) (OPT2 (qs @ [x, x]) ?R)\n                    \\<le> T\\<^sub>p ?R (qs @ [x]) (OPT2 (qs @ [x]) ?R) + 1\n  R \\<in> {[x, y], [y, x]}\n  set (a # qs) \\<subseteq> {x, y}\n  a \\<in> {x, y}\n  qs = p # ps\n\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>a = x; y \\<noteq> x; R = [y, x]; qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p [y, x] (x # qs @ [x, x])\n                          (OPT2 (x # qs @ [x, x]) [y, x])\n                         \\<le> Suc (T\\<^sub>p [y, x] (x # qs @ [x])\n                                     (OPT2 (x # qs @ [x]) [y, x]))\n 2. a \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n    \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1", "by(auto simp add: swap_def mtf2_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n  \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p R ((a # qs) @ [x, x]) (OPT2 ((a # qs) @ [x, x]) R)\n  \\<le> T\\<^sub>p R ((a # qs) @ [x]) (OPT2 ((a # qs) @ [x]) R) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  OPT2_split11:\n  assumes xy: \"x\\<noteq>y\"\n  shows \"R\\<in>{[x,y],[y,x]} \\<Longrightarrow> set xs \\<subseteq> {x,y} \\<Longrightarrow> set ys \\<subseteq> {x,y} \\<Longrightarrow> OPT2 (xs@[x,x]@ys) R = OPT2 (xs@[x,x]) R @ OPT2 ys [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<in> {[x, y], [y, x]}; set xs \\<subseteq> {x, y};\n     set ys \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                      OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y]", "proof (induct xs arbitrary: R)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ([] @ [x, x] @ ys) R =\n                         OPT2 ([] @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "case Nil"], ["proof (state)\nthis:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>R \\<in> {[x, y], [y, x]}; set [] \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ([] @ [x, x] @ ys) R =\n                         OPT2 ([] @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "then"], ["proof (chain)\npicking this:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}", "show ?case"], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n  set [] \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. OPT2 ([] @ [x, x] @ ys) R = OPT2 ([] @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y}\\<rbrakk>\n    \\<Longrightarrow> OPT2 (x # x # ys) R = OPT2 [x, x] R @ OPT2 ys [x, y]", "apply(cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> OPT2 (x # x # ys) R = OPT2 [x, x] R @ OPT2 ys [x, y]\n 2. \\<And>a list.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # x # ys) R =\n                         OPT2 [x, x] R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # x # ys) R =\n                         OPT2 [x, x] R @ OPT2 ys [x, y]", "apply(cases \"R=[x,y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n        ys = a # list; R = [x, y]\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # x # ys) R =\n                         OPT2 [x, x] R @ OPT2 ys [x, y]\n 2. \\<And>a list.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n        ys = a # list; R \\<noteq> [x, y]\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # x # ys) R =\n                         OPT2 [x, x] R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>R = [x, y] \\<or> R = [y, x]; set ys \\<subseteq> {x, y};\n        ys = a # list; R \\<noteq> [x, y]\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # x # ys) R =\n                         OPT2 [x, x] R @ OPT2 ys [x, y]", "by(simp)"], ["proof (state)\nthis:\n  OPT2 ([] @ [x, x] @ ys) R = OPT2 ([] @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set as \\<subseteq> {x, y};\n   set ys \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> OPT2 (as @ [x, x] @ ys) ?R =\n                    OPT2 (as @ [x, x]) ?R @ OPT2 ys [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (a # as) \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "note iH=this"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set as \\<subseteq> {x, y};\n   set ys \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> OPT2 (as @ [x, x] @ ys) ?R =\n                    OPT2 (as @ [x, x]) ?R @ OPT2 ys [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (a # as) \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set as \\<subseteq> {x, y};\n   set ys \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> OPT2 (as @ [x, x] @ ys) ?R =\n                    OPT2 (as @ [x, x]) ?R @ OPT2 ys [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (a # as) \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}", "have AS: \"set as \\<subseteq> {x,y}\" and A: \"a \\<in> {x,y}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> {[x, y], [y, x]}; set as \\<subseteq> {x, y};\n   set ys \\<subseteq> {x, y}\\<rbrakk>\n  \\<Longrightarrow> OPT2 (as @ [x, x] @ ys) ?R =\n                    OPT2 (as @ [x, x]) ?R @ OPT2 ys [x, y]\n  R \\<in> {[x, y], [y, x]}\n  set (a # as) \\<subseteq> {x, y}\n  set ys \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. set as \\<subseteq> {x, y} &&& a \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  set as \\<subseteq> {x, y}\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "note iH=Cons(1)[where R=\"[y,x]\", simplified, OF AS Cons(4)]"], ["proof (state)\nthis:\n  OPT2 (as @ x # x # ys) [y, x] = OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "note iH'=Cons(1)[where R=\"[x,y]\", simplified, OF AS Cons(4)]"], ["proof (state)\nthis:\n  OPT2 (as @ x # x # ys) [x, y] = OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. \\<And>a xs R.\n       \\<lbrakk>\\<And>R.\n                   \\<lbrakk>R \\<in> {[x, y], [y, x]};\n                    set xs \\<subseteq> {x, y};\n                    set ys \\<subseteq> {x, y}\\<rbrakk>\n                   \\<Longrightarrow> OPT2 (xs @ [x, x] @ ys) R =\n                                     OPT2 (xs @ [x, x]) R @ OPT2 ys [x, y];\n        R \\<in> {[x, y], [y, x]}; set (a # xs) \\<subseteq> {x, y};\n        set ys \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 ((a # xs) @ [x, x] @ ys) R =\n                         OPT2 ((a # xs) @ [x, x]) R @ OPT2 ys [x, y]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "proof (cases \"R=[x,y]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R = [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n 2. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "case True"], ["proof (state)\nthis:\n  R = [x, y]\n\ngoal (2 subgoals):\n 1. R = [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n 2. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "note R=this"], ["proof (state)\nthis:\n  R = [x, y]\n\ngoal (2 subgoals):\n 1. R = [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n 2. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "from iH iH'"], ["proof (chain)\npicking this:\n  OPT2 (as @ x # x # ys) [y, x] = OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y]\n  OPT2 (as @ x # x # ys) [x, y] = OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  OPT2 (as @ x # x # ys) [y, x] = OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y]\n  OPT2 (as @ x # x # ys) [x, y] = OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(cases \"a=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a = x\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp add: R OPT2x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "using A"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     y \\<noteq> x; a = y\\<rbrakk>\n    \\<Longrightarrow> OPT2 (y # as @ x # x # ys) R =\n                      OPT2 (y # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(cases as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     y \\<noteq> x; a = y; as = []\\<rbrakk>\n    \\<Longrightarrow> OPT2 (y # as @ x # x # ys) R =\n                      OPT2 (y # as @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # as @ x # x # ys) R =\n                         OPT2 (y # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp add: R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # as @ x # x # ys) R =\n                         OPT2 (y # as @ [x, x]) R @ OPT2 ys [x, y]", "using AS"], ["proof (prove)\nusing this:\n  set as \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # as @ x # x # ys) R =\n                         OPT2 (y # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (aa # list @ x # x # ys) [y, x] =\n                OPT2 (aa # list @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (aa # list @ x # x # ys) [x, y] =\n        OPT2 (aa # list @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list;\n        (aa = x \\<or> aa = y) \\<and> set list \\<subseteq> {x, y}\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # aa # list @ x # x # ys) R =\n                         OPT2 (y # aa # list @ [x, x]) R @ OPT2 ys [x, y]", "apply(case_tac \"aa=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (aa # list @ x # x # ys) [y, x] =\n                OPT2 (aa # list @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (aa # list @ x # x # ys) [x, y] =\n        OPT2 (aa # list @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list;\n        (aa = x \\<or> aa = y) \\<and> set list \\<subseteq> {x, y};\n        aa = x\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # aa # list @ x # x # ys) R =\n                         OPT2 (y # aa # list @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>aa list.\n       \\<lbrakk>OPT2 (aa # list @ x # x # ys) [y, x] =\n                OPT2 (aa # list @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (aa # list @ x # x # ys) [x, y] =\n        OPT2 (aa # list @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        y \\<noteq> x; a = y; as = aa # list;\n        (aa = x \\<or> aa = y) \\<and> set list \\<subseteq> {x, y};\n        aa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> OPT2 (y # aa # list @ x # x # ys) R =\n                         OPT2 (y # aa # list @ [x, x]) R @ OPT2 ys [x, y]", "by(simp_all add: R)"], ["proof (state)\nthis:\n  OPT2 ((a # as) @ [x, x] @ ys) R =\n  OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "case False"], ["proof (state)\nthis:\n  R \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "with Cons(2)"], ["proof (chain)\npicking this:\n  R \\<in> {[x, y], [y, x]}\n  R \\<noteq> [x, y]", "have R: \"R=[y,x]\""], ["proof (prove)\nusing this:\n  R \\<in> {[x, y], [y, x]}\n  R \\<noteq> [x, y]\n\ngoal (1 subgoal):\n 1. R = [y, x]", "by auto"], ["proof (state)\nthis:\n  R = [y, x]\n\ngoal (1 subgoal):\n 1. R \\<noteq> [x, y] \\<Longrightarrow>\n    OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "from iH iH'"], ["proof (chain)\npicking this:\n  OPT2 (as @ x # x # ys) [y, x] = OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y]\n  OPT2 (as @ x # x # ys) [x, y] = OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  OPT2 (as @ x # x # ys) [y, x] = OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y]\n  OPT2 (as @ x # x # ys) [x, y] = OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y]\n\ngoal (1 subgoal):\n 1. OPT2 ((a # as) @ [x, x] @ ys) R =\n    OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(cases \"a=y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a = y\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp add: R OPT2x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "using A"], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     a \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> OPT2 ((a # as) @ [x, x] @ ys) R =\n                      OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     x \\<noteq> y; a = x\\<rbrakk>\n    \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                      OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(cases as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n             OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n     OPT2 (as @ x # x # ys) [x, y] =\n     OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n     x \\<noteq> y; a = x; as = []\\<rbrakk>\n    \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                      OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        x \\<noteq> y; a = x; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                         OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(simp add: R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        x \\<noteq> y; a = x; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                         OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]", "apply(case_tac \"aa=y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        x \\<noteq> y; a = x; as = aa # list; aa = y\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                         OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]\n 2. \\<And>aa list.\n       \\<lbrakk>OPT2 (as @ x # x # ys) [y, x] =\n                OPT2 (as @ [x, x]) [y, x] @ OPT2 ys [x, y];\n        OPT2 (as @ x # x # ys) [x, y] =\n        OPT2 (as @ [x, x]) [x, y] @ OPT2 ys [x, y];\n        x \\<noteq> y; a = x; as = aa # list; aa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> OPT2 (x # as @ x # x # ys) R =\n                         OPT2 (x # as @ [x, x]) R @ OPT2 ys [x, y]", "by (simp_all add: R)"], ["proof (state)\nthis:\n  OPT2 ((a # as) @ [x, x] @ ys) R =\n  OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OPT2 ((a # as) @ [x, x] @ ys) R =\n  OPT2 ((a # as) @ [x, x]) R @ OPT2 ys [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The function steps\""], ["", "lemma steps_append: \"length qs = length as \\<Longrightarrow> steps s (qs@[q]) (as@[a]) = step (steps s qs as) q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    Partial_Cost_Model.steps s (qs @ [q]) (as @ [a]) =\n    step (Partial_Cost_Model.steps s qs as) q a", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       Partial_Cost_Model.steps s ([] @ [q]) ([] @ [a]) =\n       step (Partial_Cost_Model.steps s [] []) q a\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           Partial_Cost_Model.steps s (xs @ [q]) (ys @ [a]) =\n           step (Partial_Cost_Model.steps s xs ys) q a\\<rbrakk>\n       \\<Longrightarrow> Partial_Cost_Model.steps s ((x # xs) @ [q])\n                          ((y # ys) @ [a]) =\n                         step (Partial_Cost_Model.steps s (x # xs) (y # ys))\n                          q a", "by simp_all"], ["", "end"]]}