{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Competitive_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma steps_append: \"length qs = length as \\<Longrightarrow> steps s (qs@qs') (as@as') = steps (steps s qs as) qs' as'\"", "lemma T_append: \"length qs = length as \\<Longrightarrow> T s (qs@[q]) (as@[a]) = T s qs as + t (steps s qs as) q a\"", "lemma T_append2: \"length qs = length as \\<Longrightarrow> T s (qs@qs') (as@as') = T s qs as + T (steps s qs as) qs' as'\"", "lemma config'_rand_snoc: \"config'_rand A s (rs@[r]) = config'_rand A s rs \\<bind> Step_rand A r\"", "lemma config'_rand_append: \"config'_rand A s (xs@ys) = config'_rand A (config'_rand A s xs) ys\"", "lemma config'_rand_induct: \"(\\<forall>x \\<in> set_pmf init. P (fst x)) \\<Longrightarrow> (\\<And>s q a. P s \\<Longrightarrow> P (step s q a))\n     \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init qs). P (fst x)\"", "lemma config_rand_induct: \"P s0 \\<Longrightarrow> (\\<And>s q a. P s \\<Longrightarrow> P (step s q a)) \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config_rand A s0 qs). P (fst x)\"", "lemma T_on_rand'_append: \"T_on_rand' A s (xs@ys) = T_on_rand' A s xs + T_on_rand' A (config'_rand A s xs) ys\"", "lemma T_on_rand_append: \"T_on_rand A s (xs@ys) = T_on_rand A s xs + T_on_rand' A (config_rand A s xs) ys\"", "lemma T_on_rand'_as_sum: \"T_on_rand' A s0 rs = sum (T_on_rand'_n A s0 rs) {..<length rs} \"", "lemma T_on_rand_as_sum: \"T_on_rand A s0 rs = sum (T_on_rand_n A s0 rs) {..<length rs} \"", "lemma T_on_rand'_nn: \"T_on_rand' A s qs \\<ge> 0\"", "lemma T_on_rand_nn: \"T_on_rand (I,S) s0 qs \\<ge> 0\"", "lemma T_deter_rand: \"T_off (\\<lambda>s0. (off2 A (s0, x))) s0 qs = T_on_rand' (embed A) (return_pmf (s0,x)) qs\"", "lemma config'_embed: \"config'_rand (embed A) (return_pmf s0) qs = return_pmf (config' A s0 qs)\"", "lemma config_embed: \"config_rand (embed A) s0 qs = return_pmf (config A s0 qs)\"", "lemma T_on_embed: \"T_on A s0 qs = T_on_rand (embed A) s0 qs\"", "lemma T_on'_embed: \"T_on' A (s0,x) qs = T_on_rand' (embed A) (return_pmf (s0,x)) qs\"", "lemma compet_embed: \"compet A c S0 = compet_rand (embed A) c S0\""], "translations": [["", "lemma steps_append: \"length qs = length as \\<Longrightarrow> steps s (qs@qs') (as@as') = steps (steps s qs as) qs' as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    steps s (qs @ qs') (as @ as') = steps (steps s qs as) qs' as'", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. steps s ([] @ qs') ([] @ as') = steps (steps s [] []) qs' as'\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           steps s (xs @ qs') (ys @ as') =\n           steps (steps s xs ys) qs' as'\\<rbrakk>\n       \\<Longrightarrow> steps s ((x # xs) @ qs') ((y # ys) @ as') =\n                         steps (steps s (x # xs) (y # ys)) qs' as'", "by simp_all"], ["", "lemma T_append: \"length qs = length as \\<Longrightarrow> T s (qs@[q]) (as@[a]) = T s qs as + t (steps s qs as) q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    T s (qs @ [q]) (as @ [a]) = T s qs as + t (steps s qs as) q a", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. T s ([] @ [q]) ([] @ [a]) = T s [] [] + t (steps s [] []) q a\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           T s (xs @ [q]) (ys @ [a]) =\n           T s xs ys + t (steps s xs ys) q a\\<rbrakk>\n       \\<Longrightarrow> T s ((x # xs) @ [q]) ((y # ys) @ [a]) =\n                         T s (x # xs) (y # ys) +\n                         t (steps s (x # xs) (y # ys)) q a", "by simp_all"], ["", "lemma T_append2: \"length qs = length as \\<Longrightarrow> T s (qs@qs') (as@as') = T s qs as + T (steps s qs as) qs' as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    T s (qs @ qs') (as @ as') = T s qs as + T (steps s qs as) qs' as'", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       T s ([] @ qs') ([] @ as') = T s [] [] + T (steps s [] []) qs' as'\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           T s (xs @ qs') (ys @ as') =\n           T s xs ys + T (steps s xs ys) qs' as'\\<rbrakk>\n       \\<Longrightarrow> T s ((x # xs) @ qs') ((y # ys) @ as') =\n                         T s (x # xs) (y # ys) +\n                         T (steps s (x # xs) (y # ys)) qs' as'", "by simp_all"], ["", "abbreviation Step_rand :: \"('state,'is,'request,'answer) alg_on_rand  \\<Rightarrow> 'request \\<Rightarrow> 'state * 'is \\<Rightarrow> ('state * 'is) pmf\" where\n\"Step_rand A r s \\<equiv> bind_pmf ((snd A) s r) (\\<lambda>(a,is'). return_pmf (step (fst s) r a, is'))\""], ["", "fun config'_rand :: \"('state,'is,'request,'answer) alg_on_rand  \\<Rightarrow> ('state*'is) pmf \\<Rightarrow> 'request list  \n    \\<Rightarrow> ('state * 'is) pmf\" where\n\"config'_rand A s []  = s\" |\n\"config'_rand A s (r#rs) = config'_rand A (s \\<bind> Step_rand A r) rs\""], ["", "lemma config'_rand_snoc: \"config'_rand A s (rs@[r]) = config'_rand A s rs \\<bind> Step_rand A r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand A s (rs @ [r]) =\n    config'_rand A s rs \\<bind>\n    (\\<lambda>s.\n        snd A s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))", "apply(induct rs arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       config'_rand A s ([] @ [r]) =\n       config'_rand A s [] \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))\n 2. \\<And>a rs s.\n       (\\<And>s.\n           config'_rand A s (rs @ [r]) =\n           config'_rand A s rs \\<bind>\n           (\\<lambda>s.\n               snd A s r \\<bind>\n               (\\<lambda>(a, is').\n                   return_pmf (step (fst s) r a, is')))) \\<Longrightarrow>\n       config'_rand A s ((a # rs) @ [r]) =\n       config'_rand A s (a # rs) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))", "by(simp_all)"], ["", "lemma config'_rand_append: \"config'_rand A s (xs@ys) = config'_rand A (config'_rand A s xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand A s (xs @ ys) = config'_rand A (config'_rand A s xs) ys", "apply(induct xs arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       config'_rand A s ([] @ ys) = config'_rand A (config'_rand A s []) ys\n 2. \\<And>a xs s.\n       (\\<And>s.\n           config'_rand A s (xs @ ys) =\n           config'_rand A (config'_rand A s xs) ys) \\<Longrightarrow>\n       config'_rand A s ((a # xs) @ ys) =\n       config'_rand A (config'_rand A s (a # xs)) ys", "by(simp_all)"], ["", "abbreviation config_rand where\n\"config_rand A s0 rs == config'_rand A ((fst A s0) \\<bind> (\\<lambda>is. return_pmf (s0, is))) rs\""], ["", "lemma config'_rand_induct: \"(\\<forall>x \\<in> set_pmf init. P (fst x)) \\<Longrightarrow> (\\<And>s q a. P s \\<Longrightarrow> P (step s q a))\n     \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init qs). P (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n     \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init qs).\n                         P (fst x)", "proof (induct qs arbitrary: init)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n        \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init []).\n                            P (fst x)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n                    \\<And>s q a.\n                       P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\n        \\<in>set_pmf (config'_rand A init qs).\n  P (fst x);\n        \\<forall>x\\<in>set_pmf init. P (fst x);\n        \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set_pmf\n   (config'_rand A init (a # qs)).\n                            P (fst x)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set_pmf ?init29. P (fst x);\n   \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A ?init29 rs).\n                       P (fst x)\n  \\<forall>x\\<in>set_pmf init. P (fst x)\n  P ?s29 \\<Longrightarrow> P (step ?s29 ?q29 ?a29)\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n        \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init []).\n                            P (fst x)\n 2. \\<And>a qs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n                    \\<And>s q a.\n                       P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\n        \\<in>set_pmf (config'_rand A init qs).\n  P (fst x);\n        \\<forall>x\\<in>set_pmf init. P (fst x);\n        \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set_pmf\n   (config'_rand A init (a # qs)).\n                            P (fst x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf (config'_rand A init (r # rs)). P (fst x)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (init \\<bind>\n                       (\\<lambda>s.\n                           snd A s r \\<bind>\n                           (\\<lambda>(a, is').\n                               return_pmf (step (fst s) r a, is'))))\n                      rs).\n       P (fst x)", "apply(rule Cons(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set_pmf\n                    (init \\<bind>\n                     (\\<lambda>s.\n                         snd A s r \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf (step (fst s) r a, is')))).\n       P (fst x)\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "apply(subst Set.ball_simps(9)[where P=P, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ball\n     (fst `\n      set_pmf\n       (init \\<bind>\n        (\\<lambda>s.\n            snd A s r \\<bind>\n            (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is')))))\n     P\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "apply(subst set_map_pmf[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ball\n     (set_pmf\n       (map_pmf fst\n         (init \\<bind>\n          (\\<lambda>s.\n              snd A s r \\<bind>\n              (\\<lambda>(a, is'). return_pmf (step (fst s) r a, is'))))))\n     P\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "apply(simp only: map_bind_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ball\n     (set_pmf\n       (init \\<bind>\n        (\\<lambda>x.\n            snd A x r \\<bind>\n            (\\<lambda>xa.\n                map_pmf fst\n                 (case xa of\n                  (a, is') \\<Rightarrow>\n                    return_pmf (step (fst x) r a, is'))))))\n     P\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "apply(simp add: bind_assoc_pmf bind_return_pmf split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set_pmf init.\n       \\<forall>ya\\<in>set_pmf (snd A y r). P (step (fst y) r (fst ya))\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "using Cons(2,3)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf init. P (fst x)\n  P ?s29 \\<Longrightarrow> P (step ?s29 ?q29 ?a29)\n\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set_pmf init.\n       \\<forall>ya\\<in>set_pmf (snd A y r). P (step (fst y) r (fst ya))\n 2. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s q a. P s \\<Longrightarrow> P (step s q a)", "by fact"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf (config'_rand A init (r # rs)). P (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>init.\n       \\<lbrakk>\\<forall>x\\<in>set_pmf init. P (fst x);\n        \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config'_rand A init []).\n                            P (fst x)", "qed (simp)"], ["", "lemma config_rand_induct: \"P s0 \\<Longrightarrow> (\\<And>s q a. P s \\<Longrightarrow> P (step s q a)) \\<Longrightarrow> \\<forall>x\\<in>set_pmf (config_rand A s0 qs). P (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P s0;\n     \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set_pmf\n(config'_rand A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs).\n                         P (fst x)", "using config'_rand_induct[of \"((fst A s0) \\<bind> (\\<lambda>is. return_pmf (s0, is)))\" P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set_pmf\n                           (fst A s0 \\<bind>\n                            (\\<lambda>is. return_pmf (s0, is))).\n              P (fst x);\n   \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set_pmf\n                                    (config'_rand ?A\n(fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) ?qs).\n                       P (fst x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P s0;\n     \\<And>s q a. P s \\<Longrightarrow> P (step s q a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set_pmf\n(config'_rand A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs).\n                         P (fst x)", "by auto"], ["", "fun T_on_rand' :: \"('state,'is,'request,'answer) alg_on_rand \\<Rightarrow> ('state*'is) pmf \\<Rightarrow> 'request list \\<Rightarrow>  real\" where\n\"T_on_rand' A s [] = 0\" |\n\"T_on_rand' A s (r#rs) = E ( s \\<bind> (\\<lambda>s. bind_pmf (snd A s r) (\\<lambda>(a,is'). return_pmf (real (t (fst s) r a)))) )\n                              + T_on_rand' A (s \\<bind> Step_rand A r) rs\""], ["", "lemma T_on_rand'_append: \"T_on_rand' A s (xs@ys) = T_on_rand' A s xs + T_on_rand' A (config'_rand A s xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' A s (xs @ ys) =\n    T_on_rand' A s xs + T_on_rand' A (config'_rand A s xs) ys", "apply(induct xs arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       T_on_rand' A s ([] @ ys) =\n       T_on_rand' A s [] + T_on_rand' A (config'_rand A s []) ys\n 2. \\<And>a xs s.\n       (\\<And>s.\n           T_on_rand' A s (xs @ ys) =\n           T_on_rand' A s xs +\n           T_on_rand' A (config'_rand A s xs) ys) \\<Longrightarrow>\n       T_on_rand' A s ((a # xs) @ ys) =\n       T_on_rand' A s (a # xs) + T_on_rand' A (config'_rand A s (a # xs)) ys", "by simp_all"], ["", "abbreviation T_on_rand :: \"('state,'is,'request,'answer) alg_on_rand \\<Rightarrow> 'state \\<Rightarrow> 'request list \\<Rightarrow> real\" where\n  \"T_on_rand A s rs == T_on_rand' A (fst A s \\<bind> (\\<lambda>is. return_pmf (s,is))) rs\""], ["", "lemma T_on_rand_append: \"T_on_rand A s (xs@ys) = T_on_rand A s xs + T_on_rand' A (config_rand A s xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' A (fst A s \\<bind> (\\<lambda>is. return_pmf (s, is)))\n     (xs @ ys) =\n    T_on_rand' A (fst A s \\<bind> (\\<lambda>is. return_pmf (s, is))) xs +\n    T_on_rand' A\n     (config'_rand A (fst A s \\<bind> (\\<lambda>is. return_pmf (s, is))) xs)\n     ys", "by(rule T_on_rand'_append)"], ["", "abbreviation \"T_on_rand'_n A s0 xs n == T_on_rand' A (config'_rand A s0 (take n xs)) [xs!n]\""], ["", "lemma T_on_rand'_as_sum: \"T_on_rand' A s0 rs = sum (T_on_rand'_n A s0 rs) {..<length rs} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' A s0 rs = sum (T_on_rand'_n A s0 rs) {..<length rs}", "apply(induct rs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T_on_rand' A s0 [] = sum (T_on_rand'_n A s0 []) {..<length []}\n 2. \\<And>x xs.\n       T_on_rand' A s0 xs =\n       sum (T_on_rand'_n A s0 xs) {..<length xs} \\<Longrightarrow>\n       T_on_rand' A s0 (xs @ [x]) =\n       sum (T_on_rand'_n A s0 (xs @ [x])) {..<length (xs @ [x])}", "by(simp_all add: T_on_rand'_append nth_append)"], ["", "abbreviation \"T_on_rand_n A s0 xs n == T_on_rand' A (config_rand A s0 (take n xs)) [xs!n]\""], ["", "lemma T_on_rand_as_sum: \"T_on_rand A s0 rs = sum (T_on_rand_n A s0 rs) {..<length rs} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on_rand' A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) rs =\n    sum (T_on_rand'_n A\n          (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) rs)\n     {..<length rs}", "apply(induct rs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T_on_rand' A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) [] =\n    sum (T_on_rand'_n A\n          (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) [])\n     {..<length []}\n 2. \\<And>x xs.\n       T_on_rand' A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n        xs =\n       sum (T_on_rand'_n A\n             (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) xs)\n        {..<length xs} \\<Longrightarrow>\n       T_on_rand' A (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n        (xs @ [x]) =\n       sum (T_on_rand'_n A\n             (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n             (xs @ [x]))\n        {..<length (xs @ [x])}", "by(simp_all add: T_on_rand'_append  nth_append)"], ["", "lemma T_on_rand'_nn: \"T_on_rand' A s qs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_on_rand' A s qs", "apply(induct qs arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. 0 \\<le> T_on_rand' A s []\n 2. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       0 \\<le> T_on_rand' A s (a # qs)", "apply(simp_all add: bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       0 \\<le> E (s \\<bind>\n                  (\\<lambda>s.\n                      snd A s a \\<bind>\n                      (\\<lambda>(aa, is').\n                          return_pmf (real (t (fst s) a aa))))) +\n               T_on_rand' A\n                (s \\<bind>\n                 (\\<lambda>s.\n                     snd A s a \\<bind>\n                     (\\<lambda>(aa, is').\n                         return_pmf (step (fst s) a aa, is'))))\n                qs", "apply(rule add_nonneg_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       0 \\<le> E (s \\<bind>\n                  (\\<lambda>s.\n                      snd A s a \\<bind>\n                      (\\<lambda>(aa, is').\n                          return_pmf (real (t (fst s) a aa)))))\n 2. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       0 \\<le> T_on_rand' A\n                (s \\<bind>\n                 (\\<lambda>s.\n                     snd A s a \\<bind>\n                     (\\<lambda>(aa, is').\n                         return_pmf (step (fst s) a aa, is'))))\n                qs", "apply(rule E_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       \\<forall>x\\<in>set_pmf\n                       (s \\<bind>\n                        (\\<lambda>s.\n                            snd A s a \\<bind>\n                            (\\<lambda>(aa, is').\n                                return_pmf (real (t (fst s) a aa))))).\n          0 \\<le> x\n 2. \\<And>a qs s.\n       (\\<And>s. 0 \\<le> T_on_rand' A s qs) \\<Longrightarrow>\n       0 \\<le> T_on_rand' A\n                (s \\<bind>\n                 (\\<lambda>s.\n                     snd A s a \\<bind>\n                     (\\<lambda>(aa, is').\n                         return_pmf (step (fst s) a aa, is'))))\n                qs", "by(simp_all add: split_def)"], ["", "lemma T_on_rand_nn: \"T_on_rand (I,S) s0 qs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_on_rand' (I, S)\n             (fst (I, S) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs", "by (rule T_on_rand'_nn)"], ["", "definition compet_rand :: \"('state,'is,'request,'answer) alg_on_rand \\<Rightarrow> real \\<Rightarrow> 'state set \\<Rightarrow> bool\" where\n\"compet_rand A c S0 = (\\<forall>s\\<in>S0. \\<exists>b \\<ge> 0. \\<forall>rs. wf s rs \\<longrightarrow> T_on_rand A s rs \\<le> c * T_opt s rs + b)\""], ["", "subsection \"embeding of deterministic into randomized algorithms\""], ["", "fun embed :: \"('state,'is,'request,'answer) alg_on \\<Rightarrow> ('state,'is,'request,'answer) alg_on_rand\" where\n\"embed A = ( (\\<lambda>s. return_pmf (fst A s))  ,\n                  (\\<lambda>s r. return_pmf (snd A s r)) )\""], ["", "lemma T_deter_rand: \"T_off (\\<lambda>s0. (off2 A (s0, x))) s0 qs = T_on_rand' (embed A) (return_pmf (s0,x)) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T s0 qs (off2 A (s0, x) qs)) =\n    T_on_rand' (local.embed A) (return_pmf (s0, x)) qs", "apply(induct qs arbitrary: s0 x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s0 x.\n       real (T s0 [] (off2 A (s0, x) [])) =\n       T_on_rand' (local.embed A) (return_pmf (s0, x)) []\n 2. \\<And>a qs s0 x.\n       (\\<And>s0 x.\n           real (T s0 qs (off2 A (s0, x) qs)) =\n           T_on_rand' (local.embed A) (return_pmf (s0, x))\n            qs) \\<Longrightarrow>\n       real (T s0 (a # qs) (off2 A (s0, x) (a # qs))) =\n       T_on_rand' (local.embed A) (return_pmf (s0, x)) (a # qs)", "by(simp_all add: Step_def bind_return_pmf split: prod.split)"], ["", "lemma config'_embed: \"config'_rand (embed A) (return_pmf s0) qs = return_pmf (config' A s0 qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand (local.embed A) (return_pmf s0) qs =\n    return_pmf (config' A s0 qs)", "apply(induct qs arbitrary: s0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s0.\n       config'_rand (local.embed A) (return_pmf s0) [] =\n       return_pmf (config' A s0 [])\n 2. \\<And>a qs s0.\n       (\\<And>s0.\n           config'_rand (local.embed A) (return_pmf s0) qs =\n           return_pmf (config' A s0 qs)) \\<Longrightarrow>\n       config'_rand (local.embed A) (return_pmf s0) (a # qs) =\n       return_pmf (config' A s0 (a # qs))", "apply(simp_all add: Step_def split_def bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a qs s0.\n       (\\<And>s0.\n           config'_rand\n            (\\<lambda>s. return_pmf (fst A s),\n             \\<lambda>s r. return_pmf (snd A s r))\n            (return_pmf s0) qs =\n           return_pmf (config' A s0 qs)) \\<Longrightarrow>\n       config' A (step (fst s0) a (fst (snd A s0 a)), snd (snd A s0 a)) qs =\n       config' A (let p = snd A s0 a in (step (fst s0) a (fst p), snd p)) qs", "by metis"], ["", "lemma config_embed: \"config_rand (embed A) s0 qs = return_pmf (config A s0 qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand (local.embed A)\n     (fst (local.embed A) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is)))\n     qs =\n    return_pmf (config A s0 qs)", "apply(simp add: bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. config'_rand\n     (\\<lambda>s. return_pmf (fst A s),\n      \\<lambda>s r. return_pmf (snd A s r))\n     (return_pmf (s0, fst A s0)) qs =\n    return_pmf (config A s0 qs)", "apply(subst config'_embed[unfolded embed.simps])"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (config A s0 qs) = return_pmf (config A s0 qs)", "by simp"], ["", "lemma T_on_embed: \"T_on A s0 qs = T_on_rand (embed A) s0 qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_on A s0 qs) =\n    T_on_rand' (local.embed A)\n     (fst (local.embed A) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs", "using T_deter_rand[where x=\"fst A s0\", of s0 qs A]"], ["proof (prove)\nusing this:\n  real (T_on A s0 qs) =\n  T_on_rand' (local.embed A) (return_pmf (s0, fst A s0)) qs\n\ngoal (1 subgoal):\n 1. real (T_on A s0 qs) =\n    T_on_rand' (local.embed A)\n     (fst (local.embed A) s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs", "by(auto simp: bind_return_pmf)"], ["", "lemma T_on'_embed: \"T_on' A (s0,x) qs = T_on_rand' (embed A) (return_pmf (s0,x)) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_on' A (s0, x) qs) =\n    T_on_rand' (local.embed A) (return_pmf (s0, x)) qs", "using T_deter_rand T_on_on'"], ["proof (prove)\nusing this:\n  real (T ?s0.0 ?qs (off2 ?A (?s0.0, ?x) ?qs)) =\n  T_on_rand' (local.embed ?A) (return_pmf (?s0.0, ?x)) ?qs\n  T ?s0.0 ?qs (off2 ?A (?s0.0, ?x) ?qs) = T_on' ?A (?s0.0, ?x) ?qs\n\ngoal (1 subgoal):\n 1. real (T_on' A (s0, x) qs) =\n    T_on_rand' (local.embed A) (return_pmf (s0, x)) qs", "by metis"], ["", "lemma compet_embed: \"compet A c S0 = compet_rand (embed A) c S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compet A c S0 = compet_rand (local.embed A) c S0", "unfolding compet_def compet_rand_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>S0.\n        \\<exists>b\\<ge>0.\n           \\<forall>rs.\n              wf s rs \\<longrightarrow>\n              real (T_on A s rs) \\<le> c * real (T_opt s rs) + b) =\n    (\\<forall>s\\<in>S0.\n        \\<exists>b\\<ge>0.\n           \\<forall>rs.\n              wf s rs \\<longrightarrow>\n              T_on_rand' (local.embed A)\n               (fst (local.embed A) s \\<bind>\n                (\\<lambda>is. return_pmf (s, is)))\n               rs\n              \\<le> c * real (T_opt s rs) + b)", "using T_on_embed"], ["proof (prove)\nusing this:\n  real (T_on ?A ?s0.0 ?qs) =\n  T_on_rand' (local.embed ?A)\n   (fst (local.embed ?A) ?s0.0 \\<bind>\n    (\\<lambda>is. return_pmf (?s0.0, is)))\n   ?qs\n\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>S0.\n        \\<exists>b\\<ge>0.\n           \\<forall>rs.\n              wf s rs \\<longrightarrow>\n              real (T_on A s rs) \\<le> c * real (T_opt s rs) + b) =\n    (\\<forall>s\\<in>S0.\n        \\<exists>b\\<ge>0.\n           \\<forall>rs.\n              wf s rs \\<longrightarrow>\n              T_on_rand' (local.embed A)\n               (fst (local.embed A) s \\<bind>\n                (\\<lambda>is. return_pmf (s, is)))\n               rs\n              \\<le> c * real (T_opt s rs) + b)", "by metis"], ["", "end"], ["", "end"]]}