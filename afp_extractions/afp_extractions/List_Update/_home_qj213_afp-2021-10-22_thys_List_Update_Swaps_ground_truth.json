{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Swaps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma length_swap[simp]: \"length(swap i xs) = length xs\"", "lemma swap_id[simp]: \"Suc n \\<ge> size xs \\<Longrightarrow> swap n xs = xs\"", "lemma distinct_swap[simp]:\n  \"distinct(swap i xs) = distinct xs\"", "lemma swap_Suc[simp]: \"swap (Suc n) (a # xs) = a # swap n xs\"", "lemma index_swap_distinct:\n  \"distinct xs \\<Longrightarrow> Suc n < length xs \\<Longrightarrow>\n  index (swap n xs) x =\n  (if x = xs!n then Suc n else if x = xs!Suc n then n else index xs x)\"", "lemma set_swap[simp]: \"set(swap n xs) = set xs\"", "lemma nth_swap_id[simp]: \"Suc i < length xs \\<Longrightarrow> swap i xs ! i = xs!(i+1)\"", "lemma before_in_swap:\n \"dist_perm xs ys \\<Longrightarrow> Suc n < size xs \\<Longrightarrow>\n  x < y in (swap n xs) \\<longleftrightarrow>\n  x < y in xs \\<and> \\<not> (x = xs!n \\<and> y = xs!Suc n) \\<or> x = xs!Suc n \\<and> y = xs!n\"", "lemma Inv_swap: assumes \"dist_perm xs ys\"\nshows \"Inv xs (swap n ys) = \n  (if Suc n < size xs\n   then if ys!n < ys!Suc n in xs\n        then Inv xs ys \\<union> {(ys!n, ys!Suc n)}\n        else Inv xs ys - {(ys!Suc n, ys!n)}\n   else Inv xs ys)\"", "lemma swaps_inv[simp]:\n  \"set (swaps sws xs) = set xs \\<and>\n  size(swaps sws xs) = size xs \\<and>\n  distinct(swaps sws xs) = distinct xs\"", "lemma swaps_eq_Nil_iff[simp]: \"swaps acts xs = [] \\<longleftrightarrow> xs = []\"", "lemma swaps_map_Suc[simp]:\n  \"swaps (map Suc sws) (a # xs) = a # swaps sws xs\"", "lemma card_Inv_swaps_le:\n  \"distinct xs \\<Longrightarrow> card (Inv xs (swaps sws xs)) \\<le> length sws\"", "lemma nth_swaps: \"\\<forall>i\\<in>set is. j < i \\<Longrightarrow> swaps is xs ! j = xs ! j\"", "lemma not_before0[simp]: \"~ x < xs ! 0 in xs\"", "lemma before_id[simp]: \"\\<lbrakk> distinct xs; i < size xs; j < size xs \\<rbrakk> \\<Longrightarrow>\n  xs ! i < xs ! j in xs \\<longleftrightarrow> i < j\"", "lemma before_swaps:\n  \"\\<lbrakk> distinct is; \\<forall>i\\<in>set is. Suc i < size xs; distinct xs; i \\<notin> set is; i < j; j < size xs \\<rbrakk> \\<Longrightarrow>\n  swaps is xs ! i < swaps is xs ! j in xs\"", "lemma card_Inv_swaps:\n  \"\\<lbrakk> distinct is; \\<forall>i\\<in>set is. Suc i < size xs; distinct xs \\<rbrakk> \\<Longrightarrow>\n  card(Inv xs (swaps is xs)) = length is\"", "lemma swaps_eq_nth_take_drop: \"i < length xs \\<Longrightarrow>\n    swaps [0..<i] xs = xs!i # take i xs @ drop (Suc i) xs\"", "lemma index_swaps_size: \"distinct s \\<Longrightarrow>\n  index s q \\<le> index (swaps sws s) q + length sws\"", "lemma index_swaps_last_size: \"distinct s \\<Longrightarrow>\n  size s \\<le> index (swaps sws s) (last s) + length sws + 1\""], "translations": [["", "lemma length_swap[simp]: \"length(swap i xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap i xs) = length xs", "by(simp add: swap_def)"], ["", "lemma swap_id[simp]: \"Suc n \\<ge> size xs \\<Longrightarrow> swap n xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> Suc n \\<Longrightarrow> swap n xs = xs", "by(simp add: swap_def)"], ["", "lemma distinct_swap[simp]:\n  \"distinct(swap i xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (swap i xs) = distinct xs", "by(simp add: swap_def)"], ["", "lemma swap_Suc[simp]: \"swap (Suc n) (a # xs) = a # swap n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap (Suc n) (a # xs) = a # swap n xs", "by(induction xs) (auto simp: swap_def)"], ["", "lemma index_swap_distinct:\n  \"distinct xs \\<Longrightarrow> Suc n < length xs \\<Longrightarrow>\n  index (swap n xs) x =\n  (if x = xs!n then Suc n else if x = xs!Suc n then n else index xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; Suc n < length xs\\<rbrakk>\n    \\<Longrightarrow> index (swap n xs) x =\n                      (if x = xs ! n then Suc n\n                       else if x = xs ! Suc n then n else index xs x)", "by(auto simp add: swap_def index_swap_if_distinct)"], ["", "lemma set_swap[simp]: \"set(swap n xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swap n xs) = set xs", "by(auto simp add: swap_def set_conv_nth nth_list_update) metis"], ["", "lemma nth_swap_id[simp]: \"Suc i < length xs \\<Longrightarrow> swap i xs ! i = xs!(i+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < length xs \\<Longrightarrow> swap i xs ! i = xs ! (i + 1)", "by(simp add: swap_def)"], ["", "lemma before_in_swap:\n \"dist_perm xs ys \\<Longrightarrow> Suc n < size xs \\<Longrightarrow>\n  x < y in (swap n xs) \\<longleftrightarrow>\n  x < y in xs \\<and> \\<not> (x = xs!n \\<and> y = xs!Suc n) \\<or> x = xs!Suc n \\<and> y = xs!n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist_perm xs ys; Suc n < length xs\\<rbrakk>\n    \\<Longrightarrow> x < y in swap n xs =\n                      (x < y in xs \\<and>\n                       \\<not> (x = xs ! n \\<and> y = xs ! Suc n) \\<or>\n                       x = xs ! Suc n \\<and> y = xs ! n)", "by(simp add:before_in_def index_swap_distinct)\n  (metis Suc_lessD Suc_lessI index_less_size_conv index_nth_id less_Suc_eq n_not_Suc_n nth_index)"], ["", "lemma Inv_swap: assumes \"dist_perm xs ys\"\nshows \"Inv xs (swap n ys) = \n  (if Suc n < size xs\n   then if ys!n < ys!Suc n in xs\n        then Inv xs ys \\<union> {(ys!n, ys!Suc n)}\n        else Inv xs ys - {(ys!Suc n, ys!n)}\n   else Inv xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv xs (swap n ys) =\n    (if Suc n < length xs\n     then if ys ! n < ys ! Suc n in xs\n          then Inv xs ys \\<union> {(ys ! n, ys ! Suc n)}\n          else Inv xs ys - {(ys ! Suc n, ys ! n)}\n     else Inv xs ys)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Inv xs (swap n ys) =\n    (if Suc n < length xs\n     then if ys ! n < ys ! Suc n in xs\n          then Inv xs ys \\<union> {(ys ! n, ys ! Suc n)}\n          else Inv xs ys - {(ys ! Suc n, ys ! n)}\n     else Inv xs ys)", "have \"length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys", "using assms"], ["proof (prove)\nusing this:\n  dist_perm xs ys\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. Inv xs (swap n ys) =\n    (if Suc n < length xs\n     then if ys ! n < ys ! Suc n in xs\n          then Inv xs ys \\<union> {(ys ! n, ys ! Suc n)}\n          else Inv xs ys - {(ys ! Suc n, ys ! n)}\n     else Inv xs ys)", "with assms"], ["proof (chain)\npicking this:\n  dist_perm xs ys\n  length xs = length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  dist_perm xs ys\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. Inv xs (swap n ys) =\n    (if Suc n < length xs\n     then if ys ! n < ys ! Suc n in xs\n          then Inv xs ys \\<union> {(ys ! n, ys ! Suc n)}\n          else Inv xs ys - {(ys ! Suc n, ys ! n)}\n     else Inv xs ys)", "by(simp add: Inv_def set_eq_iff)\n      (metis before_in_def not_before_in before_in_swap)"], ["proof (state)\nthis:\n  Inv xs (swap n ys) =\n  (if Suc n < length xs\n   then if ys ! n < ys ! Suc n in xs\n        then Inv xs ys \\<union> {(ys ! n, ys ! Suc n)}\n        else Inv xs ys - {(ys ! Suc n, ys ! n)}\n   else Inv xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Perform a list of swaps, from right to left:\\<close>"], ["", "abbreviation swaps where \"swaps == foldr swap\""], ["", "lemma swaps_inv[simp]:\n  \"set (swaps sws xs) = set xs \\<and>\n  size(swaps sws xs) = size xs \\<and>\n  distinct(swaps sws xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swaps sws xs) = set xs \\<and>\n    length (swaps sws xs) = length xs \\<and>\n    distinct (swaps sws xs) = distinct xs", "by (induct sws arbitrary: xs) (simp_all add: swap_def)"], ["", "lemma swaps_eq_Nil_iff[simp]: \"swaps acts xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swaps acts xs = []) = (xs = [])", "by(induction acts)(auto simp: swap_def)"], ["", "lemma swaps_map_Suc[simp]:\n  \"swaps (map Suc sws) (a # xs) = a # swaps sws xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (map Suc sws) (a # xs) = a # swaps sws xs", "by(induction sws arbitrary: xs) auto"], ["", "lemma card_Inv_swaps_le:\n  \"distinct xs \\<Longrightarrow> card (Inv xs (swaps sws xs)) \\<le> length sws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    card (Inv xs (swaps sws xs)) \\<le> length sws", "by(induction sws) (auto simp: Inv_swap card_insert_if card_Diff_singleton_if)"], ["", "lemma nth_swaps: \"\\<forall>i\\<in>set is. j < i \\<Longrightarrow> swaps is xs ! j = xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set is. j < i \\<Longrightarrow> swaps is xs ! j = xs ! j", "by(induction \"is\")(simp_all add: swap_def)"], ["", "lemma not_before0[simp]: \"~ x < xs ! 0 in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < xs ! 0 in xs", "apply(cases \"xs = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> \\<not> x < xs ! 0 in xs\n 2. xs \\<noteq> [] \\<Longrightarrow> \\<not> x < xs ! 0 in xs", "by(auto simp: before_in_def neq_Nil_conv)"], ["", "lemma before_id[simp]: \"\\<lbrakk> distinct xs; i < size xs; j < size xs \\<rbrakk> \\<Longrightarrow>\n  xs ! i < xs ! j in xs \\<longleftrightarrow> i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> xs ! i < xs ! j in xs = (i < j)", "by(simp add: before_in_def index_nth_id)"], ["", "lemma before_swaps:\n  \"\\<lbrakk> distinct is; \\<forall>i\\<in>set is. Suc i < size xs; distinct xs; i \\<notin> set is; i < j; j < size xs \\<rbrakk> \\<Longrightarrow>\n  swaps is xs ! i < swaps is xs ! j in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct is; \\<forall>i\\<in>set is. Suc i < length xs;\n     distinct xs; i \\<notin> set is; i < j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> swaps is xs ! i < swaps is xs ! j in xs", "apply(induction \"is\" arbitrary: i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>distinct []; \\<forall>i\\<in>set []. Suc i < length xs;\n        distinct xs; i \\<notin> set []; i < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> swaps [] xs ! i < swaps [] xs ! j in xs\n 2. \\<And>a is i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>distinct is;\n                    \\<forall>i\\<in>set is. Suc i < length xs; distinct xs;\n                    i \\<notin> set is; i < j; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> swaps is xs ! i < swaps is xs ! j\n                                     in xs;\n        distinct (a # is); \\<forall>i\\<in>set (a # is). Suc i < length xs;\n        distinct xs; i \\<notin> set (a # is); i < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> swaps (a # is) xs ! i < swaps (a # is) xs ! j in xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a is i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>distinct is;\n                    \\<forall>i\\<in>set is. Suc i < length xs; distinct xs;\n                    i \\<notin> set is; i < j; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> swaps is xs ! i < swaps is xs ! j\n                                     in xs;\n        distinct (a # is); \\<forall>i\\<in>set (a # is). Suc i < length xs;\n        distinct xs; i \\<notin> set (a # is); i < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> swaps (a # is) xs ! i < swaps (a # is) xs ! j in xs", "apply(auto simp: swap_def nth_list_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma card_Inv_swaps:\n  \"\\<lbrakk> distinct is; \\<forall>i\\<in>set is. Suc i < size xs; distinct xs \\<rbrakk> \\<Longrightarrow>\n  card(Inv xs (swaps is xs)) = length is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct is; \\<forall>i\\<in>set is. Suc i < length xs;\n     distinct xs\\<rbrakk>\n    \\<Longrightarrow> card (Inv xs (swaps is xs)) = length is", "apply(induction \"is\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>i\\<in>set []. Suc i < length xs;\n     distinct xs\\<rbrakk>\n    \\<Longrightarrow> card (Inv xs (swaps [] xs)) = length []\n 2. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>distinct is;\n                 \\<forall>i\\<in>set is. Suc i < length xs;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> card (Inv xs (swaps is xs)) = length is;\n        distinct (a # is); \\<forall>i\\<in>set (a # is). Suc i < length xs;\n        distinct xs\\<rbrakk>\n       \\<Longrightarrow> card (Inv xs (swaps (a # is) xs)) = length (a # is)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>distinct is;\n                 \\<forall>i\\<in>set is. Suc i < length xs;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> card (Inv xs (swaps is xs)) = length is;\n        distinct (a # is); \\<forall>i\\<in>set (a # is). Suc i < length xs;\n        distinct xs\\<rbrakk>\n       \\<Longrightarrow> card (Inv xs (swaps (a # is) xs)) = length (a # is)", "apply(simp add: Inv_swap before_swaps card_insert_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>card (Inv xs (swaps is xs)) = length is;\n        a \\<notin> set is \\<and> distinct is;\n        Suc a < length xs \\<and> (\\<forall>i\\<in>set is. Suc i < length xs);\n        distinct xs\\<rbrakk>\n       \\<Longrightarrow> (swaps is xs ! a, swaps is xs ! Suc a)\n                         \\<notin> Inv xs (swaps is xs)", "apply(simp add: Inv_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swaps_eq_nth_take_drop: \"i < length xs \\<Longrightarrow>\n    swaps [0..<i] xs = xs!i # take i xs @ drop (Suc i) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    swaps [0..<i] xs = xs ! i # take i xs @ drop (Suc i) xs", "apply(induction i arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 < length xs \\<Longrightarrow>\n       swaps [0..<0] xs = xs ! 0 # take 0 xs @ drop (Suc 0) xs\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   i < length xs \\<Longrightarrow>\n                   swaps [0..<i] xs = xs ! i # take i xs @ drop (Suc i) xs;\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> swaps [0..<Suc i] xs =\n                         xs ! Suc i #\n                         take (Suc i) xs @ drop (Suc (Suc i)) xs", "apply (auto simp add: neq_Nil_conv swap_def drop_update_swap\n  take_Suc_conv_app_nth Cons_nth_drop_Suc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_swaps_size: \"distinct s \\<Longrightarrow>\n  index s q \\<le> index (swaps sws s) q + length sws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct s \\<Longrightarrow>\n    index s q \\<le> index (swaps sws s) q + length sws", "apply(induction sws arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       distinct s \\<Longrightarrow>\n       index s q \\<le> index (swaps [] s) q + length []\n 2. \\<And>a sws s.\n       \\<lbrakk>\\<And>s.\n                   distinct s \\<Longrightarrow>\n                   index s q \\<le> index (swaps sws s) q + length sws;\n        distinct s\\<rbrakk>\n       \\<Longrightarrow> index s q\n                         \\<le> index (swaps (a # sws) s) q +\n                               length (a # sws)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sws s.\n       \\<lbrakk>\\<And>s.\n                   distinct s \\<Longrightarrow>\n                   index s q \\<le> index (swaps sws s) q + length sws;\n        distinct s\\<rbrakk>\n       \\<Longrightarrow> index s q\n                         \\<le> index (swaps (a # sws) s) q +\n                               length (a # sws)", "apply (fastforce simp: swap_def index_swap_if_distinct index_nth_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_swaps_last_size: \"distinct s \\<Longrightarrow>\n  size s \\<le> index (swaps sws s) (last s) + length sws + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct s \\<Longrightarrow>\n    length s \\<le> index (swaps sws s) (last s) + length sws + 1", "apply(cases \"s = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct s; s = []\\<rbrakk>\n    \\<Longrightarrow> length s\n                      \\<le> index (swaps sws s) (last s) + length sws + 1\n 2. \\<lbrakk>distinct s; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length s\n                      \\<le> index (swaps sws s) (last s) + length sws + 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct s; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length s\n                      \\<le> index (swaps sws s) (last s) + length sws + 1", "using index_swaps_size[of s \"last s\" sws]"], ["proof (prove)\nusing this:\n  distinct s \\<Longrightarrow>\n  index s (last s) \\<le> index (swaps sws s) (last s) + length sws\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct s; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length s\n                      \\<le> index (swaps sws s) (last s) + length sws + 1", "by simp"], ["", "end"]]}