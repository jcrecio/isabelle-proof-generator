{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/Move_to_Front.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma mtf_id[simp]: \"x \\<notin> set xs \\<Longrightarrow> mtf x xs = xs\"", "lemma mtf0[simp]: \"x \\<in> set xs \\<Longrightarrow> mtf x xs ! 0 = x\"", "lemma before_in_mtf: assumes \"z \\<in> set xs\"\nshows \"x < y in mtf z xs  \\<longleftrightarrow>\n      (y \\<noteq> z \\<and> (if x=z then y \\<in> set xs else x < y in xs))\"", "lemma Inv_mtf: \"set xs = set ys \\<Longrightarrow> z : set ys \\<Longrightarrow> Inv xs (mtf z ys) =\n Inv xs ys \\<union> {(x,z)|x. x < z in xs \\<and> x < z in ys}\n - {(z,x)|x. z < x in xs \\<and> x < z in ys}\"", "lemma set_mtf[simp]: \"set(mtf x xs) = set xs\"", "lemma length_mtf[simp]: \"size (mtf x xs) = size xs\"", "lemma distinct_mtf[simp]: \"distinct (mtf x xs) = distinct xs\"", "lemma mtf_eq_mtf2: \"mtf x xs = mtf2 (length xs - 1) x xs\"", "lemma mtf20[simp]: \"mtf2 0 x xs = xs\"", "lemma length_mtf2[simp]: \"length (mtf2 n x xs) = length xs\"", "lemma set_mtf2[simp]: \"set(mtf2 n x xs) = set xs\"", "lemma distinct_mtf2[simp]: \"distinct (mtf2 n x xs) = distinct xs\"", "lemma card_Inv_mtf2: \"xs!j = ys!0 \\<Longrightarrow> j < length xs \\<Longrightarrow> dist_perm xs ys \\<Longrightarrow>\n   card (Inv (swaps [i..<j] xs) ys) = card (Inv xs ys) - int(j-i)\"", "lemma Lxy_length_cons: \"length (Lxy xs S) \\<le> length (Lxy (x#xs) S)\"", "lemma Lxy_empty[simp]: \"Lxy [] S = []\"", "lemma Lxy_set_filter: \"set (Lxy xs S) = S \\<inter> set xs\"", "lemma Lxy_distinct: \"distinct xs \\<Longrightarrow> distinct (Lxy xs S)\"", "lemma Lxy_append: \"Lxy (xs@ys) S = Lxy xs S @ Lxy ys S\"", "lemma Lxy_snoc: \"Lxy (xs@[x]) S = (if x\\<in>S then Lxy xs S @ [x] else Lxy xs S)\"", "lemma Lxy_not: \"S \\<inter> set xs = {} \\<Longrightarrow> Lxy xs S = []\"", "lemma Lxy_notin: \"set xs \\<inter> S = {} \\<Longrightarrow> Lxy xs S = []\"", "lemma Lxy_in: \"x\\<in>S \\<Longrightarrow> Lxy [x] S = [x]\"", "lemma Lxy_project: \n  assumes \"x\\<noteq>y\" \"x \\<in> set xs\"  \"y\\<in>set xs\" \"distinct xs\" \n    and \"x < y in xs\"\n  shows \"Lxy xs {x,y} = [x,y]\"", "lemma Lxy_mono: \"{x,y} \\<subseteq> set xs \\<Longrightarrow> distinct xs \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x,y}\"", "lemma T_ge_len: \"length as = length rs \\<Longrightarrow> T s rs as \\<ge> length rs\"", "lemma T_off_neq0: \"(\\<And>rs s0. size(alg s0 rs) = length rs) \\<Longrightarrow>\n  rs \\<noteq> [] \\<Longrightarrow> T_off alg s0 rs \\<noteq> 0\"", "lemma length_step[simp]: \"length (step s r as) = length s\"", "lemma step_Nil_iff[simp]: \"step xs r act = [] \\<longleftrightarrow> xs = []\"", "lemma set_step2: \"set(step s r (mf,sws)) = set s\"", "lemma set_step: \"set(step s r act) = set s\"", "lemma distinct_step: \"distinct(step s r as) = distinct s\"", "lemma potential:\nfixes t :: \"nat \\<Rightarrow> 'a::linordered_ab_group_add\" and p :: \"nat \\<Rightarrow> 'a\"\nassumes p0: \"p 0 = 0\" and ppos: \"\\<And>n. p n \\<ge> 0\"\nand ub: \"\\<And>n. t n + p(n+1) - p n \\<le> u n\"\nshows \"(\\<Sum>i<n. t i) \\<le> (\\<Sum>i<n. u i)\"", "lemma potential2:\nfixes t :: \"nat \\<Rightarrow> 'a::linordered_ab_group_add\" and p :: \"nat \\<Rightarrow> 'a\"\nassumes p0: \"p 0 = 0\" and ppos: \"\\<And>n. p n \\<ge> 0\"\nand ub: \"\\<And>m. m<n \\<Longrightarrow> t m + p(m+1) - p m \\<le> u m\"\nshows \"(\\<Sum>i<n. t i) \\<le> (\\<Sum>i<n. u i)\"", "lemma finite_before[simp]: \"finite (before x xs)\"", "lemma finite_after[simp]: \"finite (after x xs)\"", "lemma before_conv_take:\n  \"x : set xs \\<Longrightarrow> before x xs = set(take (index xs x) xs)\"", "lemma card_before: \"distinct xs \\<Longrightarrow> x : set xs \\<Longrightarrow> card (before x xs) = index xs x\"", "lemma before_Un: \"set xs = set ys \\<Longrightarrow> x : set xs \\<Longrightarrow>\n  before x ys = before x xs \\<inter> before x ys Un after x xs \\<inter> before x ys\"", "lemma phi_diff_aux:\n  \"card (Inv xs ys \\<union>\n             {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n             {(x, y) |y. x < y in xs \\<and> y < x in ys}) =\n   card(Inv xs ys) + card(before x xs \\<inter> before x ys)\n   - int(card(after x xs \\<inter> before x ys))\"\n  (is \"card(?I \\<union> ?B - ?A) = card ?I + card ?b - int(card ?a)\")", "lemma not_before_Cons[simp]: \"\\<not> x < y in y # xs\"", "lemma before_Cons[simp]:\n  \"y \\<in> set xs \\<Longrightarrow> y \\<noteq> x \\<Longrightarrow> before y (x#xs) = insert x (before y xs)\"", "lemma card_before_le_index: \"card (before x xs) \\<le> index xs x\"", "lemma config_config_length: \"length (fst (config A init qs)) = length init\"", "lemma config_config_distinct: \n  shows \" distinct (fst (config A init qs)) = distinct init\"", "lemma config_config_set: \n  shows \"set (fst (config A init qs)) = set init\"", "lemma config_config:\n  \"set (fst (config A init qs)) = set init\n        \\<and> distinct (fst (config A init qs)) = distinct init\n        \\<and> length (fst (config A init qs)) = length init\"", "lemma config_dist_perm:\n  \"distinct init \\<Longrightarrow> dist_perm (fst (config A init qs)) init\"", "lemma config_rand_length: \"\\<forall>x\\<in>set_pmf (config_rand  A init qs). length (fst x) = length init\"", "lemma config_rand_distinct: \n  shows \"\\<forall>x \\<in> (config_rand  A init qs). distinct (fst x) = distinct init\"", "lemma config_rand_set: \n  shows \" \\<forall>x \\<in> (config_rand   A init qs). set (fst x) = set init\"", "lemma config_rand:\n  \"\\<forall>x \\<in> (config_rand   A  init qs). set (fst x) = set init\n        \\<and> distinct (fst x) = distinct init \\<and> length (fst x) = length init\"", "lemma config_rand_dist_perm:\n  \"distinct init \\<Longrightarrow> \\<forall>x \\<in> (config_rand A init qs). dist_perm (fst x) init\"", "lemma amor_mtf_ub: assumes \"x : set ys\" \"set xs = set ys\"\nshows \"int(card(before x xs Int before x ys)) - card(after x xs Int before x ys)\n  \\<le> 2 * int(index xs x) - card (before x ys)\" (is \"?m - ?n \\<le> 2 * ?j - ?k\")", "lemma length_s_A[simp]: \"length(s_A n) = length s0\"", "lemma dist_s_A[simp]: \"distinct(s_A n)\"", "lemma set_s_A[simp]: \"set(s_A n) = set s0\"", "lemma length_s_mtf[simp]: \"length(s_mtf n) = length s0\"", "lemma dist_s_mtf[simp]: \"distinct(s_mtf n)\"", "lemma set_s_mtf[simp]: \"set (s_mtf n) = set s0\"", "lemma dperm_inv: \"dist_perm (s_A n) (s_mtf n)\"", "lemma phi0: \"Phi 0 = 0\"", "lemma phi_pos: \"Phi n \\<ge> 0\"", "lemma mtf_ub: \"t_mtf n + Phi (n+1) - Phi n \\<le> 2 * c_A n - 1 + p_A n - f_A n\"", "theorem Sleator_Tarjan: \"T_mtf n \\<le> (\\<Sum>i<n. 2*c_A i + p_A i - f_A i) - n\"", "lemma T_A_nneg: \"0 \\<le> T_A n\"", "lemma T_mtf_ub: \"\\<forall>i<n. rs!i \\<in> set s0 \\<Longrightarrow> T_mtf n \\<le> n * size s0\"", "lemma t_A_t: \"n < length rs \\<Longrightarrow> t_A n = int (t (s_A n) (rs ! n) (as ! n))\"", "lemma T_A_eq_lem: \"(\\<Sum>i=0..<length rs. t_A i) =\n  T (s_A 0) (drop 0 rs) (drop 0 as)\"", "lemma T_A_eq: \"T_A (length rs) = T s0 rs as\"", "lemma nth_off_MTF: \"n < length rs \\<Longrightarrow> off2 MTF s rs ! n = (size(fst s) - 1,[])\"", "lemma t_mtf_MTF: \"n < length rs \\<Longrightarrow>\n  t_mtf n = int (t (s_mtf n) (rs ! n) (off MTF s rs ! n))\"", "lemma mtf_MTF: \"n < length rs \\<Longrightarrow> length s = length s0 \\<Longrightarrow> mtf (rs ! n) s =\n       step s (rs ! n) (off MTF s0 rs ! n)\"", "lemma T_mtf_eq_lem: \"(\\<Sum>i=0..<length rs. t_mtf i) =\n  T (s_mtf 0) (drop 0 rs) (drop 0 (off MTF s0 rs))\"", "lemma T_mtf_eq: \"T_mtf (length rs) = T_on MTF s0 rs\"", "theorem compet_MTF: assumes \"s0 \\<noteq> []\" \"distinct s0\" \"set rs \\<subseteq> set s0\"\nshows \"T_on MTF s0 rs \\<le> (2 - 1/(size s0)) * T_opt s0 rs\"", "theorem compet_MTF': assumes \"distinct s0\"\nshows \"T_on MTF s0 rs \\<le> (2::real) * T_opt s0 rs\"", "theorem MTF_is_2_competitive: \"compet MTF 2 {s . distinct s}\"", "lemma rat_fun_lem:\n   fixes l c :: real\n   assumes [simp]: \"F \\<noteq> bot\"\n   assumes \"0 < l\"\n   assumes ev: \n     \"eventually (\\<lambda>n. l \\<le> f n / g n) F\"\n     \"eventually (\\<lambda>n. (f n + c) / (g n + d) \\<le> u) F\"\n   and\n     g: \"LIM n F. g n :> at_top\"\n   shows \"l \\<le> u\"", "lemma compet_lb0:\nfixes a Aon Aoff cruel \ndefines \"f s0 rs == real(T_on Aon s0 rs)\"\ndefines \"g s0 rs == real(T_off Aoff s0 rs)\"\nassumes \"\\<And>rs s0. size(Aoff s0 rs) = length rs\" and \"\\<And>n. cruel n \\<noteq> []\"\nassumes \"compet Aon c S0\" and \"c\\<ge>0\" and \"s0 \\<in> S0\"\n and l: \"eventually (\\<lambda>n. f s0 (cruel n) / (g s0 (cruel n) + a) \\<ge> l) sequentially\"\n and g: \"LIM n sequentially. g s0 (cruel n) :> at_top\"\n and \"l > 0\" and \"\\<And>n. static s0 (cruel n)\"\nshows \"l \\<le> c\"", "lemma length_ins_sws: \"length(ins_sws k x xs) \\<le> length xs\"", "lemma length_sort_sws_le: \"length(sort_sws k xs) \\<le> length xs ^ 2\"", "lemma swaps_ins_sws:\n  \"swaps (ins_sws k x xs) (x#xs) = insort_key k x xs\"", "lemma swaps_sort_sws[simp]:\n  \"swaps (sort_sws k xs) xs = sort_key k xs\"", "lemma set_cruel: \"s \\<noteq> [] \\<Longrightarrow> set(cruel A (s,is) n) \\<subseteq> set s\"", "lemma static_cruel: \"s \\<noteq> [] \\<Longrightarrow> static s (cruel A (s,is) n)\"", "lemma T_cruel:\n  \"s \\<noteq> [] \\<Longrightarrow> distinct s \\<Longrightarrow>\n  T s (cruel A (s,is) n) (off2 A (s,is) (cruel A (s,is) n)) \\<ge> n*(length s)\"", "lemma length_cruel[simp]: \"length (cruel A s n) = n\"", "lemma t_sort_sws: \"t s r (mf, sort_sws k s) \\<le> size s ^ 2 + size s + 1\"", "lemma T_noop:\n  \"n = length rs \\<Longrightarrow> T s rs (replicate n (0, [])) = (\\<Sum>r\\<leftarrow>rs. index s r + 1)\"", "lemma sorted_asc: \"j\\<le>i \\<Longrightarrow> i<size ss \\<Longrightarrow> \\<forall>x \\<in> set ss. \\<forall>y \\<in> set ss. k(x) \\<le> k(y) \\<longrightarrow> f y \\<le> f x\n  \\<Longrightarrow> sorted (map k ss) \\<Longrightarrow> f (ss ! i) \\<le> f (ss ! j)\"", "lemma sorted_weighted_gauss_Ico_div2:\n  fixes f :: \"nat \\<Rightarrow> nat\"\n  assumes \"\\<And>i j. i \\<le> j \\<Longrightarrow> j < n \\<Longrightarrow> f i \\<ge> f j\"\n  shows \"(\\<Sum>i=0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\"", "lemma T_adv: assumes \"l \\<noteq> 0\"\nshows \"T_off (adv A) [0..<l] (cruel A ([0..<l],fst A [0..<l]) (Suc n))\n  \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\"  (is \"?l \\<le> ?r\")", "theorem compet_lb2:\nassumes \"compet A c {xs::nat list. size xs = l}\" and \"l \\<noteq> 0\" and \"c \\<ge> 0\"\nshows \"c \\<ge> 2*l/(l+1)\""], "translations": [["", "lemma mtf_id[simp]: \"x \\<notin> set xs \\<Longrightarrow> mtf x xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> mtf x xs = xs", "by(simp add: mtf_def)"], ["", "lemma mtf0[simp]: \"x \\<in> set xs \\<Longrightarrow> mtf x xs ! 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> mtf x xs ! 0 = x", "by(auto simp: mtf_def)"], ["", "lemma before_in_mtf: assumes \"z \\<in> set xs\"\nshows \"x < y in mtf z xs  \\<longleftrightarrow>\n      (y \\<noteq> z \\<and> (if x=z then y \\<in> set xs else x < y in xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "have 0: \"index xs z < size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs z < length xs", "by (metis assms index_less_size_conv)"], ["proof (state)\nthis:\n  index xs z < length xs\n\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "let ?xs = \"take (index xs z) xs @ xs ! index xs z # drop (Suc (index xs z)) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "have \"x < y in mtf z xs = (y \\<noteq> z \\<and> (if x=z then y \\<in> set ?xs else x < y in ?xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and>\n     (if x = z\n      then y \\<in> set (take (index xs z) xs @\n                        xs ! index xs z # drop (Suc (index xs z)) xs)\n      else x < y\n           in take (index xs z) xs @\n              xs ! index xs z # drop (Suc (index xs z)) xs))", "using assms"], ["proof (prove)\nusing this:\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and>\n     (if x = z\n      then y \\<in> set (take (index xs z) xs @\n                        xs ! index xs z # drop (Suc (index xs z)) xs)\n      else x < y\n           in take (index xs z) xs @\n              xs ! index xs z # drop (Suc (index xs z)) xs))", "by(auto simp add: mtf_def before_in_def index_append)\n      (metis add_lessD1 index_less_size_conv length_take less_Suc_eq not_less_eq)"], ["proof (state)\nthis:\n  x < y in mtf z xs =\n  (y \\<noteq> z \\<and>\n   (if x = z\n    then y \\<in> set (take (index xs z) xs @\n                      xs ! index xs z # drop (Suc (index xs z)) xs)\n    else x < y\n         in take (index xs z) xs @\n            xs ! index xs z # drop (Suc (index xs z)) xs))\n\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "with id_take_nth_drop[OF 0, symmetric]"], ["proof (chain)\npicking this:\n  take (index xs z) xs @ xs ! index xs z # drop (Suc (index xs z)) xs = xs\n  x < y in mtf z xs =\n  (y \\<noteq> z \\<and>\n   (if x = z\n    then y \\<in> set (take (index xs z) xs @\n                      xs ! index xs z # drop (Suc (index xs z)) xs)\n    else x < y\n         in take (index xs z) xs @\n            xs ! index xs z # drop (Suc (index xs z)) xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  take (index xs z) xs @ xs ! index xs z # drop (Suc (index xs z)) xs = xs\n  x < y in mtf z xs =\n  (y \\<noteq> z \\<and>\n   (if x = z\n    then y \\<in> set (take (index xs z) xs @\n                      xs ! index xs z # drop (Suc (index xs z)) xs)\n    else x < y\n         in take (index xs z) xs @\n            xs ! index xs z # drop (Suc (index xs z)) xs))\n\ngoal (1 subgoal):\n 1. x < y in mtf z xs =\n    (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))", "by(simp)"], ["proof (state)\nthis:\n  x < y in mtf z xs =\n  (y \\<noteq> z \\<and> (if x = z then y \\<in> set xs else x < y in xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Inv_mtf: \"set xs = set ys \\<Longrightarrow> z : set ys \\<Longrightarrow> Inv xs (mtf z ys) =\n Inv xs ys \\<union> {(x,z)|x. x < z in xs \\<and> x < z in ys}\n - {(z,x)|x. z < x in xs \\<and> x < z in ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = set ys; z \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> Inv xs (mtf z ys) =\n                      Inv xs ys \\<union>\n                      {(x, z) |x. x < z in xs \\<and> x < z in ys} -\n                      {(z, x) |x. z < x in xs \\<and> x < z in ys}", "by(auto simp add: Inv_def before_in_mtf not_before_in dest: before_in_setD1)"], ["", "lemma set_mtf[simp]: \"set(mtf x xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mtf x xs) = set xs", "by(simp add: mtf_def)\n  (metis append_take_drop_id Cons_nth_drop_Suc index_less le_refl Un_insert_right nth_index set_append set_simps(2))"], ["", "lemma length_mtf[simp]: \"size (mtf x xs) = size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtf x xs) = length xs", "by (auto simp add: mtf_def min_def) (metis index_less_size_conv leD)"], ["", "lemma distinct_mtf[simp]: \"distinct (mtf x xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (mtf x xs) = distinct xs", "by (metis length_mtf set_mtf card_distinct distinct_card)"], ["", "subsection \"Function \\<open>mtf2\\<close>\""], ["", "definition mtf2 :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"mtf2 n x xs =\n (if x : set xs then swaps [index xs x - n..<index xs x] xs else xs)\""], ["", "lemma mtf_eq_mtf2: \"mtf x xs = mtf2 (length xs - 1) x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf x xs = mtf2 (length xs - 1) x xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mtf x xs = mtf2 (length xs - 1) x xs", "have \"x : set xs \\<Longrightarrow> index xs x - (size xs - Suc 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> index xs x - (length xs - Suc 0) = 0", "by (auto simp: less_Suc_eq_le[symmetric])"], ["proof (state)\nthis:\n  x \\<in> set xs \\<Longrightarrow> index xs x - (length xs - Suc 0) = 0\n\ngoal (1 subgoal):\n 1. mtf x xs = mtf2 (length xs - 1) x xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<Longrightarrow> index xs x - (length xs - Suc 0) = 0\n\ngoal (1 subgoal):\n 1. mtf x xs = mtf2 (length xs - 1) x xs", "by(auto simp: mtf_def mtf2_def swaps_eq_nth_take_drop)"], ["proof (state)\nthis:\n  mtf x xs = mtf2 (length xs - 1) x xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mtf20[simp]: \"mtf2 0 x xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2 0 x xs = xs", "by(auto simp add: mtf2_def)"], ["", "lemma length_mtf2[simp]: \"length (mtf2 n x xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtf2 n x xs) = length xs", "by (auto simp: mtf2_def index_less_size_conv[symmetric]\n  simp del:index_conv_size_if_notin)"], ["", "lemma set_mtf2[simp]: \"set(mtf2 n x xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mtf2 n x xs) = set xs", "by (auto simp: mtf2_def index_less_size_conv[symmetric]\n  simp del:index_conv_size_if_notin)"], ["", "lemma distinct_mtf2[simp]: \"distinct (mtf2 n x xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (mtf2 n x xs) = distinct xs", "by (metis length_mtf2 set_mtf2 card_distinct distinct_card)"], ["", "lemma card_Inv_mtf2: \"xs!j = ys!0 \\<Longrightarrow> j < length xs \\<Longrightarrow> dist_perm xs ys \\<Longrightarrow>\n   card (Inv (swaps [i..<j] xs) ys) = card (Inv xs ys) - int(j-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs ! j = ys ! 0; j < length xs; dist_perm xs ys\\<rbrakk>\n    \\<Longrightarrow> int (card (Inv (swaps [i..<j] xs) ys)) =\n                      int (card (Inv xs ys)) - int (j - i)", "proof(induction j arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs ! 0 = ys ! 0; 0 < length xs; dist_perm xs ys\\<rbrakk>\n       \\<Longrightarrow> int (card (Inv (swaps [i..<0] xs) ys)) =\n                         int (card (Inv xs ys)) - int (0 - i)\n 2. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>xs ! j = ys ! 0; j < length xs;\n                    dist_perm xs ys\\<rbrakk>\n                   \\<Longrightarrow> int\n(card (Inv (swaps [i..<j] xs) ys)) =\n                                     int (card (Inv xs ys)) - int (j - i);\n        xs ! Suc j = ys ! 0; Suc j < length xs; dist_perm xs ys\\<rbrakk>\n       \\<Longrightarrow> int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n                         int (card (Inv xs ys)) - int (Suc j - i)", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>?xs ! j = ys ! 0; j < length ?xs; dist_perm ?xs ys\\<rbrakk>\n  \\<Longrightarrow> int (card (Inv (swaps [i..<j] ?xs) ys)) =\n                    int (card (Inv ?xs ys)) - int (j - i)\n  xs ! Suc j = ys ! 0\n  Suc j < length xs\n  dist_perm xs ys\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs ! 0 = ys ! 0; 0 < length xs; dist_perm xs ys\\<rbrakk>\n       \\<Longrightarrow> int (card (Inv (swaps [i..<0] xs) ys)) =\n                         int (card (Inv xs ys)) - int (0 - i)\n 2. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>xs ! j = ys ! 0; j < length xs;\n                    dist_perm xs ys\\<rbrakk>\n                   \\<Longrightarrow> int\n(card (Inv (swaps [i..<j] xs) ys)) =\n                                     int (card (Inv xs ys)) - int (j - i);\n        xs ! Suc j = ys ! 0; Suc j < length xs; dist_perm xs ys\\<rbrakk>\n       \\<Longrightarrow> int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n                         int (card (Inv xs ys)) - int (Suc j - i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "by simp"], ["proof (state)\nthis:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv xs ys)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have 0: \"Suc j < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc j < length ys", "by (metis Suc.prems(2,3) distinct_card)"], ["proof (state)\nthis:\n  Suc j < length ys\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have 1: \"(ys ! 0, xs ! j) : Inv ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys ! 0, xs ! j) \\<in> Inv ys xs", "proof (auto simp: Inv_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys ! 0 < xs ! j in ys\n 2. xs ! j < ys ! 0 in xs", "show \"ys ! 0 < xs ! j in ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys ! 0 < xs ! j in ys", "using Suc.prems"], ["proof (prove)\nusing this:\n  xs ! Suc j = ys ! 0\n  Suc j < length xs\n  dist_perm xs ys\n\ngoal (1 subgoal):\n 1. ys ! 0 < xs ! j in ys", "by (metis Suc_lessD n_not_Suc_n not_before0 not_before_in nth_eq_iff_index_eq nth_mem)"], ["proof (state)\nthis:\n  ys ! 0 < xs ! j in ys\n\ngoal (1 subgoal):\n 1. xs ! j < ys ! 0 in xs", "show \"xs ! j < ys ! 0 in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! j < ys ! 0 in xs", "using Suc.prems"], ["proof (prove)\nusing this:\n  xs ! Suc j = ys ! 0\n  Suc j < length xs\n  dist_perm xs ys\n\ngoal (1 subgoal):\n 1. xs ! j < ys ! 0 in xs", "by (metis Suc_lessD before_id lessI)"], ["proof (state)\nthis:\n  xs ! j < ys ! 0 in xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ys ! 0, xs ! j) \\<in> Inv ys xs\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have 2: \"card(Inv ys xs) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Inv ys xs) \\<noteq> 0", "using 1"], ["proof (prove)\nusing this:\n  (ys ! 0, xs ! j) \\<in> Inv ys xs\n\ngoal (1 subgoal):\n 1. card (Inv ys xs) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (Inv ys xs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"int(card (Inv (swaps [i..<Suc j] xs) ys)) =\n          card (Inv (swap j xs) ys) - int (j-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv (swap j xs) ys)) - int (j - i)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs ! j = ys ! 0; j < length ?xs; dist_perm ?xs ys\\<rbrakk>\n  \\<Longrightarrow> int (card (Inv (swaps [i..<j] ?xs) ys)) =\n                    int (card (Inv ?xs ys)) - int (j - i)\n  xs ! Suc j = ys ! 0\n  Suc j < length xs\n  dist_perm xs ys\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv (swap j xs) ys)) - int (j - i)", "by simp"], ["proof (state)\nthis:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv (swap j xs) ys)) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "also"], ["proof (state)\nthis:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv (swap j xs) ys)) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"\\<dots> = card (Inv ys (swap j xs)) - int (j-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swap j xs) ys)) - int (j - i) =\n    int (card (Inv ys (swap j xs))) - int (j - i)", "by(simp add: card_Inv_sym)"], ["proof (state)\nthis:\n  int (card (Inv (swap j xs) ys)) - int (j - i) =\n  int (card (Inv ys (swap j xs))) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "also"], ["proof (state)\nthis:\n  int (card (Inv (swap j xs) ys)) - int (j - i) =\n  int (card (Inv ys (swap j xs))) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"\\<dots> = card (Inv ys xs - {(ys ! 0, xs ! j)}) - int (j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv ys (swap j xs))) - int (j - i) =\n    int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i)", "using Suc.prems 0"], ["proof (prove)\nusing this:\n  xs ! Suc j = ys ! 0\n  Suc j < length xs\n  dist_perm xs ys\n  Suc j < length ys\n\ngoal (1 subgoal):\n 1. int (card (Inv ys (swap j xs))) - int (j - i) =\n    int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i)", "by(simp add: Inv_swap)"], ["proof (state)\nthis:\n  int (card (Inv ys (swap j xs))) - int (j - i) =\n  int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "also"], ["proof (state)\nthis:\n  int (card (Inv ys (swap j xs))) - int (j - i) =\n  int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"\\<dots> = int(card (Inv ys xs) - 1) - (j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i) =\n    int (card (Inv ys xs) - 1) - int (j - i)", "using 1"], ["proof (prove)\nusing this:\n  (ys ! 0, xs ! j) \\<in> Inv ys xs\n\ngoal (1 subgoal):\n 1. int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i) =\n    int (card (Inv ys xs) - 1) - int (j - i)", "by(simp add: card_Diff_singleton)"], ["proof (state)\nthis:\n  int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i) =\n  int (card (Inv ys xs) - 1) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "also"], ["proof (state)\nthis:\n  int (card (Inv ys xs - {(ys ! 0, xs ! j)})) - int (j - i) =\n  int (card (Inv ys xs) - 1) - int (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"\\<dots> = card (Inv ys xs) - int (Suc j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv ys xs) - 1) - int (j - i) =\n    int (card (Inv ys xs)) - int (Suc j - i)", "using 2"], ["proof (prove)\nusing this:\n  card (Inv ys xs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (card (Inv ys xs) - 1) - int (j - i) =\n    int (card (Inv ys xs)) - int (Suc j - i)", "by arith"], ["proof (state)\nthis:\n  int (card (Inv ys xs) - 1) - int (j - i) =\n  int (card (Inv ys xs)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "also"], ["proof (state)\nthis:\n  int (card (Inv ys xs) - 1) - int (j - i) =\n  int (card (Inv ys xs)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "have \"\\<dots> = card (Inv xs ys) - int (Suc j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv ys xs)) - int (Suc j - i) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "by(simp add: card_Inv_sym)"], ["proof (state)\nthis:\n  int (card (Inv ys xs)) - int (Suc j - i) =\n  int (card (Inv xs ys)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "finally"], ["proof (chain)\npicking this:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv xs ys)) - int (Suc j - i)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv xs ys)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n    int (card (Inv xs ys)) - int (Suc j - i)", "."], ["proof (state)\nthis:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv xs ys)) - int (Suc j - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (card (Inv (swaps [i..<Suc j] xs) ys)) =\n  int (card (Inv xs ys)) - int (Suc j - i)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs ! 0 = ys ! 0; 0 < length xs; dist_perm xs ys\\<rbrakk>\n       \\<Longrightarrow> int (card (Inv (swaps [i..<0] xs) ys)) =\n                         int (card (Inv xs ys)) - int (0 - i)", "qed simp"], ["", "subsection \"Function Lxy\""], ["", "definition Lxy :: \"'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a list\" where\n  \"Lxy xs S = filter (\\<lambda>z. z\\<in>S) xs\""], ["", "thm inter_set_filter"], ["", "lemma Lxy_length_cons: \"length (Lxy xs S) \\<le> length (Lxy (x#xs) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy xs S) \\<le> length (Lxy (x # xs) S)", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>z. z \\<in> S) xs)\n    \\<le> length (filter (\\<lambda>z. z \\<in> S) (x # xs))", "by(simp)"], ["", "lemma Lxy_empty[simp]: \"Lxy [] S = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy [] S = []", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>z. z \\<in> S) [] = []", "by simp"], ["", "lemma Lxy_set_filter: \"set (Lxy xs S) = S \\<inter> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy xs S) = S \\<inter> set xs", "by (simp add: Lxy_def inter_set_filter)"], ["", "lemma Lxy_distinct: \"distinct xs \\<Longrightarrow> distinct (Lxy xs S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> distinct (Lxy xs S)", "by (simp add: Lxy_def)"], ["", "lemma Lxy_append: \"Lxy (xs@ys) S = Lxy xs S @ Lxy ys S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (xs @ ys) S = Lxy xs S @ Lxy ys S", "by(simp add: Lxy_def)"], ["", "lemma Lxy_snoc: \"Lxy (xs@[x]) S = (if x\\<in>S then Lxy xs S @ [x] else Lxy xs S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (xs @ [x]) S = (if x \\<in> S then Lxy xs S @ [x] else Lxy xs S)", "by(simp add: Lxy_def)"], ["", "lemma Lxy_not: \"S \\<inter> set xs = {} \\<Longrightarrow> Lxy xs S = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> set xs = {} \\<Longrightarrow> Lxy xs S = []", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> set xs = {} \\<Longrightarrow>\n    filter (\\<lambda>z. z \\<in> S) xs = []", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S \\<inter> set [] = {} \\<Longrightarrow>\n    filter (\\<lambda>z. z \\<in> S) [] = []\n 2. \\<And>a xs.\n       \\<lbrakk>S \\<inter> set xs = {} \\<Longrightarrow>\n                filter (\\<lambda>z. z \\<in> S) xs = [];\n        S \\<inter> set (a # xs) = {}\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>z. z \\<in> S) (a # xs) = []", "by simp_all"], ["", "lemma Lxy_notin: \"set xs \\<inter> S = {} \\<Longrightarrow> Lxy xs S = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<inter> S = {} \\<Longrightarrow> Lxy xs S = []", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] \\<inter> S = {} \\<Longrightarrow> Lxy [] S = []\n 2. \\<And>a xs.\n       \\<lbrakk>set xs \\<inter> S = {} \\<Longrightarrow> Lxy xs S = [];\n        set (a # xs) \\<inter> S = {}\\<rbrakk>\n       \\<Longrightarrow> Lxy (a # xs) S = []", "by(simp_all add: Lxy_def)"], ["", "lemma Lxy_in: \"x\\<in>S \\<Longrightarrow> Lxy [x] S = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> Lxy [x] S = [x]", "by(simp add: Lxy_def)"], ["", "lemma Lxy_project: \n  assumes \"x\\<noteq>y\" \"x \\<in> set xs\"  \"y\\<in>set xs\" \"distinct xs\" \n    and \"x < y in xs\"\n  shows \"Lxy xs {x,y} = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<in> set xs\n  y \\<in> set xs\n  distinct xs\n  x < y in xs", "have ij: \"index xs x < index xs y\"\n        and xinxs: \"index xs x < length xs\"\n        and yinxs: \"index xs y < length xs\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> set xs\n  y \\<in> set xs\n  distinct xs\n  x < y in xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&&\n    index xs x < length xs &&& index xs y < length xs", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> set xs\n  y \\<in> set xs\n  distinct xs\n  index xs x < index xs y \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. index xs x < index xs y &&&\n    index xs x < length xs &&& index xs y < length xs", "by auto"], ["proof (state)\nthis:\n  index xs x < index xs y\n  index xs x < length xs\n  index xs y < length xs\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "from xinxs"], ["proof (chain)\npicking this:\n  index xs x < length xs", "obtain a as where dec1: \"a @ [xs!index xs x] @ as = xs\"\n        and \"a = take (index xs x) xs\" and \"as = drop (Suc (index xs x)) xs\"\n        and length_a: \"length a = index xs x\" and length_as: \"length as = length xs - index xs x- 1\""], ["proof (prove)\nusing this:\n  index xs x < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! index xs x] @ as = xs; a = take (index xs x) xs;\n         as = drop (Suc (index xs x)) xs; length a = index xs x;\n         length as = length xs - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  index xs x < length xs\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>a @ [xs ! index xs x] @ as = xs; a = take (index xs x) xs;\n         as = drop (Suc (index xs x)) xs; length a = index xs x;\n         length as = length xs - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a @ [xs ! index xs x] @ as = xs\n  a = take (index xs x) xs\n  as = drop (Suc (index xs x)) xs\n  length a = index xs x\n  length as = length xs - index xs x - 1\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "have \"index xs y\\<ge>length (a @ [xs!index xs x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a @ [xs ! index xs x]) \\<le> index xs y", "using length_a ij"], ["proof (prove)\nusing this:\n  length a = index xs x\n  index xs x < index xs y\n\ngoal (1 subgoal):\n 1. length (a @ [xs ! index xs x]) \\<le> index xs y", "by auto"], ["proof (state)\nthis:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "then"], ["proof (chain)\npicking this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y", "have \"((a @ [xs!index xs x]) @ as) ! index xs y = as ! (index xs y-length (a @ [xs ! index xs x]))\""], ["proof (prove)\nusing this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! index xs x]) @ as) ! index xs y =\n    as ! (index xs y - length (a @ [xs ! index xs x]))", "using nth_append[where xs=\"a @ [xs!index xs x]\" and ys=\"as\"]"], ["proof (prove)\nusing this:\n  length (a @ [xs ! index xs x]) \\<le> index xs y\n  ((a @ [xs ! index xs x]) @ as) ! ?n =\n  (if ?n < length (a @ [xs ! index xs x]) then (a @ [xs ! index xs x]) ! ?n\n   else as ! (?n - length (a @ [xs ! index xs x])))\n\ngoal (1 subgoal):\n 1. ((a @ [xs ! index xs x]) @ as) ! index xs y =\n    as ! (index xs y - length (a @ [xs ! index xs x]))", "by(simp)"], ["proof (state)\nthis:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "then"], ["proof (chain)\npicking this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))", "have xsj: \"xs ! index xs y = as ! (index xs y-index xs x-1)\""], ["proof (prove)\nusing this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n\ngoal (1 subgoal):\n 1. xs ! index xs y = as ! (index xs y - index xs x - 1)", "using dec1 length_a"], ["proof (prove)\nusing this:\n  ((a @ [xs ! index xs x]) @ as) ! index xs y =\n  as ! (index xs y - length (a @ [xs ! index xs x]))\n  a @ [xs ! index xs x] @ as = xs\n  length a = index xs x\n\ngoal (1 subgoal):\n 1. xs ! index xs y = as ! (index xs y - index xs x - 1)", "by auto"], ["proof (state)\nthis:\n  xs ! index xs y = as ! (index xs y - index xs x - 1)\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "have las: \"(index xs y-index xs x-1) < length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs y - index xs x - 1 < length as", "using length_as yinxs ij"], ["proof (prove)\nusing this:\n  length as = length xs - index xs x - 1\n  index xs y < length xs\n  index xs x < index xs y\n\ngoal (1 subgoal):\n 1. index xs y - index xs x - 1 < length as", "by simp"], ["proof (state)\nthis:\n  index xs y - index xs x - 1 < length as\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "obtain b c where dec2: \"b @ [xs!index xs y] @ c = as\"\n            and \"b = take (index xs y-index xs x-1) as\" \"c=drop (Suc (index xs y-index xs x-1)) as\"\n            and length_b: \"length b = index xs y-index xs x-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! index xs y] @ c = as;\n         b = take (index xs y - index xs x - 1) as;\n         c = drop (Suc (index xs y - index xs x - 1)) as;\n         length b = index xs y - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id_take_nth_drop[OF las] xsj"], ["proof (prove)\nusing this:\n  as =\n  take (index xs y - index xs x - 1) as @\n  as ! (index xs y - index xs x - 1) #\n  drop (Suc (index xs y - index xs x - 1)) as\n  xs ! index xs y = as ! (index xs y - index xs x - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b @ [xs ! index xs y] @ c = as;\n         b = take (index xs y - index xs x - 1) as;\n         c = drop (Suc (index xs y - index xs x - 1)) as;\n         length b = index xs y - index xs x - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  b @ [xs ! index xs y] @ c = as\n  b = take (index xs y - index xs x - 1) as\n  c = drop (Suc (index xs y - index xs x - 1)) as\n  length b = index xs y - index xs x - 1\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "have xs_dec: \"a @ [xs!index xs x] @ b @ [xs!index xs y] @ c = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs", "using dec1 dec2"], ["proof (prove)\nusing this:\n  a @ [xs ! index xs x] @ as = xs\n  b @ [xs ! index xs y] @ c = as\n\ngoal (1 subgoal):\n 1. a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs", "by auto"], ["proof (state)\nthis:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "from xs_dec assms(4)"], ["proof (chain)\npicking this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n  distinct xs", "have \"distinct ((a @ [xs!index xs x] @ b @ [xs!index xs y]) @ c)\""], ["proof (prove)\nusing this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct ((a @ [xs ! index xs x] @ b @ [xs ! index xs y]) @ c)", "by simp"], ["proof (state)\nthis:\n  distinct ((a @ [xs ! index xs x] @ b @ [xs ! index xs y]) @ c)\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "then"], ["proof (chain)\npicking this:\n  distinct ((a @ [xs ! index xs x] @ b @ [xs ! index xs y]) @ c)", "have c_empty: \"set c \\<inter> {x,y} = {}\"\n      and b_empty: \"set b \\<inter> {x,y} = {}\"and a_empty: \"set a \\<inter> {x,y} = {}\""], ["proof (prove)\nusing this:\n  distinct ((a @ [xs ! index xs x] @ b @ [xs ! index xs y]) @ c)\n\ngoal (1 subgoal):\n 1. set c \\<inter> {x, y} = {} &&&\n    set b \\<inter> {x, y} = {} &&& set a \\<inter> {x, y} = {}", "by(auto simp add: assms(2,3))"], ["proof (state)\nthis:\n  set c \\<inter> {x, y} = {}\n  set b \\<inter> {x, y} = {}\n  set a \\<inter> {x, y} = {}\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "have \"Lxy (a @ [xs!index xs x] @ b @ [xs!index xs y] @ c) {x,y} = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) {x, y} = [x, y]", "apply(simp only: Lxy_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy a {x, y} @\n    Lxy [xs ! index xs x] {x, y} @\n    Lxy b {x, y} @ Lxy [xs ! index xs y] {x, y} @ Lxy c {x, y} =\n    [x, y]", "apply(simp add: assms(2,3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy a {x, y} @\n    Lxy [x] {x, y} @ Lxy b {x, y} @ Lxy [y] {x, y} @ Lxy c {x, y} =\n    [x, y]", "using a_empty b_empty c_empty"], ["proof (prove)\nusing this:\n  set a \\<inter> {x, y} = {}\n  set b \\<inter> {x, y} = {}\n  set c \\<inter> {x, y} = {}\n\ngoal (1 subgoal):\n 1. Lxy a {x, y} @\n    Lxy [x] {x, y} @ Lxy b {x, y} @ Lxy [y] {x, y} @ Lxy c {x, y} =\n    [x, y]", "by(simp add: Lxy_notin Lxy_in)"], ["proof (state)\nthis:\n  Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) {x, y} = [x, y]\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "with xs_dec"], ["proof (chain)\npicking this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n  Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) {x, y} = [x, y]", "show ?thesis"], ["proof (prove)\nusing this:\n  a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c = xs\n  Lxy (a @ [xs ! index xs x] @ b @ [xs ! index xs y] @ c) {x, y} = [x, y]\n\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "by auto"], ["proof (state)\nthis:\n  Lxy xs {x, y} = [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lxy_mono: \"{x,y} \\<subseteq> set xs \\<Longrightarrow> distinct xs \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "apply(cases \"x=y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x = y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}\n 2. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "apply(simp add: before_in_irefl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume xyset: \"{x,y} \\<subseteq> set xs\""], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume dxs: \"distinct xs\""], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume xy: \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "{"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume 1: \"{x,y} \\<subseteq> set xs\""], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume xny: \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "assume 3: \"x < y in xs\""], ["proof (state)\nthis:\n  x < y in xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "have \"Lxy xs {x,y} = [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy xs {x, y} = [x, y]", "apply(rule Lxy_project)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. x \\<in> set xs\n 3. y \\<in> set xs\n 4. distinct xs\n 5. x < y in xs", "using xny 1 3 dxs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} \\<subseteq> set xs\n  x < y in xs\n  distinct xs\n\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. x \\<in> set xs\n 3. y \\<in> set xs\n 4. distinct xs\n 5. x < y in xs", "by(auto)"], ["proof (state)\nthis:\n  Lxy xs {x, y} = [x, y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "then"], ["proof (chain)\npicking this:\n  Lxy xs {x, y} = [x, y]", "have \"x < y in Lxy xs {x,y}\""], ["proof (prove)\nusing this:\n  Lxy xs {x, y} = [x, y]\n\ngoal (1 subgoal):\n 1. x < y in Lxy xs {x, y}", "using xny"], ["proof (prove)\nusing this:\n  Lxy xs {x, y} = [x, y]\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y in Lxy xs {x, y}", "by(simp add: before_in_def)"], ["proof (state)\nthis:\n  x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>{?xa2, ?ya2} \\<subseteq> set xs; ?xa2 \\<noteq> ?ya2;\n   ?xa2 < ?ya2 in xs\\<rbrakk>\n  \\<Longrightarrow> ?xa2 < ?ya2 in Lxy xs {?xa2, ?ya2}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "note aha=this"], ["proof (state)\nthis:\n  \\<lbrakk>{?xa2, ?ya2} \\<subseteq> set xs; ?xa2 \\<noteq> ?ya2;\n   ?xa2 < ?ya2 in xs\\<rbrakk>\n  \\<Longrightarrow> ?xa2 < ?ya2 in Lxy xs {?xa2, ?ya2}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "have a: \"x < y in xs \\<Longrightarrow> x < y in Lxy xs {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in xs \\<Longrightarrow> x < y in Lxy xs {x, y}", "apply(subst Lxy_project)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x < y in xs \\<Longrightarrow> x \\<noteq> y\n 2. x < y in xs \\<Longrightarrow> x \\<in> set xs\n 3. x < y in xs \\<Longrightarrow> y \\<in> set xs\n 4. x < y in xs \\<Longrightarrow> distinct xs\n 5. x < y in xs \\<Longrightarrow> x < y in xs\n 6. x < y in xs \\<Longrightarrow> x < y in [x, y]", "using xy xyset dxs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} \\<subseteq> set xs\n  distinct xs\n\ngoal (6 subgoals):\n 1. x < y in xs \\<Longrightarrow> x \\<noteq> y\n 2. x < y in xs \\<Longrightarrow> x \\<in> set xs\n 3. x < y in xs \\<Longrightarrow> y \\<in> set xs\n 4. x < y in xs \\<Longrightarrow> distinct xs\n 5. x < y in xs \\<Longrightarrow> x < y in xs\n 6. x < y in xs \\<Longrightarrow> x < y in [x, y]", "by(simp_all add: before_in_def)"], ["proof (state)\nthis:\n  x < y in xs \\<Longrightarrow> x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "have t: \"{x,y}={y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {y, x}", "by(auto)"], ["proof (state)\nthis:\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "have f: \"~ x < y in xs \\<Longrightarrow> y < x in Lxy xs {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> y < x in Lxy xs {x, y}", "unfolding t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> y < x in Lxy xs {y, x}", "apply(rule aha)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> x < y in xs \\<Longrightarrow> {y, x} \\<subseteq> set xs\n 2. \\<not> x < y in xs \\<Longrightarrow> y \\<noteq> x\n 3. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "using xyset"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set xs\n\ngoal (3 subgoals):\n 1. \\<not> x < y in xs \\<Longrightarrow> {y, x} \\<subseteq> set xs\n 2. \\<not> x < y in xs \\<Longrightarrow> y \\<noteq> x\n 3. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> x < y in xs \\<Longrightarrow> y \\<noteq> x\n 2. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "using xy"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<not> x < y in xs \\<Longrightarrow> y \\<noteq> x\n 2. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "using xy xyset"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> y < x in xs", "by(simp add: not_before_in)"], ["proof (state)\nthis:\n  \\<not> x < y in xs \\<Longrightarrow> y < x in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "have b: \"~ x < y in xs \\<Longrightarrow> ~ x < y in Lxy xs {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "assume \"~ x < y in xs\""], ["proof (state)\nthis:\n  \\<not> x < y in xs\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "then"], ["proof (chain)\npicking this:\n  \\<not> x < y in xs", "have \"y < x in Lxy xs {x,y}\""], ["proof (prove)\nusing this:\n  \\<not> x < y in xs\n\ngoal (1 subgoal):\n 1. y < x in Lxy xs {x, y}", "using f"], ["proof (prove)\nusing this:\n  \\<not> x < y in xs\n  \\<not> x < y in xs \\<Longrightarrow> y < x in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. y < x in Lxy xs {x, y}", "by auto"], ["proof (state)\nthis:\n  y < x in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "then"], ["proof (chain)\npicking this:\n  y < x in Lxy xs {x, y}", "have \"~ x < y in Lxy xs {x,y}\""], ["proof (prove)\nusing this:\n  y < x in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in Lxy xs {x, y}", "using xy"], ["proof (prove)\nusing this:\n  y < x in Lxy xs {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> x < y in Lxy xs {x, y}", "by(simp add: not_before_in)"], ["proof (state)\nthis:\n  \\<not> x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "then"], ["proof (chain)\npicking this:\n  \\<not> x < y in Lxy xs {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<not> x < y in Lxy xs {x, y}", "."], ["proof (state)\nthis:\n  \\<not> x < y in Lxy xs {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<subseteq> set xs; distinct xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in xs = x < y in Lxy xs {x, y}", "from a b"], ["proof (chain)\npicking this:\n  x < y in xs \\<Longrightarrow> x < y in Lxy xs {x, y}\n  \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in xs \\<Longrightarrow> x < y in Lxy xs {x, y}\n  \\<not> x < y in xs \\<Longrightarrow> \\<not> x < y in Lxy xs {x, y}\n\ngoal (1 subgoal):\n 1. x < y in xs = x < y in Lxy xs {x, y}", "by metis"], ["proof (state)\nthis:\n  x < y in xs = x < y in Lxy xs {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"List Update as Online/Offline Algorithm\""], ["", "type_synonym 'a state = \"'a list\""], ["", "type_synonym answer = \"nat * nat list\""], ["", "definition step :: \"'a state \\<Rightarrow> 'a \\<Rightarrow> answer \\<Rightarrow> 'a state\" where\n\"step s r a =\n  (let (k,sws) = a in mtf2 k r (swaps sws s))\""], ["", "definition t :: \"'a state \\<Rightarrow> 'a \\<Rightarrow> answer \\<Rightarrow> nat\" where\n\"t s r a = (let (mf,sws) = a in index (swaps sws s) r + 1 + size sws)\""], ["", "definition static where \"static s rs = (set rs \\<subseteq> set s)\""], ["", "interpretation On_Off step t static"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "type_synonym 'a alg_off = \"'a state \\<Rightarrow> 'a list \\<Rightarrow> answer list\""], ["", "type_synonym ('a,'is) alg_on = \"('a state,'is,'a,answer) alg_on\""], ["", "lemma T_ge_len: \"length as = length rs \\<Longrightarrow> T s rs as \\<ge> length rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = length rs \\<Longrightarrow> length rs \\<le> T s rs as", "by(induction arbitrary: s rule: list_induct2)\n  (auto simp: t_def trans_le_add2)"], ["", "lemma T_off_neq0: \"(\\<And>rs s0. size(alg s0 rs) = length rs) \\<Longrightarrow>\n  rs \\<noteq> [] \\<Longrightarrow> T_off alg s0 rs \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>rs s0. length (alg s0 rs) = length rs;\n     rs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> T_off alg s0 rs \\<noteq> 0", "apply(erule_tac x=rs in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<noteq> [];\n     \\<And>s0. length (alg s0 rs) = length rs\\<rbrakk>\n    \\<Longrightarrow> T_off alg s0 rs \\<noteq> 0", "apply(erule_tac x=s0 in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<noteq> []; length (alg s0 rs) = length rs\\<rbrakk>\n    \\<Longrightarrow> T_off alg s0 rs \\<noteq> 0", "apply (auto simp: neq_Nil_conv length_Suc_conv t_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_step[simp]: \"length (step s r as) = length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (step s r as) = length s", "by(simp add: step_def split_def)"], ["", "lemma step_Nil_iff[simp]: \"step xs r act = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (step xs r act = []) = (xs = [])", "by(auto simp add: step_def mtf2_def split: prod.splits)"], ["", "lemma set_step2: \"set(step s r (mf,sws)) = set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (step s r (mf, sws)) = set s", "by(auto simp add: step_def)"], ["", "lemma set_step: \"set(step s r act) = set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (step s r act) = set s", "by(cases act)(simp add: set_step2)"], ["", "lemma distinct_step: \"distinct(step s r as) = distinct s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (step s r as) = distinct s", "by (auto simp: step_def split_def)"], ["", "subsection \"Online Algorithm Move-to-Front is 2-Competitive\""], ["", "definition MTF :: \"('a,unit) alg_on\" where\n\"MTF = (\\<lambda>_. (), \\<lambda>s r. ((size (fst s) - 1,[]), ()))\""], ["", "text\\<open>It was first proved by Sleator and Tarjan~\\cite{SleatorT-CACM85} that\nthe Move-to-Front algorithm is 2-competitive.\\<close>"], ["", "(* The core idea with upper bounds: *)"], ["", "lemma potential:\nfixes t :: \"nat \\<Rightarrow> 'a::linordered_ab_group_add\" and p :: \"nat \\<Rightarrow> 'a\"\nassumes p0: \"p 0 = 0\" and ppos: \"\\<And>n. p n \\<ge> 0\"\nand ub: \"\\<And>n. t n + p(n+1) - p n \\<le> u n\"\nshows \"(\\<Sum>i<n. t i) \\<le> (\\<Sum>i<n. u i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "let ?a = \"\\<lambda>n. t n + p(n+1) - p n\""], ["proof (state)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "have 1: \"(\\<Sum>i<n. t i) = (\\<Sum>i<n. ?a i) - p(n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n", "by(induction n) (simp_all add: p0)"], ["proof (state)\nthis:\n  sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "by (metis (erased, lifting) add.commute diff_add_cancel le_add_same_cancel2 order.trans ppos sum_mono ub)"], ["proof (state)\nthis:\n  sum t {..<n} \\<le> sum u {..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma potential2:\nfixes t :: \"nat \\<Rightarrow> 'a::linordered_ab_group_add\" and p :: \"nat \\<Rightarrow> 'a\"\nassumes p0: \"p 0 = 0\" and ppos: \"\\<And>n. p n \\<ge> 0\"\nand ub: \"\\<And>m. m<n \\<Longrightarrow> t m + p(m+1) - p m \\<le> u m\"\nshows \"(\\<Sum>i<n. t i) \\<le> (\\<Sum>i<n. u i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "let ?a = \"\\<lambda>n. t n + p(n+1) - p n\""], ["proof (state)\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "have \"(\\<Sum>i<n. t i) = (\\<Sum>i<n. ?a i) - p(n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n", "by(induction n) (simp_all add: p0)"], ["proof (state)\nthis:\n  sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "also"], ["proof (state)\nthis:\n  sum t {..<n} = (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "have      \"\\<dots> \\<le> (\\<Sum>i<n. ?a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n    \\<le> (\\<Sum>i<n. t i + p (i + 1) - p i)", "using ppos"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> p ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n    \\<le> (\\<Sum>i<n. t i + p (i + 1) - p i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n  \\<le> (\\<Sum>i<n. t i + p (i + 1) - p i)\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. t i + p (i + 1) - p i) - p n\n  \\<le> (\\<Sum>i<n. t i + p (i + 1) - p i)\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "have      \"\\<dots> \\<le> (\\<Sum>i<n. u i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. t i + p (i + 1) - p i) \\<le> sum u {..<n}", "apply(rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow> t i + p (i + 1) - p i \\<le> u i", "apply(rule ub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> i < n", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. t i + p (i + 1) - p i) \\<le> sum u {..<n}\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "finally"], ["proof (chain)\npicking this:\n  sum t {..<n} \\<le> sum u {..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  sum t {..<n} \\<le> sum u {..<n}\n\ngoal (1 subgoal):\n 1. sum t {..<n} \\<le> sum u {..<n}", "."], ["proof (state)\nthis:\n  sum t {..<n} \\<le> sum u {..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"before x xs \\<equiv> {y. y < x in xs}\""], ["", "abbreviation \"after x xs \\<equiv> {y. x < y in xs}\""], ["", "lemma finite_before[simp]: \"finite (before x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (before x xs)", "apply(rule finite_subset[where B = \"set xs\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. before x xs \\<subseteq> set xs\n 2. finite (set xs)", "apply (auto dest: before_in_setD1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_after[simp]: \"finite (after x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (after x xs)", "apply(rule finite_subset[where B = \"set xs\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. after x xs \\<subseteq> set xs\n 2. finite (set xs)", "apply (auto dest: before_in_setD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma before_conv_take:\n  \"x : set xs \\<Longrightarrow> before x xs = set(take (index xs x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    before x xs = set (take (index xs x) xs)", "by (auto simp add: before_in_def set_take_if_index index_le_size) (metis index_take leI)"], ["", "lemma card_before: \"distinct xs \\<Longrightarrow> x : set xs \\<Longrightarrow> card (before x xs) = index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> card (before x xs) = index xs x", "using  index_le_size[of xs x]"], ["proof (prove)\nusing this:\n  index xs x \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> card (before x xs) = index xs x", "by(simp add: before_conv_take distinct_card[OF distinct_take] min_def)"], ["", "lemma before_Un: \"set xs = set ys \\<Longrightarrow> x : set xs \\<Longrightarrow>\n  before x ys = before x xs \\<inter> before x ys Un after x xs \\<inter> before x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = set ys; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> before x ys =\n                      before x xs \\<inter> before x ys \\<union>\n                      after x xs \\<inter> before x ys", "by(auto)(metis before_in_setD1 not_before_in)"], ["", "lemma phi_diff_aux:\n  \"card (Inv xs ys \\<union>\n             {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n             {(x, y) |y. x < y in xs \\<and> y < x in ys}) =\n   card(Inv xs ys) + card(before x xs \\<inter> before x ys)\n   - int(card(after x xs \\<inter> before x ys))\"\n  (is \"card(?I \\<union> ?B - ?A) = card ?I + card ?b - int(card ?a)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have 1: \"?I \\<inter> ?B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv xs ys \\<inter> {(y, x) |y. y < x in xs \\<and> y < x in ys} = {}", "by(auto simp: Inv_def) (metis no_before_inI)"], ["proof (state)\nthis:\n  Inv xs ys \\<inter> {(y, x) |y. y < x in xs \\<and> y < x in ys} = {}\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have 2: \"?A \\<subseteq> ?I \\<union> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |y. x < y in xs \\<and> y < x in ys}\n    \\<subseteq> Inv xs ys \\<union>\n                {(y, x) |y. y < x in xs \\<and> y < x in ys}", "by(auto simp: Inv_def)"], ["proof (state)\nthis:\n  {(x, y) |y. x < y in xs \\<and> y < x in ys}\n  \\<subseteq> Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys}\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have 3: \"?A \\<subseteq> ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |y. x < y in xs \\<and> y < x in ys} \\<subseteq> Inv xs ys", "by(auto simp: Inv_def)"], ["proof (state)\nthis:\n  {(x, y) |y. x < y in xs \\<and> y < x in ys} \\<subseteq> Inv xs ys\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have \"int(card(?I \\<union> ?B - ?A)) = int(card ?I + card ?B) - int(card ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) +\n         card {(y, x) |y. y < x in xs \\<and> y < x in ys}) -\n    int (card {(x, y) |y. x < y in xs \\<and> y < x in ys})", "using  card_mono[OF _ 3]"], ["proof (prove)\nusing this:\n  finite (Inv xs ys) \\<Longrightarrow>\n  card {(x, y) |y. x < y in xs \\<and> y < x in ys} \\<le> card (Inv xs ys)\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) +\n         card {(y, x) |y. y < x in xs \\<and> y < x in ys}) -\n    int (card {(x, y) |y. x < y in xs \\<and> y < x in ys})", "by(simp add: card_Un_disjoint[OF _ _ 1] card_Diff_subset[OF _ 2])"], ["proof (state)\nthis:\n  int (card\n        (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n         {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n  int (card (Inv xs ys) +\n       card {(y, x) |y. y < x in xs \\<and> y < x in ys}) -\n  int (card {(x, y) |y. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "also"], ["proof (state)\nthis:\n  int (card\n        (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n         {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n  int (card (Inv xs ys) +\n       card {(y, x) |y. y < x in xs \\<and> y < x in ys}) -\n  int (card {(x, y) |y. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have \"card ?B = card (fst ` ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n    card (fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys})", "by(auto simp: card_image inj_on_def)"], ["proof (state)\nthis:\n  card {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n  card (fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "also"], ["proof (state)\nthis:\n  card {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n  card (fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have \"fst ` ?B = ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n    before x xs \\<inter> before x ys", "by force"], ["proof (state)\nthis:\n  fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n  before x xs \\<inter> before x ys\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "also"], ["proof (state)\nthis:\n  fst ` {(y, x) |y. y < x in xs \\<and> y < x in ys} =\n  before x xs \\<inter> before x ys\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have \"card ?A = card (snd ` ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(x, y) |y. x < y in xs \\<and> y < x in ys} =\n    card (snd ` {(x, y) |y. x < y in xs \\<and> y < x in ys})", "by(auto simp: card_image inj_on_def)"], ["proof (state)\nthis:\n  card {(x, y) |y. x < y in xs \\<and> y < x in ys} =\n  card (snd ` {(x, y) |y. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "also"], ["proof (state)\nthis:\n  card {(x, y) |y. x < y in xs \\<and> y < x in ys} =\n  card (snd ` {(x, y) |y. x < y in xs \\<and> y < x in ys})\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "have \"snd ` ?A = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` {(x, y) |y. x < y in xs \\<and> y < x in ys} =\n    after x xs \\<inter> before x ys", "by force"], ["proof (state)\nthis:\n  snd ` {(x, y) |y. x < y in xs \\<and> y < x in ys} =\n  after x xs \\<inter> before x ys\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "finally"], ["proof (chain)\npicking this:\n  int (card\n        (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n         {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n  int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  int (card\n        (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n         {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n  int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))\n\ngoal (1 subgoal):\n 1. int (card\n          (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n           {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n    int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))", "."], ["proof (state)\nthis:\n  int (card\n        (Inv xs ys \\<union> {(y, x) |y. y < x in xs \\<and> y < x in ys} -\n         {(x, y) |y. x < y in xs \\<and> y < x in ys})) =\n  int (card (Inv xs ys) + card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_before_Cons[simp]: \"\\<not> x < y in y # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y in y # xs", "by (simp add: before_in_def)"], ["", "lemma before_Cons[simp]:\n  \"y \\<in> set xs \\<Longrightarrow> y \\<noteq> x \\<Longrightarrow> before y (x#xs) = insert x (before y xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set xs; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> before y (x # xs) = insert x (before y xs)", "by(auto simp: before_in_def)"], ["", "lemma card_before_le_index: \"card (before x xs) \\<le> index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (before x xs) \\<le> index xs x", "apply(cases \"x \\<in> set xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> card (before x xs) \\<le> index xs x\n 2. x \\<notin> set xs \\<Longrightarrow> card (before x xs) \\<le> index xs x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> set xs \\<Longrightarrow> card (before x xs) \\<le> index xs x\n 2. x \\<in> set xs \\<Longrightarrow> card (before x xs) \\<le> index xs x", "apply (simp add: before_in_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> card (before x xs) \\<le> index xs x", "apply(induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> card (before x []) \\<le> index [] x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                card (before x xs) \\<le> index xs x;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (before x (a # xs)) \\<le> index (a # xs) x", "apply (simp add: before_in_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                card (before x xs) \\<le> index xs x;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (before x (a # xs)) \\<le> index (a # xs) x", "apply (auto simp: card_insert_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma config_config_length: \"length (fst (config A init qs)) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (config A init qs)) = length init", "apply (induct rule: config_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length init = length init\n 2. \\<And>s q a.\n       length s = length init \\<Longrightarrow>\n       length (step s q a) = length init", "by (simp_all)"], ["", "lemma config_config_distinct: \n  shows \" distinct (fst (config A init qs)) = distinct init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (config A init qs)) = distinct init", "apply (induct rule: config_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct init = distinct init\n 2. \\<And>s q a.\n       distinct s = distinct init \\<Longrightarrow>\n       distinct (step s q a) = distinct init", "by (simp_all add: distinct_step)"], ["", "lemma config_config_set: \n  shows \"set (fst (config A init qs)) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (config A init qs)) = set init", "apply(induct rule: config_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>s q a.\n       set s = set init \\<Longrightarrow> set (step s q a) = set init", "by(simp_all add: set_step)"], ["", "lemma config_config:\n  \"set (fst (config A init qs)) = set init\n        \\<and> distinct (fst (config A init qs)) = distinct init\n        \\<and> length (fst (config A init qs)) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (config A init qs)) = set init \\<and>\n    distinct (fst (config A init qs)) = distinct init \\<and>\n    length (fst (config A init qs)) = length init", "using config_config_distinct config_config_set config_config_length"], ["proof (prove)\nusing this:\n  distinct (fst (config ?A ?init ?qs)) = distinct ?init\n  set (fst (config ?A ?init ?qs)) = set ?init\n  length (fst (config ?A ?init ?qs)) = length ?init\n\ngoal (1 subgoal):\n 1. set (fst (config A init qs)) = set init \\<and>\n    distinct (fst (config A init qs)) = distinct init \\<and>\n    length (fst (config A init qs)) = length init", "by metis"], ["", "lemma config_dist_perm:\n  \"distinct init \\<Longrightarrow> dist_perm (fst (config A init qs)) init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init \\<Longrightarrow> dist_perm (fst (config A init qs)) init", "using config_config_distinct config_config_set"], ["proof (prove)\nusing this:\n  distinct (fst (config ?A ?init ?qs)) = distinct ?init\n  set (fst (config ?A ?init ?qs)) = set ?init\n\ngoal (1 subgoal):\n 1. distinct init \\<Longrightarrow> dist_perm (fst (config A init qs)) init", "by metis"], ["", "lemma config_rand_length: \"\\<forall>x\\<in>set_pmf (config_rand  A init qs). length (fst x) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       length (fst x) = length init", "apply (induct rule: config_rand_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length init = length init\n 2. \\<And>s q a.\n       length s = length init \\<Longrightarrow>\n       length (step s q a) = length init", "by (simp_all)"], ["", "lemma config_rand_distinct: \n  shows \"\\<forall>x \\<in> (config_rand  A init qs). distinct (fst x) = distinct init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       distinct (fst x) = distinct init", "apply (induct rule: config_rand_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct init = distinct init\n 2. \\<And>s q a.\n       distinct s = distinct init \\<Longrightarrow>\n       distinct (step s q a) = distinct init", "by (simp_all add: distinct_step)"], ["", "lemma config_rand_set: \n  shows \" \\<forall>x \\<in> (config_rand   A init qs). set (fst x) = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       set (fst x) = set init", "apply(induct rule: config_rand_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>s q a.\n       set s = set init \\<Longrightarrow> set (step s q a) = set init", "by(simp_all add: set_step)"], ["", "lemma config_rand:\n  \"\\<forall>x \\<in> (config_rand   A  init qs). set (fst x) = set init\n        \\<and> distinct (fst x) = distinct init \\<and> length (fst x) = length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       set (fst x) = set init \\<and>\n       distinct (fst x) = distinct init \\<and> length (fst x) = length init", "using config_rand_distinct config_rand_set config_rand_length"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       set (fst x) = set init \\<and>\n       distinct (fst x) = distinct init \\<and> length (fst x) = length init", "by metis"], ["", "lemma config_rand_dist_perm:\n  \"distinct init \\<Longrightarrow> \\<forall>x \\<in> (config_rand A init qs). dist_perm (fst x) init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init \\<Longrightarrow>\n    \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       dist_perm (fst x) init", "using config_rand_distinct config_rand_set"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n  \\<forall>x\\<in>set_pmf\n                  (config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. distinct init \\<Longrightarrow>\n    \\<forall>x\\<in>set_pmf\n                    (config'_rand A\n                      (fst A init \\<bind>\n                       (\\<lambda>is. return_pmf (init, is)))\n                      qs).\n       dist_perm (fst x) init", "by metis"], ["", "(*fixme start from Inv*)"], ["", "lemma amor_mtf_ub: assumes \"x : set ys\" \"set xs = set ys\"\nshows \"int(card(before x xs Int before x ys)) - card(after x xs Int before x ys)\n  \\<le> 2 * int(index xs x) - card (before x ys)\" (is \"?m - ?n \\<le> 2 * ?j - ?k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "have xxs: \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "let ?bxxs = \"before x xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "let ?bxys = \"before x ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "let ?axxs = \"after x xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "have 0: \"?bxxs \\<inter> ?axxs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before x xs \\<inter> after x xs = {}", "by (auto simp: before_in_def)"], ["proof (state)\nthis:\n  before x xs \\<inter> after x xs = {}\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "hence 1: \"(?bxxs \\<inter> ?bxys) \\<inter> (?axxs \\<inter> ?bxys) = {}\""], ["proof (prove)\nusing this:\n  before x xs \\<inter> after x xs = {}\n\ngoal (1 subgoal):\n 1. before x xs \\<inter> before x ys \\<inter>\n    (after x xs \\<inter> before x ys) =\n    {}", "by blast"], ["proof (state)\nthis:\n  before x xs \\<inter> before x ys \\<inter>\n  (after x xs \\<inter> before x ys) =\n  {}\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "have \"(?bxxs \\<inter> ?bxys) \\<union> (?axxs \\<inter> ?bxys) = ?bxys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before x xs \\<inter> before x ys \\<union>\n    after x xs \\<inter> before x ys =\n    before x ys", "using assms(2) before_Un xxs"], ["proof (prove)\nusing this:\n  set xs = set ys\n  \\<lbrakk>set ?xs = set ?ys; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> before ?x ?ys =\n                    before ?x ?xs \\<inter> before ?x ?ys \\<union>\n                    after ?x ?xs \\<inter> before ?x ?ys\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. before x xs \\<inter> before x ys \\<union>\n    after x xs \\<inter> before x ys =\n    before x ys", "by fastforce"], ["proof (state)\nthis:\n  before x xs \\<inter> before x ys \\<union>\n  after x xs \\<inter> before x ys =\n  before x ys\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "hence \"?m + ?n = ?k\""], ["proof (prove)\nusing this:\n  before x xs \\<inter> before x ys \\<union>\n  after x xs \\<inter> before x ys =\n  before x ys\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) +\n    int (card (after x xs \\<inter> before x ys)) =\n    int (card (before x ys))", "using card_Un_disjoint[OF _ _ 1]"], ["proof (prove)\nusing this:\n  before x xs \\<inter> before x ys \\<union>\n  after x xs \\<inter> before x ys =\n  before x ys\n  \\<lbrakk>finite (before x xs \\<inter> before x ys);\n   finite (after x xs \\<inter> before x ys)\\<rbrakk>\n  \\<Longrightarrow> card\n                     (before x xs \\<inter> before x ys \\<union>\n                      after x xs \\<inter> before x ys) =\n                    card (before x xs \\<inter> before x ys) +\n                    card (after x xs \\<inter> before x ys)\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) +\n    int (card (after x xs \\<inter> before x ys)) =\n    int (card (before x ys))", "by simp"], ["proof (state)\nthis:\n  int (card (before x xs \\<inter> before x ys)) +\n  int (card (after x xs \\<inter> before x ys)) =\n  int (card (before x ys))\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "hence \"?m - ?n = 2 * ?m - ?k\""], ["proof (prove)\nusing this:\n  int (card (before x xs \\<inter> before x ys)) +\n  int (card (after x xs \\<inter> before x ys)) =\n  int (card (before x ys))\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys)) =\n    2 * int (card (before x xs \\<inter> before x ys)) -\n    int (card (before x ys))", "by arith"], ["proof (state)\nthis:\n  int (card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys)) =\n  2 * int (card (before x xs \\<inter> before x ys)) -\n  int (card (before x ys))\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "also"], ["proof (state)\nthis:\n  int (card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys)) =\n  2 * int (card (before x xs \\<inter> before x ys)) -\n  int (card (before x ys))\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "have \"?m \\<le> ?j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) \\<le> int (index xs x)", "using card_before_le_index[of x xs] card_mono[of ?bxxs, OF _ Int_lower1]"], ["proof (prove)\nusing this:\n  card (before x xs) \\<le> index xs x\n  finite (before x xs) \\<Longrightarrow>\n  card (before x xs \\<inter> ?B1) \\<le> card (before x xs)\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) \\<le> int (index xs x)", "by(auto intro: order_trans)"], ["proof (state)\nthis:\n  int (card (before x xs \\<inter> before x ys)) \\<le> int (index xs x)\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      2 * xa - int (card (before x ys))\n      \\<le> 2 * y - int (card (before x ys))) \\<Longrightarrow>\n  int (card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))\n  \\<le> 2 * int (index xs x) - int (card (before x ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      2 * xa - int (card (before x ys))\n      \\<le> 2 * y - int (card (before x ys))) \\<Longrightarrow>\n  int (card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))\n  \\<le> 2 * int (index xs x) - int (card (before x ys))\n\ngoal (1 subgoal):\n 1. int (card (before x xs \\<inter> before x ys)) -\n    int (card (after x xs \\<inter> before x ys))\n    \\<le> 2 * int (index xs x) - int (card (before x ys))", "by auto"], ["proof (state)\nthis:\n  int (card (before x xs \\<inter> before x ys)) -\n  int (card (after x xs \\<inter> before x ys))\n  \\<le> 2 * int (index xs x) - int (card (before x ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "locale MTF_Off =\nfixes as :: \"answer list\"\nfixes rs :: \"'a list\"\nfixes s0 :: \"'a list\"\nassumes dist_s0[simp]: \"distinct s0\"\nassumes len_as: \"length as = length rs\"\nbegin"], ["", "definition mtf_A :: \"nat list\" where\n\"mtf_A = map fst as\""], ["", "definition sw_A :: \"nat list list\" where\n\"sw_A = map snd as\""], ["", "fun s_A :: \"nat \\<Rightarrow> 'a list\" where\n\"s_A 0 = s0\" |\n\"s_A(Suc n) = step (s_A n) (rs!n) (mtf_A!n, sw_A!n)\""], ["", "lemma length_s_A[simp]: \"length(s_A n) = length s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s_A n) = length s0", "by (induction n) simp_all"], ["", "lemma dist_s_A[simp]: \"distinct(s_A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (s_A n)", "by(induction n) (simp_all add: step_def)"], ["", "lemma set_s_A[simp]: \"set(s_A n) = set s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s_A n) = set s0", "by(induction n) (simp_all add: step_def)"], ["", "fun s_mtf :: \"nat \\<Rightarrow> 'a list\" where\n\"s_mtf 0 = s0\" |\n\"s_mtf (Suc n) = mtf (rs!n) (s_mtf n)\""], ["", "definition t_mtf :: \"nat \\<Rightarrow> int\" where\n\"t_mtf n = index (s_mtf n) (rs!n) + 1\""], ["", "definition T_mtf :: \"nat \\<Rightarrow> int\" where\n\"T_mtf n = (\\<Sum>i<n. t_mtf i)\""], ["", "definition c_A :: \"nat \\<Rightarrow> int\" where\n\"c_A n = index (swaps (sw_A!n) (s_A n)) (rs!n) + 1\""], ["", "definition f_A :: \"nat \\<Rightarrow> int\" where\n\"f_A n = min (mtf_A!n) (index (swaps (sw_A!n) (s_A n)) (rs!n))\""], ["", "definition p_A :: \"nat \\<Rightarrow> int\" where\n\"p_A n = size(sw_A!n)\""], ["", "definition t_A :: \"nat \\<Rightarrow> int\" where\n\"t_A n = c_A n + p_A n\""], ["", "definition T_A :: \"nat \\<Rightarrow> int\" where\n\"T_A n = (\\<Sum>i<n. t_A i)\""], ["", "lemma length_s_mtf[simp]: \"length(s_mtf n) = length s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s_mtf n) = length s0", "by (induction n) simp_all"], ["", "lemma dist_s_mtf[simp]: \"distinct(s_mtf n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (s_mtf n)", "apply(induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (s_mtf 0)\n 2. \\<And>n. distinct (s_mtf n) \\<Longrightarrow> distinct (s_mtf (Suc n))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. distinct (s_mtf n) \\<Longrightarrow> distinct (s_mtf (Suc n))", "apply (auto simp: mtf_def index_take set_drop_if_index)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>distinct (s_mtf n); rs ! n \\<in> set (s_mtf n);\n        x \\<in> set (take (index (s_mtf n) (rs ! n)) (s_mtf n));\n        x \\<in> set (drop (Suc (index (s_mtf n) (rs ! n)))\n                      (s_mtf n))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis set_drop_if_index index_take less_Suc_eq_le linear)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_s_mtf[simp]: \"set (s_mtf n) = set s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (s_mtf n) = set s0", "by (induction n) (simp_all)"], ["", "lemma dperm_inv: \"dist_perm (s_A n) (s_mtf n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm (s_A n) (s_mtf n)", "by (metis dist_s_mtf dist_s_A set_s_mtf set_s_A)"], ["", "definition Phi :: \"nat \\<Rightarrow> int\" (\"\\<Phi>\") where\n\"Phi n = card(Inv (s_A n) (s_mtf n))\""], ["", "lemma phi0: \"Phi 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> 0 = 0", "by(simp add: Phi_def)"], ["", "lemma phi_pos: \"Phi n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> n", "by(simp add: Phi_def)"], ["", "lemma mtf_ub: \"t_mtf n + Phi (n+1) - Phi n \\<le> 2 * c_A n - 1 + p_A n - f_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?xs = \"s_A n\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?ys = \"s_mtf n\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?x = \"rs!n\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?xs' = \"swaps (sw_A!n) ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?ys' = \"mtf ?x ?ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "assume xin: \"?x \\<in> set ?ys\""], ["proof (state)\nthis:\n  rs ! n \\<in> set (s_mtf n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?bb = \"before ?x ?xs \\<inter> before ?x ?ys\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "let ?ab = \"after ?x ?xs \\<inter> before ?x ?ys\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "have phi_mtf:\n    \"card(Inv ?xs' ?ys') - int(card (Inv ?xs' ?ys))\n   \\<le> 2 * int(index ?xs' ?x) - int(card (before ?x ?ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n    int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> 2 * int (index (swaps (sw_A ! n) (s_A n)) (rs ! n)) -\n          int (card (before (rs ! n) (s_mtf n)))", "using xin"], ["proof (prove)\nusing this:\n  rs ! n \\<in> set (s_mtf n)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n    int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> 2 * int (index (swaps (sw_A ! n) (s_A n)) (rs ! n)) -\n          int (card (before (rs ! n) (s_mtf n)))", "by(simp add: Inv_mtf phi_diff_aux amor_mtf_ub)"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> 2 * int (index (swaps (sw_A ! n) (s_A n)) (rs ! n)) -\n        int (card (before (rs ! n) (s_mtf n)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "have phi_sw: \"card(Inv ?xs' ?ys) \\<le> Phi n + length(sw_A!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "have \"int(card (Inv ?xs' ?ys)) \\<le> card(Inv ?xs' ?xs) + int(card(Inv ?xs ?ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n))) +\n          int (card (Inv (s_A n) (s_mtf n)))", "using card_Inv_tri_ineq[of ?xs' ?xs ?ys] xin"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist_perm (swaps (sw_A ! n) (s_A n)) (s_A n);\n   dist_perm (s_A n) (s_mtf n)\\<rbrakk>\n  \\<Longrightarrow> card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))\n                    \\<le> card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n)) +\n                          card (Inv (s_A n) (s_mtf n))\n  rs ! n \\<in> set (s_mtf n)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n))) +\n          int (card (Inv (s_A n) (s_mtf n)))", "by (simp)"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n))) +\n        int (card (Inv (s_A n) (s_mtf n)))\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "also"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n))) +\n        int (card (Inv (s_A n) (s_mtf n)))\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "have \"card(Inv ?xs' ?xs) = card(Inv ?xs ?xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n)) =\n    card (Inv (s_A n) (swaps (sw_A ! n) (s_A n)))", "by (rule card_Inv_sym)"], ["proof (state)\nthis:\n  card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n)) =\n  card (Inv (s_A n) (swaps (sw_A ! n) (s_A n)))\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "also"], ["proof (state)\nthis:\n  card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n)) =\n  card (Inv (s_A n) (swaps (sw_A ! n) (s_A n)))\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "have \"card(Inv ?xs ?xs') \\<le> size(sw_A!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))) \\<le> length (sw_A ! n)", "by (metis card_Inv_swaps_le dist_s_A)"], ["proof (state)\nthis:\n  card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))) \\<le> length (sw_A ! n)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      int x + int (card (Inv (s_A n) (s_mtf n)))\n      \\<le> int y + int (card (Inv (s_A n) (s_mtf n)))) \\<Longrightarrow>\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> int (length (sw_A ! n)) + int (card (Inv (s_A n) (s_mtf n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      int x + int (card (Inv (s_A n) (s_mtf n)))\n      \\<le> int y + int (card (Inv (s_A n) (s_mtf n)))) \\<Longrightarrow>\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> int (length (sw_A ! n)) + int (card (Inv (s_A n) (s_mtf n)))\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n    \\<le> \\<Phi> n + int (length (sw_A ! n))", "by(fastforce simp: Phi_def)"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> \\<Phi> n + int (length (sw_A ! n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> \\<Phi> n + int (length (sw_A ! n))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "have phi_free: \"card(Inv ?xs' ?ys') - Phi (Suc n) = f_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n    \\<Phi> (Suc n) =\n    f_A n", "using xin"], ["proof (prove)\nusing this:\n  rs ! n \\<in> set (s_mtf n)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n    \\<Phi> (Suc n) =\n    f_A n", "by(simp add: Phi_def mtf2_def step_def card_Inv_mtf2 index_less_size_conv f_A_def)"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n  \\<Phi> (Suc n) =\n  f_A n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n 2. \\<not> ?P \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "using xin phi_sw phi_mtf phi_free card_before[of \"s_mtf n\"]"], ["proof (prove)\nusing this:\n  rs ! n \\<in> set (s_mtf n)\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> \\<Phi> n + int (length (sw_A ! n))\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n)))\n  \\<le> 2 * int (index (swaps (sw_A ! n) (s_A n)) (rs ! n)) -\n        int (card (before (rs ! n) (s_mtf n)))\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (mtf (rs ! n) (s_mtf n)))) -\n  \\<Phi> (Suc n) =\n  f_A n\n  \\<lbrakk>distinct (s_mtf n); ?x \\<in> set (s_mtf n)\\<rbrakk>\n  \\<Longrightarrow> card (before ?x (s_mtf n)) = index (s_mtf n) ?x\n\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "by(simp add: t_mtf_def c_A_def p_A_def)"], ["proof (state)\nthis:\n  t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "assume notin: \"?x \\<notin> set ?ys\""], ["proof (state)\nthis:\n  rs ! n \\<notin> set (s_mtf n)\n\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "have \"int (card (Inv ?xs' ?ys)) - card (Inv ?xs ?ys) \\<le> card(Inv ?xs ?xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n    int (card (Inv (s_A n) (s_mtf n)))\n    \\<le> int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))", "using card_Inv_tri_ineq[OF _ dperm_inv, of ?xs' n]\n            swaps_inv[of \"sw_A!n\" \"s_A n\"]"], ["proof (prove)\nusing this:\n  dist_perm (swaps (sw_A ! n) (s_A n)) (s_A n) \\<Longrightarrow>\n  card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))\n  \\<le> card (Inv (swaps (sw_A ! n) (s_A n)) (s_A n)) +\n        card (Inv (s_A n) (s_mtf n))\n  set (swaps (sw_A ! n) (s_A n)) = set (s_A n) \\<and>\n  length (swaps (sw_A ! n) (s_A n)) = length (s_A n) \\<and>\n  distinct (swaps (sw_A ! n) (s_A n)) = distinct (s_A n)\n\ngoal (1 subgoal):\n 1. int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n    int (card (Inv (s_A n) (s_mtf n)))\n    \\<le> int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))", "by(simp add: card_Inv_sym)"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n  int (card (Inv (s_A n) (s_mtf n)))\n  \\<le> int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))\n\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "also"], ["proof (state)\nthis:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n  int (card (Inv (s_A n) (s_mtf n)))\n  \\<le> int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))\n\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "have \"\\<dots> \\<le> size(sw_A!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))\n    \\<le> int (length (sw_A ! n))", "by(simp add: card_Inv_swaps_le dperm_inv)"], ["proof (state)\nthis:\n  int (card (Inv (s_A n) (swaps (sw_A ! n) (s_A n))))\n  \\<le> int (length (sw_A ! n))\n\ngoal (1 subgoal):\n 1. rs ! n \\<notin> set (s_mtf n) \\<Longrightarrow>\n    t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "finally"], ["proof (chain)\npicking this:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n  int (card (Inv (s_A n) (s_mtf n)))\n  \\<le> int (length (sw_A ! n))", "show ?thesis"], ["proof (prove)\nusing this:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n  int (card (Inv (s_A n) (s_mtf n)))\n  \\<le> int (length (sw_A ! n))\n\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "using notin"], ["proof (prove)\nusing this:\n  int (card (Inv (swaps (sw_A ! n) (s_A n)) (s_mtf n))) -\n  int (card (Inv (s_A n) (s_mtf n)))\n  \\<le> int (length (sw_A ! n))\n  rs ! n \\<notin> set (s_mtf n)\n\ngoal (1 subgoal):\n 1. t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n", "by(simp add: t_mtf_def step_def c_A_def p_A_def f_A_def Phi_def mtf2_def)"], ["proof (state)\nthis:\n  t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_mtf n + \\<Phi> (n + 1) - \\<Phi> n \\<le> 2 * c_A n - 1 + p_A n - f_A n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Sleator_Tarjan: \"T_mtf n \\<le> (\\<Sum>i<n. 2*c_A i + p_A i - f_A i) - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "have \"(\\<Sum>i<n. t_mtf i) \\<le> (\\<Sum>i<n. 2*c_A i - 1 + p_A i - f_A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_mtf {..<n} \\<le> (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i)", "by(rule potential[where p=Phi,OF phi0 phi_pos mtf_ub])"], ["proof (state)\nthis:\n  sum t_mtf {..<n} \\<le> (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i)\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "also"], ["proof (state)\nthis:\n  sum t_mtf {..<n} \\<le> (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i)\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "have \"\\<dots> = (\\<Sum>i<n. (2*c_A i + p_A i - f_A i) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i) =\n    (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i - 1)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i) =\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i - 1)\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i - 1 + p_A i - f_A i) =\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i - 1)\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "have \"\\<dots> = (\\<Sum>i<n. 2*c_A i + p_A i - f_A i) - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i - 1) =\n    (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "by(simp add: sumr_diff_mult_const2[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i - 1) =\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "finally"], ["proof (chain)\npicking this:\n  sum t_mtf {..<n} \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "show ?thesis"], ["proof (prove)\nusing this:\n  sum t_mtf {..<n} \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "by(simp add: T_mtf_def)"], ["proof (state)\nthis:\n  T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Sleator_Tarjan': \"T_mtf n \\<le> 2*T_A n - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"T_mtf n \\<le> (\\<Sum>i<n. 2*c_A i + p_A i - f_A i) - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "by (fact Sleator_Tarjan)"], ["proof (state)\nthis:\n  T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "also"], ["proof (state)\nthis:\n  T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"(\\<Sum>i<n. 2*c_A i + p_A i - f_A i) \\<le> (\\<Sum>i<n. 2*(c_A i + p_A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n    \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))", "by(intro sum_mono) (simp add: p_A_def f_A_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n  \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n  \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"\\<dots> \\<le> 2* T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * (c_A i + p_A i)) \\<le> 2 * T_A n", "by (simp add: sum_distrib_left T_A_def t_A_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * (c_A i + p_A i)) \\<le> 2 * T_A n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n\\<rbrakk>\n  \\<Longrightarrow> T_mtf n \\<le> 2 * T_A n - int n", "show \"T_mtf n \\<le> 2* T_A n - n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n\\<rbrakk>\n  \\<Longrightarrow> T_mtf n \\<le> 2 * T_A n - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "by auto"], ["proof (state)\nthis:\n  T_mtf n \\<le> 2 * T_A n - int n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_A_nneg: \"0 \\<le> T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_A n", "by(auto simp add: sum_nonneg T_A_def t_A_def c_A_def p_A_def)"], ["", "lemma T_mtf_ub: \"\\<forall>i<n. rs!i \\<in> set s0 \\<Longrightarrow> T_mtf n \\<le> n * size s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n    T_mtf n \\<le> int (n * length s0)", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<0. rs ! i \\<in> set s0 \\<Longrightarrow>\n    T_mtf 0 \\<le> int (0 * length s0)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n                T_mtf n \\<le> int (n * length s0);\n        \\<forall>i<Suc n. rs ! i \\<in> set s0\\<rbrakk>\n       \\<Longrightarrow> T_mtf (Suc n) \\<le> int (Suc n * length s0)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i<0. rs ! i \\<in> set s0\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. rs ! i \\<in> set s0 \\<Longrightarrow>\n    T_mtf 0 \\<le> int (0 * length s0)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n                T_mtf n \\<le> int (n * length s0);\n        \\<forall>i<Suc n. rs ! i \\<in> set s0\\<rbrakk>\n       \\<Longrightarrow> T_mtf (Suc n) \\<le> int (Suc n * length s0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf 0 \\<le> int (0 * length s0)", "by(simp add: T_mtf_def)"], ["proof (state)\nthis:\n  T_mtf 0 \\<le> int (0 * length s0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n                T_mtf n \\<le> int (n * length s0);\n        \\<forall>i<Suc n. rs ! i \\<in> set s0\\<rbrakk>\n       \\<Longrightarrow> T_mtf (Suc n) \\<le> int (Suc n * length s0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n                T_mtf n \\<le> int (n * length s0);\n        \\<forall>i<Suc n. rs ! i \\<in> set s0\\<rbrakk>\n       \\<Longrightarrow> T_mtf (Suc n) \\<le> int (Suc n * length s0)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n  T_mtf n \\<le> int (n * length s0)\n  \\<forall>i<Suc n. rs ! i \\<in> set s0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n                T_mtf n \\<le> int (n * length s0);\n        \\<forall>i<Suc n. rs ! i \\<in> set s0\\<rbrakk>\n       \\<Longrightarrow> T_mtf (Suc n) \\<le> int (Suc n * length s0)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n  T_mtf n \\<le> int (n * length s0)\n  \\<forall>i<Suc n. rs ! i \\<in> set s0\n\ngoal (1 subgoal):\n 1. T_mtf (Suc n) \\<le> int (Suc n * length s0)", "using index_less_size_conv[of \"s_mtf n\" \"rs!n\"]"], ["proof (prove)\nusing this:\n  \\<forall>i<n. rs ! i \\<in> set s0 \\<Longrightarrow>\n  T_mtf n \\<le> int (n * length s0)\n  \\<forall>i<Suc n. rs ! i \\<in> set s0\n  (index (s_mtf n) (rs ! n) < length (s_mtf n)) =\n  (rs ! n \\<in> set (s_mtf n))\n\ngoal (1 subgoal):\n 1. T_mtf (Suc n) \\<le> int (Suc n * length s0)", "by(simp add: T_mtf_def t_mtf_def less_Suc_eq del: index_less)"], ["proof (state)\nthis:\n  T_mtf (Suc n) \\<le> int (Suc n * length s0)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary T_mtf_competitive: assumes \"s0 \\<noteq> []\" and \"\\<forall>i<n. rs!i \\<in> set s0\"\nshows \"T_mtf n \\<le> (2 - 1/(size s0)) * T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "assume 0: \"real_of_int(T_A n) \\<le> n * (size s0)\""], ["proof (state)\nthis:\n  real_of_int (T_A n) \\<le> real (n * length s0)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"T_mtf n \\<le> 2 * T_A n - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"T_mtf n \\<le> (\\<Sum>i<n. 2*c_A i + p_A i - f_A i) - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n", "by(rule Sleator_Tarjan)"], ["proof (state)\nthis:\n  T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "also"], ["proof (state)\nthis:\n  T_mtf n \\<le> (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i) - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"(\\<Sum>i<n. 2*c_A i + p_A i - f_A i) \\<le> (\\<Sum>i<n. 2*(c_A i + p_A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n    \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))", "by(intro sum_mono) (simp add: p_A_def f_A_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n  \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * c_A i + p_A i - f_A i)\n  \\<le> (\\<Sum>i<n. 2 * (c_A i + p_A i))\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "have \"\\<dots> \\<le> 2 * T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. 2 * (c_A i + p_A i)) \\<le> 2 * T_A n", "by (simp add: sum_distrib_left T_A_def t_A_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. 2 * (c_A i + p_A i)) \\<le> 2 * T_A n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n\\<rbrakk>\n  \\<Longrightarrow> T_mtf n \\<le> 2 * T_A n - int n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x - int n \\<le> y - int n\\<rbrakk>\n  \\<Longrightarrow> T_mtf n \\<le> 2 * T_A n - int n\n\ngoal (1 subgoal):\n 1. T_mtf n \\<le> 2 * T_A n - int n", "by simp"], ["proof (state)\nthis:\n  T_mtf n \\<le> 2 * T_A n - int n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T_mtf n \\<le> 2 * T_A n - int n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "hence \"real_of_int(T_mtf n) \\<le> 2 * of_int(T_A n) - n\""], ["proof (prove)\nusing this:\n  T_mtf n \\<le> 2 * T_A n - int n\n\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n) \\<le> real_of_int (2 * of_int (T_A n) - int n)", "by simp"], ["proof (state)\nthis:\n  real_of_int (T_mtf n) \\<le> real_of_int (2 * of_int (T_A n) - int n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "also"], ["proof (state)\nthis:\n  real_of_int (T_mtf n) \\<le> real_of_int (2 * of_int (T_A n) - int n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"\\<dots> = 2 * of_int(T_A n) - (n * size s0) / size s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (2 * of_int (T_A n) - int n) =\n    2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)", "using assms(1)"], ["proof (prove)\nusing this:\n  s0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. real_of_int (2 * of_int (T_A n) - int n) =\n    2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)", "by simp"], ["proof (state)\nthis:\n  real_of_int (2 * of_int (T_A n) - int n) =\n  2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "also"], ["proof (state)\nthis:\n  real_of_int (2 * of_int (T_A n) - int n) =\n  2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"\\<dots> \\<le> 2 * real_of_int(T_A n) - T_A n / size s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)\n    \\<le> 2 * real_of_int (T_A n) - real_of_int (T_A n) / real (length s0)", "by(rule diff_left_mono[OF divide_right_mono[OF 0]]) simp"], ["proof (state)\nthis:\n  2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)\n  \\<le> 2 * real_of_int (T_A n) - real_of_int (T_A n) / real (length s0)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "also"], ["proof (state)\nthis:\n  2 * real_of_int (T_A n) - real (n * length s0) / real (length s0)\n  \\<le> 2 * real_of_int (T_A n) - real_of_int (T_A n) / real (length s0)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"\\<dots> = (2 - 1 / size s0) * T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * real_of_int (T_A n) - real_of_int (T_A n) / real (length s0) =\n    (2 - 1 / real (length s0)) * real_of_int (T_A n)", "by algebra"], ["proof (state)\nthis:\n  2 * real_of_int (T_A n) - real_of_int (T_A n) / real (length s0) =\n  (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "finally"], ["proof (chain)\npicking this:\n  real_of_int (T_mtf n)\n  \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (T_mtf n)\n  \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "."], ["proof (state)\nthis:\n  real_of_int (T_mtf n)\n  \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "assume 0: \"\\<not> real_of_int(T_A n) \\<le> n * (size s0)\""], ["proof (state)\nthis:\n  \\<not> real_of_int (T_A n) \\<le> real (n * length s0)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"2 - 1 / size s0 \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 2 - 1 / real (length s0)", "using assms(1)"], ["proof (prove)\nusing this:\n  s0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> 2 - 1 / real (length s0)", "by (auto simp add: field_simps neq_Nil_conv)"], ["proof (state)\nthis:\n  1 \\<le> 2 - 1 / real (length s0)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"real_of_int (T_mtf n) \\<le> n * size s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n) \\<le> real (n * length s0)", "using T_mtf_ub[OF assms(2)]"], ["proof (prove)\nusing this:\n  T_mtf n \\<le> int (n * length s0)\n\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n) \\<le> real (n * length s0)", "by linarith"], ["proof (state)\nthis:\n  real_of_int (T_mtf n) \\<le> real (n * length s0)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "also"], ["proof (state)\nthis:\n  real_of_int (T_mtf n) \\<le> real (n * length s0)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"\\<dots> < of_int(T_A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n * length s0) < real_of_int (T_A n)", "using 0"], ["proof (prove)\nusing this:\n  \\<not> real_of_int (T_A n) \\<le> real (n * length s0)\n\ngoal (1 subgoal):\n 1. real (n * length s0) < real_of_int (T_A n)", "by simp"], ["proof (state)\nthis:\n  real (n * length s0) < real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "also"], ["proof (state)\nthis:\n  real (n * length s0) < real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "have \"\\<dots> \\<le> (2 - 1 / size s0) * T_A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_A n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "using assms(1) T_A_nneg[of n]"], ["proof (prove)\nusing this:\n  s0 \\<noteq> []\n  0 \\<le> T_A n\n\ngoal (1 subgoal):\n 1. real_of_int (T_A n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "by(auto simp add: mult_le_cancel_right1 field_simps neq_Nil_conv)"], ["proof (state)\nthis:\n  real_of_int (T_A n) \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. \\<not> real_of_int (T_A n) \\<le> real (n * length s0) \\<Longrightarrow>\n    real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "finally"], ["proof (chain)\npicking this:\n  real_of_int (T_mtf n) < (2 - 1 / real (length s0)) * real_of_int (T_A n)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (T_mtf n) < (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal (1 subgoal):\n 1. real_of_int (T_mtf n)\n    \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)", "by linarith"], ["proof (state)\nthis:\n  real_of_int (T_mtf n)\n  \\<le> (2 - 1 / real (length s0)) * real_of_int (T_A n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_A_t: \"n < length rs \\<Longrightarrow> t_A n = int (t (s_A n) (rs ! n) (as ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length rs \\<Longrightarrow>\n    t_A n = int (t (s_A n) (rs ! n) (as ! n))", "by(simp add: t_A_def t_def c_A_def p_A_def sw_A_def len_as split: prod.split)"], ["", "lemma T_A_eq_lem: \"(\\<Sum>i=0..<length rs. t_A i) =\n  T (s_A 0) (drop 0 rs) (drop 0 as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A {0..<length rs} = int (T (s_A 0) (drop 0 rs) (drop 0 as))", "proof(induction rule: zero_induct[of _ \"size rs\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. sum t_A {length rs..<length rs} =\n    int (T (s_A (length rs)) (drop (length rs) rs) (drop (length rs) as))\n 2. \\<And>n.\n       sum t_A {Suc n..<length rs} =\n       int (T (s_A (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) as)) \\<Longrightarrow>\n       sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum t_A {length rs..<length rs} =\n    int (T (s_A (length rs)) (drop (length rs) rs) (drop (length rs) as))\n 2. \\<And>n.\n       sum t_A {Suc n..<length rs} =\n       int (T (s_A (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) as)) \\<Longrightarrow>\n       sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A {length rs..<length rs} =\n    int (T (s_A (length rs)) (drop (length rs) rs) (drop (length rs) as))", "by (simp add: len_as)"], ["proof (state)\nthis:\n  sum t_A {length rs..<length rs} =\n  int (T (s_A (length rs)) (drop (length rs) rs) (drop (length rs) as))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A {Suc n..<length rs} =\n       int (T (s_A (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) as)) \\<Longrightarrow>\n       sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A {Suc n..<length rs} =\n       int (T (s_A (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) as)) \\<Longrightarrow>\n       sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "case (2 n)"], ["proof (state)\nthis:\n  sum t_A {Suc n..<length rs} =\n  int (T (s_A (Suc n)) (drop (Suc n) rs) (drop (Suc n) as))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_A {Suc n..<length rs} =\n       int (T (s_A (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) as)) \\<Longrightarrow>\n       sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "assume \"n < length rs\""], ["proof (state)\nthis:\n  n < length rs\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "thus ?case"], ["proof (prove)\nusing this:\n  n < length rs\n\ngoal (1 subgoal):\n 1. sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "using 2"], ["proof (prove)\nusing this:\n  n < length rs\n  sum t_A {Suc n..<length rs} =\n  int (T (s_A (Suc n)) (drop (Suc n) rs) (drop (Suc n) as))\n\ngoal (1 subgoal):\n 1. sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "by(simp add: Cons_nth_drop_Suc[symmetric,where i=n] len_as sum.atLeast_Suc_lessThan\n      t_A_t mtf_A_def sw_A_def)"], ["proof (state)\nthis:\n  sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))\n\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "assume \"\\<not> n < length rs\""], ["proof (state)\nthis:\n  \\<not> n < length rs\n\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> n < length rs\n\ngoal (1 subgoal):\n 1. sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))", "by (simp add: len_as)"], ["proof (state)\nthis:\n  sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum t_A {n..<length rs} = int (T (s_A n) (drop n rs) (drop n as))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_A_eq: \"T_A (length rs) = T s0 rs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_A (length rs) = int (T s0 rs as)", "using T_A_eq_lem"], ["proof (prove)\nusing this:\n  sum t_A {0..<length rs} = int (T (s_A 0) (drop 0 rs) (drop 0 as))\n\ngoal (1 subgoal):\n 1. T_A (length rs) = int (T s0 rs as)", "by(simp add: T_A_def atLeast0LessThan)"], ["", "lemma nth_off_MTF: \"n < length rs \\<Longrightarrow> off2 MTF s rs ! n = (size(fst s) - 1,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length rs \\<Longrightarrow>\n    off2 MTF s rs ! n = (length (fst s) - 1, [])", "by(induction rs arbitrary: s n)(auto simp add: MTF_def nth_Cons' Step_def)"], ["", "lemma t_mtf_MTF: \"n < length rs \\<Longrightarrow>\n  t_mtf n = int (t (s_mtf n) (rs ! n) (off MTF s rs ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length rs \\<Longrightarrow>\n    t_mtf n = int (t (s_mtf n) (rs ! n) (off MTF s rs ! n))", "by(simp add: t_mtf_def t_def nth_off_MTF split: prod.split)"], ["", "lemma mtf_MTF: \"n < length rs \\<Longrightarrow> length s = length s0 \\<Longrightarrow> mtf (rs ! n) s =\n       step s (rs ! n) (off MTF s0 rs ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length rs; length s = length s0\\<rbrakk>\n    \\<Longrightarrow> mtf (rs ! n) s = step s (rs ! n) (off MTF s0 rs ! n)", "by(auto simp add: nth_off_MTF step_def mtf_eq_mtf2)"], ["", "lemma T_mtf_eq_lem: \"(\\<Sum>i=0..<length rs. t_mtf i) =\n  T (s_mtf 0) (drop 0 rs) (drop 0 (off MTF s0 rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_mtf {0..<length rs} =\n    int (T (s_mtf 0) (drop 0 rs) (drop 0 (off MTF s0 rs)))", "proof(induction rule: zero_induct[of _ \"size rs\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. sum t_mtf {length rs..<length rs} =\n    int (T (s_mtf (length rs)) (drop (length rs) rs)\n          (drop (length rs) (off MTF s0 rs)))\n 2. \\<And>n.\n       sum t_mtf {Suc n..<length rs} =\n       int (T (s_mtf (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) (off MTF s0 rs))) \\<Longrightarrow>\n       sum t_mtf {n..<length rs} =\n       int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum t_mtf {length rs..<length rs} =\n    int (T (s_mtf (length rs)) (drop (length rs) rs)\n          (drop (length rs) (off MTF s0 rs)))\n 2. \\<And>n.\n       sum t_mtf {Suc n..<length rs} =\n       int (T (s_mtf (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) (off MTF s0 rs))) \\<Longrightarrow>\n       sum t_mtf {n..<length rs} =\n       int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_mtf {length rs..<length rs} =\n    int (T (s_mtf (length rs)) (drop (length rs) rs)\n          (drop (length rs) (off MTF s0 rs)))", "by (simp add: len_as)"], ["proof (state)\nthis:\n  sum t_mtf {length rs..<length rs} =\n  int (T (s_mtf (length rs)) (drop (length rs) rs)\n        (drop (length rs) (off MTF s0 rs)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_mtf {Suc n..<length rs} =\n       int (T (s_mtf (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) (off MTF s0 rs))) \\<Longrightarrow>\n       sum t_mtf {n..<length rs} =\n       int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_mtf {Suc n..<length rs} =\n       int (T (s_mtf (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) (off MTF s0 rs))) \\<Longrightarrow>\n       sum t_mtf {n..<length rs} =\n       int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "case (2 n)"], ["proof (state)\nthis:\n  sum t_mtf {Suc n..<length rs} =\n  int (T (s_mtf (Suc n)) (drop (Suc n) rs) (drop (Suc n) (off MTF s0 rs)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum t_mtf {Suc n..<length rs} =\n       int (T (s_mtf (Suc n)) (drop (Suc n) rs)\n             (drop (Suc n) (off MTF s0 rs))) \\<Longrightarrow>\n       sum t_mtf {n..<length rs} =\n       int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "assume \"n < length rs\""], ["proof (state)\nthis:\n  n < length rs\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "thus ?case"], ["proof (prove)\nusing this:\n  n < length rs\n\ngoal (1 subgoal):\n 1. sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "using 2"], ["proof (prove)\nusing this:\n  n < length rs\n  sum t_mtf {Suc n..<length rs} =\n  int (T (s_mtf (Suc n)) (drop (Suc n) rs) (drop (Suc n) (off MTF s0 rs)))\n\ngoal (1 subgoal):\n 1. sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "by(simp add: Cons_nth_drop_Suc[symmetric,where i=n] len_as sum.atLeast_Suc_lessThan\n        t_mtf_MTF[where s=s0] mtf_A_def sw_A_def mtf_MTF)"], ["proof (state)\nthis:\n  sum t_mtf {n..<length rs} =\n  int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))\n\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "assume \"\\<not> n < length rs\""], ["proof (state)\nthis:\n  \\<not> n < length rs\n\ngoal (1 subgoal):\n 1. \\<not> n < length rs \\<Longrightarrow>\n    sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> n < length rs\n\ngoal (1 subgoal):\n 1. sum t_mtf {n..<length rs} =\n    int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))", "by (simp add: len_as)"], ["proof (state)\nthis:\n  sum t_mtf {n..<length rs} =\n  int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum t_mtf {n..<length rs} =\n  int (T (s_mtf n) (drop n rs) (drop n (off MTF s0 rs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_mtf_eq: \"T_mtf (length rs) = T_on MTF s0 rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_mtf (length rs) = int (T_on MTF s0 rs)", "using T_mtf_eq_lem"], ["proof (prove)\nusing this:\n  sum t_mtf {0..<length rs} =\n  int (T (s_mtf 0) (drop 0 rs) (drop 0 (off MTF s0 rs)))\n\ngoal (1 subgoal):\n 1. T_mtf (length rs) = int (T_on MTF s0 rs)", "by(simp add: T_mtf_def atLeast0LessThan)"], ["", "corollary MTF_competitive2: \"s0 \\<noteq> [] \\<Longrightarrow> \\<forall>i<length rs. rs!i \\<in> set s0 \\<Longrightarrow>\n  T_on MTF s0 rs \\<le> (2 - 1/(size s0)) * T s0 rs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s0 \\<noteq> [];\n     \\<forall>i<length rs. rs ! i \\<in> set s0\\<rbrakk>\n    \\<Longrightarrow> real (T_on MTF s0 rs)\n                      \\<le> (2 - 1 / real (length s0)) * real (T s0 rs as)", "by (metis T_mtf_competitive T_A_eq T_mtf_eq of_int_of_nat_eq)"], ["", "corollary MTF_competitive': \"T_on MTF s0 rs \\<le> 2 * T s0 rs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_on MTF s0 rs \\<le> 2 * T s0 rs as", "using Sleator_Tarjan'[of \"length rs\"] T_A_eq T_mtf_eq"], ["proof (prove)\nusing this:\n  T_mtf (length rs) \\<le> 2 * T_A (length rs) - int (length rs)\n  T_A (length rs) = int (T s0 rs as)\n  T_mtf (length rs) = int (T_on MTF s0 rs)\n\ngoal (1 subgoal):\n 1. T_on MTF s0 rs \\<le> 2 * T s0 rs as", "by auto"], ["", "end"], ["", "theorem compet_MTF: assumes \"s0 \\<noteq> []\" \"distinct s0\" \"set rs \\<subseteq> set s0\"\nshows \"T_on MTF s0 rs \\<le> (2 - 1/(size s0)) * T_opt s0 rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "from assms(3)"], ["proof (chain)\npicking this:\n  set rs \\<subseteq> set s0", "have 1: \"\\<forall>i < length rs. rs!i \\<in> set s0\""], ["proof (prove)\nusing this:\n  set rs \\<subseteq> set s0\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs. rs ! i \\<in> set s0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs. rs ! i \\<in> set s0\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "{"], ["proof (state)\nthis:\n  \\<forall>i<length rs. rs ! i \\<in> set s0\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "fix as :: \"answer list\""], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "assume len: \"length as = length rs\""], ["proof (state)\nthis:\n  length as = length rs\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "interpret MTF_Off as rs s0"], ["proof (prove)\ngoal (1 subgoal):\n 1. MTF_Off as rs s0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct s0\n 2. length as = length rs", "qed (auto simp: assms(2) len)"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "from MTF_competitive2[OF assms(1) 1] assms(1)"], ["proof (chain)\npicking this:\n  real (T_on MTF s0 rs) \\<le> (2 - 1 / real (length s0)) * real (T s0 rs as)\n  s0 \\<noteq> []", "have \"T_on MTF s0 rs / (2 - 1 / (length s0)) \\<le> of_int(T s0 rs as)\""], ["proof (prove)\nusing this:\n  real (T_on MTF s0 rs) \\<le> (2 - 1 / real (length s0)) * real (T s0 rs as)\n  s0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n    \\<le> real_of_int (int (T s0 rs as))", "by(simp add: field_simps length_greater_0_conv[symmetric]\n        del: length_greater_0_conv)"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real_of_int (int (T s0 rs as))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "}"], ["proof (state)\nthis:\n  length ?as2 = length rs \\<Longrightarrow>\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real_of_int (int (T s0 rs ?as2))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "hence \"T_on MTF s0 rs / (2 - 1/(size s0)) \\<le> T_opt s0 rs\""], ["proof (prove)\nusing this:\n  length ?as2 = length rs \\<Longrightarrow>\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real_of_int (int (T s0 rs ?as2))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n    \\<le> real (T_opt s0 rs)", "apply(simp add: T_opt_def Inf_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs)) / (2 - 1 / real (length s0))\n        \\<le> real (T s0 rs as)) \\<Longrightarrow>\n    real (T s0 rs (off2 MTF (s0, ()) rs)) / (2 - 1 / real (length s0))\n    \\<le> real\n           (LEAST n.\n               \\<exists>as. n = T s0 rs as \\<and> length as = length rs)", "apply(rule LeastI2_wellorder)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs)) / (2 - 1 / real (length s0))\n        \\<le> real (T s0 rs as)) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T s0 rs as \\<and> length as = length rs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                   (2 - 1 / real (length s0))\n                   \\<le> real (T s0 rs as);\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                         (2 - 1 / real (length s0))\n                         \\<le> real a", "using length_replicate[of \"length rs\" undefined]"], ["proof (prove)\nusing this:\n  length (replicate (length rs) undefined) = length rs\n\ngoal (2 subgoals):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs)) / (2 - 1 / real (length s0))\n        \\<le> real (T s0 rs as)) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T s0 rs as \\<and> length as = length rs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                   (2 - 1 / real (length s0))\n                   \\<le> real (T s0 rs as);\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                         (2 - 1 / real (length s0))\n                         \\<le> real a", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                   (2 - 1 / real (length s0))\n                   \\<le> real (T s0 rs as);\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs)) /\n                         (2 - 1 / real (length s0))\n                         \\<le> real a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real (T_opt s0 rs)\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real (T_opt s0 rs)\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "using assms"], ["proof (prove)\nusing this:\n  real (T_on MTF s0 rs) / (2 - 1 / real (length s0))\n  \\<le> real (T_opt s0 rs)\n  s0 \\<noteq> []\n  distinct s0\n  set rs \\<subseteq> set s0\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs)\n    \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)", "by(simp add: field_simps\n    length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs)\n  \\<le> (2 - 1 / real (length s0)) * real (T_opt s0 rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compet_MTF': assumes \"distinct s0\"\nshows \"T_on MTF s0 rs \\<le> (2::real) * T_opt s0 rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "fix as :: \"answer list\""], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "assume len: \"length as = length rs\""], ["proof (state)\nthis:\n  length as = length rs\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "interpret MTF_Off as rs s0"], ["proof (prove)\ngoal (1 subgoal):\n 1. MTF_Off as rs s0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct s0\n 2. length as = length rs", "qed (auto simp: assms(1) len)"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "from MTF_competitive'"], ["proof (chain)\npicking this:\n  T_on MTF s0 rs \\<le> 2 * T s0 rs as", "have \"T_on MTF s0 rs / 2 \\<le> of_int(T s0 rs as)\""], ["proof (prove)\nusing this:\n  T_on MTF s0 rs \\<le> 2 * T s0 rs as\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) / 2 \\<le> real_of_int (int (T s0 rs as))", "by(simp add: field_simps length_greater_0_conv[symmetric]\n        del: length_greater_0_conv)"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs) / 2 \\<le> real_of_int (int (T s0 rs as))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "}"], ["proof (state)\nthis:\n  length ?as2 = length rs \\<Longrightarrow>\n  real (T_on MTF s0 rs) / 2 \\<le> real_of_int (int (T s0 rs ?as2))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "hence \"T_on MTF s0 rs / 2 \\<le> T_opt s0 rs\""], ["proof (prove)\nusing this:\n  length ?as2 = length rs \\<Longrightarrow>\n  real (T_on MTF s0 rs) / 2 \\<le> real_of_int (int (T s0 rs ?as2))\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) / 2 \\<le> real (T_opt s0 rs)", "apply(simp add: T_opt_def Inf_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs))\n        \\<le> real (T s0 rs as) * 2) \\<Longrightarrow>\n    real (T s0 rs (off2 MTF (s0, ()) rs))\n    \\<le> real\n           (LEAST n.\n               \\<exists>as. n = T s0 rs as \\<and> length as = length rs) *\n          2", "apply(rule LeastI2_wellorder)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs))\n        \\<le> real (T s0 rs as) * 2) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T s0 rs as \\<and> length as = length rs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs))\n                   \\<le> real (T s0 rs as) * 2;\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs))\n                         \\<le> real a * 2", "using length_replicate[of \"length rs\" undefined]"], ["proof (prove)\nusing this:\n  length (replicate (length rs) undefined) = length rs\n\ngoal (2 subgoals):\n 1. (\\<And>as.\n        length as = length rs \\<Longrightarrow>\n        real (T s0 rs (off2 MTF (s0, ()) rs))\n        \\<le> real (T s0 rs as) * 2) \\<Longrightarrow>\n    \\<exists>as. ?a4 = T s0 rs as \\<and> length as = length rs\n 2. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs))\n                   \\<le> real (T s0 rs as) * 2;\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs))\n                         \\<le> real a * 2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>as.\n                   length as = length rs \\<Longrightarrow>\n                   real (T s0 rs (off2 MTF (s0, ()) rs))\n                   \\<le> real (T s0 rs as) * 2;\n        \\<exists>as. a = T s0 rs as \\<and> length as = length rs;\n        \\<forall>b.\n           (\\<exists>as.\n               b = T s0 rs as \\<and>\n               length as = length rs) \\<longrightarrow>\n           a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real (T s0 rs (off2 MTF (s0, ()) rs))\n                         \\<le> real a * 2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs) / 2 \\<le> real (T_opt s0 rs)\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (T_on MTF s0 rs) / 2 \\<le> real (T_opt s0 rs)\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "using assms"], ["proof (prove)\nusing this:\n  real (T_on MTF s0 rs) / 2 \\<le> real (T_opt s0 rs)\n  distinct s0\n\ngoal (1 subgoal):\n 1. real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)", "by(simp add: field_simps\n    length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (state)\nthis:\n  real (T_on MTF s0 rs) \\<le> 2 * real (T_opt s0 rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem MTF_is_2_competitive: \"compet MTF 2 {s . distinct s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compet MTF 2 {s. distinct s}", "unfolding compet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>Collect distinct.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             real (T_on MTF s rs) \\<le> 2 * real (T_opt s rs) + b", "using compet_MTF'"], ["proof (prove)\nusing this:\n  distinct ?s0.0 \\<Longrightarrow>\n  real (T_on MTF ?s0.0 ?rs) \\<le> 2 * real (T_opt ?s0.0 ?rs)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>Collect distinct.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             static s rs \\<longrightarrow>\n             real (T_on MTF s rs) \\<le> 2 * real (T_opt s rs) + b", "by fastforce"], ["", "subsection \"Lower Bound for Competitiveness\""], ["", "text\\<open>This result is independent of MTF\nbut is based on the list update problem defined in this theory.\\<close>"], ["", "lemma rat_fun_lem:\n   fixes l c :: real\n   assumes [simp]: \"F \\<noteq> bot\"\n   assumes \"0 < l\"\n   assumes ev: \n     \"eventually (\\<lambda>n. l \\<le> f n / g n) F\"\n     \"eventually (\\<lambda>n. (f n + c) / (g n + d) \\<le> u) F\"\n   and\n     g: \"LIM n F. g n :> at_top\"\n   shows \"l \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> u", "proof (rule dense_le_bounded[OF \\<open>0 < l\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "assume x: \"0 < x\" \"x < l\""], ["proof (state)\nthis:\n  0 < x\n  x < l\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "define m where \"m = (x - l) / 2\""], ["proof (state)\nthis:\n  m = (x - l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "define k where \"k = l / (x - m)\""], ["proof (state)\nthis:\n  k = l / (x - m)\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "have \"x = l / k + m\" \"1 < k\" \"m < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = l / k + m &&& 1 < k &&& m < 0", "unfolding k_def m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = l / (l / (x - (x - l) / 2)) + (x - l) / 2 &&&\n    1 < l / (x - (x - l) / 2) &&& (x - l) / 2 < 0", "using x"], ["proof (prove)\nusing this:\n  0 < x\n  x < l\n\ngoal (1 subgoal):\n 1. x = l / (l / (x - (x - l) / 2)) + (x - l) / 2 &&&\n    1 < l / (x - (x - l) / 2) &&& (x - l) / 2 < 0", "by (auto simp: divide_simps)"], ["proof (state)\nthis:\n  x = l / k + m\n  1 < k\n  m < 0\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "from \\<open>1 < k\\<close>"], ["proof (chain)\npicking this:\n  1 < k", "have \"LIM n F. (k - 1) * g n :> at_top\""], ["proof (prove)\nusing this:\n  1 < k\n\ngoal (1 subgoal):\n 1. LIM n F. (k - 1) * g n :> at_top", "by (intro filterlim_tendsto_pos_mult_at_top[OF tendsto_const _ g]) (simp add: field_simps)"], ["proof (state)\nthis:\n  LIM n F. (k - 1) * g n :> at_top\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "then"], ["proof (chain)\npicking this:\n  LIM n F. (k - 1) * g n :> at_top", "have \"eventually (\\<lambda>n. d \\<le> (k - 1) * g n) F\""], ["proof (prove)\nusing this:\n  LIM n F. (k - 1) * g n :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n", "by (simp add: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "have \"eventually (\\<lambda>n. 1 \\<le> g n) F\" \"eventually (\\<lambda>n. 1 - d \\<le> g n) F\" \"eventually (\\<lambda>n. c / m - d \\<le> g n) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. 1 \\<le> g n &&&\n    \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n &&&\n    \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n", "using g"], ["proof (prove)\nusing this:\n  filterlim g at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. 1 \\<le> g n &&&\n    \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n &&&\n    \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n", "by (auto simp add: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F. 1 \\<le> g n\n  \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n\n  \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n\n  \\<forall>\\<^sub>F n in F. 1 \\<le> g n\n  \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n\n  \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n", "have \"eventually (\\<lambda>n. x \\<le> u) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n\n  \\<forall>\\<^sub>F n in F. 1 \\<le> g n\n  \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n\n  \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. x \\<le> u", "using ev"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F. d \\<le> (k - 1) * g n\n  \\<forall>\\<^sub>F n in F. 1 \\<le> g n\n  \\<forall>\\<^sub>F n in F. 1 - d \\<le> g n\n  \\<forall>\\<^sub>F n in F. c / m - d \\<le> g n\n  \\<forall>\\<^sub>F n in F. l \\<le> f n / g n\n  \\<forall>\\<^sub>F n in F. (f n + c) / (g n + d) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. x \\<le> u", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "assume d: \"d \\<le> (k - 1) * g n\" \"1 \\<le> g n\" \"1 - d \\<le> g n\" \"c / m - d \\<le> g n\"\n       and l: \"l \\<le> f n / g n\" and u: \"(f n + c) / (g n + d) \\<le> u\""], ["proof (state)\nthis:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n\n  l \\<le> f n / g n\n  (f n + c) / (g n + d) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "from d"], ["proof (chain)\npicking this:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n", "have \"g n + d \\<le> k * g n\""], ["proof (prove)\nusing this:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n\n\ngoal (1 subgoal):\n 1. g n + d \\<le> k * g n", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  g n + d \\<le> k * g n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "from d"], ["proof (chain)\npicking this:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n", "have g: \"0 < g n\" \"0 < g n + d\""], ["proof (prove)\nusing this:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n\n\ngoal (1 subgoal):\n 1. 0 < g n &&& 0 < g n + d", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  0 < g n\n  0 < g n + d\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "with \\<open>0 < l\\<close> l"], ["proof (chain)\npicking this:\n  0 < l\n  l \\<le> f n / g n\n  0 < g n\n  0 < g n + d", "have \"0 < f n\""], ["proof (prove)\nusing this:\n  0 < l\n  l \\<le> f n / g n\n  0 < g n\n  0 < g n + d\n\ngoal (1 subgoal):\n 1. 0 < f n", "by (auto simp: field_simps intro: mult_pos_pos less_le_trans)"], ["proof (state)\nthis:\n  0 < f n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "note \\<open>x = l / k + m\\<close>"], ["proof (state)\nthis:\n  x = l / k + m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "also"], ["proof (state)\nthis:\n  x = l / k + m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "have \"l / k \\<le> f n / (k * g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l / k \\<le> f n / (k * g n)", "using l \\<open>1 < k\\<close>"], ["proof (prove)\nusing this:\n  l \\<le> f n / g n\n  1 < k\n\ngoal (1 subgoal):\n 1. l / k \\<le> f n / (k * g n)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  l / k \\<le> f n / (k * g n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "also"], ["proof (state)\nthis:\n  l / k \\<le> f n / (k * g n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "have \"\\<dots> \\<le> f n / (g n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n / (k * g n) \\<le> f n / (g n + d)", "using d \\<open>1 < k\\<close> \\<open>0 < f n\\<close>"], ["proof (prove)\nusing this:\n  d \\<le> (k - 1) * g n\n  1 \\<le> g n\n  1 - d \\<le> g n\n  c / m - d \\<le> g n\n  1 < k\n  0 < f n\n\ngoal (1 subgoal):\n 1. f n / (k * g n) \\<le> f n / (g n + d)", "by (intro divide_left_mono mult_pos_pos) (auto simp: field_simps)"], ["proof (state)\nthis:\n  f n / (k * g n) \\<le> f n / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "also"], ["proof (state)\nthis:\n  f n / (k * g n) \\<le> f n / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "have \"m \\<le> c / (g n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> c / (g n + d)", "using \\<open>c / m - d \\<le> g n\\<close> \\<open>0 < g n\\<close> \\<open>0 < g n + d\\<close> \\<open>m < 0\\<close>"], ["proof (prove)\nusing this:\n  c / m - d \\<le> g n\n  0 < g n\n  0 < g n + d\n  m < 0\n\ngoal (1 subgoal):\n 1. m \\<le> c / (g n + d)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  m \\<le> c / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "also"], ["proof (state)\nthis:\n  m \\<le> c / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "have \"f n / (g n + d) + c / (g n + d) = (f n + c) / (g n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n / (g n + d) + c / (g n + d) = (f n + c) / (g n + d)", "using \\<open>0 < g n + d\\<close>"], ["proof (prove)\nusing this:\n  0 < g n + d\n\ngoal (1 subgoal):\n 1. f n / (g n + d) + c / (g n + d) = (f n + c) / (g n + d)", "by (auto simp: add_divide_distrib)"], ["proof (state)\nthis:\n  f n / (g n + d) + c / (g n + d) = (f n + c) / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "also"], ["proof (state)\nthis:\n  f n / (g n + d) + c / (g n + d) = (f n + c) / (g n + d)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "note u"], ["proof (state)\nthis:\n  (f n + c) / (g n + d) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>d \\<le> (k - 1) * g n; 1 \\<le> g n; 1 - d \\<le> g n;\n        c / m - d \\<le> g n; l \\<le> f n / g n;\n        (f n + c) / (g n + d) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> x \\<le> u", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + m \\<le> y + m;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x + m \\<le> y + m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      f n / (g n + d) + x \\<le> f n / (g n + d) + y\\<rbrakk>\n  \\<Longrightarrow> x \\<le> u", "show \"x \\<le> u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + m \\<le> y + m;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> x + m \\<le> y + m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      f n / (g n + d) + x \\<le> f n / (g n + d) + y\\<rbrakk>\n  \\<Longrightarrow> x \\<le> u\n\ngoal (1 subgoal):\n 1. x \\<le> u", "by simp"], ["proof (state)\nthis:\n  x \\<le> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F. x \\<le> u\n\ngoal (1 subgoal):\n 1. \\<And>w. \\<lbrakk>0 < w; w < l\\<rbrakk> \\<Longrightarrow> w \\<le> u", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in F. x \\<le> u", "show \"x \\<le> u\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F. x \\<le> u\n\ngoal (1 subgoal):\n 1. x \\<le> u", "by auto"], ["proof (state)\nthis:\n  x \\<le> u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compet_lb0:\nfixes a Aon Aoff cruel \ndefines \"f s0 rs == real(T_on Aon s0 rs)\"\ndefines \"g s0 rs == real(T_off Aoff s0 rs)\"\nassumes \"\\<And>rs s0. size(Aoff s0 rs) = length rs\" and \"\\<And>n. cruel n \\<noteq> []\"\nassumes \"compet Aon c S0\" and \"c\\<ge>0\" and \"s0 \\<in> S0\"\n and l: \"eventually (\\<lambda>n. f s0 (cruel n) / (g s0 (cruel n) + a) \\<ge> l) sequentially\"\n and g: \"LIM n sequentially. g s0 (cruel n) :> at_top\"\n and \"l > 0\" and \"\\<And>n. static s0 (cruel n)\"\nshows \"l \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> c", "let ?h = \"\\<lambda>b s0 rs. (f s0 rs - b) / g s0 rs\""], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> c", "have g': \"LIM n sequentially. g s0 (cruel n) + a :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM n sequentially. g s0 (cruel n) + a :> at_top", "using filterlim_tendsto_add_at_top[OF tendsto_const g]"], ["proof (prove)\nusing this:\n  LIM x sequentially. ?c + g s0 (cruel x) :> at_top\n\ngoal (1 subgoal):\n 1. LIM n sequentially. g s0 (cruel n) + a :> at_top", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  LIM n sequentially. g s0 (cruel n) + a :> at_top\n\ngoal (1 subgoal):\n 1. l \\<le> c", "from competE[OF assms(5) \\<open>c\\<ge>0\\<close> _ \\<open>s0 \\<in> S0\\<close>] assms(3)"], ["proof (chain)\npicking this:\n  \\<forall>s0 rs. length (?aoff s0 rs) = length rs \\<Longrightarrow>\n  \\<exists>b\\<ge>0.\n     \\<forall>rs.\n        static s0 rs \\<longrightarrow>\n        real (T_on Aon s0 rs) \\<le> c * real (T_off ?aoff s0 rs) + b\n  length (Aoff ?s0.0 ?rs) = length ?rs", "obtain b where\n    \"\\<forall>rs. static s0 rs \\<and> rs \\<noteq> [] \\<longrightarrow> ?h b s0 rs \\<le> c \""], ["proof (prove)\nusing this:\n  \\<forall>s0 rs. length (?aoff s0 rs) = length rs \\<Longrightarrow>\n  \\<exists>b\\<ge>0.\n     \\<forall>rs.\n        static s0 rs \\<longrightarrow>\n        real (T_on Aon s0 rs) \\<le> c * real (T_off ?aoff s0 rs) + b\n  length (Aoff ?s0.0 ?rs) = length ?rs\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<forall>rs.\n           static s0 rs \\<and> rs \\<noteq> [] \\<longrightarrow>\n           (f s0 rs - b) / g s0 rs \\<le> c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp del: neq0_conv simp: neq0_conv[symmetric]\n        field_simps f_def g_def T_off_neq0[of Aoff, OF assms(3)])"], ["proof (state)\nthis:\n  \\<forall>rs.\n     static s0 rs \\<and> rs \\<noteq> [] \\<longrightarrow>\n     (f s0 rs - b) / g s0 rs \\<le> c\n\ngoal (1 subgoal):\n 1. l \\<le> c", "hence \"\\<forall>n. (?h b s0 o cruel) n \\<le> c\""], ["proof (prove)\nusing this:\n  \\<forall>rs.\n     static s0 rs \\<and> rs \\<noteq> [] \\<longrightarrow>\n     (f s0 rs - b) / g s0 rs \\<le> c\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       ((\\<lambda>rs. (f s0 rs - b) / g s0 rs) \\<circ> cruel) n \\<le> c", "using assms(4,11)"], ["proof (prove)\nusing this:\n  \\<forall>rs.\n     static s0 rs \\<and> rs \\<noteq> [] \\<longrightarrow>\n     (f s0 rs - b) / g s0 rs \\<le> c\n  cruel ?n \\<noteq> []\n  static s0 (cruel ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       ((\\<lambda>rs. (f s0 rs - b) / g s0 rs) \\<circ> cruel) n \\<le> c", "by simp"], ["proof (state)\nthis:\n  \\<forall>n.\n     ((\\<lambda>rs. (f s0 rs - b) / g s0 rs) \\<circ> cruel) n \\<le> c\n\ngoal (1 subgoal):\n 1. l \\<le> c", "with rat_fun_lem[OF sequentially_bot \\<open>l>0\\<close> _ _ g', of \"f s0 o cruel\" \"-b\" \"- a\" c] assms(7) l"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>\\<^sub>F n in sequentially.\n              l \\<le> (f s0 \\<circ> cruel) n / (g s0 (cruel n) + a);\n   \\<forall>\\<^sub>F n in sequentially.\n      ((f s0 \\<circ> cruel) n + - b) / (g s0 (cruel n) + a + - a)\n      \\<le> c\\<rbrakk>\n  \\<Longrightarrow> l \\<le> c\n  s0 \\<in> S0\n  \\<forall>\\<^sub>F n in sequentially.\n     l \\<le> f s0 (cruel n) / (g s0 (cruel n) + a)\n  \\<forall>n.\n     ((\\<lambda>rs. (f s0 rs - b) / g s0 rs) \\<circ> cruel) n \\<le> c", "show \"l \\<le> c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>\\<^sub>F n in sequentially.\n              l \\<le> (f s0 \\<circ> cruel) n / (g s0 (cruel n) + a);\n   \\<forall>\\<^sub>F n in sequentially.\n      ((f s0 \\<circ> cruel) n + - b) / (g s0 (cruel n) + a + - a)\n      \\<le> c\\<rbrakk>\n  \\<Longrightarrow> l \\<le> c\n  s0 \\<in> S0\n  \\<forall>\\<^sub>F n in sequentially.\n     l \\<le> f s0 (cruel n) / (g s0 (cruel n) + a)\n  \\<forall>n.\n     ((\\<lambda>rs. (f s0 rs - b) / g s0 rs) \\<circ> cruel) n \\<le> c\n\ngoal (1 subgoal):\n 1. l \\<le> c", "by (auto)"], ["proof (state)\nthis:\n  l \\<le> c\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sorting\\<close>"], ["", "fun ins_sws where\n\"ins_sws k x [] = []\" |\n\"ins_sws k x (y#ys) = (if k x \\<le> k y then [] else map Suc (ins_sws k x ys) @ [0])\""], ["", "fun sort_sws where\n\"sort_sws k [] = []\" |\n\"sort_sws k (x#xs) =\n  ins_sws k x (sort_key k xs) @  map Suc (sort_sws k xs)\""], ["", "lemma length_ins_sws: \"length(ins_sws k x xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ins_sws k x xs) \\<le> length xs", "by(induction xs) auto"], ["", "lemma length_sort_sws_le: \"length(sort_sws k xs) \\<le> length xs ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sort_sws k xs) \\<le> (length xs)\\<^sup>2", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (sort_sws k []) \\<le> (length [])\\<^sup>2\n 2. \\<And>a xs.\n       length (sort_sws k xs) \\<le> (length xs)\\<^sup>2 \\<Longrightarrow>\n       length (sort_sws k (a # xs)) \\<le> (length (a # xs))\\<^sup>2", "case (Cons x xs)"], ["proof (state)\nthis:\n  length (sort_sws k xs) \\<le> (length xs)\\<^sup>2\n\ngoal (2 subgoals):\n 1. length (sort_sws k []) \\<le> (length [])\\<^sup>2\n 2. \\<And>a xs.\n       length (sort_sws k xs) \\<le> (length xs)\\<^sup>2 \\<Longrightarrow>\n       length (sort_sws k (a # xs)) \\<le> (length (a # xs))\\<^sup>2", "thus ?case"], ["proof (prove)\nusing this:\n  length (sort_sws k xs) \\<le> (length xs)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length (sort_sws k (x # xs)) \\<le> (length (x # xs))\\<^sup>2", "using length_ins_sws[of k x \"sort_key k xs\"]"], ["proof (prove)\nusing this:\n  length (sort_sws k xs) \\<le> (length xs)\\<^sup>2\n  length (ins_sws k x (sort_key k xs)) \\<le> length (sort_key k xs)\n\ngoal (1 subgoal):\n 1. length (sort_sws k (x # xs)) \\<le> (length (x # xs))\\<^sup>2", "by (simp add: numeral_eq_Suc)"], ["proof (state)\nthis:\n  length (sort_sws k (x # xs)) \\<le> (length (x # xs))\\<^sup>2\n\ngoal (1 subgoal):\n 1. length (sort_sws k []) \\<le> (length [])\\<^sup>2", "qed simp"], ["", "lemma swaps_ins_sws:\n  \"swaps (ins_sws k x xs) (x#xs) = insort_key k x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (ins_sws k x xs) (x # xs) = insort_key k x xs", "by(induction xs)(auto simp: swap_def[of 0])"], ["", "lemma swaps_sort_sws[simp]:\n  \"swaps (sort_sws k xs) xs = sort_key k xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (sort_sws k xs) xs = sort_key k xs", "by(induction xs)(auto simp: swaps_ins_sws)"], ["", "text\\<open>The cruel adversary:\\<close>"], ["", "fun cruel :: \"('a,'is) alg_on \\<Rightarrow> 'a state * 'is \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n\"cruel A s 0 = []\" |\n\"cruel A s (Suc n) = last (fst s) # cruel A (Step A s (last (fst s))) n\""], ["", "definition adv :: \"('a,'is) alg_on \\<Rightarrow> ('a::linorder) alg_off\" where\n\"adv A s rs = (if rs=[] then [] else\n  let crs = cruel A (Step A (s, fst A s) (last s)) (size rs - 1)\n  in (0,sort_sws (\\<lambda>x. size rs - 1 - count_list crs x) s) # replicate (size rs - 1) (0,[]))\""], ["", "lemma set_cruel: \"s \\<noteq> [] \\<Longrightarrow> set(cruel A (s,is) n) \\<subseteq> set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    set (cruel A (s, is) n) \\<subseteq> set s", "apply(induction n arbitrary: s \"is\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s is.\n       s \\<noteq> [] \\<Longrightarrow>\n       set (cruel A (s, is) 0) \\<subseteq> set s\n 2. \\<And>n s is.\n       \\<lbrakk>\\<And>s is.\n                   s \\<noteq> [] \\<Longrightarrow>\n                   set (cruel A (s, is) n) \\<subseteq> set s;\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> set (cruel A (s, is) (Suc n)) \\<subseteq> set s", "apply(auto simp: step_def Step_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s is a b x2 x.\n       \\<lbrakk>\\<And>s is.\n                   s \\<noteq> [] \\<Longrightarrow>\n                   set (cruel A (s, is) n) \\<subseteq> set s;\n        s \\<noteq> []; snd A (s, is) (last s) = ((a, b), x2);\n        x \\<in> set (cruel A (mtf2 a (last s) (swaps b s), x2) n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set s", "by (metis empty_iff swaps_inv last_in_set list.set(1) rev_subsetD set_mtf2)"], ["", "lemma static_cruel: \"s \\<noteq> [] \\<Longrightarrow> static s (cruel A (s,is) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> static s (cruel A (s, is) n)", "by(simp add: set_cruel static_def)"], ["", "(* Do not convert into structured proof - eta conversion screws it up! *)"], ["", "lemma T_cruel:\n  \"s \\<noteq> [] \\<Longrightarrow> distinct s \\<Longrightarrow>\n  T s (cruel A (s,is) n) (off2 A (s,is) (cruel A (s,is) n)) \\<ge> n*(length s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; distinct s\\<rbrakk>\n    \\<Longrightarrow> n * length s\n                      \\<le> T s (cruel A (s, is) n)\n                             (off2 A (s, is) (cruel A (s, is) n))", "apply(induction n arbitrary: s \"is\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s is.\n       \\<lbrakk>s \\<noteq> []; distinct s\\<rbrakk>\n       \\<Longrightarrow> 0 * length s\n                         \\<le> T s (cruel A (s, is) 0)\n                                (off2 A (s, is) (cruel A (s, is) 0))\n 2. \\<And>n s is.\n       \\<lbrakk>\\<And>s is.\n                   \\<lbrakk>s \\<noteq> []; distinct s\\<rbrakk>\n                   \\<Longrightarrow> n * length s\n                                     \\<le> T s (cruel A (s, is) n)\n      (off2 A (s, is) (cruel A (s, is) n));\n        s \\<noteq> []; distinct s\\<rbrakk>\n       \\<Longrightarrow> Suc n * length s\n                         \\<le> T s (cruel A (s, is) (Suc n))\n                                (off2 A (s, is) (cruel A (s, is) (Suc n)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s is.\n       \\<lbrakk>\\<And>s is.\n                   \\<lbrakk>s \\<noteq> []; distinct s\\<rbrakk>\n                   \\<Longrightarrow> n * length s\n                                     \\<le> T s (cruel A (s, is) n)\n      (off2 A (s, is) (cruel A (s, is) n));\n        s \\<noteq> []; distinct s\\<rbrakk>\n       \\<Longrightarrow> Suc n * length s\n                         \\<le> T s (cruel A (s, is) (Suc n))\n                                (off2 A (s, is) (cruel A (s, is) (Suc n)))", "apply(erule_tac x = \"fst(Step A (s, is) (last s))\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s is.\n       \\<lbrakk>s \\<noteq> []; distinct s;\n        \\<And>isa.\n           \\<lbrakk>fst (Step A (s, is) (last s)) \\<noteq> [];\n            distinct (fst (Step A (s, is) (last s)))\\<rbrakk>\n           \\<Longrightarrow> n * length (fst (Step A (s, is) (last s)))\n                             \\<le> T (fst (Step A (s, is) (last s)))\n                                    (cruel A\n(fst (Step A (s, is) (last s)), isa) n)\n                                    (off2 A\n(fst (Step A (s, is) (last s)), isa)\n(cruel A (fst (Step A (s, is) (last s)), isa) n))\\<rbrakk>\n       \\<Longrightarrow> Suc n * length s\n                         \\<le> T s (cruel A (s, is) (Suc n))\n                                (off2 A (s, is) (cruel A (s, is) (Suc n)))", "apply(erule_tac x = \"snd(Step A (s, is) (last s))\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s is.\n       \\<lbrakk>s \\<noteq> []; distinct s;\n        \\<lbrakk>fst (Step A (s, is) (last s)) \\<noteq> [];\n         distinct (fst (Step A (s, is) (last s)))\\<rbrakk>\n        \\<Longrightarrow> n * length (fst (Step A (s, is) (last s)))\n                          \\<le> T (fst (Step A (s, is) (last s)))\n                                 (cruel A\n                                   (fst (Step A (s, is) (last s)),\n                                    snd (Step A (s, is) (last s)))\n                                   n)\n                                 (off2 A\n                                   (fst (Step A (s, is) (last s)),\n                                    snd (Step A (s, is) (last s)))\n                                   (cruel A\n                                     (fst (Step A (s, is) (last s)),\nsnd (Step A (s, is) (last s)))\n                                     n))\\<rbrakk>\n       \\<Longrightarrow> Suc n * length s\n                         \\<le> T s (cruel A (s, is) (Suc n))\n                                (off2 A (s, is) (cruel A (s, is) (Suc n)))", "apply(frule_tac sws = \"snd(fst(snd A (s,is) (last s)))\" in index_swaps_last_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s is.\n       \\<lbrakk>s \\<noteq> []; distinct s;\n        \\<lbrakk>fst (Step A (s, is) (last s)) \\<noteq> [];\n         distinct (fst (Step A (s, is) (last s)))\\<rbrakk>\n        \\<Longrightarrow> n * length (fst (Step A (s, is) (last s)))\n                          \\<le> T (fst (Step A (s, is) (last s)))\n                                 (cruel A\n                                   (fst (Step A (s, is) (last s)),\n                                    snd (Step A (s, is) (last s)))\n                                   n)\n                                 (off2 A\n                                   (fst (Step A (s, is) (last s)),\n                                    snd (Step A (s, is) (last s)))\n                                   (cruel A\n                                     (fst (Step A (s, is) (last s)),\nsnd (Step A (s, is) (last s)))\n                                     n));\n        length s\n        \\<le> index (swaps (snd (fst (snd A (s, is) (last s)))) s)\n               (last s) +\n              length (snd (fst (snd A (s, is) (last s)))) +\n              1\\<rbrakk>\n       \\<Longrightarrow> Suc n * length s\n                         \\<le> T s (cruel A (s, is) (Suc n))\n                                (off2 A (s, is) (cruel A (s, is) (Suc n)))", "apply(simp add: distinct_step t_def split_def Step_def\n        length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_cruel[simp]: \"length (cruel A s n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cruel A s n) = n", "by (induction n arbitrary: s) (auto)"], ["", "lemma t_sort_sws: \"t s r (mf, sort_sws k s) \\<le> size s ^ 2 + size s + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t s r (mf, sort_sws k s) \\<le> (length s)\\<^sup>2 + length s + 1", "using length_sort_sws_le[of k s] index_le_size[of \"sort_key k s\" r]"], ["proof (prove)\nusing this:\n  length (sort_sws k s) \\<le> (length s)\\<^sup>2\n  index (sort_key k s) r \\<le> length (sort_key k s)\n\ngoal (1 subgoal):\n 1. t s r (mf, sort_sws k s) \\<le> (length s)\\<^sup>2 + length s + 1", "by (simp add: t_def add_mono index_le_size algebra_simps)"], ["", "lemma T_noop:\n  \"n = length rs \\<Longrightarrow> T s rs (replicate n (0, [])) = (\\<Sum>r\\<leftarrow>rs. index s r + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length rs \\<Longrightarrow>\n    T s rs (replicate n (0, [])) = (\\<Sum>r\\<leftarrow>rs. index s r + 1)", "by(induction rs arbitrary: s n)(auto simp: t_def step_def)"], ["", "lemma sorted_asc: \"j\\<le>i \\<Longrightarrow> i<size ss \\<Longrightarrow> \\<forall>x \\<in> set ss. \\<forall>y \\<in> set ss. k(x) \\<le> k(y) \\<longrightarrow> f y \\<le> f x\n  \\<Longrightarrow> sorted (map k ss) \\<Longrightarrow> f (ss ! i) \\<le> f (ss ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < length ss;\n     \\<forall>x\\<in>set ss.\n        \\<forall>y\\<in>set ss.\n           k x \\<le> k y \\<longrightarrow> f y \\<le> f x;\n     sorted (map k ss)\\<rbrakk>\n    \\<Longrightarrow> f (ss ! i) \\<le> f (ss ! j)", "by (auto simp: sorted_iff_nth_mono)"], ["", "lemma sorted_weighted_gauss_Ico_div2:\n  fixes f :: \"nat \\<Rightarrow> nat\"\n  assumes \"\\<And>i j. i \\<le> j \\<Longrightarrow> j < n \\<Longrightarrow> f i \\<ge> f j\"\n  shows \"(\\<Sum>i=0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "case (Suc n)"], ["proof (state)\nthis:\n  n = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "with assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?j \\<le> f ?i\n  n = Suc n", "have \"Suc n * (\\<Sum>i=0..<Suc n. Suc i * f i) \\<le> (\\<Sum>i=0..<Suc n. Suc i) * sum f {0..<Suc n}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?j \\<le> f ?i\n  n = Suc n\n\ngoal (1 subgoal):\n 1. Suc n * (\\<Sum>i = 0..<Suc n. Suc i * f i)\n    \\<le> sum Suc {0..<Suc n} * sum f {0..<Suc n}", "by (intro Chebyshev_sum_upper_nat [of \"Suc n\" Suc f]) auto"], ["proof (state)\nthis:\n  Suc n * (\\<Sum>i = 0..<Suc n. Suc i * f i)\n  \\<le> sum Suc {0..<Suc n} * sum f {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "then"], ["proof (chain)\npicking this:\n  Suc n * (\\<Sum>i = 0..<Suc n. Suc i * f i)\n  \\<le> sum Suc {0..<Suc n} * sum f {0..<Suc n}", "have \"Suc n * (2 * (\\<Sum>i=0..n. Suc i * f i)) \\<le> 2 * (\\<Sum>i=0..n. Suc i) * sum f {0..n}\""], ["proof (prove)\nusing this:\n  Suc n * (\\<Sum>i = 0..<Suc n. Suc i * f i)\n  \\<le> sum Suc {0..<Suc n} * sum f {0..<Suc n}\n\ngoal (1 subgoal):\n 1. Suc n * (2 * (\\<Sum>i = 0..n. Suc i * f i))\n    \\<le> 2 * sum Suc {0..n} * sum f {0..n}", "by (simp add: atLeastLessThanSuc_atLeastAtMost)"], ["proof (state)\nthis:\n  Suc n * (2 * (\\<Sum>i = 0..n. Suc i * f i))\n  \\<le> 2 * sum Suc {0..n} * sum f {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "also"], ["proof (state)\nthis:\n  Suc n * (2 * (\\<Sum>i = 0..n. Suc i * f i))\n  \\<le> 2 * sum Suc {0..n} * sum f {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "have \"2 * (\\<Sum>i=0..n. Suc i) = Suc n * (n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sum Suc {0..n} = Suc n * (n + 2)", "using arith_series_nat [of 1 1 n]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..n. 1 + i * 1) = Suc n * (2 * 1 + n * 1) div 2\n\ngoal (1 subgoal):\n 1. 2 * sum Suc {0..n} = Suc n * (n + 2)", "by simp"], ["proof (state)\nthis:\n  2 * sum Suc {0..n} = Suc n * (n + 2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "finally"], ["proof (chain)\npicking this:\n  Suc n * (2 * (\\<Sum>i = 0..n. Suc i * f i))\n  \\<le> Suc n * (n + 2) * sum f {0..n}", "have \"2 * (\\<Sum>i=0..n. Suc i * f i) \\<le> (n + 2) * sum f {0..n}\""], ["proof (prove)\nusing this:\n  Suc n * (2 * (\\<Sum>i = 0..n. Suc i * f i))\n  \\<le> Suc n * (n + 2) * sum f {0..n}\n\ngoal (1 subgoal):\n 1. 2 * (\\<Sum>i = 0..n. Suc i * f i) \\<le> (n + 2) * sum f {0..n}", "by (simp only: ac_simps Suc_mult_le_cancel1)"], ["proof (state)\nthis:\n  2 * (\\<Sum>i = 0..n. Suc i * f i) \\<le> (n + 2) * sum f {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "with Suc"], ["proof (chain)\npicking this:\n  n = Suc n\n  2 * (\\<Sum>i = 0..n. Suc i * f i) \\<le> (n + 2) * sum f {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n\n  2 * (\\<Sum>i = 0..n. Suc i * f i) \\<le> (n + 2) * sum f {0..n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2", "by (simp only: atLeastLessThanSuc_atLeastAtMost) simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. (i + 1) * f i) \\<le> (n + 1) * sum f {0..<n} div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_adv: assumes \"l \\<noteq> 0\"\nshows \"T_off (adv A) [0..<l] (cruel A ([0..<l],fst A [0..<l]) (Suc n))\n  \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\"  (is \"?l \\<le> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?s = \"[0..<l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?r = \"last ?s\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?S' = \"Step A (?s,fst A ?s) ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?s' = \"fst ?S'\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?cr = \"cruel A ?S' n\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?c = \"count_list ?cr\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?k = \"\\<lambda>x. n - ?c x\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "let ?sort = \"sort_key ?k ?s\""], ["proof (state)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have 1: \"set ?s' = {0..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))) = {0..<l}", "by(simp add: set_step Step_def split: prod.split)"], ["proof (state)\nthis:\n  set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))) = {0..<l}\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have 3: \"\\<And>x. x < l \\<Longrightarrow> ?c x \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < l \\<Longrightarrow>\n       count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x\n       \\<le> n", "by(simp) (metis count_le_length length_cruel)"], ["proof (state)\nthis:\n  ?x < l \\<Longrightarrow>\n  count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) ?x\n  \\<le> n\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"?l = t ?s (last ?s) (0, sort_sws ?k ?s) + (\\<Sum>x\\<in>set ?s'. ?c x * (index ?sort x + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n)) =\n    t [0..<l] (last [0..<l])\n     (0, sort_sws\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l]) +\n    (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n       count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n       (index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x +\n        1))", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n)) =\n    t [0..<l] (last [0..<l])\n     (0, sort_sws\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l]) +\n    (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n       count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n       (index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x +\n        1))", "apply(simp add:  adv_def T_noop sum_list_map_eq_sum_count2[OF set_cruel] Step_def\n      split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    \\<forall>a b x2.\n       snd A ([0..<l], fst A [0..<l]) (l - Suc 0) =\n       ((a, b), x2) \\<longrightarrow>\n       (\\<Sum>x\\<in>set (step [0..<l] (l - Suc 0) (a, b)).\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x +\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x *\n          index\n           (step [0..<l] (l - Suc 0)\n             (0, sort_sws\n                  (\\<lambda>x.\n                      n -\n                      count_list\n                       (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x)\n                  [0..<l]))\n           x) =\n       (\\<Sum>x\\<in>set (step [0..<l] (l - Suc 0) (a, b)).\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x +\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x *\n          index\n           (sort_key\n             (\\<lambda>x.\n                 n -\n                 count_list\n                  (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x)\n             [0..<l])\n           x)", "apply(subst (3) step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    \\<forall>a b x2.\n       snd A ([0..<l], fst A [0..<l]) (l - Suc 0) =\n       ((a, b), x2) \\<longrightarrow>\n       (\\<Sum>x\\<in>set (step [0..<l] (l - Suc 0) (a, b)).\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x +\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x *\n          index\n           (let (k, sws) =\n                  (0, sort_sws\n                       (\\<lambda>x.\n                           n -\n                           count_list\n                            (cruel A (step [0..<l] (l - Suc 0) (a, b), x2)\n                              n)\n                            x)\n                       [0..<l])\n            in mtf2 k (l - Suc 0) (swaps sws [0..<l]))\n           x) =\n       (\\<Sum>x\\<in>set (step [0..<l] (l - Suc 0) (a, b)).\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x +\n          count_list (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x *\n          index\n           (sort_key\n             (\\<lambda>x.\n                 n -\n                 count_list\n                  (cruel A (step [0..<l] (l - Suc 0) (a, b), x2) n) x)\n             [0..<l])\n           x)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n)) =\n  t [0..<l] (last [0..<l])\n   (0, sort_sws\n        (\\<lambda>x.\n            n -\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x)\n        [0..<l]) +\n  (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n     count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n      x *\n     (index\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l])\n       x +\n      1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n)) =\n  t [0..<l] (last [0..<l])\n   (0, sort_sws\n        (\\<lambda>x.\n            n -\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x)\n        [0..<l]) +\n  (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n     count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n      x *\n     (index\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l])\n       x +\n      1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"(\\<Sum>x\\<in>set ?s'. ?c x * (index ?sort x + 1)) = (\\<Sum>x\\<in>{0..<l}. ?c x * (index ?sort x + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n       count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n       (index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x +\n        1)) =\n    (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n        (index\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l])\n          x +\n         1))", "by (simp add: 1)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n     count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n      x *\n     (index\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l])\n       x +\n      1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        x +\n       1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))).\n     count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n      x *\n     (index\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l])\n       x +\n      1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        x +\n       1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = (\\<Sum>x\\<in>{0..<l}. ?c (?sort ! x) * (index ?sort (?sort ! x) + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n        (index\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l])\n          x +\n         1)) =\n    (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x) *\n        (index\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l])\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l] !\n           x) +\n         1))", "by(rule sum.reindex_bij_betw[where ?h = \"nth ?sort\", symmetric])\n      (simp add: bij_betw_imageI inj_on_nth nth_image)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        x +\n       1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l] !\n         x) +\n       1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        x +\n       1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l] !\n         x) +\n       1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = (\\<Sum>x\\<in>{0..<l}. ?c (?sort ! x) * (x+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x) *\n        (index\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l])\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l] !\n           x) +\n         1)) =\n    (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x) *\n        (x + 1))", "by(simp add: index_nth_id)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l] !\n         x) +\n       1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (x + 1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (index\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n        (sort_key\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l] !\n         x) +\n       1)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (x + 1))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> \\<le> (\\<Sum>x\\<in>{0..<l}. (x+1) * ?c (?sort ! x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x) *\n        (x + 1))\n    \\<le> (\\<Sum>x = 0..<l.\n              (x + 1) *\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               (sort_key\n                 (\\<lambda>x.\n                     n -\n                     count_list\n                      (cruel A\n                        (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                      x)\n                 [0..<l] !\n                x))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (x + 1))\n  \\<le> (\\<Sum>x = 0..<l.\n            (x + 1) *\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n             (sort_key\n               (\\<lambda>x.\n                   n -\n                   count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    x)\n               [0..<l] !\n              x))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also(ord_eq_le_subst)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x) *\n      (x + 1))\n  \\<le> (\\<Sum>x = 0..<l.\n            (x + 1) *\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n             (sort_key\n               (\\<lambda>x.\n                   n -\n                   count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    x)\n               [0..<l] !\n              x))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> \\<le> (l+1) * (\\<Sum>x\\<in>{0..<l}. ?c (?sort ! x)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        (x + 1) *\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x))\n    \\<le> (l + 1) *\n          (\\<Sum>x = 0..<l.\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               (sort_key\n                 (\\<lambda>x.\n                     n -\n                     count_list\n                      (cruel A\n                        (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                      x)\n                 [0..<l] !\n                x)) div\n          2", "apply(rule sorted_weighted_gauss_Ico_div2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>x \\<le> j; j < l\\<rbrakk>\n       \\<Longrightarrow> count_list\n                          (cruel A\n                            (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                            n)\n                          (sort_key\n                            (\\<lambda>x.\n                                n -\n                                count_list\n                                 (cruel A\n                                   (Step A ([0..<l], fst A [0..<l])\n                                     (last [0..<l]))\n                                   n)\n                                 x)\n                            [0..<l] !\n                           j)\n                         \\<le> count_list\n                                (cruel A\n                                  (Step A ([0..<l], fst A [0..<l])\n                                    (last [0..<l]))\n                                  n)\n                                (sort_key\n                                  (\\<lambda>x.\nn -\ncount_list (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x)\n                                  [0..<l] !\n                                 x)", "apply(erule sorted_asc[where k = \"\\<lambda>x. n - count_list (cruel A ?S' n) x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x j.\n       j < l \\<Longrightarrow>\n       j < length\n            (sort_key\n              (\\<lambda>x.\n                  n -\n                  count_list\n                   (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                     n)\n                   x)\n              [0..<l])\n 2. \\<And>x j.\n       j < l \\<Longrightarrow>\n       \\<forall>x\\<in>set (sort_key\n                            (\\<lambda>x.\n                                n -\n                                count_list\n                                 (cruel A\n                                   (Step A ([0..<l], fst A [0..<l])\n                                     (last [0..<l]))\n                                   n)\n                                 x)\n                            [0..<l]).\n          \\<forall>y\\<in>set (sort_key\n                               (\\<lambda>x.\n                                   n -\n                                   count_list\n                                    (cruel A\n(Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                                    x)\n                               [0..<l]).\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x\n             \\<le> n -\n                   count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    y \\<longrightarrow>\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) y\n             \\<le> count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    x\n 3. \\<And>x j.\n       j < l \\<Longrightarrow>\n       sorted\n        (map (\\<lambda>x.\n                 n -\n                 count_list\n                  (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                    n)\n                  x)\n          (sort_key\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l]))", "apply(auto simp add: index_nth_id dest!: 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j x y.\n       \\<lbrakk>count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n) j\n                \\<le> n;\n        n -\n        count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n)\n         x\n        \\<le> n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n) y;\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x\n        \\<le> n;\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) y\n        \\<le> n\\<rbrakk>\n       \\<Longrightarrow> count_list\n                          (cruel A\n                            (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n)\n                          y\n                         \\<le> count_list\n                                (cruel A\n                                  (Step A ([0..<l], fst A [0..<l])\n                                    (l - Suc 0))\n                                  n)\n                                x", "using assms [[linarith_split_limit = 20]]"], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>j x y.\n       \\<lbrakk>count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n) j\n                \\<le> n;\n        n -\n        count_list (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n)\n         x\n        \\<le> n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n) y;\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x\n        \\<le> n;\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) y\n        \\<le> n\\<rbrakk>\n       \\<Longrightarrow> count_list\n                          (cruel A\n                            (Step A ([0..<l], fst A [0..<l]) (l - Suc 0)) n)\n                          y\n                         \\<le> count_list\n                                (cruel A\n                                  (Step A ([0..<l], fst A [0..<l])\n                                    (l - Suc 0))\n                                  n)\n                                x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      (x + 1) *\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x))\n  \\<le> (l + 1) *\n        (\\<Sum>x = 0..<l.\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n             (sort_key\n               (\\<lambda>x.\n                   n -\n                   count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    x)\n               [0..<l] !\n              x)) div\n        2\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      (x + 1) *\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x))\n  \\<le> (l + 1) *\n        (\\<Sum>x = 0..<l.\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n             (sort_key\n               (\\<lambda>x.\n                   n -\n                   count_list\n                    (cruel A\n                      (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                    x)\n               [0..<l] !\n              x)) div\n        2\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"(\\<Sum>x\\<in>{0..<l}. ?c (?sort ! x)) = (\\<Sum>x\\<in>{0..<l}. ?c (?sort ! (index ?sort x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          x)) =\n    (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          index\n           (sort_key\n             (\\<lambda>x.\n                 n -\n                 count_list\n                  (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                    n)\n                  x)\n             [0..<l])\n           x))", "by(rule sum.reindex_bij_betw[where ?h = \"index ?sort\", symmetric])\n      (simp add: bij_betw_imageI inj_on_index2 index_image)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        x)) =\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x))\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = (\\<Sum>x\\<in>{0..<l}. ?c x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        count_list\n         (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l] !\n          index\n           (sort_key\n             (\\<lambda>x.\n                 n -\n                 count_list\n                  (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                    n)\n                  x)\n             [0..<l])\n           x)) =\n    sum (count_list\n          (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n     {0..<l}", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x)) =\n  sum (count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n   {0..<l}\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      count_list\n       (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n       (sort_key\n         (\\<lambda>x.\n             n -\n             count_list\n              (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n              x)\n         [0..<l] !\n        index\n         (sort_key\n           (\\<lambda>x.\n               n -\n               count_list\n                (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                x)\n           [0..<l])\n         x)) =\n  sum (count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n   {0..<l}\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = length ?cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (count_list\n          (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n     {0..<l} =\n    length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)", "using set_cruel[of ?s' A _ n] assms 1"], ["proof (prove)\nusing this:\n  fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) \\<noteq>\n  [] \\<Longrightarrow>\n  set (cruel A (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l])), ?is)\n        n)\n  \\<subseteq> set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l])))\n  l \\<noteq> 0\n  set (fst (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))) = {0..<l}\n\ngoal (1 subgoal):\n 1. sum (count_list\n          (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n     {0..<l} =\n    length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)", "by(auto simp add: sum_count_set Step_def split: prod.split)"], ["proof (state)\nthis:\n  sum (count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n   {0..<l} =\n  length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  sum (count_list\n        (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n))\n   {0..<l} =\n  length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) = n", "by simp"], ["proof (state)\nthis:\n  length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) = n\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  length (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) = n\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"t ?s (last ?s) (0, sort_sws ?k ?s) \\<le> (length ?s)^2 + length ?s + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t [0..<l] (last [0..<l])\n     (0, sort_sws\n          (\\<lambda>x.\n              n -\n              count_list\n               (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n               x)\n          [0..<l])\n    \\<le> (length [0..<l])\\<^sup>2 + length [0..<l] + 1", "by(rule t_sort_sws)"], ["proof (state)\nthis:\n  t [0..<l] (last [0..<l])\n   (0, sort_sws\n        (\\<lambda>x.\n            n -\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x)\n        [0..<l])\n  \\<le> (length [0..<l])\\<^sup>2 + length [0..<l] + 1\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "also"], ["proof (state)\nthis:\n  t [0..<l] (last [0..<l])\n   (0, sort_sws\n        (\\<lambda>x.\n            n -\n            count_list\n             (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n) x)\n        [0..<l])\n  \\<le> (length [0..<l])\\<^sup>2 + length [0..<l] + 1\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "have \"\\<dots> = l^2 + l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length [0..<l])\\<^sup>2 + length [0..<l] + 1 = l\\<^sup>2 + l + 1", "by simp"], ["proof (state)\nthis:\n  (length [0..<l])\\<^sup>2 + length [0..<l] + 1 = l\\<^sup>2 + l + 1\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              t [0..<l] (last [0..<l])\n               (0, sort_sws\n                    (\\<lambda>x.\n                        n -\n                        count_list\n                         (cruel A\n                           (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                           n)\n                         x)\n                    [0..<l]) +\n              x\n              \\<le> t [0..<l] (last [0..<l])\n                     (0, sort_sws\n                          (\\<lambda>x.\n                              n -\n                              count_list\n                               (cruel A\n                                 (Step A ([0..<l], fst A [0..<l])\n                                   (last [0..<l]))\n                                 n)\n                               x)\n                          [0..<l]) +\n                    y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      t [0..<l] (last [0..<l])\n       (0, sort_sws\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l]) +\n      x\n      \\<le> t [0..<l] (last [0..<l])\n             (0, sort_sws\n                  (\\<lambda>x.\n                      n -\n                      count_list\n                       (cruel A\n                         (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                       x)\n                  [0..<l]) +\n            y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (l + 1) * n div 2 \\<le> y + (l + 1) * n div 2\\<rbrakk>\n  \\<Longrightarrow> T_off (adv A) [0..<l]\n                     (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n                    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "show \"?l \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              t [0..<l] (last [0..<l])\n               (0, sort_sws\n                    (\\<lambda>x.\n                        n -\n                        count_list\n                         (cruel A\n                           (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                           n)\n                         x)\n                    [0..<l]) +\n              x\n              \\<le> t [0..<l] (last [0..<l])\n                     (0, sort_sws\n                          (\\<lambda>x.\n                              n -\n                              count_list\n                               (cruel A\n                                 (Step A ([0..<l], fst A [0..<l])\n                                   (last [0..<l]))\n                                 n)\n                               x)\n                          [0..<l]) +\n                    y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      t [0..<l] (last [0..<l])\n       (0, sort_sws\n            (\\<lambda>x.\n                n -\n                count_list\n                 (cruel A (Step A ([0..<l], fst A [0..<l]) (last [0..<l]))\n                   n)\n                 x)\n            [0..<l]) +\n      x\n      \\<le> t [0..<l] (last [0..<l])\n             (0, sort_sws\n                  (\\<lambda>x.\n                      n -\n                      count_list\n                       (cruel A\n                         (Step A ([0..<l], fst A [0..<l]) (last [0..<l])) n)\n                       x)\n                  [0..<l]) +\n            y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (l + 1) * n div 2 \\<le> y + (l + 1) * n div 2\\<rbrakk>\n  \\<Longrightarrow> T_off (adv A) [0..<l]\n                     (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n                    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\n\ngoal (1 subgoal):\n 1. T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n    \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2", "by auto"], ["proof (state)\nthis:\n  T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n  \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The main theorem:\\<close>"], ["", "theorem compet_lb2:\nassumes \"compet A c {xs::nat list. size xs = l}\" and \"l \\<noteq> 0\" and \"c \\<ge> 0\"\nshows \"c \\<ge> 2*l/(l+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * l) / real (l + 1) \\<le> c", "proof (rule compet_lb0[OF _ _ assms(1) \\<open>c\\<ge>0\\<close>])"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "let ?S0 = \"{xs::nat list. size xs = l}\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "let ?s0 = \"[0..<l]\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "let ?cruel = \"cruel A (?s0,fst A ?s0) o Suc\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "let ?on = \"\\<lambda>n. T_on A ?s0 (?cruel n)\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "let ?off = \"\\<lambda>n. T_off (adv A) ?s0 (?cruel n)\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>rs s0. length (?Aoff s0 rs) = length rs\n 2. \\<And>n. ?cruel n \\<noteq> []\n 3. ?s0.0 \\<in> {xs. length xs = l}\n 4. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real (T_off ?Aoff ?s0.0 (?cruel n)) + ?a)\n 5. LIM n sequentially. real (T_off ?Aoff ?s0.0 (?cruel n)) :> at_top\n 6. 0 < real (2 * l) / real (l + 1)\n 7. \\<And>n. static ?s0.0 (?cruel n)", "show \"\\<And>s0 rs. length (adv A s0 rs) = length rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s0 rs. length (adv A s0 rs) = length rs", "by(simp add: adv_def)"], ["proof (state)\nthis:\n  length (adv A ?s0.0 ?rs) = length ?rs\n\ngoal (6 subgoals):\n 1. \\<And>n. ?cruel n \\<noteq> []\n 2. ?s0.0 \\<in> {xs. length xs = l}\n 3. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real (T_on A ?s0.0 (?cruel n)) /\n             (real\n               (T ?s0.0 (?cruel n)\n                 (adv A (?s0.12 (?cruel n) ?s0.0) (?cruel n))) +\n              ?a)\n 4. LIM n sequentially.\n       real\n        (T ?s0.0 (?cruel n)\n          (adv A (?s0.12 (?cruel n) ?s0.0) (?cruel n))) :> at_top\n 5. 0 < real (2 * l) / real (l + 1)\n 6. \\<And>n. static ?s0.0 (?cruel n)", "show \"\\<And>n. ?cruel n \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. (cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n \\<noteq> []\n\ngoal (5 subgoals):\n 1. ?s0.0 \\<in> {xs. length xs = l}\n 2. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A ?s0.0\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T ?s0.0\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     ?s0.0)\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 3. LIM n sequentially.\n       real\n        (T ?s0.0 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              ?s0.0)\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 4. 0 < real (2 * l) / real (l + 1)\n 5. \\<And>n.\n       static ?s0.0\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "show \"?s0 \\<in> ?S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<l] \\<in> {xs. length xs = l}", "by simp"], ["proof (state)\nthis:\n  [0..<l] \\<in> {xs. length xs = l}\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "{"], ["proof (state)\nthis:\n  [0..<l] \\<in> {xs. length xs = l}\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "fix Z::real and n::nat"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "assume \"n \\<ge> nat(ceiling Z)\""], ["proof (state)\nthis:\n  nat \\<lceil>Z\\<rceil> \\<le> n\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "have \"?off n \\<ge> length(?cruel n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n    \\<le> T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by(rule T_ge_len) (simp add: adv_def)"], ["proof (state)\nthis:\n  length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  \\<le> T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "hence \"?off n > n\""], ["proof (prove)\nusing this:\n  length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  \\<le> T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. n < T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by simp"], ["proof (state)\nthis:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "hence \"Z \\<le> ?off n\""], ["proof (prove)\nusing this:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. Z \\<le> real\n             (T_off (adv A) [0..<l]\n               ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n))", "using \\<open>n \\<ge> nat(ceiling Z)\\<close>"], ["proof (prove)\nusing this:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  nat \\<lceil>Z\\<rceil> \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<le> real\n             (T_off (adv A) [0..<l]\n               ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n))", "by linarith"], ["proof (state)\nthis:\n  Z \\<le> real\n           (T_off (adv A) [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "}"], ["proof (state)\nthis:\n  nat \\<lceil>?Z2\\<rceil> \\<le> ?n2 \\<Longrightarrow>\n  ?Z2\n  \\<le> real\n         (T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))) /\n             (real\n               (T [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n                 (adv A\n                   (?s0.12\n                     ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                       (?n15 n))\n                     [0..<l])\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n                     (?n15 n)))) +\n              ?a)\n 2. LIM n sequentially.\n       real\n        (T [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n          (adv A\n            (?s0.12\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))\n              [0..<l])\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc)\n              (?n15 n)))) :> at_top\n 3. 0 < real (2 * l) / real (l + 1)\n 4. \\<And>n.\n       static [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) (?n15 n))", "thus \"LIM n sequentially. real (?off n) :> at_top\""], ["proof (prove)\nusing this:\n  nat \\<lceil>?Z2\\<rceil> \\<le> ?n2 \\<Longrightarrow>\n  ?Z2\n  \\<le> real\n         (T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2))\n\ngoal (1 subgoal):\n 1. LIM n sequentially.\n       real\n        (T_off (adv A) [0..<l]\n          ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) :> at_top", "by(auto simp only: filterlim_at_top eventually_sequentially)"], ["proof (state)\nthis:\n  LIM n sequentially.\n     real\n      (T_off (adv A) [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) :> at_top\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "let ?a = \"- (l^2 + l + 1)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "assume \"n \\<ge> l^2 + l + 1\""], ["proof (state)\nthis:\n  l\\<^sup>2 + l + 1 \\<le> n\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "have \"2*l/(l+1) = 2*l*(n+1) / ((l+1)*(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * l) / real (l + 1) =\n    real (2 * l * (n + 1)) / real ((l + 1) * (n + 1))", "by (simp del: One_nat_def)"], ["proof (state)\nthis:\n  real (2 * l) / real (l + 1) =\n  real (2 * l * (n + 1)) / real ((l + 1) * (n + 1))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "also"], ["proof (state)\nthis:\n  real (2 * l) / real (l + 1) =\n  real (2 * l * (n + 1)) / real ((l + 1) * (n + 1))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "have \"\\<dots> = 2*real(l*(n+1)) / ((l+1)*(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * l * (n + 1)) / real ((l + 1) * (n + 1)) =\n    2 * real (l * (n + 1)) / real ((l + 1) * (n + 1))", "by simp"], ["proof (state)\nthis:\n  real (2 * l * (n + 1)) / real ((l + 1) * (n + 1)) =\n  2 * real (l * (n + 1)) / real ((l + 1) * (n + 1))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "also"], ["proof (state)\nthis:\n  real (2 * l * (n + 1)) / real ((l + 1) * (n + 1)) =\n  2 * real (l * (n + 1)) / real ((l + 1) * (n + 1))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "have \"l * (n+1) \\<le> ?on n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l * (n + 1)\n    \\<le> T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "using T_cruel[of ?s0 \"Suc n\"] \\<open>l \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>[0..<l] \\<noteq> []; distinct [0..<l]\\<rbrakk>\n  \\<Longrightarrow> Suc n * length [0..<l]\n                    \\<le> T [0..<l] (cruel ?A ([0..<l], ?is) (Suc n))\n                           (off2 ?A ([0..<l], ?is)\n                             (cruel ?A ([0..<l], ?is) (Suc n)))\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l * (n + 1)\n    \\<le> T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  l * (n + 1)\n  \\<le> T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "also"], ["proof (state)\nthis:\n  l * (n + 1)\n  \\<le> T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "have \"2*real(?on n) / ((l+1)*(n+1)) \\<le> 2*real(?on n)/(2*(?off n + ?a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "have 0: \"2*real(?on n) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 *\n            real\n             (T_on A [0..<l]\n               ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "have 1: \"0 < real ((l + 1) * (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real ((l + 1) * (n + 1))", "by (simp del: of_nat_Suc)"], ["proof (state)\nthis:\n  0 < real ((l + 1) * (n + 1))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "have \"?off n \\<ge> length(?cruel n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n    \\<le> T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by(rule T_ge_len) (simp add: adv_def)"], ["proof (state)\nthis:\n  length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  \\<le> T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "hence \"?off n > n\""], ["proof (prove)\nusing this:\n  length ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  \\<le> T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. n < T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by simp"], ["proof (state)\nthis:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "hence \"?off n + ?a > 0\""], ["proof (prove)\nusing this:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n\ngoal (1 subgoal):\n 1. 0 < int (T_off (adv A) [0..<l]\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n        - int (l\\<^sup>2 + l + 1)", "using \\<open>n \\<ge> l^2 + l + 1\\<close>"], ["proof (prove)\nusing this:\n  n < T_off (adv A) [0..<l]\n       ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)\n  l\\<^sup>2 + l + 1 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < int (T_off (adv A) [0..<l]\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n        - int (l\\<^sup>2 + l + 1)", "by linarith"], ["proof (state)\nthis:\n  0 < int (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n      - int (l\\<^sup>2 + l + 1)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "hence 2: \"real_of_int(2*(?off n + ?a)) > 0\""], ["proof (prove)\nusing this:\n  0 < int (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n      - int (l\\<^sup>2 + l + 1)\n\ngoal (1 subgoal):\n 1. 0 < real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))", "by(simp only: of_int_0_less_iff zero_less_mult_iff zero_less_numeral simp_thms)"], ["proof (state)\nthis:\n  0 < real_of_int\n       (2 *\n        (int (T_off (adv A) [0..<l]\n               ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n         - int (l\\<^sup>2 + l + 1)))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "have \"?off n + ?a \\<le> (l+1)*(n) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_off (adv A) [0..<l]\n          ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n    - int (l\\<^sup>2 + l + 1)\n    \\<le> int ((l + 1) * n div 2)", "using T_adv[OF \\<open>l\\<noteq>0\\<close>, of A n]"], ["proof (prove)\nusing this:\n  T_off (adv A) [0..<l] (cruel A ([0..<l], fst A [0..<l]) (Suc n))\n  \\<le> l\\<^sup>2 + l + 1 + (l + 1) * n div 2\n\ngoal (1 subgoal):\n 1. int (T_off (adv A) [0..<l]\n          ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n    - int (l\\<^sup>2 + l + 1)\n    \\<le> int ((l + 1) * n div 2)", "by (simp only: o_apply of_nat_add of_nat_le_iff)"], ["proof (state)\nthis:\n  int (T_off (adv A) [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n  - int (l\\<^sup>2 + l + 1)\n  \\<le> int ((l + 1) * n div 2)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "also"], ["proof (state)\nthis:\n  int (T_off (adv A) [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n  - int (l\\<^sup>2 + l + 1)\n  \\<le> int ((l + 1) * n div 2)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "have \"\\<dots> \\<le> (l+1)*(n+1) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((l + 1) * n div 2) \\<le> int ((l + 1) * (n + 1) div 2)", "by (simp)"], ["proof (state)\nthis:\n  int ((l + 1) * n div 2) \\<le> int ((l + 1) * (n + 1) div 2)\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "finally"], ["proof (chain)\npicking this:\n  int (T_off (adv A) [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n  - int (l\\<^sup>2 + l + 1)\n  \\<le> int ((l + 1) * (n + 1) div 2)", "have \"2*(?off n + ?a) \\<le> (l+1)*(n+1)\""], ["proof (prove)\nusing this:\n  int (T_off (adv A) [0..<l]\n        ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n  - int (l\\<^sup>2 + l + 1)\n  \\<le> int ((l + 1) * (n + 1) div 2)\n\ngoal (1 subgoal):\n 1. 2 *\n    (int (T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n     - int (l\\<^sup>2 + l + 1))\n    \\<le> int ((l + 1) * (n + 1))", "by (simp add: zdiv_int)"], ["proof (state)\nthis:\n  2 *\n  (int (T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n   - int (l\\<^sup>2 + l + 1))\n  \\<le> int ((l + 1) * (n + 1))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "hence \"of_int(2*(?off n + ?a)) \\<le> real((l+1)*(n+1))\""], ["proof (prove)\nusing this:\n  2 *\n  (int (T_off (adv A) [0..<l]\n         ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n   - int (l\\<^sup>2 + l + 1))\n  \\<le> int ((l + 1) * (n + 1))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (2 *\n      (int (T_off (adv A) [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n       - int (l\\<^sup>2 + l + 1)))\n    \\<le> real ((l + 1) * (n + 1))", "by (simp only: of_int_le_iff)"], ["proof (state)\nthis:\n  real_of_int\n   (2 *\n    (int (T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n     - int (l\\<^sup>2 + l + 1)))\n  \\<le> real ((l + 1) * (n + 1))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "from divide_left_mono[OF this 0 mult_pos_pos[OF 1 2]]"], ["proof (chain)\npicking this:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real ((l + 1) * (n + 1))\n  \\<le> 2 *\n        real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real ((l + 1) * (n + 1))\n  \\<le> 2 *\n        real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))\n\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real ((l + 1) * (n + 1))\n    \\<le> 2 *\n          real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          real_of_int\n           (2 *\n            (int (T_off (adv A) [0..<l]\n                   ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n             - int (l\\<^sup>2 + l + 1)))", "."], ["proof (state)\nthis:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real ((l + 1) * (n + 1))\n  \\<le> 2 *\n        real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real ((l + 1) * (n + 1))\n  \\<le> 2 *\n        real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "also"], ["proof (state)\nthis:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real ((l + 1) * (n + 1))\n  \\<le> 2 *\n        real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (2 *\n          (int (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           - int (l\\<^sup>2 + l + 1)))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "have \"\\<dots> = ?on n / (?off n + ?a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real_of_int\n     (2 *\n      (int (T_off (adv A) [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n       - int (l\\<^sup>2 + l + 1))) =\n    real\n     (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n    real_of_int\n     (int (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n      - int (l\\<^sup>2 + l + 1))", "by (simp del: distrib_left_numeral One_nat_def cruel.simps)"], ["proof (state)\nthis:\n  2 *\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real_of_int\n   (2 *\n    (int (T_off (adv A) [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n     - int (l\\<^sup>2 + l + 1))) =\n  real (T_on A [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n  real_of_int\n   (int (T_off (adv A) [0..<l]\n          ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n    - int (l\\<^sup>2 + l + 1))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * real x / real ((l + 1) * (n + 1))\n      \\<le> 2 * real y / real ((l + 1) * (n + 1))) \\<Longrightarrow>\n  real (2 * l) / real (l + 1)\n  \\<le> real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (int (T_off (adv A) [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n          - int (l\\<^sup>2 + l + 1))", "have \"2*l/(l+1) \\<le> ?on n / (real (?off n) + ?a)\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * real x / real ((l + 1) * (n + 1))\n      \\<le> 2 * real y / real ((l + 1) * (n + 1))) \\<Longrightarrow>\n  real (2 * l) / real (l + 1)\n  \\<le> real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        real_of_int\n         (int (T_off (adv A) [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n          - int (l\\<^sup>2 + l + 1))\n\ngoal (1 subgoal):\n 1. real (2 * l) / real (l + 1)\n    \\<le> real\n           (T_on A [0..<l]\n             ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n          (real\n            (T_off (adv A) [0..<l]\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n           real_of_int (- int (l\\<^sup>2 + l + 1)))", "by (auto simp: divide_right_mono)"], ["proof (state)\nthis:\n  real (2 * l) / real (l + 1)\n  \\<le> real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n        (real\n          (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n         real_of_int (- int (l\\<^sup>2 + l + 1)))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "}"], ["proof (state)\nthis:\n  l\\<^sup>2 + l + 1 \\<le> ?n2 \\<Longrightarrow>\n  real (2 * l) / real (l + 1)\n  \\<le> real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2)) /\n        (real\n          (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2)) +\n         real_of_int (- int (l\\<^sup>2 + l + 1)))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              ?a)\n 2. 0 < real (2 * l) / real (l + 1)\n 3. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "thus \"eventually (\\<lambda>n. (2 * l) / (l + 1) \\<le> ?on n / (real(?off n) + ?a)) sequentially\""], ["proof (prove)\nusing this:\n  l\\<^sup>2 + l + 1 \\<le> ?n2 \\<Longrightarrow>\n  real (2 * l) / real (l + 1)\n  \\<le> real\n         (T_on A [0..<l]\n           ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2)) /\n        (real\n          (T_off (adv A) [0..<l]\n            ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n2)) +\n         real_of_int (- int (l\\<^sup>2 + l + 1)))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       real (2 * l) / real (l + 1)\n       \\<le> real\n              (T_on A [0..<l]\n                ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n             (real\n               (T_off (adv A) [0..<l]\n                 ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n              real_of_int (- int (l\\<^sup>2 + l + 1)))", "by(auto simp add: filterlim_at_top eventually_sequentially)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     real (2 * l) / real (l + 1)\n     \\<le> real\n            (T_on A [0..<l]\n              ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) /\n           (real\n             (T_off (adv A) [0..<l]\n               ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)) +\n            real_of_int (- int (l\\<^sup>2 + l + 1)))\n\ngoal (2 subgoals):\n 1. 0 < real (2 * l) / real (l + 1)\n 2. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "show \"0 < 2*l / (l+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real (2 * l) / real (l + 1)", "using \\<open>l \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real (2 * l) / real (l + 1)", "by(simp)"], ["proof (state)\nthis:\n  0 < real (2 * l) / real (l + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "show \"\\<And>n. static ?s0 (?cruel n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "using \\<open>l \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) n)", "by(simp add: static_cruel del: cruel.simps)"], ["proof (state)\nthis:\n  static [0..<l] ((cruel A ([0..<l], fst A [0..<l]) \\<circ> Suc) ?n)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}