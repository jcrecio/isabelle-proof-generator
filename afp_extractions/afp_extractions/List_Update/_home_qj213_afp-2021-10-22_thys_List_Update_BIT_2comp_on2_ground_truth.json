{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/BIT_2comp_on2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma E_bernoulli3: assumes \"0<p\"\n    and \"p<1\"\n    and \"finite (set_pmf (bind_pmf (bernoulli_pmf p) f))\"\n    shows \"E (bind_pmf (bernoulli_pmf p) f) = E(f True)*p + E(f False)*(1-p)\" (is \"?L = ?R\")", "lemma BIT_inv2: \"x\\<noteq>y \\<Longrightarrow> z\\<in>{x,y} \\<Longrightarrow> BIT_inv s z [x,y] = (s= type0 [x,y] z (other z x y))\"", "lemma costBIT_0x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 0\"", "lemma costBIT_0y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 1\"", "lemma costBIT_1x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 1/4\"", "lemma costBIT_1y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 3/4\"", "lemma costBIT_3x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 3/4\"", "lemma costBIT_3y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 1/4\"", "lemma costBIT_4x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 0.5\"", "lemma costBIT_4y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 0.5\"", "lemmas costBIT = costBIT_0x costBIT_0y costBIT_1x costBIT_1y costBIT_3x costBIT_3y costBIT_4x costBIT_4y", "lemma oneBIT_step0x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type0 [x0, y0] x y) x = type0 [x0, y0] x y\"", "lemma oneBIT_step0y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type0 [x0, y0] x y) y = type4 [x0, y0] x y\"", "lemma oneBIT_step1x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type1 [x0, y0] x y) x = type0 [x0, y0] x y\"", "lemma oneBIT_step1y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type1 [x0, y0] x y) y = type3 [x0, y0] x y\"", "lemma oneBIT_step3x: \n    assumes \"x\\<noteq>y\" \"x:{x0,y0}\" \"y:{x0,y0}\"\n    shows \"BIT_Step (type3 [x0, y0] x y) x = type1 [x0, y0] x y\"", "lemma oneBIT_step3y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type3 [x0, y0] x y) y = type0 [x0, y0] y x\"", "lemma oneBIT_step4x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type4 [x0, y0] x y) x =  type1 [x0, y0] x y\"", "lemma oneBIT_step4y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type4 [x0, y0] x y) y = type0 [x0, y0] y x\"", "lemmas oneBIT_step = oneBIT_step0x oneBIT_step0y oneBIT_step1x oneBIT_step1y oneBIT_step3x oneBIT_step3y oneBIT_step4x oneBIT_step4y", "lemma bit_yx: assumes \"x \\<noteq> y\" \n      and kas: \"init \\<in> {[x,y],[y,x]}\"\n      and \"qs \\<in> lang (Star(Times (Atom y) (Atom x))) \"\n   shows \"T\\<^sub>p_on_rand' BIT (type1 init x y) (qs@r) = 0.75 * length qs + T\\<^sub>p_on_rand' BIT (type1 init x y) r \n    \\<and> config'_rand BIT (type1 init x y) qs  = (type1 init x y)\"", "lemma bit_yxyx: assumes \"x \\<noteq> y\" and kas: \"init \\<in> {[x,y],[y,x]}\" and\n      \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n   shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) (qs@r) = 0.75 * length qs + T\\<^sub>p_on_rand' BIT (type1 init x y) r \n    \\<and> config'_rand BIT (type0 init x y) qs  = (type1 init x y)\"", "lemma BIT_x: assumes \"x\\<noteq>y\"\n       \"init \\<in> {[x,y],[y,x]}\" \"qs \\<in> lang (Plus (Atom x) One)\"\n shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) (qs@r) = T\\<^sub>p_on_rand' BIT (type0 init x y) r \n    \\<and> config'_rand BIT  (type0 init x y) qs = (type0 init x y)\"", "lemma BIT_a: assumes \"x \\<noteq> y\"\n    \" init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"config'_rand BIT (type0 init x y) qs = (type0 init y x)\" (is ?C)\n    and b: \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 1.5\" (is ?T)", "lemma bit_a: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\n      \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\"", "lemma bit_a'': \" a \\<noteq> b \\<Longrightarrow>\n         {a, b} = {x, y} \\<Longrightarrow>\n         BIT_inv s a [x, y] \\<Longrightarrow>\n         set qs \\<subseteq> {a, b} \\<Longrightarrow>\n         qs \\<in> lang (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n         BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\"", "lemma BIT_b: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * length v - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init y x)\" (is ?C)", "lemma bit_b''1: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * length qs - 0.5\"", "lemma BIT_b2: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * (length v - 1) - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init y x)\" (is ?C)", "lemma bit_b''2: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * (length qs - 1) - 0.5\"", "lemma bit_b: assumes \"x \\<noteq> y\"\n      \"init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows  \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\"\n  and \"config'_rand BIT (type0 init x y) qs = type0 init y x\"", "lemma bit_b'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\"", "lemma bit_b''': \" a \\<noteq> b \\<Longrightarrow>\n         {a, b} = {x, y} \\<Longrightarrow>\n         BIT_inv s a [x, y] \\<Longrightarrow>\n         set qs \\<subseteq> {a, b} \\<Longrightarrow>\n         qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow>\n         BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\"", "lemma BIT_c: assumes \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * length v - 0.5\"\n      and \"config'_rand BIT  (type0 init x y) v = (type0 init x y)\" (is ?C)", "lemma bit_c''1: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * length qs - 0.5\"", "lemma bit_c: assumes \"x \\<noteq> y\"\n      \"init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows  \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\"\n  and \"config'_rand BIT (type0 init x y) qs = type0 init x y\"", "lemma bit_c'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\"", "lemma BIT_c2: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * (length v - 1) - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init x y)\" (is ?C)", "lemma bit_c''2: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * (length qs - 1) - 0.5\"", "lemma bit_d: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Atom x, Atom x])\"\n  shows \"T\\<^sub>p_on_rand' BIT s qs \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n     T\\<^sub>p_on_rand' BIT s qs = 0\"", "lemma bit_d': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Atom x, Atom x])\"\n  shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n     T\\<^sub>p_on_rand' BIT s qs = 0\"", "lemma BIT_inv_initial: assumes \"(x::nat) \\<noteq> y\"\n    shows \"BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\"", "lemma D'': assumes \"qs \\<in> Lxx a b\"\n    \"a \\<noteq> b\" \"{a, b} = {x, y}\" \"BIT_inv s a [x, y]\"\n    \"set qs \\<subseteq> {a, b}\"\n shows \"T\\<^sub>p_on_rand' BIT s qs \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\"", "theorem BIT_175comp_on_2:\n    assumes \"(x::nat) \\<noteq> y\" \"set \\<sigma> \\<subseteq> {x,y}\"     \n     shows \"T\\<^sub>p_on_rand BIT [x,y] \\<sigma>  \\<le> 1.75 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 1.75\""], "translations": [["", "lemma E_bernoulli3: assumes \"0<p\"\n    and \"p<1\"\n    and \"finite (set_pmf (bind_pmf (bernoulli_pmf p) f))\"\n    shows \"E (bind_pmf (bernoulli_pmf p) f) = E(f True)*p + E(f False)*(1-p)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have T: \"(\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f True) a))\n            = E(f True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    E (f True)", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    measure_pmf.expectation (f True) (\\<lambda>x. x)", "apply(subst integral_measure_pmf[of \"bind_pmf (bernoulli_pmf p) f\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f True); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f True); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f True); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f True); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "apply(simp add: set_pmf_bernoulli)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f True); a \\<noteq> 0; 0 < p; p < 1;\n        \\<forall>x. finite (set_pmf (f x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. a \\<in> set_pmf (f x)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f True) a *\\<^sub>R a)", "by(simp add: set_pmf_bernoulli mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) = E (f True)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have F: \"(\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f False) a))\n            = E(f False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    E (f False)", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    measure_pmf.expectation (f False) (\\<lambda>x. x)", "apply(subst integral_measure_pmf[of \"bind_pmf (bernoulli_pmf p) f\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f False); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f False); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f False); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f False); a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "apply(simp add: set_pmf_bernoulli)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (f False); a \\<noteq> 0; 0 < p; p < 1;\n        \\<forall>x. finite (set_pmf (f x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. a \\<in> set_pmf (f x)\n 2. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n    (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (f False) a *\\<^sub>R a)", "by(simp add: set_pmf_bernoulli mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) =\n  E (f False)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have \"?L = (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a *\n       (pmf (f True) a * p +\n        pmf (f False) a * (1 - p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf p \\<bind> f) (\\<lambda>x. x) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "apply(subst integral_measure_pmf[of \"bind_pmf (bernoulli_pmf p) f\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bernoulli_pmf p \\<bind> f);\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (bernoulli_pmf p \\<bind> f) a *\\<^sub>R a) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (3 subgoals):\n 1. finite (set_pmf (bernoulli_pmf p \\<bind> f))\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bernoulli_pmf p \\<bind> f);\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 3. (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (bernoulli_pmf p \\<bind> f) a *\\<^sub>R a) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set_pmf (bernoulli_pmf p \\<bind> f);\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set_pmf (bernoulli_pmf p \\<bind> f)\n 2. (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (bernoulli_pmf p \\<bind> f) a *\\<^sub>R a) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (bernoulli_pmf p \\<bind> f) a *\\<^sub>R a) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  finite (set_pmf (bernoulli_pmf p \\<bind> f))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>set_pmf (bernoulli_pmf p \\<bind> f).\n       pmf (bernoulli_pmf p \\<bind> f) a *\\<^sub>R a) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "apply(simp add: set_pmf_bernoulli )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1; \\<forall>x. finite (set_pmf (f x))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n                         pmf (bernoulli_pmf p \\<bind> f) a * a) =\n                      (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n                         a *\n                         (pmf (f True) a * p + pmf (f False) a * (1 - p)))", "by(simp add: pmf_bind mult_ac)"], ["proof (state)\nthis:\n  E (bernoulli_pmf p \\<bind> f) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "also"], ["proof (state)\nthis:\n  E (bernoulli_pmf p \\<bind> f) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * (pmf (f True) a * p + pmf (f False) a * (1 - p)))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have \"\\<dots> = (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f True) a * p)\n                                    + (a * pmf (f False) a * (1 - p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * (pmf (f True) a * p + pmf (f False) a * (1 - p))) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * pmf (f True) a * p + a * pmf (f False) a * (1 - p))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Union>x. set_pmf (f x)) = (\\<Union>x. set_pmf (f x))\n 2. \\<And>x.\n       x \\<in> (\\<Union>x. set_pmf (f x)) \\<Longrightarrow>\n       x * (pmf (f True) x * p + pmf (f False) x * (1 - p)) =\n       x * pmf (f True) x * p + x * pmf (f False) x * (1 - p)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>x. set_pmf (f x)) \\<Longrightarrow>\n       x * (pmf (f True) x * p + pmf (f False) x * (1 - p)) =\n       x * pmf (f True) x * p + x * pmf (f False) x * (1 - p)", "by algebra"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * (pmf (f True) a * p + pmf (f False) a * (1 - p))) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * pmf (f True) a * p + a * pmf (f False) a * (1 - p))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * (pmf (f True) a * p + pmf (f False) a * (1 - p))) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * pmf (f True) a * p + a * pmf (f False) a * (1 - p))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have \"\\<dots> = (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f True) a * p))\n                  + (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f False) a * (1 - p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * pmf (f True) a * p + a * pmf (f False) a * (1 - p)) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a * (1 - p))", "by (simp add: sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * pmf (f True) a * p + a * pmf (f False) a * (1 - p)) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a * (1 - p))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n     a * pmf (f True) a * p + a * pmf (f False) a * (1 - p)) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a * (1 - p))\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have \"\\<dots> = (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f True) a)) * p\n                  + (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). (a * pmf (f False) a )) * (1 - p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)).\n       a * pmf (f False) a * (1 - p)) =\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) * p +\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) * (1 - p)", "by (simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a * (1 - p)) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) * p +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) * (1 - p)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a * p) +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a * (1 - p)) =\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) * p +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) * (1 - p)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "have \"\\<dots> = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) * p +\n    (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) *\n    (1 - p) =\n    E (f True) * p + E (f False) * (1 - p)", "unfolding T F"], ["proof (prove)\ngoal (1 subgoal):\n 1. E (f True) * p + E (f False) * (1 - p) =\n    E (f True) * p + E (f False) * (1 - p)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f True) a) * p +\n  (\\<Sum>a\\<in>(\\<Union>x. set_pmf (f x)). a * pmf (f False) a) * (1 - p) =\n  E (f True) * p + E (f False) * (1 - p)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "finally"], ["proof (chain)\npicking this:\n  E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "show ?thesis"], ["proof (prove)\nusing this:\n  E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)\n\ngoal (1 subgoal):\n 1. E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)", "."], ["proof (state)\nthis:\n  E (bernoulli_pmf p \\<bind> f) = E (f True) * p + E (f False) * (1 - p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"types of configurations\""], ["", "definition \"type0 init x y = do {\n                  (a::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  (b::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  return_pmf  ([x,y], ([a,b],init))\n                }\""], ["", "definition \"type1 init x y = do {\n                  (a::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  (b::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  return_pmf ( if ~[a,b]!(index init x)\\<and>[a,b]!(index init y) then ([y,x], ([a,b],init))\n                         else ([x,y], ([a,b],init)))\n                }\""], ["", "definition \"type3 init x y = do {\n                  (a::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  (b::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  return_pmf ( if [a,b]!(index init x)\\<and>~[a,b]!(index init y) then ([x,y], ([a,b],init))\n                         else ([y,x], ([a,b],init)))\n                }\""], ["", "definition \"type4 init x y = do {\n                  (a::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  (b::bool) \\<leftarrow> (bernoulli_pmf 0.5);\n                  return_pmf ( if ~[a,b]!(index init y) then ([x,y], ([a,b],init))\n                         else ([y,x], ([a,b],init)))\n                }\""], ["", "definition \"BIT_inv s x i == (s = (type0 i x (hd (filter (\\<lambda>y. y\\<noteq>x) i) )))\""], ["", "lemma BIT_inv2: \"x\\<noteq>y \\<Longrightarrow> z\\<in>{x,y} \\<Longrightarrow> BIT_inv s z [x,y] = (s= type0 [x,y] z (other z x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; z \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> BIT_inv s z [x, y] =\n                      (s = type0 [x, y] z (other z x y))", "unfolding BIT_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; z \\<in> {x, y}\\<rbrakk>\n    \\<Longrightarrow> (s =\n                       type0 [x, y] z\n                        (hd (filter (\\<lambda>y. y \\<noteq> z) [x, y]))) =\n                      (s = type0 [x, y] z (other z x y))", "by(auto simp add: other_def)"], ["", "subsubsection \"cost of BIT\""], ["", "lemma costBIT_0x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    0", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type0 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) =\n                      0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type0 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) =\n                      0", "apply(simp_all add: type0_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p [x0, y0] x0\n(if x then 0 else length (fst ([x0, y0], [x, xa], [x0, y0])), [])))))) =\n                      0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p [y0, x0] y0\n(if xa then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])), [])))))) =\n                      0", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_0y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    1", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type0 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    1", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type0 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type0 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) =\n                      1", "apply(simp_all add: type0_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p [x0, y0] y0\n(if xa then 0 else length (fst ([x0, y0], [x, xa], [x0, y0])), [])))))) =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p [y0, x0] x0\n(if x then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])), [])))))) =\n                      1", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_1x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 1/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    1 / 4", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    1 / 4", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type1 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      4 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type1 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      4 =\n                      1", "apply(simp_all add: type1_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      1", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_1y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 3/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    3 / 4", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type1 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    3 / 4", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type1 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      4 =\n                      3\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type1 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      4 =\n                      3", "apply(simp_all add: type1_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      3\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      3", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_3x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 3/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    3 / 4", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    3 / 4", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type3 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      4 =\n                      3\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type3 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      4 =\n                      3", "apply(simp_all add: type3_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      3\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      3", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_3y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 1/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    1 / 4", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type3 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    1 / 4", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type3 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      4 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type3 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      4 =\n                      1", "apply(simp_all add: type3_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      4 =\n                      1", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_4x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s x \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))) = 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    5 / 10", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    5 / 10", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type4 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      2 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type4 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      2 =\n                      1", "apply(simp_all add: type4_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      2 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      2 =\n                      1", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBIT_4y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows\n  \"E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s. BIT_step s y \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))) = 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    5 / 10", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. E (type4 [x0, y0] x y \\<bind>\n       (\\<lambda>s.\n           BIT_step s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    5 / 10", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (type4 [x0, y0] x0 y0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s y0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) y0 a))))) *\n                      2 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (type4 [x0, y0] y0 x0 \\<bind>\n                         (\\<lambda>s.\n                             BIT_step s x0 \\<bind>\n                             (\\<lambda>(a, is').\n                                 return_pmf\n                                  (real (t\\<^sub>p (fst s) x0 a))))) *\n                      2 =\n                      1", "apply(simp_all add: type4_def BIT_step_def bind_assoc_pmf bind_return_pmf )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0])))\ny0 (if fst (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                   else ([y0, x0], [x, xa], [x0, y0]))))\n        y0\n    then 0\n    else length\n          (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      2 =\n                      1\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> E (bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>x.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xa.\n                                 return_pmf\n                                  (real\n                                    (t\\<^sub>p\n(fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0])))\nx0 (if fst (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                   else ([x0, y0], [x, xa], [x0, y0]))))\n        x0\n    then 0\n    else length\n          (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))),\n    [])))))) *\n                      2 =\n                      1", "apply(simp_all add: E_bernoulli3 t\\<^sub>p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas costBIT = costBIT_0x costBIT_0y costBIT_1x costBIT_1y costBIT_3x costBIT_3y costBIT_4x costBIT_4y"], ["", "subsubsection \"state transformation of BIT\""], ["", "abbreviation \"BIT_Step s x == (s \\<bind> (\\<lambda>s. BIT_step s x \\<bind> (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))))\""], ["", "lemma oneBIT_step0x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type0 [x0, y0] x y) x = type0 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type0 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type0 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type0 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type0 [x0, y0] x y", "apply(simp add: type0_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = x \\<longrightarrow>\n                       (x0 = x \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 ([x, y], [\\<not> xa, xb], [x, x]))) =\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>a.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>b.\n                                return_pmf\n                                 ([x, y], [a, b], [x, x])))) \\<and>\n                       (x0 \\<noteq> x \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 ([x, y], [xa, \\<not> xb], [x0, x]))) =\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>a.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>b.\n                                return_pmf\n                                 ([x, y], [a, b], [x0, x]))))) \\<and>\n                      (y0 \\<noteq> x \\<longrightarrow>\n                       x0 = x \\<longrightarrow>\n                       bernoulli_pmf (1 / 2) \\<bind>\n                       (\\<lambda>xa.\n                           bernoulli_pmf (1 / 2) \\<bind>\n                           (\\<lambda>xb.\n                               return_pmf\n                                ([x, y], [\\<not> xa, xb], [x, y0]))) =\n                       bernoulli_pmf (1 / 2) \\<bind>\n                       (\\<lambda>a.\n                           bernoulli_pmf (1 / 2) \\<bind>\n                           (\\<lambda>b.\n                               return_pmf ([x, y], [a, b], [x, y0]))))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               ([x0, y0], [\\<not> x, xa], [x0, y0]))) =\n                      bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>a.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>b.\n                              return_pmf ([x0, y0], [a, b], [x0, y0])))\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               ([y0, x0], [x, \\<not> xa], [x0, y0]))) =\n                      bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>a.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>b.\n                              return_pmf ([y0, x0], [a, b], [x0, y0])))", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf ([x0, y0], [\\<not> x, xa], [x0, y0]))))\n                          i =\n                         pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>a.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>b.\nreturn_pmf ([x0, y0], [a, b], [x0, y0]))))\n                          i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               ([y0, x0], [x, \\<not> xa], [x0, y0]))) =\n                      bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>a.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>b.\n                              return_pmf ([y0, x0], [a, b], [x0, y0])))", "apply(simp add: pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               ([y0, x0], [x, \\<not> xa], [x0, y0]))) =\n                      bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>a.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>b.\n                              return_pmf ([y0, x0], [a, b], [x0, y0])))", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf ([y0, x0], [x, \\<not> xa], [x0, y0]))))\n                          i =\n                         pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>a.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>b.\nreturn_pmf ([y0, x0], [a, b], [x0, y0]))))\n                          i", "apply(simp add: add.commute pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step0y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type0 [x0, y0] x y) y = type4 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type0 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type4 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type0 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type4 [x0, y0] x y", "apply(simp add: type0_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (swaps\n                                   (if Suc 0\n \\<le> (if xa then 0 else length (fst ([x, y], [xa, xb], [x0, y0])))\n                                    then [Suc 0 -\n    (if [xa, xb] ! 0 then 0\n     else length (fst ([x, y], [xa, xb], [x0, y0])))..<\n    0] @\n   [0]\n                                    else [])\n                                   [x, y],\n                                  [\\<not> xa, xb], [y, y]))) =\n                        type4 [y, y] x y) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (swaps\n                                   (if Suc 0\n \\<le> (if xb then 0 else length (fst ([x, y], [xa, xb], [x0, y0])))\n                                    then [Suc 0 -\n    (if [xa, xb] ! (index [y0] y + 1) then 0\n     else length (fst ([x, y], [xa, xb], [x0, y0])))..<\n    0] @\n   [0]\n                                    else [])\n                                   [x, y],\n                                  [xa, \\<not> xb], [x0, y]))) =\n                        type4 [x0, y] x y)) \\<and>\n                      (y0 \\<noteq> y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (swaps\n                                   (if Suc 0\n \\<le> (if xa then 0 else length (fst ([x, y], [xa, xb], [x0, y0])))\n                                    then [Suc 0 -\n    (if [xa, xb] ! 0 then 0\n     else length (fst ([x, y], [xa, xb], [x0, y0])))..<\n    0] @\n   [0]\n                                    else [])\n                                   [x, y],\n                                  [\\<not> xa, xb], [y, y0]))) =\n                        type4 [y, y0] x y) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (swaps\n                                   (if Suc 0\n \\<le> (if [] ! 0 then 0 else length (fst ([x, y], [xa, xb], [x0, y0])))\n                                    then [Suc 0 -\n    (if [xa, xb] ! (index [y0] y + 1) then 0\n     else length (fst ([x, y], [xa, xb], [x0, y0])))..<\n    0] @\n   [0]\n                                    else [])\n                                   [x, y],\n                                  [xa, xb], [x0, y0]))) =\n                        type4 [x0, y0] x y))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (swaps\n                                 (if Suc 0\n                                     \\<le> (if xa then 0\n      else length (fst ([x0, y0], [x, xa], [x0, y0])))\n                                  then [Suc 0 -\n  (if [x, xa] ! (index [y0] y0 + 1) then 0\n   else length (fst ([x0, y0], [x, xa], [x0, y0])))..<\n  0] @\n [0]\n                                  else [])\n                                 [x0, y0],\n                                [x, \\<not> xa], [x0, y0]))) =\n                      type4 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (swaps\n                                 (if Suc 0\n                                     \\<le> (if x then 0\n      else length (fst ([y0, x0], [x, xa], [x0, y0])))\n                                  then [Suc 0 -\n  (if [x, xa] ! 0 then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])))..<\n  0] @\n [0]\n                                  else [])\n                                 [y0, x0],\n                                [\\<not> x, xa], [x0, y0]))) =\n                      type4 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (swaps\n   (if Suc 0\n       \\<le> (if xa then 0 else length (fst ([x0, y0], [x, xa], [x0, y0])))\n    then [Suc 0 -\n          (if [x, xa] ! (index [y0] y0 + 1) then 0\n           else length (fst ([x0, y0], [x, xa], [x0, y0])))..<\n          0] @\n         [0]\n    else [])\n   [x0, y0],\n  [x, \\<not> xa], [x0, y0]))))\n                          i =\n                         pmf (type4 [x0, y0] x0 y0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (swaps\n                                 (if Suc 0\n                                     \\<le> (if x then 0\n      else length (fst ([y0, x0], [x, xa], [x0, y0])))\n                                  then [Suc 0 -\n  (if [x, xa] ! 0 then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])))..<\n  0] @\n [0]\n                                  else [])\n                                 [y0, x0],\n                                [\\<not> x, xa], [x0, y0]))) =\n                      type4 [x0, y0] y0 x0", "apply(simp add: add.commute pmf_bind swap_def type4_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (swaps\n                                 (if Suc 0\n                                     \\<le> (if x then 0\n      else length (fst ([y0, x0], [x, xa], [x0, y0])))\n                                  then [Suc 0 -\n  (if [x, xa] ! 0 then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])))..<\n  0] @\n [0]\n                                  else [])\n                                 [y0, x0],\n                                [\\<not> x, xa], [x0, y0]))) =\n                      type4 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (swaps\n   (if Suc 0\n       \\<le> (if x then 0 else length (fst ([y0, x0], [x, xa], [x0, y0])))\n    then [Suc 0 -\n          (if [x, xa] ! 0 then 0\n           else length (fst ([y0, x0], [x, xa], [x0, y0])))..<\n          0] @\n         [0]\n    else [])\n   [y0, x0],\n  [\\<not> x, xa], [x0, y0]))))\n                          i =\n                         pmf (type4 [x0, y0] y0 x0) i", "apply(simp add: pmf_bind swap_def type4_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step1x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type1 [x0, y0] x y) x = type0 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type1 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type0 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type1 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type0 [x0, y0] x y", "apply(simp add: type1_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = x \\<longrightarrow>\n                       (x0 = x \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                      [xa, xb] ! (index [y0] y + 1)\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n        then ([y, x], [xa, xb], [x0, y0])\n        else ([x, y], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0]))))\n                                     x)\n                                   (fst (snd\n    (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n   else ([x, y], [xa, xb], [x0, y0])))))) =\n                        type0 [x, x] x y) \\<and>\n                       (x0 \\<noteq> x \\<longrightarrow>\n                        (x0 = y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                       [xa, xb] ! 0\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type0 [y, x] x y) \\<and>\n                        (x0 \\<noteq> y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                    [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n              [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n            [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type0 [x0, x] x y))) \\<and>\n                      (y0 \\<noteq> x \\<longrightarrow>\n                       (x0 = x \\<longrightarrow>\n                        (y0 = y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type0 [x, y] x y) \\<and>\n                        (y0 \\<noteq> y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type0 [x, y0] x y)) \\<and>\n                       (x0 \\<noteq> x \\<longrightarrow>\n                        (y0 = y \\<longrightarrow>\n                         (x0 = y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xa\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! 0\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! 0\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type0 [y, y] x y) \\<and>\n                         (x0 \\<noteq> y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xb\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                 [xa, xb] ! (index [y0] y + 1)\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! (index [y0] y + 1)\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! (index [y0] y + 1)\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                 [xa, xb] ! (index [y0] y + 1)\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n               [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n             [xa, xb] ! (index [y0] y + 1)\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type0 [x0, y] x y)) \\<and>\n                        (y0 \\<noteq> y \\<longrightarrow>\n                         (x0 = y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xa\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! 0\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! 0\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type0 [y, y0] x y) \\<and>\n                         (x0 \\<noteq> y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   ([x, y], [xa, xb], [x0, y0]))) =\n                          type0 [x0, y0] x y))))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if \\<not> x \\<and> xa\n                        then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if \\<not> [x, xa] ! 0 \\<and>\n                          [x, xa] ! (index [y0] y0 + 1)\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! 0 \\<and>\n                            [x, xa] ! (index [y0] y0 + 1)\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! 0 \\<and>\n                         [x, xa] ! (index [y0] y0 + 1)\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] x0 y0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] y0 x0", "apply(simp add: pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if \\<not> xa \\<and> x\n                        then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                          [x, xa] ! 0\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                            [x, xa] ! 0\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                         [x, xa] ! 0\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] y0 x0) i", "apply(simp add: add.commute pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step1y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type1 [x0, y0] x y) y = type3 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type1 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type3 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type1 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type3 [x0, y0] x y", "apply(simp add: type1_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = x \\<longrightarrow>\n                       (x0 = x \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                      [xa, xb] ! (index [y0] y + 1)\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n        then ([y, x], [xa, xb], [x0, y0])\n        else ([x, y], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (length\n                                     (snd\n (snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))))\n                                   (fst (snd\n    (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n   else ([x, y], [xa, xb], [x0, y0])))))) =\n                        type3 [x, x] x y) \\<and>\n                       (x0 \\<noteq> x \\<longrightarrow>\n                        (x0 = y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                       [xa, xb] ! 0\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xb \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type3 [y, x] x y) \\<and>\n                        (x0 \\<noteq> y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                    [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n              [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n            [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (length\n(snd (snd (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0])))))\n                                    (fst\n(snd (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xb \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type3 [x0, x] x y))) \\<and>\n                      (y0 \\<noteq> x \\<longrightarrow>\n                       (x0 = x \\<longrightarrow>\n                        (y0 = y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xa \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type3 [x, y] x y) \\<and>\n                        (y0 \\<noteq> y \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n                else ([x, y], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if \\<not> [xa, xb] ! 0 \\<and>\n                       [xa, xb] ! (index [y0] y + 1)\n                    then ([y, x], [xa, xb], [x0, y0])\n                    else ([x, y], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n             then ([y, x], [xa, xb], [x0, y0])\n             else ([x, y], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n           then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if \\<not> [xa, xb] ! 0 \\<and> [xa, xb] ! (index [y0] y + 1)\n         then ([y, x], [xa, xb], [x0, y0])\n         else ([x, y], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (length\n(snd (snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n           else ([x, y], [xa, xb], [x0, y0])))))\n                                    (fst\n(snd (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n      else ([x, y], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if \\<not> xa \\<and> [] ! 0 then ([y, x], [xa, xb], [x0, y0])\n    else ([x, y], [xa, xb], [x0, y0])))))) =\n                         type3 [x, y0] x y)) \\<and>\n                       (x0 \\<noteq> x \\<longrightarrow>\n                        (y0 = y \\<longrightarrow>\n                         (x0 = y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xa\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! 0\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! 0\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n y)\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type3 [y, y] x y) \\<and>\n                         (x0 \\<noteq> y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xb\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                 [xa, xb] ! (index [y0] y + 1)\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! (index [y0] y + 1)\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! (index [y0] y + 1)\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! (index [y0] y + 1)\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                 [xa, xb] ! (index [y0] y + 1)\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n               [xa, xb] ! (index [y0] y + 1)\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n             [xa, xb] ! (index [y0] y + 1)\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n y)\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xb then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type3 [x0, y] x y)) \\<and>\n                        (y0 \\<noteq> y \\<longrightarrow>\n                         (x0 = y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if \\<not> [] ! 0 \\<and> xa\n                 then ([y, x], [xa, xb], [x0, y0])\n                 else ([x, y], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! 0\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                        [xa, xb] ! 0\n                     then ([y, x], [xa, xb], [x0, y0])\n                     else ([x, y], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                     [xa, xb] ! 0\n                  then ([y, x], [xa, xb], [x0, y0])\n                  else ([x, y], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n              then ([y, x], [xa, xb], [x0, y0])\n              else ([x, y], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n            then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and> [xa, xb] ! 0\n          then ([y, x], [xa, xb], [x0, y0])\n          else ([x, y], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n            else ([x, y], [xa, xb], [x0, y0]))))\n y)\n                                     (fst\n (snd (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n       else ([x, y], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if \\<not> [] ! 0 \\<and> xa then ([y, x], [xa, xb], [x0, y0])\n     else ([x, y], [xa, xb], [x0, y0])))))) =\n                          type3 [y, y0] x y) \\<and>\n                         (x0 \\<noteq> y \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (swaps\n                                     (if Suc 0\n   \\<le> (if [] ! 0 then 0\n          else length\n                (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                         [xa, xb] ! (index [y0] y + 1)\n                      then ([y, x], [xa, xb], [x0, y0])\n                      else ([x, y], [xa, xb], [x0, y0]))))\nthen [Suc 0 -\n      (if [] ! 0 then 0\n       else length\n             (fst (if \\<not> [xa, xb] ! (index [y0] x + 1) \\<and>\n                      [xa, xb] ! (index [y0] y + 1)\n                   then ([y, x], [xa, xb], [x0, y0])\n                   else ([x, y], [xa, xb], [x0, y0]))))..<\n      0] @\n     [0]\nelse [])\n                                     [x, y],\n                                    [xa, xb], [x0, y0]))) =\n                          type3 [x0, y0] x y))))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type3 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type3 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if \\<not> x \\<and> xa\n                        then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if \\<not> [x, xa] ! 0 \\<and>\n                          [x, xa] ! (index [y0] y0 + 1)\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! 0 \\<and>\n                            [x, xa] ! (index [y0] y0 + 1)\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! 0 \\<and>\n                         [x, xa] ! (index [y0] y0 + 1)\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n                then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! 0 \\<and> [x, xa] ! (index [y0] y0 + 1)\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> x \\<and> xa then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type3 [x0, y0] x0 y0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type3 [x0, y0] y0 x0", "apply(simp add: add.commute pmf_bind swap_def type3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type3 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if \\<not> xa \\<and> x\n                        then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                          [x, xa] ! 0\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                            [x, xa] ! 0\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and>\n                         [x, xa] ! 0\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1) \\<and> [x, xa] ! 0\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> xa \\<and> x then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type3 [x0, y0] y0 x0) i", "apply(simp add: pmf_bind swap_def type3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step3x: \n    assumes \"x\\<noteq>y\" \"x:{x0,y0}\" \"y:{x0,y0}\"\n    shows \"BIT_Step (type3 [x0, y0] x y) x = type1 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type3 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type1 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type3 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type1 [x0, y0] x y", "apply(simp add: type3_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                      \\<not> [xa, xb] ! 0\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (length\n                                     (snd\n (snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))))\n                                   (fst (snd\n    (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type1 [y, y] x y) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        (x0 = x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! 0 \\<and>\n                       \\<not> [xa, xb] ! (index [y0] y + 1)\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type1 [x, y] x y) \\<and>\n                        (x0 \\<noteq> x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! (index [y0] y + 1)\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                    \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n              \\<not> [xa, xb] ! (index [y0] y + 1)\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n            \\<not> [xa, xb] ! (index [y0] y + 1)\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (length\n(snd (snd (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0])))))\n                                    (fst\n(snd (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type1 [x0, y] x y))) \\<and>\n                      (y0 \\<noteq> y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        (y0 = x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! 0\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! 0\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\nx)\n                                    (fst\n(snd (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type1 [y, x] x y) \\<and>\n                        (y0 \\<noteq> x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if x\n\\<in> set (fst (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! 0\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! 0\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         x\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     x]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (length\n(snd (snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0])))))\n                                    (fst\n(snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type1 [y, y0] x y)) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        (y0 = x \\<longrightarrow>\n                         (x0 = x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if xa \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if [xa, xb] ! 0 \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! 0 \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n x)\n                                     (fst\n (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type1 [x, x] x y) \\<and>\n                         (x0 \\<noteq> x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if xb \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                 \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                 \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n               \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n             \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n x)\n                                     (fst\n (snd (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type1 [x0, x] x y)) \\<and>\n                        (y0 \\<noteq> x \\<longrightarrow>\n                         (x0 = x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if x\n \\<in> set (fst (if xa \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x -\n     (if fst (snd (if [xa, xb] ! 0 \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! 0 \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          x\n      then 0\n      else length\n            (fst (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      x]\n    (swaps []\n      (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (index\n (snd (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n x)\n                                     (fst\n (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type1 [x, y0] x y) \\<and>\n                         (x0 \\<noteq> x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (swaps\n                                     (if Suc 0\n   \\<le> (if [] ! 0 then 0\n          else length\n                (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                         \\<not> [xa, xb] ! (index [y0] y + 1)\n                      then ([x, y], [xa, xb], [x0, y0])\n                      else ([y, x], [xa, xb], [x0, y0]))))\nthen [Suc 0 -\n      (if [] ! 0 then 0\n       else length\n             (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))..<\n      0] @\n     [0]\nelse [])\n                                     [y, x],\n                                    [xa, xb], [x0, y0]))) =\n                          type1 [x0, y0] x y))))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if x \\<and> \\<not> xa\n                        then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if [x, xa] ! 0 \\<and>\n                          \\<not> [x, xa] ! (index [y0] y0 + 1)\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if [x, xa] ! 0 \\<and>\n                            \\<not> [x, xa] ! (index [y0] y0 + 1)\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if [x, xa] ! 0 \\<and>\n                         \\<not> [x, xa] ! (index [y0] y0 + 1)\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type1 [x0, y0] x0 y0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(simp add: pmf_bind swap_def type1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if xa \\<and> \\<not> x\n                        then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                          \\<not> [x, xa] ! 0\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                            \\<not> [x, xa] ! 0\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                         \\<not> [x, xa] ! 0\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type1 [x0, y0] y0 x0) i", "apply(simp add: add.commute pmf_bind swap_def type1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step3y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type3 [x0, y0] x y) y = type0 [x0, y0] y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type3 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type0 [x0, y0] y x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type3 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type0 [x0, y0] y x", "apply(simp add: type3_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                      \\<not> [xa, xb] ! 0\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     y)\n                                   (fst (snd\n    (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type0 [y, y] y x) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        (x0 = x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! 0 \\<and>\n                       \\<not> [xa, xb] ! (index [y0] y + 1)\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if xa \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type0 [x, y] y x) \\<and>\n                        (x0 \\<noteq> x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! (index [y0] y + 1)\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                    \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                \\<not> [xa, xb] ! (index [y0] y + 1)\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n              \\<not> [xa, xb] ! (index [y0] y + 1)\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n            \\<not> [xa, xb] ! (index [y0] y + 1)\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if [] ! 0 \\<and> \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type0 [x0, y] y x))) \\<and>\n                      (y0 \\<noteq> y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        (y0 = x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! 0\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! 0\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if xb \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type0 [y, x] y x) \\<and>\n                        (y0 \\<noteq> x \\<longrightarrow>\n                         bernoulli_pmf (1 / 2) \\<bind>\n                         (\\<lambda>xa.\n                             bernoulli_pmf (1 / 2) \\<bind>\n                             (\\<lambda>xb.\n                                 return_pmf\n                                  (if y\n\\<in> set (fst (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0])))\n                                   then swaps\n   [index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y -\n    (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! 0\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))) !\n        index\n         (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                       \\<not> [xa, xb] ! 0\n                    then ([x, y], [xa, xb], [x0, y0])\n                    else ([y, x], [xa, xb], [x0, y0]))))\n         y\n     then 0\n     else length\n           (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))))..<\n    index\n     (swaps []\n       (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n             then ([x, y], [xa, xb], [x0, y0])\n             else ([y, x], [xa, xb], [x0, y0]))))\n     y]\n   (swaps []\n     (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n           then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\n                                   else swaps []\n   (fst (if [xa, xb] ! (index [y0] x + 1) \\<and> \\<not> [xa, xb] ! 0\n         then ([x, y], [xa, xb], [x0, y0])\n         else ([y, x], [xa, xb], [x0, y0]))),\n                                   flip\n                                    (index\n(snd (snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n           else ([y, x], [xa, xb], [x0, y0]))))\ny)\n                                    (fst\n(snd (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n      else ([y, x], [xa, xb], [x0, y0])))),\n                                   snd (snd\n   (if [] ! 0 \\<and> \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n    else ([y, x], [xa, xb], [x0, y0])))))) =\n                         type0 [y, y0] y x)) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        (y0 = x \\<longrightarrow>\n                         (x0 = x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if xa \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if [xa, xb] ! 0 \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! 0 \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type0 [x, x] y x) \\<and>\n                         (x0 \\<noteq> x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if xb \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                 \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n                 \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n               \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! (index [y0] x + 1) \\<and>\n             \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xb \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type0 [x0, x] y x)) \\<and>\n                        (y0 \\<noteq> x \\<longrightarrow>\n                         (x0 = x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   (if y\n \\<in> set (fst (if xa \\<and> \\<not> [] ! 0\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0])))\n                                    then swaps\n    [index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y -\n     (if fst (snd (if [xa, xb] ! 0 \\<and>\n                      \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))) !\n         index\n          (snd (snd (if [xa, xb] ! 0 \\<and>\n                        \\<not> [xa, xb] ! (index [y0] y + 1)\n                     then ([x, y], [xa, xb], [x0, y0])\n                     else ([y, x], [xa, xb], [x0, y0]))))\n          y\n      then 0\n      else length\n            (fst (if [xa, xb] ! 0 \\<and>\n                     \\<not> [xa, xb] ! (index [y0] y + 1)\n                  then ([x, y], [xa, xb], [x0, y0])\n                  else ([y, x], [xa, xb], [x0, y0]))))..<\n     index\n      (swaps []\n        (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n              then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0]))))\n      y]\n    (swaps []\n      (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n                                    else swaps []\n    (fst (if [xa, xb] ! 0 \\<and> \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))),\n                                    flip\n                                     (length\n (snd (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0])))))\n                                     (fst\n (snd (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))),\n                                    snd (snd\n    (if xa \\<and> \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))))) =\n                          type0 [x, y0] y x) \\<and>\n                         (x0 \\<noteq> x \\<longrightarrow>\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>xb.\n                                  return_pmf\n                                   ([y, x], [xa, xb], [x0, y0]))) =\n                          type0 [x0, y0] y x))))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if x \\<and> \\<not> xa\n                        then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if [x, xa] ! 0 \\<and>\n                          \\<not> [x, xa] ! (index [y0] y0 + 1)\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if [x, xa] ! 0 \\<and>\n                            \\<not> [x, xa] ! (index [y0] y0 + 1)\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if [x, xa] ! 0 \\<and>\n                         \\<not> [x, xa] ! (index [y0] y0 + 1)\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if [x, xa] ! 0 \\<and> \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if x \\<and> \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] y0 x0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(simp add: add.commute pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n               then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n          then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n        then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n      then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if xa \\<and> \\<not> x\n                        then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                          \\<not> [x, xa] ! 0\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                            \\<not> [x, xa] ! 0\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and>\n                         \\<not> [x, xa] ! 0\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                  then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n                then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if [x, xa] ! (index [y0] y0 + 1) \\<and> \\<not> [x, xa] ! 0\n              then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if xa \\<and> \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] x0 y0) i", "apply(simp add: pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step4x: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type4 [x0, y0] x y) x =  type1 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type4 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type1 [x0, y0] x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type4 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) x a, is'))) =\n    type1 [x0, y0] x y", "apply(simp add: type4_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (length\n                                     (snd\n (snd (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))))\n                                   (fst (snd\n    (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type1 [y, y] x y) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     x)\n                                   (fst (snd\n    (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type1 [x0, y] x y)) \\<and>\n                      (y0 \\<noteq> y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     x)\n                                   (fst (snd\n    (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type1 [y, y0] x y) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if x \\<in> set\n        (fst (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x -\n   (if fst (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        x\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    x]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     x)\n                                   (fst (snd\n    (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type1 [x0, y0] x y))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type1 [x0, y0] x0 y0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(simp add: pmf_bind swap_def type1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type1 [x0, y0] y0 x0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if \\<not> [x, xa] ! 0\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! 0\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! 0\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type1 [x0, y0] y0 x0) i", "apply(simp add: add.commute pmf_bind swap_def type1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oneBIT_step4y: \n    assumes \"x\\<noteq>y\" \"x : {x0,y0}\" \"y\\<in>{x0,y0}\"\n    shows \"BIT_Step (type4 [x0, y0] x y) y = type0 [x0, y0] y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type4 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type0 [x0, y0] y x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> {x0, y0}\n  y \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. type4 [x0, y0] x y \\<bind>\n    (\\<lambda>s.\n        BIT_step s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (step (fst s) y a, is'))) =\n    type0 [x0, y0] y x", "apply(simp add: type4_def BIT_step_def bind_assoc_pmf bind_return_pmf step_def mtf2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x = x0 \\<or> x = y0; y = x0 \\<or> y = y0\\<rbrakk>\n    \\<Longrightarrow> (y0 = y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     y)\n                                   (fst (snd\n    (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type0 [y, y] y x) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     y)\n                                   (fst (snd\n    (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xb then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type0 [x0, y] y x)) \\<and>\n                      (y0 \\<noteq> y \\<longrightarrow>\n                       (x0 = y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! 0 then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (index\n                                     (snd\n (snd (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0]))))\n                                     y)\n                                   (fst (snd\n    (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> xa then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type0 [y, y0] y x) \\<and>\n                       (x0 \\<noteq> y \\<longrightarrow>\n                        bernoulli_pmf (1 / 2) \\<bind>\n                        (\\<lambda>xa.\n                            bernoulli_pmf (1 / 2) \\<bind>\n                            (\\<lambda>xb.\n                                return_pmf\n                                 (if y \\<in> set\n        (fst (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n              else ([y, x], [xa, xb], [x0, y0])))\n                                  then swaps\n  [index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y -\n   (if fst (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                 then ([x, y], [xa, xb], [x0, y0])\n                 else ([y, x], [xa, xb], [x0, y0]))) !\n       index\n        (snd (snd (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                   then ([x, y], [xa, xb], [x0, y0])\n                   else ([y, x], [xa, xb], [x0, y0]))))\n        y\n    then 0\n    else length\n          (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n                then ([x, y], [xa, xb], [x0, y0])\n                else ([y, x], [xa, xb], [x0, y0]))))..<\n   index\n    (swaps []\n      (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n            then ([x, y], [xa, xb], [x0, y0])\n            else ([y, x], [xa, xb], [x0, y0]))))\n    y]\n  (swaps []\n    (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n          then ([x, y], [xa, xb], [x0, y0])\n          else ([y, x], [xa, xb], [x0, y0]))))\n                                  else swaps []\n  (fst (if \\<not> [xa, xb] ! (index [y0] y + 1)\n        then ([x, y], [xa, xb], [x0, y0])\n        else ([y, x], [xa, xb], [x0, y0]))),\n                                  flip\n                                   (length\n                                     (snd\n (snd (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n       else ([y, x], [xa, xb], [x0, y0])))))\n                                   (fst (snd\n    (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n     else ([y, x], [xa, xb], [x0, y0])))),\n                                  snd (snd\n  (if \\<not> [] ! 0 then ([x, y], [xa, xb], [x0, y0])\n   else ([y, x], [xa, xb], [x0, y0])))))) =\n                        type0 [x0, y0] y x))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if y0 \\<in> set\n       (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n             else ([y0, x0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0 -\n (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n               then ([x0, y0], [x, xa], [x0, y0])\n               else ([y0, x0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                 then ([x0, y0], [x, xa], [x0, y0])\n                 else ([y0, x0], [x, xa], [x0, y0]))))\n      y0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n          then ([x0, y0], [x, xa], [x0, y0])\n          else ([y0, x0], [x, xa], [x0, y0]))))\n  y0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n        then ([x0, y0], [x, xa], [x0, y0])\n        else ([y0, x0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n      then ([x0, y0], [x, xa], [x0, y0])\n      else ([y0, x0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n     else ([y0, x0], [x, xa], [x0, y0]))))\n                                   y0)\n                                 (fst (snd\n  (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n   else ([y0, x0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n else ([y0, x0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0; x0 \\<noteq> y0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if y0 \\<in> set (fst (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                        else ([y0, x0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0 -\n         (if fst (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                       then ([x0, y0], [x, xa], [x0, y0])\n                       else ([y0, x0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                         then ([x0, y0], [x, xa], [x0, y0])\n                         else ([y0, x0], [x, xa], [x0, y0]))))\n              y0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                      then ([x0, y0], [x, xa], [x0, y0])\n                      else ([y0, x0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                  then ([x0, y0], [x, xa], [x0, y0])\n                  else ([y0, x0], [x, xa], [x0, y0]))))\n          y0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n                then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! (index [y0] y0 + 1)\n              then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n                else ([y0, x0], [x, xa], [x0, y0]))))\n     y0)\n   (fst (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n              else ([y0, x0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> xa then ([x0, y0], [x, xa], [x0, y0])\n            else ([y0, x0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] y0 x0) i\n 2. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(simp add: add.commute pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n    \\<Longrightarrow> bernoulli_pmf (1 / 2) \\<bind>\n                      (\\<lambda>x.\n                          bernoulli_pmf (1 / 2) \\<bind>\n                          (\\<lambda>xa.\n                              return_pmf\n                               (if x0 \\<in> set\n       (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n             else ([x0, y0], [x, xa], [x0, y0])))\n                                then swaps\n[index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0 -\n (if fst (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n               else ([x0, y0], [x, xa], [x0, y0]))) !\n     index\n      (snd (snd (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                 else ([x0, y0], [x, xa], [x0, y0]))))\n      x0\n  then 0\n  else length\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))))..<\n index\n  (swaps []\n    (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n          else ([x0, y0], [x, xa], [x0, y0]))))\n  x0]\n(swaps []\n  (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n        else ([x0, y0], [x, xa], [x0, y0]))))\n                                else swaps []\n(fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n      else ([x0, y0], [x, xa], [x0, y0]))),\n                                flip\n                                 (index\n                                   (snd (snd\n    (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n     else ([x0, y0], [x, xa], [x0, y0]))))\n                                   x0)\n                                 (fst (snd\n  (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n   else ([x0, y0], [x, xa], [x0, y0])))),\n                                snd (snd\n(if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n else ([x0, y0], [x, xa], [x0, y0])))))) =\n                      type0 [x0, y0] x0 y0", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>y0 \\<noteq> x0; x = y0; y = x0; y0 \\<noteq> x0\\<rbrakk>\n       \\<Longrightarrow> pmf (bernoulli_pmf (1 / 2) \\<bind>\n                              (\\<lambda>x.\n                                  bernoulli_pmf (1 / 2) \\<bind>\n                                  (\\<lambda>xa.\nreturn_pmf\n (if x0 \\<in> set (fst (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                        else ([x0, y0], [x, xa], [x0, y0])))\n  then swaps\n        [index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0 -\n         (if fst (snd (if \\<not> [x, xa] ! 0\n                       then ([y0, x0], [x, xa], [x0, y0])\n                       else ([x0, y0], [x, xa], [x0, y0]))) !\n             index\n              (snd (snd (if \\<not> [x, xa] ! 0\n                         then ([y0, x0], [x, xa], [x0, y0])\n                         else ([x0, y0], [x, xa], [x0, y0]))))\n              x0\n          then 0\n          else length\n                (fst (if \\<not> [x, xa] ! 0\n                      then ([y0, x0], [x, xa], [x0, y0])\n                      else ([x0, y0], [x, xa], [x0, y0]))))..<\n         index\n          (swaps []\n            (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                  else ([x0, y0], [x, xa], [x0, y0]))))\n          x0]\n        (swaps []\n          (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n  else swaps []\n        (fst (if \\<not> [x, xa] ! 0 then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0]))),\n  flip\n   (index\n     (snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n                else ([x0, y0], [x, xa], [x0, y0]))))\n     x0)\n   (fst (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n              else ([x0, y0], [x, xa], [x0, y0])))),\n  snd (snd (if \\<not> x then ([y0, x0], [x, xa], [x0, y0])\n            else ([x0, y0], [x, xa], [x0, y0])))))))\n                          i =\n                         pmf (type0 [x0, y0] x0 y0) i", "apply(simp add: pmf_bind swap_def type0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas oneBIT_step = oneBIT_step0x oneBIT_step0y oneBIT_step1x oneBIT_step1y oneBIT_step3x oneBIT_step3y oneBIT_step4x oneBIT_step4y"], ["", "subsection \"Analysis of the four phase forms\""], ["", "subsubsection \"yx\""], ["", "lemma bit_yx: assumes \"x \\<noteq> y\" \n      and kas: \"init \\<in> {[x,y],[y,x]}\"\n      and \"qs \\<in> lang (Star(Times (Atom y) (Atom x))) \"\n   shows \"T\\<^sub>p_on_rand' BIT (type1 init x y) (qs@r) = 0.75 * length qs + T\\<^sub>p_on_rand' BIT (type1 init x y) r \n    \\<and> config'_rand BIT (type1 init x y) qs  = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) qs = type1 init x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) qs = type1 init x y", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))", "have \"qs \\<in> star ({[y]} @@ {[x]})\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))\n\ngoal (1 subgoal):\n 1. qs \\<in> star ({[y]} @@ {[x]})", "by (simp)"], ["proof (state)\nthis:\n  qs \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) qs = type1 init x y", "from this assms"], ["proof (chain)\npicking this:\n  qs \\<in> star ({[y]} @@ {[x]})\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  qs \\<in> star ({[y]} @@ {[x]})\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (Star (Times (Atom y) (Atom x)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) qs = type1 init x y", "proof (induct qs rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "case (append u v)"], ["proof (state)\nthis:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n   v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                    75 / 10\\<^sup>2 * real (length v) +\n                    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                    Partial_Cost_Model.config'_rand BIT (type1 init x y) v =\n                    type1 init x y\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "then"], ["proof (chain)\npicking this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n   v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                    75 / 10\\<^sup>2 * real (length v) +\n                    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                    Partial_Cost_Model.config'_rand BIT (type1 init x y) v =\n                    type1 init x y\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))", "have uyx: \"u = [y,x]\""], ["proof (prove)\nusing this:\n  u \\<in> {[y]} @@ {[x]}\n  v \\<in> star ({[y]} @@ {[x]})\n  \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n   v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                    75 / 10\\<^sup>2 * real (length v) +\n                    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                    Partial_Cost_Model.config'_rand BIT (type1 init x y) v =\n                    type1 init x y\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\n\ngoal (1 subgoal):\n 1. u = [y, x]", "by auto"], ["proof (state)\nthis:\n  u = [y, x]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have yy: \"T\\<^sub>p_on_rand' BIT (type1 init x y)  (v @ r)  = 0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r  \n            \\<and> config'_rand BIT  (type1 init x y) v = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) v = type1 init x y", "apply(rule append(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<noteq> y\n 2. init \\<in> {[x, y], [y, x]}\n 3. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "apply(fact)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "using append(2,6)"], ["proof (prove)\nusing this:\n  v \\<in> star ({[y]} @@ {[x]})\n  u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\n\ngoal (1 subgoal):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "by(simp_all)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) v = type1 init x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have s2: \"config'_rand BIT  (type1 init x y) [y,x] = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, x] =\n    type1 init x y", "using kas assms(1)"], ["proof (prove)\nusing this:\n  init \\<in> {[x, y], [y, x]}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, x] =\n    type1 init x y", "by (auto simp add: oneBIT_step )"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, x] =\n  type1 init x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have ta: \"T\\<^sub>p_on_rand' BIT (type1 init x y) u = 1.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) u = 15 / 10", "using kas assms(1)"], ["proof (prove)\nusing this:\n  init \\<in> {[x, y], [y, x]}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) u = 15 / 10", "by(auto simp add: uyx oneBIT_step costBIT_1y costBIT_3x)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u = 15 / 10\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have config: \"config'_rand BIT  (type1 init x y) (u @ v)\n          = type1 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n    type1 init x y", "by (simp only: config'_rand_append s2 uyx yy)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n  type1 init x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ (v @ r))  \n        = T\\<^sub>p_on_rand' BIT (type1 init x y) u  + T\\<^sub>p_on_rand' BIT ( config'_rand BIT (type1 init x y)  u) (v@r) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n    T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    T\\<^sub>p_on_rand' BIT\n     (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r)", "by (simp only: T_on_rand'_append)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"\\<dots> =  T\\<^sub>p_on_rand' BIT  (type1 init x y) u + T\\<^sub>p_on_rand' BIT (type1 init x y) (v@r) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    T\\<^sub>p_on_rand' BIT\n     (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r) =\n    T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)", "unfolding uyx"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) [y, x] +\n    T\\<^sub>p_on_rand' BIT\n     (Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, x]) (v @ r) =\n    T\\<^sub>p_on_rand' BIT (type1 init x y) [y, x] +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)", "by(simp only: s2)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type1 init x y) u) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"\\<dots> = T\\<^sub>p_on_rand' BIT (type1 init x y) u  + 0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n    T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by(simp only: yy)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"\\<dots> = 2*0.75 + 0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by(simp add: ta)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"\\<dots> = 0.75 * (2+length v) + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by (simp add: ring_distribs del: add_2_eq_Suc' add_2_eq_Suc)"], ["proof (state)\nthis:\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "also"], ["proof (state)\nthis:\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "have \"\\<dots> = 0.75 * length (u @ v) + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "using uyx"], ["proof (prove)\nusing this:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by simp"], ["proof (state)\nthis:\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n         v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n                          75 / 10\\<^sup>2 * real (length v) +\n                          T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                          Partial_Cost_Model.config'_rand BIT\n                           (type1 init x y) v =\n                          type1 init x y;\n        x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n        u @ v \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y)\n                          ((u @ v) @ r) =\n                         75 / 10\\<^sup>2 * real (length (u @ v)) +\n                         T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                         Partial_Cost_Model.config'_rand BIT\n                          (type1 init x y) (u @ v) =\n                         type1 init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) ((u @ v) @ r) =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n    type1 init x y", "using config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n  type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) ((u @ v) @ r) =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n    type1 init x y", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) ((u @ v) @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) (u @ v) =\n  type1 init x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; init \\<in> {[x, y], [y, x]};\n     [] \\<in> lang (Star (Times (Atom y) (Atom x)))\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type1 init x y) ([] @ r) =\n                      75 / 10\\<^sup>2 * real (length []) +\n                      T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n                      Partial_Cost_Model.config'_rand BIT (type1 init x y)\n                       [] =\n                      type1 init x y", "qed simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (qs @ r) =\n  75 / 10\\<^sup>2 * real (length qs) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) qs = type1 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"(yx)*yx\""], ["", "lemma bit_yxyx: assumes \"x \\<noteq> y\" and kas: \"init \\<in> {[x,y],[y,x]}\" and\n      \"qs \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n   shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) (qs@r) = 0.75 * length qs + T\\<^sub>p_on_rand' BIT (type1 init x y) r \n    \\<and> config'_rand BIT (type0 init x y) qs  = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "obtain u v where uu: \"u \\<in> lang (Times (Atom y) (Atom x))\"\n              and vv: \"v \\<in> lang (seq[ Star(Times (Atom y) (Atom x))])\"\n              and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (Times (Atom y) (Atom x));\n         v \\<in> lang (seq [Star (Times (Atom y) (Atom x))]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (Times (Atom y) (Atom x));\n         v \\<in> lang (seq [Star (Times (Atom y) (Atom x))]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (Times (Atom y) (Atom x))\n  v \\<in> lang (seq [Star (Times (Atom y) (Atom x))])\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (Times (Atom y) (Atom x))", "have uyx: \"u = [y,x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (Times (Atom y) (Atom x))\n\ngoal (1 subgoal):\n 1. u = [y, x]", "by(auto)"], ["proof (state)\nthis:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "from qsuv uyx"], ["proof (chain)\npicking this:\n  qs = u @ v\n  u = [y, x]", "have vqs: \"length v = length qs - 2\""], ["proof (prove)\nusing this:\n  qs = u @ v\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. length v = length qs - 2", "by auto"], ["proof (state)\nthis:\n  length v = length qs - 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "from qsuv uyx"], ["proof (chain)\npicking this:\n  qs = u @ v\n  u = [y, x]", "have vqs2: \"length v + 2 = length qs\""], ["proof (prove)\nusing this:\n  qs = u @ v\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. length v + 2 = length qs", "by auto"], ["proof (state)\nthis:\n  length v + 2 = length qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have s2: \"config'_rand BIT  (type0 init x y) [y,x] = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [y, x] =\n    type1 init x y", "using kas assms(1)"], ["proof (prove)\nusing this:\n  init \\<in> {[x, y], [y, x]}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [y, x] =\n    type1 init x y", "by(auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) [y, x] =\n  type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have ta: \"T\\<^sub>p_on_rand' BIT (type0 init x y) u = 1.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) u = 15 / 10", "using kas assms(1)"], ["proof (prove)\nusing this:\n  init \\<in> {[x, y], [y, x]}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) u = 15 / 10", "by (auto simp add: uyx oneBIT_step costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u = 15 / 10\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have tat: \"T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =   0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r\n            \\<and> config'_rand BIT (type1 init x y) v = (type1 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type1 init x y) v = type1 init x y", "apply(rule bit_yx)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<noteq> y\n 2. init \\<in> {[x, y], [y, x]}\n 3. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "apply(fact)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "using vv"], ["proof (prove)\nusing this:\n  v \\<in> lang (seq [Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. v \\<in> lang (Star (Times (Atom y) (Atom x)))", "by(simp_all)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) v = type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have config: \"config'_rand BIT (type0 init x y) (u @ v) = type1 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) (u @ v) =\n    type1 init x y", "by(simp only: config'_rand_append s2 uyx tat)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (u @ v) =\n  type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ (v @ r)) \n        = T\\<^sub>p_on_rand' BIT (type0 init x y) u + T\\<^sub>p_on_rand' BIT (config'_rand BIT (type0 init x y) u) (v@r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    T\\<^sub>p_on_rand' BIT\n     (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r)", "by (simp only: T_on_rand'_append)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"\\<dots> =  T\\<^sub>p_on_rand' BIT (type0 init x y) u + T\\<^sub>p_on_rand' BIT (type1 init x y) (v@r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    T\\<^sub>p_on_rand' BIT\n     (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)", "by(simp only: uyx s2)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT\n   (Partial_Cost_Model.config'_rand BIT (type0 init x y) u) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"\\<dots> = T\\<^sub>p_on_rand' BIT (type0 init x y) u + 0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by(simp only: tat)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) (v @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"\\<dots> = 2*0.75 + 0.75*length v + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n    75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by(simp add: ta)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) u +\n  75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"\\<dots> = 0.75 * (2+length v) + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by (simp add: ring_distribs del: add_2_eq_Suc' add_2_eq_Suc)"], ["proof (state)\nthis:\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "also"], ["proof (state)\nthis:\n  2 * (75 / 10\\<^sup>2) + 75 / 10\\<^sup>2 * real (length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "have \"\\<dots> = 0.75 * length (u @ v) + T\\<^sub>p_on_rand' BIT (type1 init x y) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "using uyx"], ["proof (prove)\nusing this:\n  u = [y, x]\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (2 + length v) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n    75 / 10\\<^sup>2 * real (length (u @ v)) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r", "by simp"], ["proof (state)\nthis:\n  75 / 10\\<^sup>2 * real (2 + length v) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "using qsuv config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v @ r) =\n  75 / 10\\<^sup>2 * real (length (u @ v)) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r\n  qs = u @ v\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (u @ v) =\n  type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    75 / 10\\<^sup>2 * real (length qs) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n  75 / 10\\<^sup>2 * real (length qs) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type1 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>x^+..\\<close>\\<close>"], ["", "lemma BIT_x: assumes \"x\\<noteq>y\"\n       \"init \\<in> {[x,y],[y,x]}\" \"qs \\<in> lang (Plus (Atom x) One)\"\n shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) (qs@r) = T\\<^sub>p_on_rand' BIT (type0 init x y) r \n    \\<and> config'_rand BIT  (type0 init x y) qs = (type0 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have s: \"config'_rand BIT (type0 init x y) qs = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "by (auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have t: \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 0", "by (auto simp add: costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "using s t"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "by(simp add: T_on_rand'_append)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (qs @ r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Phase Form A\""], ["", "lemma BIT_a: assumes \"x \\<noteq> y\"\n    \" init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n  shows \"config'_rand BIT (type0 init x y) qs = (type0 init y x)\" (is ?C)\n    and b: \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 1.5\" (is ?T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs =\n    type0 init y x &&&\n    T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x\n 2. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "from assms(3)"], ["proof (chain)\npicking this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])", "have alt: \"qs = [x,y,y] \\<or> qs = [y,y]\""], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. qs = [x, y, y] \\<or> qs = [y, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> {[], [x]} @@ {[y]} @@ {[y]} \\<Longrightarrow>\n    qs = [x, y, y] \\<or> qs = [y, y]", "by fastforce"], ["proof (state)\nthis:\n  qs = [x, y, y] \\<or> qs = [y, y]\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x\n 2. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "show ?C"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "using assms(1,2) alt"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs = [x, y, y] \\<or> qs = [y, y]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "by (auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "show ?T"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "using assms(1,2) alt"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs = [x, y, y] \\<or> qs = [y, y]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10", "by(auto simp add: oneBIT_step costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs = 15 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_a: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Plus (Atom x) One, Atom y, Atom y])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\n      \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by fastforce"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have p: \"T\\<^sub>p_on_rand' BIT s qs = 1.5\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs = 15 / 10", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs =\n                      15 / 10\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "apply(rule BIT_a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      15 / 10", "apply(rule BIT_a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "with OPT2_A[OF assms(1,5)]"], ["proof (chain)\npicking this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs \\<le> 1.75 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 1\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] y x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] y x", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom x), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "have \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "using assms(1) kas f lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  x0 \\<noteq> y0\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "then"], ["proof (chain)\npicking this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "show ?thesis"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "using BIT s p"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n  s = type0 [x0, y0] x y\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_a'': \" a \\<noteq> b \\<Longrightarrow>\n         {a, b} = {x, y} \\<Longrightarrow>\n         BIT_inv s a [x, y] \\<Longrightarrow>\n         set qs \\<subseteq> {a, b} \\<Longrightarrow>\n         qs \\<in> lang (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n         BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n     set qs \\<subseteq> {a, b};\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                       (last qs) [x, y] \\<and>\n                      T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "using bit_a[of a b x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv ?s a [x, y];\n   set ?qs \\<subseteq> {a, b};\n   ?qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT ?s ?qs\n                    \\<le> 175 / 10\\<^sup>2 *\n                          real\n                           (T\\<^sub>p [a, b] ?qs (OPT2 ?qs [a, b])) \\<and>\n                    BIT_inv (Partial_Cost_Model.config'_rand BIT ?s ?qs)\n                     (last ?qs) [x, y] \\<and>\n                    T\\<^sub>p_on_rand' BIT ?s ?qs = 15 / 10\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n     set qs \\<subseteq> {a, b};\n     qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n    \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                       (last qs) [x, y] \\<and>\n                      T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "by blast"], ["", "subsubsection \"Phase Form B\""], ["", "lemma BIT_b: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * length v - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init y x)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have lenvmod: \"length v mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "by(simp add: conc_assoc)"], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[y]} @@ {[y]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}", "have \"p = [y,x]\" \"r=[y,y]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [y, y]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]", "have a: \"length v = 4+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v = 4 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 4 + length q\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "from a b"], ["proof (chain)\npicking this:\n  length v = 4 + length q\n  length q mod 2 = 0", "show \"length v mod 2 = 0\""], ["proof (prove)\nusing this:\n  length v = 4 + length q\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 0\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom y, Atom y])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                      and \"b \\<in> lang (seq[Atom y, Atom y])\"\n                      and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom y, Atom y]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "then"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b", "have bb: \"b=[y,y]\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. b = [y, y]", "by auto"], ["proof (state)\nthis:\n  b = [y, y]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from vab bb"], ["proof (chain)\npicking this:\n  v = a @ b\n  b = [y, y]", "have lenv: \"length v = length a + 2\""], ["proof (prove)\nusing this:\n  v = a @ b\n  b = [y, y]\n\ngoal (1 subgoal):\n 1. length v = length a + 2", "by auto"], ["proof (state)\nthis:\n  length v = length a + 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from bit_yxyx[OF assms(1,2) aa]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ ?r) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y", "have stars: \"T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b)  = 0.75 * length a + T\\<^sub>p_on_rand' BIT (type1 init x y) b\"\n                             and s2: \"config'_rand BIT (type0 init x y) a = type1 init x y\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ ?r) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n    75 / 10\\<^sup>2 * real (length a) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) b &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y", "by fast+"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have t: \"T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1", "by (auto simp add: oneBIT_step  costBIT bb)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have s: \"config'_rand BIT  (type1 init x y) [y, y] = type0 init y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, y] =\n    type0 init y x", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, y] =\n    type0 init y x", "by (auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) [y, y] =\n  type0 init y x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have config: \"config'_rand BIT (type0 init x y) (a @ b) = type0 init y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n    type0 init y x", "by (simp only: config'_rand_append s2 vab bb s)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init y x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have calc: \"3 * Suc (Suc (length a)) / 4 - 1 / 2 = 3 * (2+length a) / 4 - 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (3 * Suc (Suc (length a))) / 4 - 1 / 2 =\n    real (3 * (2 + length a)) / 4 - 1 / 2", "by simp"], ["proof (state)\nthis:\n  real (3 * Suc (Suc (length a))) / 4 - 1 / 2 =\n  real (3 * (2 + length a)) / 4 - 1 / 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from t stars"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b", "have \"T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) = 0.75 * length a + 1\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n    75 / 10\\<^sup>2 * real (length a) + 1", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1", "show \"T\\<^sub>p_on_rand' BIT  (type0 init x y) v = 0.75 * length v - 0.5\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "unfolding lenv"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length a + 2) - 5 / 10", "by(simp add: vab ring_distribs del: add_2_eq_Suc')"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from config vab"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init y x\n  v = a @ b", "show ?C"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init y x\n  v = a @ b\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_b''1: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * length qs - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(5)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by fastforce"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs = 0.75 * length qs - 0.5\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(rule BIT_b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(rule BIT_b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] y x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] y x", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom y,\n                  Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "have config: \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "using assms(1) kas lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "using BIT config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "by simp"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BIT_b2: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * (length v - 1) - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init y x)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "from assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "obtain w where  vw: \"v = [x]@w\" and\n          w: \"w \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>v = [x] @ w;\n         w \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y,\n                        Atom y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  v = [x] @ w\n  w \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have c1: \"config'_rand BIT (type0 init x y) [x] = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] =\n    type0 init x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] =\n    type0 init x y", "by(auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have t1: \"T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0", "by(auto simp add: costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "show \"T\\<^sub>p_on_rand' BIT (type0 init x y) v\n      = 0.75 * (length v - 1) - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10", "unfolding vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) ([x] @ w) =\n    75 / 10\\<^sup>2 * real (length ([x] @ w) - 1) - 5 / 10", "apply(simp only: T_on_rand'_append c1 BIT_b[OF assms(1,2) w] t1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + (75 / 10\\<^sup>2 * real (length w) - 5 / 10) =\n    75 / 10\\<^sup>2 * real (length ([x] @ w) - 1) - 5 / 10", "by (simp)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "show \"config'_rand BIT (type0 init x y) v = (type0 init y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "unfolding vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) ([x] @ w) =\n    type0 init y x", "by(simp only: config'_rand_append c1 BIT_b[OF assms(1,2) w])"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_b''2: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * (length qs - 1) - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(5)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by fastforce"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs = 0.75 * (length qs-1) - 0.5\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(rule BIT_b2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(rule BIT_b2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] y x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] y x", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_b2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule BIT_b2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "have config: \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "using assms(1) kas lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "using BIT config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "by simp"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_b: assumes \"x \\<noteq> y\"\n      \"init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows  \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\"\n  and \"config'_rand BIT (type0 init x y) qs = type0 init y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "obtain u v where uu: \"u \\<in> lang (Plus (Atom x) One)\"\n        and vv: \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom y, Atom y])\"\n        and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y, Atom y]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom y, Atom y]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (question (Atom x))\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n  qs = u @ v\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "have lenv: \"length v mod 2 = 0 \\<and> last v = y \\<and> v\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "by simp"], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in>{[y]} @@ {[y]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[y]} @@ {[y]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}", "have rr: \"p = [y,x]\" \"r=[y,y]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[y]} @@ {[y]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [y, y]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]", "have a: \"length v = 4+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. length v = 4 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 4 + length q\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "have \"last v = last r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last v = last r", "using pqr rr"], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. last v = last r", "by auto"], ["proof (state)\nthis:\n  last v = last r\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  last v = last r", "have c: \"last v = y\""], ["proof (prove)\nusing this:\n  last v = last r\n\ngoal (1 subgoal):\n 1. last v = y", "using rr"], ["proof (prove)\nusing this:\n  last v = last r\n  p = [y, x]\n  r = [y, y]\n\ngoal (1 subgoal):\n 1. last v = y", "by auto"], ["proof (state)\nthis:\n  last v = y\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "from a b c"], ["proof (chain)\npicking this:\n  length v = 4 + length q\n  length q mod 2 = 0\n  last v = y", "show ?thesis"], ["proof (prove)\nusing this:\n  length v = 4 + length q\n  length q mod 2 = 0\n  last v = y\n\ngoal (1 subgoal):\n 1. length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom y, Atom y])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom y, Atom y])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                    and \"b \\<in> lang (seq[Atom y, Atom y])\"\n                    and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom y, Atom y]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom y, Atom y])\n  v = a @ b\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "from BIT_x[OF assms(1,2) uu]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ ?r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y", "have u_t: \"T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v)  = T\\<^sub>p_on_rand' BIT (type0 init x y) v\"\n      and u_c: \"config'_rand BIT (type0 init x y) u = type0 init x y\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ ?r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) v &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "from BIT_b[OF assms(1,2) vv]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "have b_t: \"T\\<^sub>p_on_rand' BIT (type0 init x y) v  = 0.75 * length v - 0.5\"\n      and  b_c: \"config'_rand BIT (type0 init x y) v = (type0 init y x)\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init y x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "have BIT: \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs  = 0.75 * length v - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "by(simp add: qsuv u_t b_t)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "(* OPT *)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (question (Atom x))", "have uuu: \"u=[] \\<or> u=[x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. u = [] \\<or> u = [x]", "by auto"], ["proof (state)\nthis:\n  u = [] \\<or> u = [x]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "have OPT: \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "apply(rule OPT2_B)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. qs = ?u @ v\n 3. ?u = [] \\<or> ?u = [x]\n 4. v \\<in> lang\n             (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                   Atom y, Atom y])", "by(fact)+"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "from lenv"], ["proof (chain)\npicking this:\n  length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []", "have \"v \\<noteq> []\"  \"last v = y\""], ["proof (prove)\nusing this:\n  length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []\n\ngoal (1 subgoal):\n 1. v \\<noteq> [] &&& last v = y", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> []\n  last v = y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> []\n  last v = y", "have 1:  \"last qs = y\""], ["proof (prove)\nusing this:\n  v \\<noteq> []\n  last v = y\n\ngoal (1 subgoal):\n 1. last qs = y", "using last_appendR qsuv"], ["proof (prove)\nusing this:\n  v \\<noteq> []\n  last v = y\n  ?ys \\<noteq> [] \\<Longrightarrow> last (?xs @ ?ys) = last ?ys\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. last qs = y", "by simp"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "then"], ["proof (chain)\npicking this:\n  last qs = y", "have 2: \"other (last qs) x y = x\""], ["proof (prove)\nusing this:\n  last qs = y\n\ngoal (1 subgoal):\n 1. other (last qs) x y = x", "unfolding other_def"], ["proof (prove)\nusing this:\n  last qs = y\n\ngoal (1 subgoal):\n 1. (if last qs = x then y else x) = x", "by simp"], ["proof (state)\nthis:\n  other (last qs) x y = x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "show \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "using BIT OPT lenv"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  length v mod 2 = 0 \\<and> last v = y \\<and> v \\<noteq> []\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "(* config *)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "show \"config'_rand BIT (type0 init x y) qs = type0 init y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x", "by (auto simp add: config'_rand_append qsuv u_c b_c)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_b'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(5)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])", "have lqs: \"last qs = y\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. last qs = y", "by fastforce"], ["proof (state)\nthis:\n  last qs = y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs \\<le> 1.75 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [x0, y0] qs (OPT2 qs [x0, y0]))\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(rule bit_b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(rule bit_b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] y x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] y x", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] y0 x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule bit_b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom y0, Atom y0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] x0 y0", "apply(rule bit_b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom y, Atom y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom x0, Atom x0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x", "have \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] y x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "using assms(1) kas lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  last qs = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] y x \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] y x) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "then"], ["proof (chain)\npicking this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "show ?thesis"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "using BIT s"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_b''': \" a \\<noteq> b \\<Longrightarrow>\n         {a, b} = {x, y} \\<Longrightarrow>\n         BIT_inv s a [x, y] \\<Longrightarrow>\n         set qs \\<subseteq> {a, b} \\<Longrightarrow>\n         qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom y, Atom y]) \\<Longrightarrow>\n         BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and> T\\<^sub>p_on_rand' BIT s qs = 1.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n     set qs \\<subseteq> {a, b};\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y])\\<rbrakk>\n    \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                       (last qs) [x, y] \\<and>\n                      T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "using bit_a[of a b x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv ?s a [x, y];\n   set ?qs \\<subseteq> {a, b};\n   ?qs \\<in> lang (seq [question (Atom a), Atom b, Atom b])\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT ?s ?qs\n                    \\<le> 175 / 10\\<^sup>2 *\n                          real\n                           (T\\<^sub>p [a, b] ?qs (OPT2 ?qs [a, b])) \\<and>\n                    BIT_inv (Partial_Cost_Model.config'_rand BIT ?s ?qs)\n                     (last ?qs) [x, y] \\<and>\n                    T\\<^sub>p_on_rand' BIT ?s ?qs = 15 / 10\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; {a, b} = {x, y}; BIT_inv s a [x, y];\n     set qs \\<subseteq> {a, b};\n     qs \\<in> lang\n               (seq [question (Atom x), Atom y, Atom x,\n                     Star (Times (Atom y) (Atom x)), Atom y,\n                     Atom y])\\<rbrakk>\n    \\<Longrightarrow> BIT_inv (Partial_Cost_Model.config'_rand BIT s qs)\n                       (last qs) [x, y] \\<and>\n                      T\\<^sub>p_on_rand' BIT s qs = 15 / 10", "oops"], ["", "subsubsection \"Phase Form C\""], ["", "lemma BIT_c: assumes \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * length v - 0.5\"\n      and \"config'_rand BIT  (type0 init x y) v = (type0 init x y)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have A: \"x\\<noteq>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom x])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                      and \"b \\<in> lang (seq[Atom x])\"\n                      and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom x]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "then"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b", "have bb: \"b=[x]\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b\n\ngoal (1 subgoal):\n 1. b = [x]", "by auto"], ["proof (state)\nthis:\n  b = [x]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from aa"], ["proof (chain)\npicking this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])", "have lena: \"length a > 0\""], ["proof (prove)\nusing this:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. 0 < length a", "by auto"], ["proof (state)\nthis:\n  0 < length a\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from vab bb"], ["proof (chain)\npicking this:\n  v = a @ b\n  b = [x]", "have lenv: \"length v = length a + 1\""], ["proof (prove)\nusing this:\n  v = a @ b\n  b = [x]\n\ngoal (1 subgoal):\n 1. length v = length a + 1", "by auto"], ["proof (state)\nthis:\n  length v = length a + 1\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from bit_yxyx assms(1,2) aa"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<noteq> ?y; ?init \\<in> {[?x, ?y], [?y, ?x]};\n   ?qs\n   \\<in> lang\n          (seq [Times (Atom ?y) (Atom ?x),\n                Star (Times (Atom ?y) (Atom ?x))])\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 ?init ?x ?y) (?qs @ ?r) =\n                    75 / 10\\<^sup>2 * real (length ?qs) +\n                    T\\<^sub>p_on_rand' BIT (type1 ?init ?x ?y) ?r \\<and>\n                    Partial_Cost_Model.config'_rand BIT (type0 ?init ?x ?y)\n                     ?qs =\n                    type1 ?init ?x ?y\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])", "have stars: \"T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b)  = 0.75 * length a + T\\<^sub>p_on_rand' BIT (type1 init x y) b\"\n                             and s2: \"config'_rand BIT (type0 init x y) a = type1 init x y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; ?init \\<in> {[?x, ?y], [?y, ?x]};\n   ?qs\n   \\<in> lang\n          (seq [Times (Atom ?y) (Atom ?x),\n                Star (Times (Atom ?y) (Atom ?x))])\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 ?init ?x ?y) (?qs @ ?r) =\n                    75 / 10\\<^sup>2 * real (length ?qs) +\n                    T\\<^sub>p_on_rand' BIT (type1 ?init ?x ?y) ?r \\<and>\n                    Partial_Cost_Model.config'_rand BIT (type0 ?init ?x ?y)\n                     ?qs =\n                    type1 ?init ?x ?y\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n    75 / 10\\<^sup>2 * real (length a) +\n    T\\<^sub>p_on_rand' BIT (type1 init x y) b &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y", "by fast+"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) a = type1 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have t: \"T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1 / 4", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1 / 4", "by (auto simp add: bb costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1 / 4\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have s: \"config'_rand BIT  (type1 init x y) b = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) b = type0 init x y", "using assms(1,2)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type1 init x y) b = type0 init x y", "by (auto simp add: bb oneBIT_step1x )"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type1 init x y) b = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have config: \"config'_rand BIT  (type0 init x y) (a @ b) = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n    type0 init x y", "by (simp only: config'_rand_append s2 vab s)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have calc: \"3 * Suc (Suc (length a)) / 4 - 1 / 2 = 3 * (2+length a) / 4 - 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (3 * Suc (Suc (length a))) / 4 - 1 / 2 =\n    real (3 * (2 + length a)) / 4 - 1 / 2", "by simp"], ["proof (state)\nthis:\n  real (3 * Suc (Suc (length a))) / 4 - 1 / 2 =\n  real (3 * (2 + length a)) / 4 - 1 / 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from t stars"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1 / 4\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b", "have \"T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) = 0.75 * length a + 1/4\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b = 1 / 4\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) +\n  T\\<^sub>p_on_rand' BIT (type1 init x y) b\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n    75 / 10\\<^sup>2 * real (length a) + 1 / 4", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1 / 4\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1 / 4", "show \"T\\<^sub>p_on_rand' BIT  (type0 init x y) v = 0.75 * length v - 0.5\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1 / 4\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "unfolding lenv"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (a @ b) =\n  75 / 10\\<^sup>2 * real (length a) + 1 / 4\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length a + 1) - 5 / 10", "by(simp add: vab ring_distribs del: add_2_eq_Suc')"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from config vab"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init x y\n  v = a @ b", "show ?C"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) (a @ b) =\n  type0 init x y\n  v = a @ b\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_c''1: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * length qs - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(5)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by fastforce"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs = 0.75 * length qs - 0.5\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(rule BIT_c)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "apply(rule BIT_c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] x y", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule BIT_c)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule BIT_c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "have config: \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "using assms(1) kas lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  last qs = x\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "using BIT config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs) - 5 / 10", "by simp"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 75 / 10\\<^sup>2 * real (length qs) - 5 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_c: assumes \"x \\<noteq> y\"\n      \"init \\<in> {[x,y],[y,x]}\"\n   \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows  \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\"\n  and \"config'_rand BIT (type0 init x y) qs = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "obtain u v where uu: \"u \\<in> lang (Plus (Atom x) One)\"\n        and vv: \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n        and qsuv: \"qs = u @ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> lang (question (Atom x));\n         v \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x]);\n         qs = u @ v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  u \\<in> lang (question (Atom x))\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n  qs = u @ v\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have lenv: \"length v mod 2 = 1 \\<and> length v \\<ge> 3 \\<and> last v = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have \"v \\<in> ({[y]} @@ {[x]}) @@ star({[y]} @@ {[x]}) @@ {[x]}\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "by auto"], ["proof (state)\nthis:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "then"], ["proof (chain)\npicking this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}", "obtain p q r where pqr: \"v=p@q@r\" and \"p\\<in>({[y]} @@ {[x]})\"\n              and q: \"q \\<in> star ({[y]} @@ {[x]})\" and \"r \\<in> {[x]}\""], ["proof (prove)\nusing this:\n  v \\<in> ({[y]} @@ {[x]}) @@ star ({[y]} @@ {[x]}) @@ {[x]}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r.\n        \\<lbrakk>v = p @ q @ r; p \\<in> {[y]} @@ {[x]};\n         q \\<in> star ({[y]} @@ {[x]}); r \\<in> {[x]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis concE)"], ["proof (state)\nthis:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "then"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}", "have rr: \"p = [y,x]\"  \"r=[x]\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p \\<in> {[y]} @@ {[x]}\n  q \\<in> star ({[y]} @@ {[x]})\n  r \\<in> {[x]}\n\ngoal (1 subgoal):\n 1. p = [y, x] &&& r = [x]", "by auto"], ["proof (state)\nthis:\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "with pqr"], ["proof (chain)\npicking this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]", "have a: \"length v = 3+length q\""], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. length v = 3 + length q", "by auto"], ["proof (state)\nthis:\n  length v = 3 + length q\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "have \"last v = last r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last v = last r", "using pqr rr"], ["proof (prove)\nusing this:\n  v = p @ q @ r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. last v = last r", "by auto"], ["proof (state)\nthis:\n  last v = last r\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "then"], ["proof (chain)\npicking this:\n  last v = last r", "have c: \"last v = x\""], ["proof (prove)\nusing this:\n  last v = last r\n\ngoal (1 subgoal):\n 1. last v = x", "using rr"], ["proof (prove)\nusing this:\n  last v = last r\n  p = [y, x]\n  r = [x]\n\ngoal (1 subgoal):\n 1. last v = x", "by auto"], ["proof (state)\nthis:\n  last v = x\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "from q"], ["proof (chain)\npicking this:\n  q \\<in> star ({[y]} @@ {[x]})", "have b: \"length q mod 2 = 0\""], ["proof (prove)\nusing this:\n  q \\<in> star ({[y]} @@ {[x]})\n\ngoal (1 subgoal):\n 1. length q mod 2 = 0", "apply(induct q rule: star_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length [] mod 2 = 0\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> {[y]} @@ {[x]}; v \\<in> star ({[y]} @@ {[x]});\n        length v mod 2 = 0\\<rbrakk>\n       \\<Longrightarrow> length (u @ v) mod 2 = 0", "by (auto)"], ["proof (state)\nthis:\n  length q mod 2 = 0\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "from a b c"], ["proof (chain)\npicking this:\n  length v = 3 + length q\n  length q mod 2 = 0\n  last v = x", "show \"length v mod 2 = 1 \\<and> length v \\<ge> 3 \\<and> last v = x\""], ["proof (prove)\nusing this:\n  length v = 3 + length q\n  length q mod 2 = 0\n  last v = x\n\ngoal (1 subgoal):\n 1. length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "by auto"], ["proof (state)\nthis:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have \"v \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\n                          @@ lang (seq[Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Times (Atom y) (Atom x),\n                   Star (Times (Atom y) (Atom x))]) @@\n            lang (seq [Atom x])", "by (auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "then"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])", "obtain a b where aa: \"a \\<in> lang (seq[Times (Atom y) (Atom x), Star(Times (Atom y) (Atom x))])\"\n                      and \"b \\<in> lang (seq[Atom x])\"\n                      and vab: \"v = a @ b\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x))]) @@\n          lang (seq [Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> lang\n                          (seq [Times (Atom y) (Atom x),\n                                Star (Times (Atom y) (Atom x))]);\n         b \\<in> lang (seq [Atom x]); v = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule concE)"], ["proof (state)\nthis:\n  a \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x))])\n  b \\<in> lang (seq [Atom x])\n  v = a @ b\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from BIT_x[OF assms(1,2) uu]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ ?r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y", "have u_t: \"T\\<^sub>p_on_rand' BIT (type0 init x y)  (u @ v)  = T\\<^sub>p_on_rand' BIT (type0 init x y) v\"\n      and u_c: \"config'_rand BIT (type0 init x y) u = type0 init x y\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ ?r) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) ?r \\<and>\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v) =\n    T\\<^sub>p_on_rand' BIT (type0 init x y) v &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) (u @ v) =\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) u = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from BIT_c[OF assms(1,2) vv]"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have b_t: \"T\\<^sub>p_on_rand' BIT (type0 init x y) v  = 0.75 * length v - 0.5\"\n      and  b_c: \"config'_rand BIT (type0 init x y) v = (type0 init x y)\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have BIT: \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs  = 0.75 * length v - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "by(simp add: qsuv u_t b_t)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "(* OPT *)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from uu"], ["proof (chain)\npicking this:\n  u \\<in> lang (question (Atom x))", "have uuu: \"u=[] \\<or> u=[x]\""], ["proof (prove)\nusing this:\n  u \\<in> lang (question (Atom x))\n\ngoal (1 subgoal):\n 1. u = [] \\<or> u = [x]", "by auto"], ["proof (state)\nthis:\n  u = [] \\<or> u = [x]\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from vv"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])", "have vvv: \"v \\<in> lang (seq\n          [Atom y, Atom x,\n           Star (Times (Atom y) (Atom x)),\n           Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (1 subgoal):\n 1. v \\<in> lang\n             (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "by(auto simp: conc_def)"], ["proof (state)\nthis:\n  v \\<in> lang\n           (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have OPT: \"T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) = (length v) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2", "apply(rule OPT2_C)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. qs = ?u @ v\n 3. ?u = [] \\<or> ?u = [x]\n 4. v \\<in> lang\n             (seq [Atom y, Atom x, Star (Times (Atom y) (Atom x)), Atom x])", "by(fact)+"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "from lenv"], ["proof (chain)\npicking this:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x", "have \"v \\<noteq> []\"  \"last v = x\""], ["proof (prove)\nusing this:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n\ngoal (1 subgoal):\n 1. v \\<noteq> [] &&& last v = x", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> []\n  last v = x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> []\n  last v = x", "have 1:  \"last qs = x\""], ["proof (prove)\nusing this:\n  v \\<noteq> []\n  last v = x\n\ngoal (1 subgoal):\n 1. last qs = x", "using last_appendR qsuv"], ["proof (prove)\nusing this:\n  v \\<noteq> []\n  last v = x\n  ?ys \\<noteq> [] \\<Longrightarrow> last (?xs @ ?ys) = last ?ys\n  qs = u @ v\n\ngoal (1 subgoal):\n 1. last qs = x", "by simp"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "then"], ["proof (chain)\npicking this:\n  last qs = x", "have 2: \"other (last qs) x y = y\""], ["proof (prove)\nusing this:\n  last qs = x\n\ngoal (1 subgoal):\n 1. other (last qs) x y = y", "unfolding other_def"], ["proof (prove)\nusing this:\n  last qs = x\n\ngoal (1 subgoal):\n 1. (if last qs = x then y else x) = y", "by simp"], ["proof (state)\nthis:\n  other (last qs) x y = y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have vgt3: \"length v \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> length v", "using lenv"], ["proof (prove)\nusing this:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n\ngoal (1 subgoal):\n 1. 3 \\<le> length v", "by simp"], ["proof (state)\nthis:\n  3 \\<le> length v\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs  = 0.75 * length v - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "using BIT"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n    75 / 10\\<^sup>2 * real (length v) - 5 / 10", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have \"\\<dots> \\<le> 1.75 * (length v - 1)/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "have \"10 + 6 * length v \\<le> 7 * Suc (length v) \n        \\<longleftrightarrow> 10 + 6 * length v \\<le> 7 * length v + 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (10 + 6 * length v \\<le> 7 * Suc (length v)) =\n    (10 + 6 * length v \\<le> 7 * length v + 7)", "by auto"], ["proof (state)\nthis:\n  (10 + 6 * length v \\<le> 7 * Suc (length v)) =\n  (10 + 6 * length v \\<le> 7 * length v + 7)\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "also"], ["proof (state)\nthis:\n  (10 + 6 * length v \\<le> 7 * Suc (length v)) =\n  (10 + 6 * length v \\<le> 7 * length v + 7)\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "have \"\\<dots> \\<longleftrightarrow> 3 \\<le> length v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (10 + 6 * length v \\<le> 7 * length v + 7) = (3 \\<le> length v)", "by auto"], ["proof (state)\nthis:\n  (10 + 6 * length v \\<le> 7 * length v + 7) = (3 \\<le> length v)\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "also"], ["proof (state)\nthis:\n  (10 + 6 * length v \\<le> 7 * length v + 7) = (3 \\<le> length v)\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "have \"\\<dots> \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (3 \\<le> length v) = True", "using vgt3"], ["proof (prove)\nusing this:\n  3 \\<le> length v\n\ngoal (1 subgoal):\n 1. (3 \\<le> length v) = True", "by auto"], ["proof (state)\nthis:\n  (3 \\<le> length v) = True\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "finally"], ["proof (chain)\npicking this:\n  (10 + 6 * length v \\<le> 7 * Suc (length v)) = True", "have A: \" 6 * length v - 4 \\<le> 7 * (length v - 1)\""], ["proof (prove)\nusing this:\n  (10 + 6 * length v \\<le> 7 * Suc (length v)) = True\n\ngoal (1 subgoal):\n 1. 6 * length v - 4 \\<le> 7 * (length v - 1)", "by simp"], ["proof (state)\nthis:\n  6 * length v - 4 \\<le> 7 * (length v - 1)\n\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 75 / 10\\<^sup>2 * real (length v) - 5 / 10\n    \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 6 * real (length v) - 4 \\<le> 7 * real (length v - Suc 0)", "using A"], ["proof (prove)\nusing this:\n  6 * length v - 4 \\<le> 7 * (length v - 1)\n\ngoal (1 subgoal):\n 1. 6 * real (length v) - 4 \\<le> 7 * real (length v - Suc 0)", "by linarith"], ["proof (state)\nthis:\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "also"], ["proof (state)\nthis:\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  \\<le> 175 / 10\\<^sup>2 * real (length v - 1) / 2\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have \"\\<dots> = 1.75 * (length v div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "from div_mult_mod_eq"], ["proof (chain)\npicking this:\n  ?a div ?b * ?b + ?a mod ?b = ?a", "have \"length v = length v div 2 * 2 + length v mod 2\""], ["proof (prove)\nusing this:\n  ?a div ?b * ?b + ?a mod ?b = ?a\n\ngoal (1 subgoal):\n 1. length v = length v div 2 * 2 + length v mod 2", "by auto"], ["proof (state)\nthis:\n  length v = length v div 2 * 2 + length v mod 2\n\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "with lenv"], ["proof (chain)\npicking this:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n  length v = length v div 2 * 2 + length v mod 2", "have \"length v = length v div 2 * 2 + 1\""], ["proof (prove)\nusing this:\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n  length v = length v div 2 * 2 + length v mod 2\n\ngoal (1 subgoal):\n 1. length v = length v div 2 * 2 + 1", "by auto"], ["proof (state)\nthis:\n  length v = length v div 2 * 2 + 1\n\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "then"], ["proof (chain)\npicking this:\n  length v = length v div 2 * 2 + 1", "have \"(length v - 1) / 2 = length v div 2\""], ["proof (prove)\nusing this:\n  length v = length v div 2 * 2 + 1\n\ngoal (1 subgoal):\n 1. real (length v - 1) / 2 = real (length v div 2)", "by simp"], ["proof (state)\nthis:\n  real (length v - 1) / 2 = real (length v div 2)\n\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "then"], ["proof (chain)\npicking this:\n  real (length v - 1) / 2 = real (length v div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (length v - 1) / 2 = real (length v div 2)\n\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n    175 / 10\\<^sup>2 * real (length v div 2)", "by simp"], ["proof (state)\nthis:\n  175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n  175 / 10\\<^sup>2 * real (length v div 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n  175 / 10\\<^sup>2 * real (length v div 2)\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "also"], ["proof (state)\nthis:\n  175 / 10\\<^sup>2 * real (length v - 1) / 2 =\n  175 / 10\\<^sup>2 * real (length v div 2)\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "have \"\\<dots> = 1.75 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v div 2) =\n    175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "using OPT"], ["proof (prove)\nusing this:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n\ngoal (1 subgoal):\n 1. 175 / 10\\<^sup>2 * real (length v div 2) =\n    175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "by auto"], ["proof (state)\nthis:\n  175 / 10\\<^sup>2 * real (length v div 2) =\n  175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "show \"T\\<^sub>p_on_rand' BIT (type0 init x y) qs \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y])\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "using BIT OPT lenv   1 2"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs =\n  75 / 10\\<^sup>2 * real (length v) - 5 / 10\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = length v div 2\n  length v mod 2 = 1 \\<and> 3 \\<le> length v \\<and> last v = x\n  last qs = x\n  other (last qs) x y = y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "(* config *)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "show \"config'_rand BIT  (type0 init x y) qs  = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y", "by (auto simp add: config'_rand_append qsuv u_c b_c)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) qs = type0 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_c'': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Plus (Atom x) One, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows  \n    \"T\\<^sub>p_on_rand' BIT s qs  \\<le> 1.75 * T\\<^sub>p [x,y] qs (OPT2 qs [x,y]) \n      \\<and>  BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by fastforce"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs \\<le> 1.75 * T\\<^sub>p [x, y] qs (OPT2 qs [x, y])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [x0, y0] qs (OPT2 qs [x0, y0]))\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(rule bit_c )"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs\n                      \\<le> 175 / 10\\<^sup>2 *\n                            real (T\\<^sub>p [y0, x0] qs (OPT2 qs [y0, x0]))", "apply(rule bit_c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] x y", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule bit_c)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom x0), Atom y0, Atom x0,\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule bit_c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [question (Atom x), Atom y, Atom x,\n                  Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [question (Atom y0), Atom x0, Atom y0,\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "have \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "using assms(1) kas f lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  x0 \\<noteq> y0\n  last qs = x\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "then"], ["proof (chain)\npicking this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "show ?thesis"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "using BIT s"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y]))\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BIT_c2: assumes A: \"x \\<noteq> y\"\n       \"init \\<in> {[x,y],[y,x]}\"\n    \"v \\<in> lang (seq [Atom x, Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\"\n    shows \"T\\<^sub>p_on_rand' BIT (type0 init x y) v = 0.75 * (length v - 1) - 0.5\" (is ?T)\n     and \"config'_rand BIT  (type0 init x y) v = (type0 init x y)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10 &&&\n    Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "from assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom x])", "obtain w where  vw: \"v = [x]@w\" and\n          w: \"w \\<in> lang (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)), Atom x])\""], ["proof (prove)\nusing this:\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>v = [x] @ w;\n         w \\<in> lang\n                  (seq [Times (Atom y) (Atom x),\n                        Star (Times (Atom y) (Atom x)), Atom x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  v = [x] @ w\n  w \\<in> lang\n           (seq [Times (Atom y) (Atom x), Star (Times (Atom y) (Atom x)),\n                 Atom x])\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have c1: \"config'_rand BIT (type0 init x y) [x] = type0 init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] =\n    type0 init x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] =\n    type0 init x y", "by(auto simp add: oneBIT_step)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) [x] = type0 init x y\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "have t1: \"T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  init \\<in> {[x, y], [y, x]}\n  v \\<in> lang\n           (seq [Atom x, Times (Atom y) (Atom x),\n                 Star (Times (Atom y) (Atom x)), Atom x])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0", "by(auto simp add: costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) [x] = 0\n\ngoal (2 subgoals):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n 2. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "show \"T\\<^sub>p_on_rand' BIT (type0 init x y) v\n      = 0.75 * (length v - 1) - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n    75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10", "unfolding vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 init x y) ([x] @ w) =\n    75 / 10\\<^sup>2 * real (length ([x] @ w) - 1) - 5 / 10", "apply(simp only: T_on_rand'_append c1 BIT_c[OF assms(1,2) w] t1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + (75 / 10\\<^sup>2 * real (length w) - 5 / 10) =\n    75 / 10\\<^sup>2 * real (length ([x] @ w) - 1) - 5 / 10", "by (simp)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 init x y) v =\n  75 / 10\\<^sup>2 * real (length v - 1) - 5 / 10\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "show \"config'_rand BIT (type0 init x y) v = (type0 init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y", "unfolding vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 init x y) ([x] @ w) =\n    type0 init x y", "by(simp only: config'_rand_append c1 BIT_c[OF assms(1,2) w])"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT (type0 init x y) v = type0 init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_c''2: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \n    \"qs \\<in> lang (seq[Atom x, Atom y, Atom x, Star(Times (Atom y) (Atom x)), Atom x])\"\n shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n          T\\<^sub>p_on_rand' BIT s qs  = 0.75 * (length qs - 1) - 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(5)"], ["proof (chain)\npicking this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])", "have lqs: \"last qs = x\""], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. last qs = x", "by fastforce"], ["proof (state)\nthis:\n  last qs = x\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have BIT: \"T\\<^sub>p_on_rand' BIT s qs = 0.75 * (length qs-1) - 0.5\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x0 y0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(rule BIT_c2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p_on_rand' BIT (type0 [x0, y0] y0 x0) qs =\n                      75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "apply(rule BIT_c2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "from assms(1,2) kas"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "have \"config'_rand BIT s qs = type0 [x0, y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "unfolding s"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT (type0 [x0, y0] x y) qs =\n    type0 [x0, y0] x y", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] x0 y0) qs =\n                      type0 [x0, y0] x0 y0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule BIT_c2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> x0 \\<noteq> y0\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 3. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 4. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[x0, y0], [y0, x0]}\n 2. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x0 \\<noteq> y0; x = x0; y = y0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom x0, Times (Atom y0) (Atom x0),\nStar (Times (Atom y0) (Atom x0)), Atom x0])\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> Partial_Cost_Model.config'_rand BIT\n                       (type0 [x0, y0] y0 x0) qs =\n                      type0 [x0, y0] y0 x0", "apply(rule BIT_c2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> y0 \\<noteq> x0\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 3. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> [x0, y0] \\<in> {[y0, x0], [x0, y0]}\n 2. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "using assms(5)"], ["proof (prove)\nusing this:\n  qs \\<in> lang\n            (seq [Atom x, Atom y, Atom x, Star (Times (Atom y) (Atom x)),\n                  Atom x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<noteq> x0; {y0, x0} = {x0, y0}; x = y0; y = x0\\<rbrakk>\n    \\<Longrightarrow> qs \\<in> lang\n                                (seq [Atom y0, Times (Atom x0) (Atom y0),\nStar (Times (Atom x0) (Atom y0)), Atom y0])", "apply(simp add: conc_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "have config: \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "using assms(1) kas lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  last qs = x\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "using BIT config"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs =\n    75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10", "by simp"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs =\n  75 / 10\\<^sup>2 * real (length qs - 1) - 5 / 10\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Phase Form D\""], ["", "lemma bit_d: assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Atom x, Atom x])\"\n  shows \"T\\<^sub>p_on_rand' BIT s qs \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n     T\\<^sub>p_on_rand' BIT s qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])", "have qs: \"qs = [x,x]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. qs = [x, x]", "by auto"], ["proof (state)\nthis:\n  qs = [x, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "then"], ["proof (chain)\npicking this:\n  qs = [x, x]", "have OPT: \"T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 0\""], ["proof (prove)\nusing this:\n  qs = [x, x]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 0", "by (simp add: t\\<^sub>p_def step_def)"], ["proof (state)\nthis:\n  T\\<^sub>p [x, y] qs (OPT2 qs [x, y]) = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])", "have f: \"x0\\<noteq>y0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n  BIT_inv s x [x0, y0]\n  set qs \\<subseteq> {x, y}\n  qs \\<in> lang (seq [Atom x, Atom x])\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> y0", "by auto"], ["proof (state)\nthis:\n  x0 \\<noteq> y0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "from assms(1,3) assms(2)[symmetric]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}", "have s: \"s = type0 [x0,y0] x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  BIT_inv s x [x0, y0]\n  {x0, y0} = {x, y}\n\ngoal (1 subgoal):\n 1. s = type0 [x0, y0] x y", "apply(simp add: BIT_inv2[OF f] other_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; s = type0 [x0, y0] x (if x = x0 then y0 else x0);\n     {x0, y0} = {x, y}\\<rbrakk>\n    \\<Longrightarrow> (x = x0 \\<longrightarrow>\n                       type0 [x0, y0] x0 y0 = type0 [x0, y0] x0 y) \\<and>\n                      (x \\<noteq> x0 \\<longrightarrow>\n                       type0 [x0, y0] x x0 = type0 [x0, y0] x y)", "by fast"], ["proof (state)\nthis:\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "from assms(1,2)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}", "have kas: \"[x,y] = [x0,y0] \\<or> [x,y] = [y0,x0]\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]", "by auto"], ["proof (state)\nthis:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "have BIT: \"T\\<^sub>p_on_rand' BIT (type0 [x0,y0] x y) qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs = 0", "using kas assms(1,2)"], ["proof (prove)\nusing this:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs = 0", "by (auto simp add: qs oneBIT_step costBIT)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs = 0\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "have lqs: \"last qs = x\" \"last qs \\<in> {x0,y0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last qs = x &&& last qs \\<in> {x0, y0}", "using assms(2,4) qs"], ["proof (prove)\nusing this:\n  {x, y} = {x0, y0}\n  set qs \\<subseteq> {x, y}\n  qs = [x, x]\n\ngoal (1 subgoal):\n 1. last qs = x &&& last qs \\<in> {x0, y0}", "by auto"], ["proof (state)\nthis:\n  last qs = x\n  last qs \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "have inv: \"config'_rand BIT s qs = type0 [x0, y0] x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "using kas assms(1,2)"], ["proof (prove)\nusing this:\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  x \\<noteq> y\n  {x, y} = {x0, y0}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "by (auto simp add: qs s  oneBIT_step0x)"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "then"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y", "have \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0]\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand BIT s qs = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "using assms(1) kas f lqs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  [x, y] = [x0, y0] \\<or> [x, y] = [y0, x0]\n  x0 \\<noteq> y0\n  last qs = x\n  last qs \\<in> {x0, y0}\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand BIT s qs =\n    type0 [x0, y0] x y \\<Longrightarrow>\n    BIT_inv (type0 [x0, y0] x y) (last qs) [x0, y0]", "by(auto simp add: BIT_inv2 other_def)"], ["proof (state)\nthis:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "then"], ["proof (chain)\npicking this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]", "show ?thesis"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "using BIT s"], ["proof (prove)\nusing this:\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x0, y0]\n  T\\<^sub>p_on_rand' BIT (type0 [x0, y0] x y) qs = 0\n  s = type0 [x0, y0] x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "by(auto)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_d': assumes \n    \"x \\<noteq> y\" \"{x, y} = {x0, y0}\" \"BIT_inv s x [x0, y0]\"\n    \"set qs \\<subseteq> {x, y}\" \"qs \\<in> lang (seq [Atom x, Atom x])\"\n  shows \"BIT_inv (config'_rand BIT s qs) (last qs) [x0, y0] \\<and>\n     T\\<^sub>p_on_rand' BIT s qs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "using bit_d[OF assms]"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [x, y] qs (OPT2 qs [x, y])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n   [x0, y0] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 0\n\ngoal (1 subgoal):\n 1. BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs)\n     [x0, y0] \\<and>\n    T\\<^sub>p_on_rand' BIT s qs = 0", "by blast"], ["", "subsection \"Phase Partitioning\""], ["", "lemma BIT_inv_initial: assumes \"(x::nat) \\<noteq> y\"\n    shows \"BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]", "apply(simp add: BIT_inv2 BIT_init_def type0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    map_pmf (Pair [x, y])\n     (map_pmf (\\<lambda>l. (l, [x, y]))\n       (return_pmf [] \\<bind>\n        (\\<lambda>xs.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>x. return_pmf (x # xs))) \\<bind>\n        (\\<lambda>xs.\n            bernoulli_pmf (1 / 2) \\<bind>\n            (\\<lambda>x. return_pmf (x # xs))))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>a.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>b. return_pmf ([x, other x x y], [a, b], [x, y])))", "apply(simp add: map_pmf_def other_def bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xb. return_pmf ([x, y], [xb, xa], [x, y]))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>a.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>b. return_pmf ([x, y], [a, b], [x, y])))", "using bind_commute_pmf"], ["proof (prove)\nusing this:\n  ?A \\<bind> (\\<lambda>x. ?B \\<bind> ?C x) =\n  ?B \\<bind> (\\<lambda>y. ?A \\<bind> (\\<lambda>x. ?C x y))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>xa.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>xb. return_pmf ([x, y], [xb, xa], [x, y]))) =\n    bernoulli_pmf (1 / 2) \\<bind>\n    (\\<lambda>a.\n        bernoulli_pmf (1 / 2) \\<bind>\n        (\\<lambda>b. return_pmf ([x, y], [a, b], [x, y])))", "by fast"], ["", "lemma D'': assumes \"qs \\<in> Lxx a b\"\n    \"a \\<noteq> b\" \"{a, b} = {x, y}\" \"BIT_inv s a [x, y]\"\n    \"set qs \\<subseteq> {a, b}\"\n shows \"T\\<^sub>p_on_rand' BIT s qs \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(rule LxxE[OF assms(1)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "using bit_d[OF assms(2-5)]"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 0\n\ngoal (4 subgoals):\n 1. qs \\<in> lang (seq [Atom a, Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 4. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(rule bit_b''[OF assms(2-5)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b,\n                    Atom b]) \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom b, Atom b])\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 3. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(rule bit_c''[OF assms(2-5)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)),\n                    Atom a]) \\<Longrightarrow>\n    qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom a,\n                    Star (Times (Atom b) (Atom a)), Atom a])\n 2. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "using bit_a[OF assms(2-5)]"], ["proof (prove)\nusing this:\n  qs \\<in> lang (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y] \\<and>\n  T\\<^sub>p_on_rand' BIT s qs = 15 / 10\n\ngoal (1 subgoal):\n 1. qs \\<in> lang\n              (seq [question (Atom a), Atom b, Atom b]) \\<Longrightarrow>\n    T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem BIT_175comp_on_2:\n    assumes \"(x::nat) \\<noteq> y\" \"set \\<sigma> \\<subseteq> {x,y}\"     \n     shows \"T\\<^sub>p_on_rand BIT [x,y] \\<sigma>  \\<le> 1.75 * real (T\\<^sub>p_opt [x,y] \\<sigma>) + 1.75\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT\n     (fst BIT [x, y] \\<bind> (\\<lambda>is. return_pmf ([x, y], is)))\n     \\<sigma>\n    \\<le> 175 / 10\\<^sup>2 * real (T\\<^sub>p_opt [x, y] \\<sigma>) +\n          175 / 10\\<^sup>2", "proof (rule Phase_partitioning_general[where P=BIT_inv], goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}\n 4. BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\n 5. \\<And>a b \\<sigma> s.\n       \\<lbrakk>\\<sigma> \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        BIT_inv s a [x, y]; set \\<sigma> \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT s \\<sigma>\n                         \\<le> 175 / 10\\<^sup>2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>\n                                  (OPT2 \\<sigma> [a, b])) \\<and>\n                         BIT_inv\n                          (Partial_Cost_Model.config'_rand BIT s \\<sigma>)\n                          (last \\<sigma>) [x, y]", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}\n 4. BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\n 5. \\<And>a b \\<sigma> s.\n       \\<lbrakk>\\<sigma> \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        BIT_inv s a [x, y]; set \\<sigma> \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT s \\<sigma>\n                         \\<le> 175 / 10\\<^sup>2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>\n                                  (OPT2 \\<sigma> [a, b])) \\<and>\n                         BIT_inv\n                          (Partial_Cost_Model.config'_rand BIT s \\<sigma>)\n                          (last \\<sigma>) [x, y]", "show \"BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]", "by (rule BIT_inv_initial[OF assms(1)])"], ["proof (state)\nthis:\n  BIT_inv (map_pmf (Pair [x, y]) (fst BIT [x, y])) x [x, y]\n\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma> s.\n       \\<lbrakk>\\<sigma> \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        BIT_inv s a [x, y]; set \\<sigma> \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT s \\<sigma>\n                         \\<le> 175 / 10\\<^sup>2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>\n                                  (OPT2 \\<sigma> [a, b])) \\<and>\n                         BIT_inv\n                          (Partial_Cost_Model.config'_rand BIT s \\<sigma>)\n                          (last \\<sigma>) [x, y]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma> s.\n       \\<lbrakk>\\<sigma> \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        BIT_inv s a [x, y]; set \\<sigma> \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT s \\<sigma>\n                         \\<le> 175 / 10\\<^sup>2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>\n                                  (OPT2 \\<sigma> [a, b])) \\<and>\n                         BIT_inv\n                          (Partial_Cost_Model.config'_rand BIT s \\<sigma>)\n                          (last \\<sigma>) [x, y]", "case (5 a b qs s)"], ["proof (state)\nthis:\n  qs \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  BIT_inv s a [x, y]\n  set qs \\<subseteq> {a, b}\n\ngoal (4 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}\n 4. \\<And>a b \\<sigma> s.\n       \\<lbrakk>\\<sigma> \\<in> Lxx a b; a \\<noteq> b; {a, b} = {x, y};\n        BIT_inv s a [x, y]; set \\<sigma> \\<subseteq> {a, b}\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' BIT s \\<sigma>\n                         \\<le> 175 / 10\\<^sup>2 *\n                               real\n                                (T\\<^sub>p [a, b] \\<sigma>\n                                  (OPT2 \\<sigma> [a, b])) \\<and>\n                         BIT_inv\n                          (Partial_Cost_Model.config'_rand BIT s \\<sigma>)\n                          (last \\<sigma>) [x, y]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  BIT_inv s a [x, y]\n  set qs \\<subseteq> {a, b}", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> Lxx a b\n  a \\<noteq> b\n  {a, b} = {x, y}\n  BIT_inv s a [x, y]\n  set qs \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' BIT s qs\n    \\<le> 175 / 10\\<^sup>2 *\n          real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n    BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]", "by(rule D'')"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' BIT s qs\n  \\<le> 175 / 10\\<^sup>2 *\n        real (T\\<^sub>p [a, b] qs (OPT2 qs [a, b])) \\<and>\n  BIT_inv (Partial_Cost_Model.config'_rand BIT s qs) (last qs) [x, y]\n\ngoal (3 subgoals):\n 1. x \\<noteq> y\n 2. 0 \\<le> 175 / 10\\<^sup>2\n 3. set \\<sigma> \\<subseteq> {x, y}", "qed (simp_all add: assms)"], ["", "end"]]}