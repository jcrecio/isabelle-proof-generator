{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Update/List_Factoring.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Update", "problem_names": ["lemma befaf: assumes \"q\\<in>set s\" \"distinct s\"\nshows \"before q s \\<union> {q} \\<union> after q s = set s\"", "lemma index_sum: assumes \"distinct s\" \"q\\<in>set s\"\nshows \"index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)\"", "lemma t\\<^sub>p_sumofALG: \"distinct (fst s) \\<Longrightarrow> snd a = [] \\<Longrightarrow> (qs!i)\\<in>set (fst s) \n    \\<Longrightarrow> t\\<^sub>p (fst s) (qs!i) a = (\\<Sum>e\\<in>set (fst s). ALG e qs i s)\"", "lemma t\\<^sub>p_sumofALGreal: assumes \"distinct (fst s)\" \"snd a = []\" \"qs!i \\<in> set(fst s)\" \nshows \"real(t\\<^sub>p (fst s) (qs!i) a) = (\\<Sum>e\\<in>set (fst s). real(ALG e qs i s))\"", "lemma steps'_steps: \"length as = length qs \\<Longrightarrow> steps' s as qs (length as) = steps s as qs\"", "lemma steps'_length: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow> length (steps' s qs as n) = length s\"", "lemma steps'_set: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow> set (steps' s qs as n) = set s\"", "lemma steps'_distinct2: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow>  distinct s \\<Longrightarrow> distinct (steps' s qs as n)\"", "lemma steps'_distinct: \"length qs = length as \\<Longrightarrow> length as = n\n  \\<Longrightarrow> distinct (steps' s qs as n) = distinct s\"", "lemma steps'_dist_perm: \"length qs = length as \\<Longrightarrow> length as = n\n  \\<Longrightarrow> dist_perm s s \\<Longrightarrow> dist_perm (steps' s qs as n) (steps' s qs as n)\"", "lemma steps'_rests: \"length qs = length as \\<Longrightarrow> n \\<le> length as \\<Longrightarrow> steps' s qs as n = steps' s (qs@r1) (as@r2) n\"", "lemma steps'_append: \"length qs = length as \\<Longrightarrow> length qs = n \\<Longrightarrow> steps' s (qs@[q]) (as@[a]) (Suc n) = step (steps' s qs as n) q a\"", "lemma ALG'_det_append: \"n < length Strat \\<Longrightarrow> n < length qs \\<Longrightarrow> ALG'_det Strat (qs@a) init n x \n                        = ALG'_det Strat qs init n x\"", "lemma ALG'_refl: \"qs!i = x \\<Longrightarrow> ALG' A qs init i x = 0\"", "lemma ALGxy_det_alternativ: \"ALGxy_det A qs init x y\n   =  (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i \\<in> {y,x})}. ALG'_det A qs init i y + ALG'_det A qs init i x)\"", "lemma ALGxy_def2:\n  \"ALGxy A qs init x y = (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i \\<in> {y,x})}. ALG' A qs init i y + ALG' A qs init i x)\"", "lemma ALGxy_append: \"ALGxy A (rs@[r]) init x y =\n      ALGxy A rs init x y + (if (r \\<in> {y,x}) then ALG' A (rs@[r]) init (length rs) y + ALG' A (rs@[r]) init (length rs) x else 0 )\"", "lemma ALGxy_wholerange: \"ALGxy A qs init x y\n    = (\\<Sum>i<(length qs). (if qs ! i \\<in> {y, x}\n          then ALG' A qs init i y + ALG' A qs init i x\n          else 0 ))\"", "lemma umformung:\n  fixes A :: \"(('a::linorder) list,'is,'a,(nat * nat list)) alg_on_rand\"\n  assumes no_paid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s,is) q). paid=[]\"\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\"\n  assumes \"\\<And>x. x < length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x))\"\n  shows \"T\\<^sub>p_on_rand A init qs = \n    (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALGxy A qs init x y)\"", "lemma before_in_index1:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(if (x < y in l) then 0 else 1) = index l x\"", "lemma before_in_index2:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(if (x < y in l) then 1 else 0) = index l y\"", "lemma before_in_index:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(x < y in l) = (index l x = 0)\"", "lemma T_on_n_no_paid:\n      assumes \n      nopaid: \"\\<And>s n. map_pmf (\\<lambda>x. snd (fst x)) (snd A s n) = return_pmf []\" \n      shows \"T_on_rand_n A init qs i = E (config'' A qs init i \\<bind> (\\<lambda>p. return_pmf (real(index (fst p) (qs ! i)))))\"", "lemma pairwise_property_lemma:\n  assumes  \nrelativeorder: \"(\\<And>init qs. distinct init \\<Longrightarrow> qs \\<in> {xs. set xs \\<subseteq> set init}\n    \\<Longrightarrow> (\\<And>x y. (x,y)\\<in> {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x\\<noteq>y} \n                \\<Longrightarrow> x \\<noteq> y\n                \\<Longrightarrow> Pbefore_in x y A qs init = Pbefore_in x y A (Lxy qs {x,y}) (Lxy init {x,y})\n        ))\" \nand nopaid: \"\\<And>xa r. \\<forall>z\\<in> set_pmf(snd A xa r). snd(fst z) = []\"\nshows \"pairwise A\"", "lemma umf_pair: assumes\n   0: \"pairwise A\"\n  assumes 1: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n  assumes 2: \"set qs \\<subseteq> set init\"\n  assumes 3: \"distinct init\"\n  assumes 4: \"\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x))\"\n   shows \"T\\<^sub>p_on_rand A init qs\n      = (\\<Sum>(x,y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}. T\\<^sub>p_on_rand A (Lxy init {x,y}) (Lxy qs {x,y}))\"", "lemma ALG_P_erwischt_alle:\n  assumes dinit: \"distinct init\" \n  shows\n  \"\\<forall>l< length sws. Suc (sws!l) < length init \\<Longrightarrow> length sws\n        = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set (init::('a::linorder) list) \\<and> y\\<in>set init \\<and> x<y}. ALG_P sws x y init)\"", "lemma t\\<^sub>p_sumofALGALGP:\nassumes \"distinct s\" \"(qs!i)\\<in>set s\"\n  and \"\\<forall>l< length (snd a). Suc ((snd a)!l) < length s\"\nshows \"t\\<^sub>p s (qs!i) a = (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s,())) \n      + (\\<Sum>(x,y)\\<in>{(x::('a::linorder),y). x \\<in> set s \\<and> y\\<in>set s \\<and> x<y}. ALG_P (snd a) x y s)\"", "lemma ALG_P'_rest: \"n < length qs \\<Longrightarrow> n < length Strat \\<Longrightarrow> \n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y\"", "lemma ALG_P'_rest2: \"n < length qs \\<Longrightarrow> n < length Strat \\<Longrightarrow> \n  ALG_P' Strat qs init n x y =\n    ALG_P' (Strat@r1) (qs@r2) init n x y\"", "lemma wegdamit: \"length A < length Strat \\<Longrightarrow> b \\<notin> {x,y} \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y\n    = ALGxy_det Strat A init x y\"", "lemma ALG_P_split: \"length qs < length Strat \\<Longrightarrow> ALG_Pxy Strat (qs@[q]) init x y = ALG_Pxy Strat qs init x y\n            +  ALG_P' Strat (qs@[q]) init (length qs) x y \"", "lemma swap0in2:  assumes \"set l = {x,y}\" \"x\\<noteq>y\" \"length l = 2\" \"dist_perm l l\"\n  shows\n    \"x < y in (swap 0) l = (~ x < y in l)\"", "lemma before_in_swap2:\n \"dist_perm xs ys \\<Longrightarrow> Suc n < size xs \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow>\n  x < y in (swap n xs) \\<longleftrightarrow>\n  (~ x < y in xs \\<and> (y = xs!n \\<and> x = xs!Suc n)\n      \\<or> x < y in xs \\<and> ~(y = xs!Suc n \\<and> x = xs!n))\"", "lemma projected_paid_same_effect: \n  assumes\n   d: \"dist_perm s1 s1\"  \n  and ee: \"x\\<noteq>y\"  \n  and f: \"set s2 = {x, y}\"  \n  and g: \"length s2 = 2\"  \n  and h: \"dist_perm s2 s2\"  \n  shows \"x < y in s1 = x < y in s2 \\<Longrightarrow>\n  x < y in swaps acs s1 = x < y in (swap 0 ^^ ALG_P acs x y s1) s2\"", "lemma steps_steps':\n  \"length qs = length as \\<Longrightarrow> steps s qs as = steps' s qs as (length as)\"", "lemma T1_7': \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs \\<Longrightarrow> length Strat = length qs\n      \\<Longrightarrow> n\\<le>length qs \\<Longrightarrow>  \n      x\\<noteq>(y::('a::linorder)) \\<Longrightarrow>\n      x\\<in> set init \\<Longrightarrow> y \\<in> set init \\<Longrightarrow> distinct init \\<Longrightarrow>\n      set qs \\<subseteq> set init \\<Longrightarrow>\n      (\\<exists>Strat2 sws. \n        \\<^cancel>\\<open>T\\<^sub>p_opt (Lxy init {x,y}) (Lxy (take n qs) {x,y}) \\<le> T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2\n          \\<and>\\<close>  length Strat2 = length (Lxy (take n qs) {x,y})\n          \\<and>     (x < y in (steps' init (take n qs) (take n Strat) n))\n              = (x < y in (swaps sws (steps' (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2 (length Strat2))))\n          \\<and> T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2 + length sws =            \n          ALGxy_det Strat (take n qs) init x y + ALG_Pxy Strat (take n qs) init x y)\"", "lemma T1_7:\nassumes \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\" \"length Strat = length qs\"\n  \"x \\<noteq> (y::('a::linorder))\" \"x\\<in> set init\" \"y \\<in> set init\" \"distinct init\"\n  \"set qs \\<subseteq> set init\"\nshows \"T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\"", "lemma T_snoc: \"length rs = length as\n       \\<Longrightarrow>  T init (rs@[r]) (as@[a])\n        = T init rs as + t\\<^sub>p (steps' init rs as (length rs)) r a\"", "lemma steps'_snoc: \"length rs = length as \\<Longrightarrow> n = (length as)\n       \\<Longrightarrow> steps' init (rs@[r]) (as@[a]) (Suc n) = step (steps' init rs as n) r a\"", "lemma steps'_take:\n  assumes \"n<length qs\" \"length qs = length Strat\" \n  shows \"steps' init (take n qs) (take n Strat) n\n      = steps' init qs Strat n\"", "lemma Tp_darstellung: \"length qs = length Strat\n        \\<Longrightarrow> T\\<^sub>p init qs Strat =\n        (\\<Sum>i\\<in>{..<length qs}. t\\<^sub>p (steps' init qs Strat i) (qs!i) (Strat!i))\"", "lemma umformung_OPT':\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\"\n  assumes qsStrat: \"length qs = length Strat\"\n  assumes noStupid: \"\\<And>x l. x<length Strat \\<Longrightarrow> l< length (snd (Strat ! x)) \\<Longrightarrow> Suc ((snd (Strat ! x))!l)  < length init\"\n  shows \"T\\<^sub>p init qs Strat = \n    (\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\"", "lemma nn_contains_Inf:\n  fixes S :: \"nat set\"\n  assumes nn: \"S \\<noteq> {}\"\n  shows \"Inf S \\<in> S\"", "lemma steps_length: \"length qs = length as \\<Longrightarrow> length (steps s qs as) = length s\"", "lemma OPT_noStupid:\n  fixes Strat\n  assumes [simp]: \"length Strat = length qs\"\n  assumes opt: \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\"\n  assumes init_nempty: \"init\\<noteq>[]\"\n  shows \"\\<And>x l. x < length Strat \\<Longrightarrow>\n        l < length (snd (Strat ! x)) \\<Longrightarrow>\n       Suc ((snd (Strat ! x))!l) < length init\"", "lemma umformung_OPT:\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\" \n  assumes a: \"T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat\"\n  assumes b: \" length qs = length Strat\"\n  assumes c: \"init\\<noteq>[]\"\n  shows \"T\\<^sub>p_opt init qs = \n    (\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\"", "lemma cardofpairs: \"S \\<noteq> [] \\<Longrightarrow> sorted S \\<Longrightarrow> distinct S \\<Longrightarrow> card {(x,y). x \\<in> set S \\<and> y\\<in>set S \\<and> x<y} = ((length S)*(length S-1)) / 2\"", "lemma factoringlemma_withconstant:\n    fixes A\n          and b::real\n          and c::real\n      assumes c: \"c \\<ge> 1\"\n      assumes dist: \"\\<forall>e\\<in>S0. distinct e\"\n      assumes notempty: \"\\<forall>e\\<in>S0. length e > 0\"\n      (* A has pairwise property *)\n      assumes pw: \"pairwise A\"\n      (* A is c-competitive on list of length 2 *) \n      assumes on2: \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \\<forall>(x,y)\\<in>{(x,y). x \\<in> set s0 \\<and> y\\<in>set s0 \\<and> x<y}. T\\<^sub>p_on_rand A (Lxy s0 {x,y}) (Lxy qs {x,y})  \\<le> c * (T\\<^sub>p_opt (Lxy s0 {x,y}) (Lxy qs {x,y})) + b\" \n      assumes nopaid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n      assumes 4: \"\\<And>init qs. distinct init \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> (\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x)))\" \n      (* then A is c-competitive on arbitrary list lengths *)\n      shows \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0.  \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \n              T\\<^sub>p_on_rand A s0 qs \\<le> c * real (T\\<^sub>p_opt s0 qs) + b\"", "lemma factoringlemma_withconstant':\n    fixes A\n          and b::real\n          and c::real\n      assumes c: \"c \\<ge> 1\"\n      assumes dist: \"\\<forall>e\\<in>S0. distinct e\"\n      assumes notempty: \"\\<forall>e\\<in>S0. length e > 0\"\n      (* A has pairwise property *)\n      assumes pw: \"pairwise A\"\n      (* A is c-competitive on list of length 2 *) \n      assumes on2: \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \\<forall>(x,y)\\<in>{(x,y). x \\<in> set s0 \\<and> y\\<in>set s0 \\<and> x<y}. T\\<^sub>p_on_rand A (Lxy s0 {x,y}) (Lxy qs {x,y})  \\<le> c * (T\\<^sub>p_opt (Lxy s0 {x,y}) (Lxy qs {x,y})) + b\" \n      assumes nopaid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n      assumes 4: \"\\<And>init qs. distinct init \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> (\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x)))\" \n      (* then A is c-competitive on arbitrary list lengths *)\n      shows \"compet_rand A c S0\""], "translations": [["", "lemma befaf: assumes \"q\\<in>set s\" \"distinct s\"\nshows \"before q s \\<union> {q} \\<union> after q s = set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "have \"before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s}\n      = {y. index s y \\<le> index s q \\<and> q \\<in> set s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} =\n    {y. index s y \\<le> index s q \\<and> q \\<in> set s}", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. index s y < index s q \\<and> q \\<in> set s} \\<union>\n    {y. index s y = index s q \\<and> q \\<in> set s} =\n    {y. index s y \\<le> index s q \\<and> q \\<in> set s}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>index s x \\<le> index s q; q \\<in> set s;\n        x \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> index s x < index s q", "by (simp add: le_neq_implies_less)"], ["proof (state)\nthis:\n  before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "also"], ["proof (state)\nthis:\n  before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "have \"\\<dots> =  {y. index s y \\<le> index s q \\<and> y\\<in> set s \\<and> q \\<in> set s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. index s y \\<le> index s q \\<and> q \\<in> set s} =\n    {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>index s x \\<le> index s q; q \\<in> set s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set s", "by (metis index_conv_size_if_notin index_less_size_conv not_less)"], ["proof (state)\nthis:\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "also"], ["proof (state)\nthis:\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "with \\<open>q \\<in> set s\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> set s\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s}", "have \"\\<dots> = {y. index s y \\<le> index s q \\<and> y\\<in> set s}\""], ["proof (prove)\nusing this:\n  q \\<in> set s\n  {y. index s y \\<le> index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s}\n\ngoal (1 subgoal):\n 1. {y. index s y \\<le> index s q \\<and>\n        y \\<in> set s \\<and> q \\<in> set s} =\n    {y. index s y \\<le> index s q \\<and> y \\<in> set s}", "by auto"], ["proof (state)\nthis:\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "finally"], ["proof (chain)\npicking this:\n  before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s}", "have \"before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} \\<union> after q s\n      = {y. index s y \\<le> index s q \\<and> y\\<in> set s} \\<union> {y. index s y > index s q \\<and> y \\<in> set s}\""], ["proof (prove)\nusing this:\n  before q s \\<union> {y. index s y = index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union>\n    {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n    after q s =\n    {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n    {y. index s q < index s y \\<and> y \\<in> set s}", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  {y. index s y < index s q \\<and> q \\<in> set s} \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s}\n\ngoal (1 subgoal):\n 1. {y. index s y < index s q \\<and> q \\<in> set s} \\<union>\n    {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n    {y. index s q < index s y \\<and> y \\<in> set s} =\n    {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n    {y. index s q < index s y \\<and> y \\<in> set s}", "by simp"], ["proof (state)\nthis:\n  before q s \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n  after q s =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n  {y. index s q < index s y \\<and> y \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "also"], ["proof (state)\nthis:\n  before q s \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n  after q s =\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n  {y. index s q < index s y \\<and> y \\<in> set s}\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "have \"\\<dots> = set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n    {y. index s q < index s y \\<and> y \\<in> set s} =\n    set s", "by auto"], ["proof (state)\nthis:\n  {y. index s y \\<le> index s q \\<and> y \\<in> set s} \\<union>\n  {y. index s q < index s y \\<and> y \\<in> set s} =\n  set s\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "finally"], ["proof (chain)\npicking this:\n  before q s \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n  after q s =\n  set s", "show ?thesis"], ["proof (prove)\nusing this:\n  before q s \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n  after q s =\n  set s\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "using assms"], ["proof (prove)\nusing this:\n  before q s \\<union>\n  {y. index s y = index s q \\<and> q \\<in> set s} \\<union>\n  after q s =\n  set s\n  q \\<in> set s\n  distinct s\n\ngoal (1 subgoal):\n 1. before q s \\<union> {q} \\<union> after q s = set s", "by simp"], ["proof (state)\nthis:\n  before q s \\<union> {q} \\<union> after q s = set s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_sum: assumes \"distinct s\" \"q\\<in>set s\"\nshows \"index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "from assms"], ["proof (chain)\npicking this:\n  distinct s\n  q \\<in> set s", "have bia_empty: \"before q s \\<inter> ({q} \\<union> after q s) = {}\""], ["proof (prove)\nusing this:\n  distinct s\n  q \\<in> set s\n\ngoal (1 subgoal):\n 1. before q s \\<inter> ({q} \\<union> after q s) = {}", "by(auto simp: before_in_def)"], ["proof (state)\nthis:\n  before q s \\<inter> ({q} \\<union> after q s) = {}\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "from befaf[OF assms(2) assms(1)]"], ["proof (chain)\npicking this:\n  before q s \\<union> {q} \\<union> after q s = set s", "have \"(\\<Sum>e\\<in>set s. if e < q in s then 1::nat else 0)\n    = (\\<Sum>e\\<in>(before q s \\<union> {q} \\<union> after q s). if e < q in s then 1 else 0)\""], ["proof (prove)\nusing this:\n  before q s \\<union> {q} \\<union> after q s = set s\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0)\n            + (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) + (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "have \"(\\<Sum>e\\<in>(before q s \\<union> {q} \\<union> after q s). if e < q in s then 1::nat else 0)\n      = (\\<Sum>e\\<in>(before q s \\<union> ({q} \\<union> after q s)). if e < q in s then 1::nat else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n       if e < q in s then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "have \"\\<dots> = (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0)\n          + (\\<Sum>e\\<in>({q} \\<union> after q s). if e < q in s then 1 else 0)\n          - (\\<Sum>e\\<in>(before q s \\<inter> ({q} \\<union> after q s)). if e < q in s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n    (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n       if e < q in s then 1 else 0)", "apply(rule sum_Un_nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (before q s)\n 2. finite ({q} \\<union> after q s)", "by(simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n  (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n  (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "have \"\\<dots> = (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0)\n          + (\\<Sum>e\\<in>({q} \\<union> after q s). if e < q in s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n    (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0)", "using bia_empty"], ["proof (prove)\nusing this:\n  before q s \\<inter> ({q} \\<union> after q s) = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n    (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n  (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) -\n  (\\<Sum>e\\<in>before q s \\<inter> ({q} \\<union> after q s).\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "have \"\\<dots> = (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0)\n          + (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) + (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "by (simp add: before_in_def)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q} \\<union> after q s. if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n       if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)", "."], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s \\<union> {q} \\<union> after q s.\n     if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>({q} \\<union> after q s). 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n    (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0) =\n    (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q < q in s \\<Longrightarrow> False", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. index s q < index s q \\<and> q \\<in> set s \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>{q}. if e < q in s then 1 else 0) +\n  (\\<Sum>e\\<in>after q s. if e < q in s then 1 else 0) =\n  (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = card (before q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0) =\n    card (before q s)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0) =\n  card (before q s)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>before q s. 1) + (\\<Sum>e\\<in>{q} \\<union> after q s. 0) =\n  card (before q s)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = card (set (take (index s q) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (before q s) = card (set (take (index s q) s))", "using before_conv_take[OF assms(2)]"], ["proof (prove)\nusing this:\n  before q s = set (take (index s q) s)\n\ngoal (1 subgoal):\n 1. card (before q s) = card (set (take (index s q) s))", "by simp"], ["proof (state)\nthis:\n  card (before q s) = card (set (take (index s q) s))\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  card (before q s) = card (set (take (index s q) s))\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = length (take (index s q) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (take (index s q) s)) = length (take (index s q) s)", "using distinct_card assms(1) distinct_take"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  distinct s\n  distinct ?xs \\<Longrightarrow> distinct (take ?i ?xs)\n\ngoal (1 subgoal):\n 1. card (set (take (index s q) s)) = length (take (index s q) s)", "by metis"], ["proof (state)\nthis:\n  card (set (take (index s q) s)) = length (take (index s q) s)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  card (set (take (index s q) s)) = length (take (index s q) s)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = min (length s) (index s q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (index s q) s) = min (length s) (index s q)", "by simp"], ["proof (state)\nthis:\n  length (take (index s q) s) = min (length s) (index s q)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "also"], ["proof (state)\nthis:\n  length (take (index s q) s) = min (length s) (index s q)\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "have \"\\<dots> = index s q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length s) (index s q) = index s q", "using index_le_size[of s q]"], ["proof (prove)\nusing this:\n  index s q \\<le> length s\n\ngoal (1 subgoal):\n 1. min (length s) (index s q) = index s q", "by(auto)"], ["proof (state)\nthis:\n  min (length s) (index s q) = index s q\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0) = index s q", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0) = index s q\n\ngoal (1 subgoal):\n 1. index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  index s q = (\\<Sum>e\\<in>set s. if e < q in s then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"ALG\""], ["", "fun ALG :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> ('a list * 'is) \\<Rightarrow> nat\" where\n  \"ALG x qs i s = (if x < (qs!i) in fst s then 1::nat else 0)\""], ["", "(* no paid exchanges, requested items in state (nice, quickcheck is awesome!) *)"], ["", "lemma t\\<^sub>p_sumofALG: \"distinct (fst s) \\<Longrightarrow> snd a = [] \\<Longrightarrow> (qs!i)\\<in>set (fst s) \n    \\<Longrightarrow> t\\<^sub>p (fst s) (qs!i) a = (\\<Sum>e\\<in>set (fst s). ALG e qs i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (fst s); snd a = []; qs ! i \\<in> set (fst s)\\<rbrakk>\n    \\<Longrightarrow> t\\<^sub>p (fst s) (qs ! i) a =\n                      (\\<Sum>e\\<in>set (fst s). ALG e qs i s)", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (fst s); snd a = []; qs ! i \\<in> set (fst s)\\<rbrakk>\n    \\<Longrightarrow> (let (mf, sws) = a\n                       in index (swaps sws (fst s)) (qs ! i) + length sws) =\n                      (\\<Sum>e\\<in>set (fst s). ALG e qs i s)", "apply(simp add: split_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (fst s); snd a = []; qs ! i \\<in> set (fst s)\\<rbrakk>\n    \\<Longrightarrow> index (fst s) (qs ! i) =\n                      (\\<Sum>e\\<in>set (fst s).\n                         if e < qs ! i in fst s then 1 else 0)", "using index_sum"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?s; ?q \\<in> set ?s\\<rbrakk>\n  \\<Longrightarrow> index ?s ?q =\n                    (\\<Sum>e\\<in>set ?s. if e < ?q in ?s then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (fst s); snd a = []; qs ! i \\<in> set (fst s)\\<rbrakk>\n    \\<Longrightarrow> index (fst s) (qs ! i) =\n                      (\\<Sum>e\\<in>set (fst s).\n                         if e < qs ! i in fst s then 1 else 0)", "by metis"], ["", "lemma t\\<^sub>p_sumofALGreal: assumes \"distinct (fst s)\" \"snd a = []\" \"qs!i \\<in> set(fst s)\" \nshows \"real(t\\<^sub>p (fst s) (qs!i) a) = (\\<Sum>e\\<in>set (fst s). real(ALG e qs i s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "from assms"], ["proof (chain)\npicking this:\n  distinct (fst s)\n  snd a = []\n  qs ! i \\<in> set (fst s)", "have \"real(t\\<^sub>p (fst s) (qs!i) a) = real(\\<Sum>e\\<in>set (fst s). ALG e qs i s)\""], ["proof (prove)\nusing this:\n  distinct (fst s)\n  snd a = []\n  qs ! i \\<in> set (fst s)\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    real (\\<Sum>e\\<in>set (fst s). ALG e qs i s)", "using t\\<^sub>p_sumofALG"], ["proof (prove)\nusing this:\n  distinct (fst s)\n  snd a = []\n  qs ! i \\<in> set (fst s)\n  \\<lbrakk>distinct (fst ?s); snd ?a = [];\n   ?qs ! ?i \\<in> set (fst ?s)\\<rbrakk>\n  \\<Longrightarrow> t\\<^sub>p (fst ?s) (?qs ! ?i) ?a =\n                    (\\<Sum>e\\<in>set (fst ?s). ALG e ?qs ?i ?s)\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    real (\\<Sum>e\\<in>set (fst s). ALG e qs i s)", "by metis"], ["proof (state)\nthis:\n  real (t\\<^sub>p (fst s) (qs ! i) a) =\n  real (\\<Sum>e\\<in>set (fst s). ALG e qs i s)\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "also"], ["proof (state)\nthis:\n  real (t\\<^sub>p (fst s) (qs ! i) a) =\n  real (\\<Sum>e\\<in>set (fst s). ALG e qs i s)\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "have \"\\<dots> = (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>e\\<in>set (fst s). ALG e qs i s) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "by auto"], ["proof (state)\nthis:\n  real (\\<Sum>e\\<in>set (fst s). ALG e qs i s) =\n  (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "finally"], ["proof (chain)\npicking this:\n  real (t\\<^sub>p (fst s) (qs ! i) a) =\n  (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "show ?thesis"], ["proof (prove)\nusing this:\n  real (t\\<^sub>p (fst s) (qs ! i) a) =\n  (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))\n\ngoal (1 subgoal):\n 1. real (t\\<^sub>p (fst s) (qs ! i) a) =\n    (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))", "."], ["proof (state)\nthis:\n  real (t\\<^sub>p (fst s) (qs ! i) a) =\n  (\\<Sum>e\\<in>set (fst s). real (ALG e qs i s))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"The function steps'\""], ["", "fun steps' where\n  \"steps' s _ _ 0 = s\"\n| \"steps' s [] [] (Suc n) = s\"\n| \"steps' s (q#qs) (a#as) (Suc n) = steps' (step s q a) qs as n\""], ["", "lemma steps'_steps: \"length as = length qs \\<Longrightarrow> steps' s as qs (length as) = steps s as qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = length qs \\<Longrightarrow>\n    steps' s as qs (length as) = Partial_Cost_Model.steps s as qs", "by(induct arbitrary: s rule: list_induct2, simp_all)"], ["", "lemma steps'_length: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow> length (steps' s qs as n) = length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; n \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> length (steps' s qs as n) = length s", "apply(induct qs as arbitrary: s  n rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s n.\n       n \\<le> length [] \\<Longrightarrow>\n       length (steps' s [] [] n) = length s\n 2. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           length (steps' s xs ys n) = length s;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> length (steps' s (x # xs) (y # ys) n) = length s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           length (steps' s xs ys n) = length s;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> length (steps' s (x # xs) (y # ys) n) = length s", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           length (steps' s xs ys n) = length s;\n        n \\<le> length (y # ys); n = 0\\<rbrakk>\n       \\<Longrightarrow> length (steps' s (x # xs) (y # ys) n) = length s\n 2. \\<And>x xs y ys s n nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           length (steps' s xs ys n) = length s;\n        n \\<le> length (y # ys); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length (steps' s (x # xs) (y # ys) n) = length s", "by (auto)"], ["", "lemma steps'_set: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow> set (steps' s qs as n) = set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; n \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> set (steps' s qs as n) = set s", "apply(induct qs as arbitrary: s  n rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s n.\n       n \\<le> length [] \\<Longrightarrow> set (steps' s [] [] n) = set s\n 2. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           set (steps' s xs ys n) = set s;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (steps' s (x # xs) (y # ys) n) = set s", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           set (steps' s xs ys n) = set s;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (steps' s (x # xs) (y # ys) n) = set s", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           set (steps' s xs ys n) = set s;\n        n \\<le> length (y # ys); n = 0\\<rbrakk>\n       \\<Longrightarrow> set (steps' s (x # xs) (y # ys) n) = set s\n 2. \\<And>x xs y ys s n nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           set (steps' s xs ys n) = set s;\n        n \\<le> length (y # ys); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> set (steps' s (x # xs) (y # ys) n) = set s", "by(auto simp: set_step)"], ["", "lemma steps'_distinct2: \"length qs = length as \\<Longrightarrow> n \\<le> length as\n  \\<Longrightarrow>  distinct s \\<Longrightarrow> distinct (steps' s qs as n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; n \\<le> length as; distinct s\\<rbrakk>\n    \\<Longrightarrow> distinct (steps' s qs as n)", "apply(induct qs as arbitrary: s  n rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>n \\<le> length []; distinct s\\<rbrakk>\n       \\<Longrightarrow> distinct (steps' s [] [] n)\n 2. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           \\<lbrakk>n \\<le> length ys; distinct s\\<rbrakk>\n           \\<Longrightarrow> distinct (steps' s xs ys n);\n        n \\<le> length (y # ys); distinct s\\<rbrakk>\n       \\<Longrightarrow> distinct (steps' s (x # xs) (y # ys) n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           \\<lbrakk>n \\<le> length ys; distinct s\\<rbrakk>\n           \\<Longrightarrow> distinct (steps' s xs ys n);\n        n \\<le> length (y # ys); distinct s\\<rbrakk>\n       \\<Longrightarrow> distinct (steps' s (x # xs) (y # ys) n)", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           \\<lbrakk>n \\<le> length ys; distinct s\\<rbrakk>\n           \\<Longrightarrow> distinct (steps' s xs ys n);\n        n \\<le> length (y # ys); distinct s; n = 0\\<rbrakk>\n       \\<Longrightarrow> distinct (steps' s (x # xs) (y # ys) n)\n 2. \\<And>x xs y ys s n nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           \\<lbrakk>n \\<le> length ys; distinct s\\<rbrakk>\n           \\<Longrightarrow> distinct (steps' s xs ys n);\n        n \\<le> length (y # ys); distinct s; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> distinct (steps' s (x # xs) (y # ys) n)", "by(auto simp: distinct_step)"], ["", "lemma steps'_distinct: \"length qs = length as \\<Longrightarrow> length as = n\n  \\<Longrightarrow> distinct (steps' s qs as n) = distinct s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; length as = n\\<rbrakk>\n    \\<Longrightarrow> distinct (steps' s qs as n) = distinct s", "by (induct qs as arbitrary: s n rule: list_induct2) (fastforce simp add: distinct_step)+"], ["", "lemma steps'_dist_perm: \"length qs = length as \\<Longrightarrow> length as = n\n  \\<Longrightarrow> dist_perm s s \\<Longrightarrow> dist_perm (steps' s qs as n) (steps' s qs as n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; length as = n; dist_perm s s\\<rbrakk>\n    \\<Longrightarrow> dist_perm (steps' s qs as n) (steps' s qs as n)", "using steps'_set steps'_distinct"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?qs = length ?as; ?n \\<le> length ?as\\<rbrakk>\n  \\<Longrightarrow> set (steps' ?s ?qs ?as ?n) = set ?s\n  \\<lbrakk>length ?qs = length ?as; length ?as = ?n\\<rbrakk>\n  \\<Longrightarrow> distinct (steps' ?s ?qs ?as ?n) = distinct ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; length as = n; dist_perm s s\\<rbrakk>\n    \\<Longrightarrow> dist_perm (steps' s qs as n) (steps' s qs as n)", "by blast"], ["", "lemma steps'_rests: \"length qs = length as \\<Longrightarrow> n \\<le> length as \\<Longrightarrow> steps' s qs as n = steps' s (qs@r1) (as@r2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; n \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> steps' s qs as n = steps' s (qs @ r1) (as @ r2) n", "apply(induct qs as arbitrary: s  n rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s n.\n       n \\<le> length [] \\<Longrightarrow>\n       steps' s [] [] n = steps' s ([] @ r1) ([] @ r2) n\n 2. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           steps' s xs ys n = steps' s (xs @ r1) (ys @ r2) n;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> steps' s (x # xs) (y # ys) n =\n                         steps' s ((x # xs) @ r1) ((y # ys) @ r2) n", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           steps' s xs ys n = steps' s (xs @ r1) (ys @ r2) n;\n        n \\<le> length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> steps' s (x # xs) (y # ys) n =\n                         steps' s ((x # xs) @ r1) ((y # ys) @ r2) n", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           steps' s xs ys n = steps' s (xs @ r1) (ys @ r2) n;\n        n \\<le> length (y # ys); n = 0\\<rbrakk>\n       \\<Longrightarrow> steps' s (x # xs) (y # ys) n =\n                         steps' s ((x # xs) @ r1) ((y # ys) @ r2) n\n 2. \\<And>x xs y ys s n nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           n \\<le> length ys \\<Longrightarrow>\n           steps' s xs ys n = steps' s (xs @ r1) (ys @ r2) n;\n        n \\<le> length (y # ys); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> steps' s (x # xs) (y # ys) n =\n                         steps' s ((x # xs) @ r1) ((y # ys) @ r2) n", "by auto"], ["", "lemma steps'_append: \"length qs = length as \\<Longrightarrow> length qs = n \\<Longrightarrow> steps' s (qs@[q]) (as@[a]) (Suc n) = step (steps' s qs as n) q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs = length as; length qs = n\\<rbrakk>\n    \\<Longrightarrow> steps' s (qs @ [q]) (as @ [a]) (Suc n) =\n                      step (steps' s qs as n) q a", "apply(induct qs as arbitrary: s  n rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s n.\n       length [] = n \\<Longrightarrow>\n       steps' s ([] @ [q]) ([] @ [a]) (Suc n) = step (steps' s [] [] n) q a\n 2. \\<And>x xs y ys s n.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s n.\n           length xs = n \\<Longrightarrow>\n           steps' s (xs @ [q]) (ys @ [a]) (Suc n) =\n           step (steps' s xs ys n) q a;\n        length (x # xs) = n\\<rbrakk>\n       \\<Longrightarrow> steps' s ((x # xs) @ [q]) ((y # ys) @ [a])\n                          (Suc n) =\n                         step (steps' s (x # xs) (y # ys) n) q a", "by auto"], ["", "subsubsection \"\\<open>ALG'_det\\<close>\""], ["", "definition \"ALG'_det Strat qs init i x = ALG x qs i (swaps (snd (Strat!i)) (steps' init qs Strat i),())\""], ["", "lemma ALG'_det_append: \"n < length Strat \\<Longrightarrow> n < length qs \\<Longrightarrow> ALG'_det Strat (qs@a) init n x \n                        = ALG'_det Strat qs init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "assume qs: \"n < length qs\""], ["proof (state)\nthis:\n  n < length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "assume S: \"n < length Strat\""], ["proof (state)\nthis:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "have tt: \"(qs @ a) ! n = qs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qs @ a) ! n = qs ! n", "using qs"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. (qs @ a) ! n = qs ! n", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (qs @ a) ! n = qs ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "have \"steps' init (take n qs) (take n Strat) n = steps' init ((take n qs) @ drop n qs) ((take n Strat) @ (drop n Strat)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "apply(rule steps'_rests)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "have A: \"steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "have \"steps' init (take n qs) (take n Strat) n = steps' init ((take n qs) @ ((drop n qs)@a)) ((take n Strat) @((drop n Strat)@[])) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs @ drop n qs @ a)\n     (take n Strat @ drop n Strat @ []) n", "apply(rule steps'_rests)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ a) (take n Strat @ drop n Strat @ [])\n   n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ a) (take n Strat @ drop n Strat @ [])\n   n", "have B: \"steps' init (take n qs) (take n Strat) n = steps' init (qs@a) (Strat@[]) n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ a) (take n Strat @ drop n Strat @ [])\n   n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (qs @ a) (Strat @ []) n", "by (metis append_assoc List.append_take_drop_id)"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ a) (Strat @ []) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "from A B"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ a) (Strat @ []) n", "have \"steps' init qs Strat n = steps' init (qs@a) (Strat@[]) n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ a) (Strat @ []) n\n\ngoal (1 subgoal):\n 1. steps' init qs Strat n = steps' init (qs @ a) (Strat @ []) n", "by auto"], ["proof (state)\nthis:\n  steps' init qs Strat n = steps' init (qs @ a) (Strat @ []) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  steps' init qs Strat n = steps' init (qs @ a) (Strat @ []) n", "have C: \"steps' init qs Strat n = steps' init (qs@a) Strat n\""], ["proof (prove)\nusing this:\n  steps' init qs Strat n = steps' init (qs @ a) (Strat @ []) n\n\ngoal (1 subgoal):\n 1. steps' init qs Strat n = steps' init (qs @ a) Strat n", "by auto"], ["proof (state)\nthis:\n  steps' init qs Strat n = steps' init (qs @ a) Strat n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length Strat; n < length qs\\<rbrakk>\n    \\<Longrightarrow> ALG'_det Strat (qs @ a) init n x =\n                      ALG'_det Strat qs init n x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat (qs @ a) init n x = ALG'_det Strat qs init n x", "unfolding ALG'_det_def C"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG x (qs @ a) n\n     (swaps (snd (Strat ! n)) (steps' init (qs @ a) Strat n), ()) =\n    ALG x qs n (swaps (snd (Strat ! n)) (steps' init (qs @ a) Strat n), ())", "unfolding ALG.simps tt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < qs ! n\n        in fst (swaps (snd (Strat ! n)) (steps' init (qs @ a) Strat n), ())\n     then 1 else 0) =\n    (if x < qs ! n\n        in fst (swaps (snd (Strat ! n)) (steps' init (qs @ a) Strat n), ())\n     then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  ALG'_det Strat (qs @ a) init n x = ALG'_det Strat qs init n x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"ALG'\""], ["", "abbreviation \"config'' A qs init n == config_rand A init (take n qs)\""], ["", "definition \"ALG' A qs init i x = E( map_pmf (ALG x qs i) (config'' A qs init i))\""], ["", "lemma ALG'_refl: \"qs!i = x \\<Longrightarrow> ALG' A qs init i x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! i = x \\<Longrightarrow> ALG' A qs init i x = 0", "unfolding ALG'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! i = x \\<Longrightarrow>\n    E (map_pmf (\\<lambda>xa. real (ALG x qs i xa))\n        (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs))) =\n    0", "by(simp add: split_def before_in_def)"], ["", "subsubsection \"\\<open>ALGxy_det\\<close>\""], ["", "definition ALGxy_det where\n  \"ALGxy_det A qs init x y = (\\<Sum>i\\<in>{..<length qs}. (if (qs!i \\<in> {y,x}) then ALG'_det A qs init i y + ALG'_det A qs init i x\n                                                    else 0::nat))\""], ["", "lemma ALGxy_det_alternativ: \"ALGxy_det A qs init x y\n   =  (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i \\<in> {y,x})}. ALG'_det A qs init i y + ALG'_det A qs init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have f: \"{i. i<length qs} = {..<length qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs} = {..<length qs}", "by(auto)"], ["proof (state)\nthis:\n  {i. i < length qs} = {..<length qs}\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have e: \"{i. i<length qs \\<and> (qs!i \\<in> {y,x})} = {i. i<length qs} \\<inter> {i. (qs!i \\<in> {y,x})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> qs ! i \\<in> {y, x}} =\n    {i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> qs ! i \\<in> {y, x}} =\n  {i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have \"(\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i \\<in> {y,x})}. ALG'_det A qs init i y + ALG'_det A qs init i x)\n    = (\\<Sum>i\\<in>{i. i<length qs} \\<inter> {i. (qs!i \\<in> {y,x})}. ALG'_det A qs init i y + ALG'_det A qs init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x) =\n    (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "unfolding e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x) =\n    (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have \"\\<dots> = (\\<Sum>i\\<in>{i. i<length qs}. (if i \\<in> {i. (qs!i \\<in> {y,x})} then ALG'_det A qs init i y + ALG'_det A qs init i x\n                                                    else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x) =\n    (\\<Sum>i | i < length qs.\n       if i \\<in> {i. qs ! i \\<in> {y, x}}\n       then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)", "apply(rule sum.inter_restrict)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i < length qs}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<length qs}. (if i \\<in> {i. (qs!i \\<in> {y,x})} then ALG'_det A qs init i y + ALG'_det A qs init i x\n                                                    else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs.\n       if i \\<in> {i. qs ! i \\<in> {y, x}}\n       then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n    (\\<Sum>i<length qs.\n        if i \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        if i \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n    (\\<Sum>i<length qs.\n        if i \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n  (\\<Sum>i<length qs.\n      if i \\<in> {i. qs ! i \\<in> {y, x}}\n      then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n  (\\<Sum>i<length qs.\n      if i \\<in> {i. qs ! i \\<in> {y, x}}\n      then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "have \"\\<dots> = ALGxy_det A qs init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        if i \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n    ALGxy_det A qs init x y", "unfolding ALGxy_det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        if i \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x}\n        then ALG'_det A qs init i y + ALG'_det A qs init i x else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      if i \\<in> {i. qs ! i \\<in> {y, x}}\n      then ALG'_det A qs init i y + ALG'_det A qs init i x else 0) =\n  ALGxy_det A qs init x y\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  ALGxy_det A qs init x y", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x) =\n  ALGxy_det A qs init x y\n\ngoal (1 subgoal):\n 1. ALGxy_det A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG'_det A qs init i y + ALG'_det A qs init i x)", "by simp"], ["proof (state)\nthis:\n  ALGxy_det A qs init x y =\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG'_det A qs init i y + ALG'_det A qs init i x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"ALGxy\""], ["", "definition ALGxy where\n  \"ALGxy A qs init x y = (\\<Sum>i\\<in>{..<length qs} \\<inter> {i. (qs!i \\<in> {y,x})}. ALG' A qs init i y + ALG' A qs init i x)\""], ["", "lemma ALGxy_def2:\n  \"ALGxy A qs init x y = (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i \\<in> {y,x})}. ALG' A qs init i y + ALG' A qs init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG' A qs init i y + ALG' A qs init i x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG' A qs init i y + ALG' A qs init i x)", "have a: \"{i. i<length qs \\<and> (qs!i \\<in> {y,x})} = {..<length qs} \\<inter> {i. (qs!i \\<in> {y,x})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> qs ! i \\<in> {y, x}} =\n    {..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> qs ! i \\<in> {y, x}} =\n  {..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}}\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG' A qs init i y + ALG' A qs init i x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n       ALG' A qs init i y + ALG' A qs init i x)", "unfolding ALGxy_def a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x) =\n    (\\<Sum>i\\<in>{..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x)", "by simp"], ["proof (state)\nthis:\n  ALGxy A qs init x y =\n  (\\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n     ALG' A qs init i y + ALG' A qs init i x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ALGxy_append: \"ALGxy A (rs@[r]) init x y =\n      ALGxy A rs init x y + (if (r \\<in> {y,x}) then ALG' A (rs@[r]) init (length rs) y + ALG' A (rs@[r]) init (length rs) x else 0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "have \"ALGxy A (rs@[r]) init x y = (\\<Sum>i\\<in>{..<(Suc (length rs))} \\<inter> {i. (rs @ [r]) ! i \\<in> {y, x}}.\n       ALG' A (rs @ [r]) init i y +\n       ALG' A (rs @ [r]) init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n                 {i. (rs @ [r]) ! i \\<in> {y, x}}.\n       ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x)", "unfolding ALGxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<length (rs @ [r])} \\<inter>\n                 {i. (rs @ [r]) ! i \\<in> {y, x}}.\n       ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x) =\n    (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n                 {i. (rs @ [r]) ! i \\<in> {y, x}}.\n       ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x)", "by(simp)"], ["proof (state)\nthis:\n  ALGxy A (rs @ [r]) init x y =\n  (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n               {i. (rs @ [r]) ! i \\<in> {y, x}}.\n     ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "also"], ["proof (state)\nthis:\n  ALGxy A (rs @ [r]) init x y =\n  (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n               {i. (rs @ [r]) ! i \\<in> {y, x}}.\n     ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<(Suc (length rs))}. (if i\\<in>{i. (rs @ [r]) ! i \\<in> {y, x}} then\n       ALG' A (rs @ [r]) init i y +\n       ALG' A (rs @ [r]) init i x else 0) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n                 {i. (rs @ [r]) ! i \\<in> {y, x}}.\n       ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x) =\n    (\\<Sum>i<Suc (length rs).\n        if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n        then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0)", "apply(rule sum.inter_restrict)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..<Suc (length rs)}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n               {i. (rs @ [r]) ! i \\<in> {y, x}}.\n     ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x) =\n  (\\<Sum>i<Suc (length rs).\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<Suc (length rs)} \\<inter>\n               {i. (rs @ [r]) ! i \\<in> {y, x}}.\n     ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x) =\n  (\\<Sum>i<Suc (length rs).\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<length rs}. (if i\\<in>{i. (rs @ [r]) ! i \\<in> {y, x}} then\n       ALG' A (rs @ [r]) init i y +\n       ALG' A (rs @ [r]) init i x else 0) ) + (if length rs\\<in>{i. (rs @ [r]) ! i \\<in> {y, x}} then\n       ALG' A (rs @ [r]) init (length rs) y +\n       ALG' A (rs @ [r]) init(length rs) x else 0) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc (length rs).\n        if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n        then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x\n        else 0) =\n    (\\<Sum>i<length rs.\n        if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n        then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x\n        else 0) +\n    (if length rs \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc (length rs).\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0) =\n  (\\<Sum>i<length rs.\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0) +\n  (if length rs \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc (length rs).\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0) =\n  (\\<Sum>i<length rs.\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0) +\n  (if length rs \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "have \"\\<dots> = ALGxy A rs init x y + (if r \\<in> {y, x} then\n       ALG' A (rs @ [r]) init (length rs) y +\n       ALG' A (rs @ [r]) init(length rs) x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length rs.\n        if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n        then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x\n        else 0) +\n    (if length rs \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0) =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "apply(simp add: ALGxy_def sum.inter_restrict nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length rs.\n        if rs ! i = y \\<or> rs ! i = x\n        then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x\n        else 0) =\n    (\\<Sum>xa<length rs.\n        if rs ! xa = y \\<or> rs ! xa = x\n        then ALG' A rs init xa y + ALG' A rs init xa x else 0)", "unfolding ALG'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length rs.\n        if rs ! i = y \\<or> rs ! i = x\n        then E (map_pmf (\\<lambda>x. real (ALG y (rs @ [r]) i x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take i (rs @ [r])))) +\n             E (map_pmf (\\<lambda>xa. real (ALG x (rs @ [r]) i xa))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take i (rs @ [r]))))\n        else 0) =\n    (\\<Sum>xa<length rs.\n        if rs ! xa = y \\<or> rs ! xa = x\n        then E (map_pmf (\\<lambda>x. real (ALG y rs xa x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs))) +\n             E (map_pmf (\\<lambda>xb. real (ALG x rs xa xb))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs)))\n        else 0)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length rs} = {..<length rs}\n 2. \\<And>xa.\n       xa \\<in> {..<length rs} \\<Longrightarrow>\n       (if rs ! xa = y \\<or> rs ! xa = x\n        then E (map_pmf (\\<lambda>x. real (ALG y (rs @ [r]) xa x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa (rs @ [r])))) +\n             E (map_pmf (\\<lambda>xb. real (ALG x (rs @ [r]) xa xb))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa (rs @ [r]))))\n        else 0) =\n       (if rs ! xa = y \\<or> rs ! xa = x\n        then E (map_pmf (\\<lambda>x. real (ALG y rs xa x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs))) +\n             E (map_pmf (\\<lambda>xb. real (ALG x rs xa xb))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs)))\n        else 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length rs} \\<Longrightarrow>\n       (if rs ! xa = y \\<or> rs ! xa = x\n        then E (map_pmf (\\<lambda>x. real (ALG y (rs @ [r]) xa x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa (rs @ [r])))) +\n             E (map_pmf (\\<lambda>xb. real (ALG x (rs @ [r]) xa xb))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa (rs @ [r]))))\n        else 0) =\n       (if rs ! xa = y \\<or> rs ! xa = x\n        then E (map_pmf (\\<lambda>x. real (ALG y rs xa x))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs))) +\n             E (map_pmf (\\<lambda>xb. real (ALG x rs xa xb))\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   (take xa rs)))\n        else 0)", "by(auto simp: nth_append)"], ["proof (state)\nthis:\n  (\\<Sum>i<length rs.\n      if i \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n      then ALG' A (rs @ [r]) init i y + ALG' A (rs @ [r]) init i x else 0) +\n  (if length rs \\<in> {i. (rs @ [r]) ! i \\<in> {y, x}}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0) =\n  ALGxy A rs init x y +\n  (if r \\<in> {y, x}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "finally"], ["proof (chain)\npicking this:\n  ALGxy A (rs @ [r]) init x y =\n  ALGxy A rs init x y +\n  (if r \\<in> {y, x}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ALGxy A (rs @ [r]) init x y =\n  ALGxy A rs init x y +\n  (if r \\<in> {y, x}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A (rs @ [r]) init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "."], ["proof (state)\nthis:\n  ALGxy A (rs @ [r]) init x y =\n  ALGxy A rs init x y +\n  (if r \\<in> {y, x}\n   then ALG' A (rs @ [r]) init (length rs) y +\n        ALG' A (rs @ [r]) init (length rs) x\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ALGxy_wholerange: \"ALGxy A qs init x y\n    = (\\<Sum>i<(length qs). (if qs ! i \\<in> {y, x}\n          then ALG' A qs init i y + ALG' A qs init i x\n          else 0 ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "have \"ALGxy A qs init x y\n      = (\\<Sum>i\\<in> {i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x)", "unfolding ALGxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x) =\n    (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} \\<inter> {i. qs ! i \\<in> {y, x}} =\n    {i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}\n 2. \\<And>xa.\n       xa \\<in> {i. i < length qs} \\<inter>\n                {i. qs ! i \\<in> {y, x}} \\<Longrightarrow>\n       ALG' A qs init xa y + ALG' A qs init xa x =\n       ALG' A qs init xa y + ALG' A qs init xa x", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} \\<inter> {i. qs ! i = y \\<or> qs ! i = x} =\n    {i. i < length qs} \\<inter> {i. qs ! i = y \\<or> qs ! i = x}\n 2. \\<And>xa.\n       xa \\<in> {i. i < length qs} \\<inter>\n                {i. qs ! i \\<in> {y, x}} \\<Longrightarrow>\n       ALG' A qs init xa y + ALG' A qs init xa x =\n       ALG' A qs init xa y + ALG' A qs init xa x", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {i. i < length qs} \\<inter>\n                {i. qs ! i \\<in> {y, x}} \\<Longrightarrow>\n       ALG' A qs init xa y + ALG' A qs init xa x =\n       ALG' A qs init xa y + ALG' A qs init xa x", "by simp"], ["proof (state)\nthis:\n  ALGxy A qs init x y =\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG' A qs init i y + ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "also"], ["proof (state)\nthis:\n  ALGxy A qs init x y =\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG' A qs init i y + ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "have \"\\<dots> = (\\<Sum>i\\<in>{i. i < length qs}.  if i \\<in> {i. qs ! i \\<in> {y, x}}\n                                    then ALG' A qs init i y + ALG' A qs init i x \n                                    else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n       ALG' A qs init i y + ALG' A qs init i x) =\n    (\\<Sum>i | i < length qs.\n       if i \\<in> {i. qs ! i \\<in> {y, x}}\n       then ALG' A qs init i y + ALG' A qs init i x else 0)", "by(rule sum.inter_restrict) simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG' A qs init i y + ALG' A qs init i x) =\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG' A qs init i y + ALG' A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs} \\<inter> {i. qs ! i \\<in> {y, x}}.\n     ALG' A qs init i y + ALG' A qs init i x) =\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG' A qs init i y + ALG' A qs init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "have \"\\<dots> = (\\<Sum>i<(length qs). (if qs ! i \\<in> {y, x}\n          then ALG' A qs init i y + ALG' A qs init i x\n          else 0 ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs.\n       if i \\<in> {i. qs ! i \\<in> {y, x}}\n       then ALG' A qs init i y + ALG' A qs init i x else 0) =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {i. i < length qs} = {..<length qs}\n 2. \\<And>xa.\n       xa \\<in> {..<length qs} \\<Longrightarrow>\n       (if xa \\<in> {i. qs ! i \\<in> {y, x}}\n        then ALG' A qs init xa y + ALG' A qs init xa x else 0) =\n       (if qs ! xa \\<in> {y, x}\n        then ALG' A qs init xa y + ALG' A qs init xa x else 0)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs.\n     if i \\<in> {i. qs ! i \\<in> {y, x}}\n     then ALG' A qs init i y + ALG' A qs init i x else 0) =\n  (\\<Sum>i<length qs.\n      if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "finally"], ["proof (chain)\npicking this:\n  ALGxy A qs init x y =\n  (\\<Sum>i<length qs.\n      if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n      else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ALGxy A qs init x y =\n  (\\<Sum>i<length qs.\n      if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy A qs init x y =\n    (\\<Sum>i<length qs.\n        if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n        else 0)", "."], ["proof (state)\nthis:\n  ALGxy A qs init x y =\n  (\\<Sum>i<length qs.\n      if qs ! i \\<in> {y, x} then ALG' A qs init i y + ALG' A qs init i x\n      else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Transformation to Blocking Cost\""], ["", "lemma umformung:\n  fixes A :: \"(('a::linorder) list,'is,'a,(nat * nat list)) alg_on_rand\"\n  assumes no_paid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s,is) q). paid=[]\"\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\"\n  assumes \"\\<And>x. x < length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x))\"\n  shows \"T\\<^sub>p_on_rand A init qs = \n    (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALGxy A qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have config_dist: \"\\<forall>n. \\<forall>xa \\<in> set_pmf (config'' A qs init n). distinct (fst xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<forall>xa\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand A\n                          (fst A init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          (take n qs)).\n          distinct (fst xa)", "using dist config_rand_distinct"], ["proof (prove)\nusing this:\n  distinct init\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     distinct (fst x) = distinct ?init\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<forall>xa\\<in>set_pmf\n                        (Partial_Cost_Model.config'_rand A\n                          (fst A init \\<bind>\n                           (\\<lambda>is. return_pmf (init, is)))\n                          (take n qs)).\n          distinct (fst xa)", "by metis"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<forall>xa\\<in>set_pmf\n                      (Partial_Cost_Model.config'_rand A\n                        (fst A init \\<bind>\n                         (\\<lambda>is. return_pmf (init, is)))\n                        (take n qs)).\n        distinct (fst xa)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E0: \"T\\<^sub>p_on_rand A init qs =\n        (\\<Sum>i\\<in>{..<length qs}. T\\<^sub>p_on_rand_n A init qs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    sum (Partial_Cost_Model.T_on_rand'_n A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs}", "unfolding T_on_rand_as_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs} =\n    sum (Partial_Cost_Model.T_on_rand'_n A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs}", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  sum (Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n   {..<length qs}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  sum (Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n   {..<length qs}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have \"\\<dots> = \n  (\\<Sum>i<length qs.  E (bind_pmf (config'' A qs init i)\n                          (\\<lambda>s. bind_pmf (snd A s (qs ! i))\n                            (\\<lambda>(a, nis). return_pmf (real (\\<Sum>x\\<in>set init. ALG x qs i s))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (Partial_Cost_Model.T_on_rand'_n A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n     {..<length qs} =\n    (\\<Sum>i<length qs.\n        E (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs) \\<bind>\n           (\\<lambda>s.\n               snd A s (qs ! i) \\<bind>\n               (\\<lambda>(a, nis).\n                   return_pmf\n                    (real (\\<Sum>x\\<in>set init. ALG x qs i s))))))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} = {..<length qs}\n 2. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs x =\n       E (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x qs) \\<bind>\n          (\\<lambda>s.\n              snd A s (qs ! x) \\<bind>\n              (\\<lambda>(a, nis).\n                  return_pmf\n                   (real (\\<Sum>xa\\<in>set init. ALG xa qs x s)))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs x =\n       E (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x qs) \\<bind>\n          (\\<lambda>s.\n              snd A s (qs ! x) \\<bind>\n              (\\<lambda>(a, nis).\n                  return_pmf\n                   (real (\\<Sum>xa\\<in>set init. ALG xa qs x s)))))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       E (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x qs) \\<bind>\n          (\\<lambda>s.\n              snd A s (qs ! x) \\<bind>\n              (\\<lambda>(a, is').\n                  return_pmf (real (t\\<^sub>p (fst s) (qs ! x) a))))) =\n       E (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x qs) \\<bind>\n          (\\<lambda>s.\n              snd A s (qs ! x) \\<bind>\n              (\\<lambda>(a, nis).\n                  return_pmf\n                   (\\<Sum>xa\\<in>set init.\n                      real (if xa < qs ! x in fst s then 1 else 0)))))", "apply(rule arg_cong[where f=E])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take x qs) \\<bind>\n       (\\<lambda>s.\n           snd A s (qs ! x) \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) (qs ! x) a)))) =\n       Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take x qs) \\<bind>\n       (\\<lambda>s.\n           snd A s (qs ! x) \\<bind>\n           (\\<lambda>(a, nis).\n               return_pmf\n                (\\<Sum>xa\\<in>set init.\n                   real (if xa < qs ! x in fst s then 1 else 0))))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take x qs) =\n       Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take x qs)\n 2. \\<And>x xa.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs))\\<rbrakk>\n       \\<Longrightarrow> snd A xa (qs ! x) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (real (t\\<^sub>p (fst xa) (qs ! x) a))) =\n                         snd A xa (qs ! x) \\<bind>\n                         (\\<lambda>(a, nis).\n                             return_pmf\n                              (\\<Sum>xb\\<in>set init.\n                                 real\n                                  (if xb < qs ! x in fst xa then 1 else 0)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs))\\<rbrakk>\n       \\<Longrightarrow> snd A xa (qs ! x) \\<bind>\n                         (\\<lambda>(a, is').\n                             return_pmf\n                              (real (t\\<^sub>p (fst xa) (qs ! x) a))) =\n                         snd A xa (qs ! x) \\<bind>\n                         (\\<lambda>(a, nis).\n                             return_pmf\n                              (\\<Sum>xb\\<in>set init.\n                                 real\n                                  (if xb < qs ! x in fst xa then 1 else 0)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs))\\<rbrakk>\n       \\<Longrightarrow> snd A xa (qs ! x) = snd A xa (qs ! x)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (case xb of\n                          (a, is') \\<Rightarrow>\n                            return_pmf\n                             (real (t\\<^sub>p (fst xa) (qs ! x) a))) =\n                         (case xb of\n                          (a, nis) \\<Rightarrow>\n                            return_pmf\n                             (\\<Sum>xaa\\<in>set init.\n                                real\n                                 (if xaa < qs ! x in fst xa then 1 else 0)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (case xb of\n                          (a, is') \\<Rightarrow>\n                            return_pmf\n                             (real (t\\<^sub>p (fst xa) (qs ! x) a))) =\n                         (case xb of\n                          (a, nis) \\<Rightarrow>\n                            return_pmf\n                             (\\<Sum>xaa\\<in>set init.\n                                real\n                                 (if xaa < qs ! x in fst xa then 1 else 0)))", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> real (t\\<^sub>p (fst xa) (qs ! x) (fst xb)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "apply(subst t\\<^sub>p_sumofALGreal)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> distinct (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 4. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "proof (goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> distinct (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 4. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "case 1"], ["proof (state)\nthis:\n  x_ < length qs\n  xa_\n  \\<in> set_pmf\n         (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x_ qs))\n  xb_ \\<in> set_pmf (snd A xa_ (qs ! x_))\n\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> distinct (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 4. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "then"], ["proof (chain)\npicking this:\n  x_ < length qs\n  xa_\n  \\<in> set_pmf\n         (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x_ qs))\n  xb_ \\<in> set_pmf (snd A xa_ (qs ! x_))", "show ?case"], ["proof (prove)\nusing this:\n  x_ < length qs\n  xa_\n  \\<in> set_pmf\n         (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x_ qs))\n  xb_ \\<in> set_pmf (snd A xa_ (qs ! x_))\n\ngoal (1 subgoal):\n 1. distinct (fst xa_)", "using config_dist"], ["proof (prove)\nusing this:\n  x_ < length qs\n  xa_\n  \\<in> set_pmf\n         (Partial_Cost_Model.config'_rand A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n           (take x_ qs))\n  xb_ \\<in> set_pmf (snd A xa_ (qs ! x_))\n  \\<forall>n.\n     \\<forall>xa\\<in>set_pmf\n                      (Partial_Cost_Model.config'_rand A\n                        (fst A init \\<bind>\n                         (\\<lambda>is. return_pmf (init, is)))\n                        (take n qs)).\n        distinct (fst xa)\n\ngoal (1 subgoal):\n 1. distinct (fst xa_)", "by(metis)"], ["proof (state)\nthis:\n  distinct (fst xa_)\n\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "case (2 a b c)"], ["proof (state)\nthis:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> snd (fst xb) = []\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 3. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "then"], ["proof (chain)\npicking this:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))", "show ?case"], ["proof (prove)\nusing this:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (1 subgoal):\n 1. snd (fst c) = []", "using no_paid[of \"fst b\" \"snd b\"]"], ["proof (prove)\nusing this:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n  \\<forall>((free, paid), uu_)\\<in>set_pmf (snd A (fst b, snd b) ?q).\n     paid = []\n\ngoal (1 subgoal):\n 1. snd (fst c) = []", "by(auto simp add: split_def)"], ["proof (state)\nthis:\n  snd (fst c) = []\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "case (3 a b c)"], ["proof (state)\nthis:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "with config_rand_set"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))", "have a: \"set (fst b) = set init\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (1 subgoal):\n 1. set (fst b) = set init", "by metis"], ["proof (state)\nthis:\n  set (fst b) = set init\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "with inlist"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init\n  set (fst b) = set init", "have \" set qs \\<subseteq> set (fst b)\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  set (fst b) = set init\n\ngoal (1 subgoal):\n 1. set qs \\<subseteq> set (fst b)", "by auto"], ["proof (state)\nthis:\n  set qs \\<subseteq> set (fst b)\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (fst xa)\n 2. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "with 3"], ["proof (chain)\npicking this:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n  set qs \\<subseteq> set (fst b)", "show ?case"], ["proof (prove)\nusing this:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n  set qs \\<subseteq> set (fst b)\n\ngoal (1 subgoal):\n 1. qs ! a \\<in> set (fst b)", "by auto"], ["proof (state)\nthis:\n  qs ! a \\<in> set (fst b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "case (4 a b c)"], ["proof (state)\nthis:\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "with config_rand_set"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))", "have a: \"set (fst b) = set init\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  a < length qs\n  b \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take a qs))\n  c \\<in> set_pmf (snd A b (qs ! a))\n\ngoal (1 subgoal):\n 1. set (fst b) = set init", "by metis"], ["proof (state)\nthis:\n  set (fst b) = set init\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x < length qs;\n        xa \\<in> set_pmf\n                  (Partial_Cost_Model.config'_rand A\n                    (fst A init \\<bind>\n                     (\\<lambda>is. return_pmf (init, is)))\n                    (take x qs));\n        xb \\<in> set_pmf (snd A xa (qs ! x))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>e\\<in>set (fst xa). real (ALG e qs x xa)) =\n                         (\\<Sum>xb\\<in>set init.\n                            real (if xb < qs ! x in fst xa then 1 else 0))", "then"], ["proof (chain)\npicking this:\n  set (fst b) = set init", "show ?case"], ["proof (prove)\nusing this:\n  set (fst b) = set init\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set (fst b). real (ALG e qs a b)) =\n    (\\<Sum>x\\<in>set init. real (if x < qs ! a in fst b then 1 else 0))", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set (fst b). real (ALG e qs a b)) =\n  (\\<Sum>x\\<in>set init. real (if x < qs ! a in fst b then 1 else 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n   {..<length qs} =\n  (\\<Sum>i<length qs.\n      E (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs) \\<bind>\n         (\\<lambda>s.\n             snd A s (qs ! i) \\<bind>\n             (\\<lambda>(a, nis).\n                 return_pmf (real (\\<Sum>x\\<in>set init. ALG x qs i s))))))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "(* hier erst s, dann init *)"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n   {..<length qs} =\n  (\\<Sum>i<length qs.\n      E (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs) \\<bind>\n         (\\<lambda>s.\n             snd A s (qs ! i) \\<bind>\n             (\\<lambda>(a, nis).\n                 return_pmf (real (\\<Sum>x\\<in>set init. ALG x qs i s))))))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  sum (Partial_Cost_Model.T_on_rand'_n A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs)\n   {..<length qs} =\n  (\\<Sum>i<length qs.\n      E (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs) \\<bind>\n         (\\<lambda>s.\n             snd A s (qs ! i) \\<bind>\n             (\\<lambda>(a, nis).\n                 return_pmf (real (\\<Sum>x\\<in>set init. ALG x qs i s))))))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have \"\\<dots> = (\\<Sum>i<length qs.\n               E (map_pmf (\\<lambda>(is, s). (real (\\<Sum>x\\<in>set init. ALG x qs i (is,s))))\n                           (config'' A qs init i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        E (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs) \\<bind>\n           (\\<lambda>s.\n               snd A s (qs ! i) \\<bind>\n               (\\<lambda>(a, nis).\n                   return_pmf\n                    (real (\\<Sum>x\\<in>set init. ALG x qs i s)))))) =\n    (\\<Sum>i<length qs.\n        E (map_pmf\n            (\\<lambda>(is, s).\n                real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n            (Partial_Cost_Model.config'_rand A\n              (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take i qs))))", "apply(simp only: map_pmf_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        E (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs) \\<bind>\n           (\\<lambda>s.\n               snd A s (qs ! i) \\<bind>\n               (\\<lambda>p.\n                   return_pmf\n                    (real (\\<Sum>x\\<in>set init. ALG x qs i s)))))) =\n    (\\<Sum>i<length qs.\n        E (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs) \\<bind>\n           (\\<lambda>x.\n               return_pmf\n                (real\n                  (\\<Sum>xa\\<in>set init. ALG xa qs i (fst x, snd x))))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      E (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs) \\<bind>\n         (\\<lambda>s.\n             snd A s (qs ! i) \\<bind>\n             (\\<lambda>(a, nis).\n                 return_pmf\n                  (real (\\<Sum>x\\<in>set init. ALG x qs i s)))))) =\n  (\\<Sum>i<length qs.\n      E (map_pmf\n          (\\<lambda>(is, s).\n              real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs))))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      E (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take i qs) \\<bind>\n         (\\<lambda>s.\n             snd A s (qs ! i) \\<bind>\n             (\\<lambda>(a, nis).\n                 return_pmf\n                  (real (\\<Sum>x\\<in>set init. ALG x qs i s)))))) =\n  (\\<Sum>i<length qs.\n      E (map_pmf\n          (\\<lambda>(is, s).\n              real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs))))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E1: \"\\<dots> = (\\<Sum>i<length qs. (\\<Sum>x\\<in>set init. ALG' A qs init i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        E (map_pmf\n            (\\<lambda>(is, s).\n                real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n            (Partial_Cost_Model.config'_rand A\n              (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n              (take i qs)))) =\n    (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} = {..<length qs}\n 2. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       E (map_pmf\n           (\\<lambda>(is, s).\n               real (\\<Sum>xa\\<in>set init. ALG xa qs x (is, s)))\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take x qs))) =\n       sum (ALG' A qs init x) (set init)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       E (map_pmf\n           (\\<lambda>(is, s).\n               real (\\<Sum>xa\\<in>set init. ALG xa qs x (is, s)))\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take x qs))) =\n       sum (ALG' A qs init x) (set init)", "apply(simp add: split_def ALG'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       E (map_pmf\n           (\\<lambda>p.\n               \\<Sum>xa\\<in>set init.\n                 real (if xa < qs ! x in fst p then 1 else 0))\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n             (take x qs))) =\n       (\\<Sum>xa\\<in>set init.\n          E (map_pmf\n              (\\<lambda>xb. real (if xa < qs ! x in fst xb then 1 else 0))\n              (Partial_Cost_Model.config'_rand A\n                (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                (take x qs))))", "apply(rule E_linear_sum_allg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       finite\n        (set_pmf\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take x qs)))", "by(rule assms(4))"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      E (map_pmf\n          (\\<lambda>(is, s).\n              real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs)))) =\n  (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      E (map_pmf\n          (\\<lambda>(is, s).\n              real (\\<Sum>x\\<in>set init. ALG x qs i (is, s)))\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take i qs)))) =\n  (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E2: \"\\<dots> = (\\<Sum>x\\<in>set init.\n          (\\<Sum>i<length qs. ALG' A qs init i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init)) =\n    (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x)", "by(rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init)) =\n  (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "(* die summen tauschen *)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init)) =\n  (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. sum (ALG' A qs init i) (set init)) =\n  (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E3: \"\\<dots> = (\\<Sum>x\\<in>set init.\n          (\\<Sum>y\\<in>set init.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG' A qs init i x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x) =\n    (\\<Sum>x\\<in>set init.\n       \\<Sum>y\\<in>set init.\n         \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> set init\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"(\\<Sum>i<length qs. ALG' A qs init i x)\n                = sum (%i. ALG' A qs init i x) {i. i<length qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs. ALG' A qs init i x) =\n    (\\<Sum>i | i < length qs. ALG' A qs init i x)", "by (metis lessThan_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>i | i < length qs. ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>i | i < length qs. ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"\\<dots> = sum (%i. ALG' A qs init i x) \n                        (\\<Union>y\\<in>{y. y \\<in> set init}. {i. i < length qs \\<and> qs ! i = y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs. ALG' A qs init i x) =\n    (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                     {i. i < length qs \\<and> qs ! i = y}).\n       ALG' A qs init i x)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {i. i < length qs} =\n    (\\<Union>y\\<in>{y. y \\<in> set init}.\n        {i. i < length qs \\<and> qs ! i = y})\n 2. \\<And>xa.\n       xa \\<in> (\\<Union>y\\<in>{y. y \\<in> set init}.\n                    {i. i < length qs \\<and> qs ! i = y}) \\<Longrightarrow>\n       ALG' A qs init xa x = ALG' A qs init xa x", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x < length qs \\<Longrightarrow> qs ! x \\<in> set init", "using inlist"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>x. x < length qs \\<Longrightarrow> qs ! x \\<in> set init", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs. ALG' A qs init i x) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs. ALG' A qs init i x) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"\\<dots> = sum (%t. sum (%i. ALG' A qs init i x) {i. i<length qs \\<and> qs ! i = t}) {y. y\\<in> set init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                     {i. i < length qs \\<and> qs ! i = y}).\n       ALG' A qs init i x) =\n    (\\<Sum>t\\<in>{y. y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = t. ALG' A qs init i x)", "apply(rule sum.UNION_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {y. y \\<in> set init}\n 2. \\<forall>i\\<in>{y. y \\<in> set init}.\n       finite {ia. ia < length qs \\<and> qs ! ia = i}\n 3. \\<forall>i\\<in>{y. y \\<in> set init}.\n       \\<forall>j\\<in>{y. y \\<in> set init}.\n          i \\<noteq> j \\<longrightarrow>\n          {ia. ia < length qs \\<and> qs ! ia = i} \\<inter>\n          {i. i < length qs \\<and> qs ! i = j} =\n          {}", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set init.\n       \\<forall>j\\<in>set init.\n          i \\<noteq> j \\<longrightarrow>\n          {ia. ia < length qs \\<and> qs ! ia = i} \\<inter>\n          {i. i < length qs \\<and> qs ! i = j} =\n          {}", "by force"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG' A qs init i x) =\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t. ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG' A qs init i x) =\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t. ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"\\<dots> = (\\<Sum>y\\<in>set init. \\<Sum>i | i < length qs \\<and> qs ! i = y.\n                       ALG' A qs init i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>{y. y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = t. ALG' A qs init i x) =\n    (\\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t. ALG' A qs init i x) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs. ALG' A qs init i x) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs. ALG' A qs init i x) =\n    (\\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "."], ["proof (state)\nthis:\n  (\\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. set init = set init", "qed (simp)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>x\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set init. \\<Sum>i<length qs. ALG' A qs init i x) =\n  (\\<Sum>x\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> (set init \\<times> set init).\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG' A qs init i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set init.\n       \\<Sum>y\\<in>set init.\n         \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by (rule sum.cartesian_product)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> {(x,y). x\\<in>set init \\<and> y\\<in> set init}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG' A qs init i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E4: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x\\<in>set init \\<and> y\\<in> set init \\<and> x\\<noteq>y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG' A qs init i x))\" (is \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f x y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "let ?M = \"{(x,y). x\\<in>set init \\<and> y\\<in> set init \\<and> x=y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have A: \"?L = ?R \\<union> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init} =\n    {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init} =\n  {(x, y).\n   x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have B: \"{} = ?R \\<inter> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} =\n    {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "by auto"], ["proof (state)\nthis:\n  {} =\n  {(x, y).\n   x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R \\<union> ?M. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by(simp only: A)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?M. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "apply(rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n 2. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n 3. {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y} =\n    {}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)\n 3. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n 4. {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y} =\n    {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "have \"(\\<Sum>(x,y)\\<in> ?M. ?f x y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    0", "apply(rule sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n       0", "by (auto simp add: ALG'_refl)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow> x \\<in> set init \\<and> y \\<in> set init.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow> x \\<in> set init \\<and> y \\<in> set init.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG' A qs init i x)\n           + (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=x}. ALG' A qs init i y) )\"\n            (is \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f x y +  ?f y x)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "let ?R' = \"{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> y<x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have A: \"?L = ?R \\<union> ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<union>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} =\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<union>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have \"{} = ?R \\<inter> ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  {} =\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have C: \"?R' = (%(x,y). (y, x)) ` ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    (\\<lambda>(x, y). (y, x)) `\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n  (\\<lambda>(x, y). (y, x)) `\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have D: \"(\\<Sum>(x,y)\\<in> ?R'. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "have \"(\\<Sum>(x,y)\\<in> ?R'. ?f x y) = (\\<Sum>(x,y)\\<in> (%(x,y). (y, x)) ` ?R. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>(\\<lambda>(x, y). (y, x)) `\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by(simp only: C)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>(\\<lambda>(x, y). (y, x)) `\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>(\\<lambda>(x, y). (y, x)) `\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "have \"(\\<Sum>z\\<in> (%(x,y). (y, x)) ` ?R. (%(x,y). ?f x y) z) = (\\<Sum>z\\<in>?R. ((%(x,y). ?f x y) \\<circ> (%(x,y). (y, x))) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n                 {(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       case z of\n       (x, y) \\<Rightarrow>\n         \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    sum ((\\<lambda>(x, y).\n             \\<Sum>i | i < length qs \\<and> qs ! i = y.\n               ALG' A qs init i x) \\<circ>\n         (\\<lambda>(x, y). (y, x)))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "apply(rule sum.reindex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). (y, x))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "by(fact swap_inj_on)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n               {(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG' A qs init i x) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n               {(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG' A qs init i x) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "have \"\\<dots> = (\\<Sum>z\\<in>?R. (%(x,y). ?f y x) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>(x, y).\n             \\<Sum>i | i < length qs \\<and> qs ! i = y.\n               ALG' A qs init i x) \\<circ>\n         (\\<lambda>(x, y). (y, x)))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       case z of\n       (x, y) \\<Rightarrow>\n         \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       ((\\<lambda>(x, y).\n            \\<Sum>i | i < length qs \\<and> qs ! i = y.\n              ALG' A qs init i x) \\<circ>\n        (\\<lambda>(x, y). (y, x)))\n        x =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "by(auto)"], ["proof (state)\nthis:\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG' A qs init i x) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R \\<union> ?R'. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x < y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "by(simp only: A)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?R'. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x < y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)", "apply(rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n 3. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    {}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)\n 3. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n 4. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?R. ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)", "by(simp only: D)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y + ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "by(simp add: split_def sum.distrib[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E5: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i=y \\<or> qs!i=x)}. ALG' A qs init i y + ALG' A qs init i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG' A qs init i y + ALG' A qs init i x)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "obtain a b where x: \"x=(a,b)\" and a: \"a \\<in> set init\" \"b \\<in> set init\" \"a < b\""], ["proof (prove)\nusing this:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = (a, b); a \\<in> set init; b \\<in> set init;\n         a < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "then"], ["proof (chain)\npicking this:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b", "have \"a\\<noteq>b\""], ["proof (prove)\nusing this:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> b", "have disj: \"{i. i < length qs \\<and> qs ! i = b} \\<inter> {i. i < length qs \\<and> qs ! i = a} = {}\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> qs ! i = b} \\<inter>\n    {i. i < length qs \\<and> qs ! i = a} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> qs ! i = b} \\<inter>\n  {i. i < length qs \\<and> qs ! i = a} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "have unio: \"{i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)}\n            = {i. i < length qs \\<and> qs ! i = b} \\<union> {i. i < length qs \\<and> qs ! i = a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)} =\n    {i. i < length qs \\<and> qs ! i = b} \\<union>\n    {i. i < length qs \\<and> qs ! i = a}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)} =\n  {i. i < length qs \\<and> qs ! i = b} \\<union>\n  {i. i < length qs \\<and> qs ! i = a}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "have \"(\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n          {i. i < length qs \\<and> qs ! i = a}. ALG' A qs init i b +\n               ALG' A qs init i a)\n               = (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b}. ALG' A qs init i b +\n               ALG' A qs init i a) + (\\<Sum>i\\<in>\n          {i. i < length qs \\<and> qs ! i = a}. ALG' A qs init i b +\n               ALG' A qs init i a) - (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n          {i. i < length qs \\<and> qs ! i = a}. ALG' A qs init i b +\n               ALG' A qs init i a) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a)", "apply(rule sum_Un)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {i. i < length qs \\<and> qs ! i = b}\n 2. finite {i. i < length qs \\<and> qs ! i = a}", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "have \"\\<dots> = (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b}. ALG' A qs init i b +\n               ALG' A qs init i a) + (\\<Sum>i\\<in>\n          {i. i < length qs \\<and> qs ! i = a}. ALG' A qs init i b +\n               ALG' A qs init i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a)", "using disj"], ["proof (prove)\nusing this:\n  {i. i < length qs \\<and> qs ! i = b} \\<inter>\n  {i. i < length qs \\<and> qs ! i = a} =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "have \"\\<dots> = (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b}. ALG' A qs init i a)\n         + (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = a}. ALG' A qs init i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG' A qs init i b + ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b)", "by (auto simp: ALG'_refl)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG' A qs init i b + ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG' A qs init i y + ALG' A qs init i x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b)\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n    (case x of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG' A qs init i y + ALG' A qs init i x)", "unfolding x"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG' A qs init i b + ALG' A qs init i a) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b)\n\ngoal (1 subgoal):\n 1. (case (a, b) of\n     (x, y) \\<Rightarrow>\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n    (case (a, b) of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG' A qs init i y + ALG' A qs init i x)", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b) \\<Longrightarrow>\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b) =\n    (\\<Sum>i | i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a).\n       ALG' A qs init i b + ALG' A qs init i a)", "unfolding unio"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG' A qs init i b) \\<Longrightarrow>\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b. ALG' A qs init i a) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a. ALG' A qs init i b) =\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG' A qs init i b + ALG' A qs init i a)", "by simp"], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG' A qs init i y + ALG' A qs init i x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG' A qs init i y + ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y. ALG' A qs init i x) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x. ALG' A qs init i y)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG' A qs init i y + ALG' A qs init i x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "have E6: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                  ALGxy A qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG' A qs init i y + ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "unfolding ALGxy_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG' A qs init i y + ALG' A qs init i x) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n         ALG' A qs init i y + ALG' A qs init i x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG' A qs init i y + ALG' A qs init i x) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* this is lemma 1.4 *)"], ["", "lemma before_in_index1:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(if (x < y in l) then 0 else 1) = index l x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y in l then 0 else 1) = index l x", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index l x < index l y \\<and> y \\<in> set l then 0 else 1) =\n    index l x", "proof (auto, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 3. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "(* bad style! *)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 3. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "case 1"], ["proof (state)\nthis:\n  index l x < index l y\n  y \\<in> set l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 3. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have \"index l y < length l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. index l y < length l", "by simp"], ["proof (state)\nthis:\n  index l y < length l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 3. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "with assms(2) 1(1)"], ["proof (chain)\npicking this:\n  length l = 2\n  index l x < index l y\n  index l y < length l", "show \"index l x = 0\""], ["proof (prove)\nusing this:\n  length l = 2\n  index l x < index l y\n  index l y < length l\n\ngoal (1 subgoal):\n 1. index l x = 0", "by auto"], ["proof (state)\nthis:\n  index l x = 0\n\ngoal (2 subgoals):\n 1. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 2. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 2. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "case 2"], ["proof (state)\nthis:\n  \\<not> index l x < index l y\n\ngoal (2 subgoals):\n 1. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 2. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have a: \"index l x < length l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. index l x < length l", "by simp"], ["proof (state)\nthis:\n  index l x < length l\n\ngoal (2 subgoals):\n 1. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 2. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  x \\<noteq> y", "have \"index l y \\<noteq> index l x\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index l y \\<noteq> index l x", "by simp"], ["proof (state)\nthis:\n  index l y \\<noteq> index l x\n\ngoal (2 subgoals):\n 1. \\<not> index l x < index l y \\<Longrightarrow> Suc 0 = index l x\n 2. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "with assms(2) 2(1) a"], ["proof (chain)\npicking this:\n  length l = 2\n  \\<not> index l x < index l y\n  index l x < length l\n  index l y \\<noteq> index l x", "show \"Suc 0 = index l x\""], ["proof (prove)\nusing this:\n  length l = 2\n  \\<not> index l x < index l y\n  index l x < length l\n  index l y \\<noteq> index l x\n\ngoal (1 subgoal):\n 1. Suc 0 = index l x", "by simp"], ["proof (state)\nthis:\n  Suc 0 = index l x\n\ngoal (1 subgoal):\n 1. y \\<notin> set l \\<Longrightarrow> Suc 0 = index l x", "qed (simp add: assms)"], ["", "lemma before_in_index2:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(if (x < y in l) then 1 else 0) = index l y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y in l then 1 else 0) = index l y", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index l x < index l y \\<and> y \\<in> set l then 1 else 0) =\n    index l y", "proof (auto, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. \\<not> index l x < index l y \\<Longrightarrow> index l y = 0\n 3. y \\<notin> set l \\<Longrightarrow> l = []", "(* bad style! *)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. \\<not> index l x < index l y \\<Longrightarrow> index l y = 0\n 3. y \\<notin> set l \\<Longrightarrow> l = []", "case 2"], ["proof (state)\nthis:\n  \\<not> index l x < index l y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. \\<not> index l x < index l y \\<Longrightarrow> index l y = 0\n 3. y \\<notin> set l \\<Longrightarrow> l = []", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  x \\<noteq> y", "have a: \"index l y \\<noteq> index l x\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index l y \\<noteq> index l x", "by simp"], ["proof (state)\nthis:\n  index l y \\<noteq> index l x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. \\<not> index l x < index l y \\<Longrightarrow> index l y = 0\n 3. y \\<notin> set l \\<Longrightarrow> l = []", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have \"index l x < length l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. index l x < length l", "by simp"], ["proof (state)\nthis:\n  index l x < length l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. \\<not> index l x < index l y \\<Longrightarrow> index l y = 0\n 3. y \\<notin> set l \\<Longrightarrow> l = []", "with assms(2) a 2(1)"], ["proof (chain)\npicking this:\n  length l = 2\n  index l y \\<noteq> index l x\n  \\<not> index l x < index l y\n  index l x < length l", "show \"index l y = 0\""], ["proof (prove)\nusing this:\n  length l = 2\n  index l y \\<noteq> index l x\n  \\<not> index l x < index l y\n  index l x < length l\n\ngoal (1 subgoal):\n 1. index l y = 0", "by auto"], ["proof (state)\nthis:\n  index l y = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. y \\<notin> set l \\<Longrightarrow> l = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. y \\<notin> set l \\<Longrightarrow> l = []", "case 1"], ["proof (state)\nthis:\n  index l x < index l y\n  y \\<in> set l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. y \\<notin> set l \\<Longrightarrow> l = []", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have a: \"index l y < length l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. index l y < length l", "by simp"], ["proof (state)\nthis:\n  index l y < length l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. y \\<notin> set l \\<Longrightarrow> l = []", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  x \\<noteq> y", "have \"index l y \\<noteq> index l x\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index l y \\<noteq> index l x", "by simp"], ["proof (state)\nthis:\n  index l y \\<noteq> index l x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> Suc 0 = index l y\n 2. y \\<notin> set l \\<Longrightarrow> l = []", "with assms(2) 1(1) a"], ["proof (chain)\npicking this:\n  length l = 2\n  index l x < index l y\n  index l y < length l\n  index l y \\<noteq> index l x", "show \"Suc 0 = index l y\""], ["proof (prove)\nusing this:\n  length l = 2\n  index l x < index l y\n  index l y < length l\n  index l y \\<noteq> index l x\n\ngoal (1 subgoal):\n 1. Suc 0 = index l y", "by simp"], ["proof (state)\nthis:\n  Suc 0 = index l y\n\ngoal (1 subgoal):\n 1. y \\<notin> set l \\<Longrightarrow> l = []", "qed (simp add: assms)"], ["", "lemma before_in_index:\n  fixes l\n  assumes \"set l = {x,y}\" and \"length l = 2\" and \"x\\<noteq>y\"\n  shows \"(x < y in l) = (index l x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in l = (index l x = 0)", "unfolding before_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index l x < index l y \\<and> y \\<in> set l) = (index l x = 0)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. index l x = 0 \\<Longrightarrow> index l x < index l y\n 3. index l x = 0 \\<Longrightarrow> y \\<in> set l", "case 1"], ["proof (state)\nthis:\n  index l x < index l y\n  y \\<in> set l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. index l x = 0 \\<Longrightarrow> index l x < index l y\n 3. index l x = 0 \\<Longrightarrow> y \\<in> set l", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have \"index l y < length l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. index l y < length l", "by simp"], ["proof (state)\nthis:\n  index l y < length l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>index l x < index l y; y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> index l x = 0\n 2. index l x = 0 \\<Longrightarrow> index l x < index l y\n 3. index l x = 0 \\<Longrightarrow> y \\<in> set l", "with assms(2) 1(1)"], ["proof (chain)\npicking this:\n  length l = 2\n  index l x < index l y\n  index l y < length l", "show \"index l x = 0\""], ["proof (prove)\nusing this:\n  length l = 2\n  index l x < index l y\n  index l y < length l\n\ngoal (1 subgoal):\n 1. index l x = 0", "by auto"], ["proof (state)\nthis:\n  index l x = 0\n\ngoal (2 subgoals):\n 1. index l x = 0 \\<Longrightarrow> index l x < index l y\n 2. index l x = 0 \\<Longrightarrow> y \\<in> set l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. index l x = 0 \\<Longrightarrow> index l x < index l y\n 2. index l x = 0 \\<Longrightarrow> y \\<in> set l", "case 2"], ["proof (state)\nthis:\n  index l x = 0\n\ngoal (2 subgoals):\n 1. index l x = 0 \\<Longrightarrow> index l x < index l y\n 2. index l x = 0 \\<Longrightarrow> y \\<in> set l", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  x \\<noteq> y", "have \"index l y \\<noteq> index l x\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index l y \\<noteq> index l x", "by simp"], ["proof (state)\nthis:\n  index l y \\<noteq> index l x\n\ngoal (2 subgoals):\n 1. index l x = 0 \\<Longrightarrow> index l x < index l y\n 2. index l x = 0 \\<Longrightarrow> y \\<in> set l", "with 2(1)"], ["proof (chain)\npicking this:\n  index l x = 0\n  index l y \\<noteq> index l x", "show \"index l x < index l y\""], ["proof (prove)\nusing this:\n  index l x = 0\n  index l y \\<noteq> index l x\n\ngoal (1 subgoal):\n 1. index l x < index l y", "by simp"], ["proof (state)\nthis:\n  index l x < index l y\n\ngoal (1 subgoal):\n 1. index l x = 0 \\<Longrightarrow> y \\<in> set l", "qed (simp add: assms)"], ["", "subsection \"The pairwise property\""], ["", "definition pairwise where\n  \"pairwise A = (\\<forall>init. distinct init \\<longrightarrow> (\\<forall>qs\\<in>{xs. set xs \\<subseteq> set init}. \\<forall>(x::('a::linorder),y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. T\\<^sub>p_on_rand A (Lxy init {x,y}) (Lxy qs {x,y}) = ALGxy A qs init x y))\""], ["", "definition \"Pbefore_in x y A qs init = map_pmf (\\<lambda>p. x < y in fst p) (config_rand A init qs)\""], ["", "lemma T_on_n_no_paid:\n      assumes \n      nopaid: \"\\<And>s n. map_pmf (\\<lambda>x. snd (fst x)) (snd A s n) = return_pmf []\" \n      shows \"T_on_rand_n A init qs i = E (config'' A qs init i \\<bind> (\\<lambda>p. return_pmf (real(index (fst p) (qs ! i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "have \"(\\<lambda>s. snd A s (qs ! i) \\<bind>\n            (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a))))\n       =\n        (\\<lambda>s. (snd A s (qs ! i) \\<bind> (\\<lambda>x. return_pmf (snd (fst x))))\n              \\<bind> (\\<lambda>p. return_pmf\n               (real (index (swaps p (fst s)) (qs ! i)) +\n                real (length p))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        snd A s (qs ! i) \\<bind>\n        (\\<lambda>(a, is').\n            return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a)))) =\n    (\\<lambda>s.\n        snd A s (qs ! i) \\<bind>\n        (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n        (\\<lambda>p.\n            return_pmf\n             (real (index (swaps p (fst s)) (qs ! i)) + real (length p))))", "by(simp add: t\\<^sub>p_def split_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>(a, is').\n          return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a)))) =\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n      (\\<lambda>p.\n          return_pmf\n           (real (index (swaps p (fst s)) (qs ! i)) + real (length p))))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "also"], ["proof (state)\nthis:\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>(a, is').\n          return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a)))) =\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n      (\\<lambda>p.\n          return_pmf\n           (real (index (swaps p (fst s)) (qs ! i)) + real (length p))))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "have \"\\<dots> = (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        snd A s (qs ! i) \\<bind>\n        (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n        (\\<lambda>p.\n            return_pmf\n             (real (index (swaps p (fst s)) (qs ! i)) + real (length p)))) =\n    (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))", "using nopaid[unfolded map_pmf_def]"], ["proof (prove)\nusing this:\n  snd A ?s ?n \\<bind> (\\<lambda>x. return_pmf (snd (fst x))) = return_pmf []\n\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        snd A s (qs ! i) \\<bind>\n        (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n        (\\<lambda>p.\n            return_pmf\n             (real (index (swaps p (fst s)) (qs ! i)) + real (length p)))) =\n    (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))", "by(simp add: split_def bind_return_pmf)"], ["proof (state)\nthis:\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>x. return_pmf (snd (fst x))) \\<bind>\n      (\\<lambda>p.\n          return_pmf\n           (real (index (swaps p (fst s)) (qs ! i)) + real (length p)))) =\n  (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>(a, is').\n          return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a)))) =\n  (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>s.\n      snd A s (qs ! i) \\<bind>\n      (\\<lambda>(a, is').\n          return_pmf (real (t\\<^sub>p (fst s) (qs ! i) a)))) =\n  (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i))))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.T_on_rand'_n A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n    E (Partial_Cost_Model.config'_rand A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n        (take i qs) \\<bind>\n       (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.T_on_rand'_n A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs i =\n  E (Partial_Cost_Model.config'_rand A\n      (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n      (take i qs) \\<bind>\n     (\\<lambda>p. return_pmf (real (index (fst p) (qs ! i)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairwise_property_lemma:\n  assumes  \nrelativeorder: \"(\\<And>init qs. distinct init \\<Longrightarrow> qs \\<in> {xs. set xs \\<subseteq> set init}\n    \\<Longrightarrow> (\\<And>x y. (x,y)\\<in> {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x\\<noteq>y} \n                \\<Longrightarrow> x \\<noteq> y\n                \\<Longrightarrow> Pbefore_in x y A qs init = Pbefore_in x y A (Lxy qs {x,y}) (Lxy init {x,y})\n        ))\" \nand nopaid: \"\\<And>xa r. \\<forall>z\\<in> set_pmf(snd A xa r). snd(fst z) = []\"\nshows \"pairwise A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Factoring.pairwise A", "unfolding pairwise_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>init.\n       distinct init \\<longrightarrow>\n       (\\<forall>qs\\<in>{xs. set xs \\<subseteq> set init}.\n           \\<forall>(x, y)\n                    \\<in>{(x, y).\n                          x \\<in> set init \\<and>\n                          y \\<in> set init \\<and> x < y}.\n              T\\<^sub>p_on_rand' A\n               (fst A (Lxy init {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n               (Lxy qs {x, y}) =\n              ALGxy A qs init x y)", "proof (clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "case (1 init rs x y)"], ["proof (state)\nthis:\n  distinct init\n  set rs \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "then"], ["proof (chain)\npicking this:\n  distinct init\n  set rs \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y", "have xny: \"x\\<noteq>y\""], ["proof (prove)\nusing this:\n  distinct init\n  set rs \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "note dinit=1(1)"], ["proof (state)\nthis:\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "then"], ["proof (chain)\npicking this:\n  distinct init", "have dLyx: \"distinct (Lxy init {y,x})\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {y, x})", "by(rule Lxy_distinct)"], ["proof (state)\nthis:\n  distinct (Lxy init {y, x})\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "from dinit"], ["proof (chain)\npicking this:\n  distinct init", "have dLxy: \"distinct (Lxy init {x,y})\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "by(rule Lxy_distinct)"], ["proof (state)\nthis:\n  distinct (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "have setLxy: \"set (Lxy init {x, y}) = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "apply(subst Lxy_set_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "using 1"], ["proof (prove)\nusing this:\n  distinct init\n  set rs \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y\n\ngoal (1 subgoal):\n 1. {x, y} \\<inter> set init = {x, y}", "by auto"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "have setLyx: \"set (Lxy init {y, x}) = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Lxy init {y, x}) = {x, y}", "apply(subst Lxy_set_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y, x} \\<inter> set init = {x, y}", "using 1"], ["proof (prove)\nusing this:\n  distinct init\n  set rs \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y\n\ngoal (1 subgoal):\n 1. {y, x} \\<inter> set init = {x, y}", "by auto"], ["proof (state)\nthis:\n  set (Lxy init {y, x}) = {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "have lengthLyx:\" length  (Lxy init {y, x}) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {y, x}) = 2", "using setLyx distinct_card[OF dLyx] xny"], ["proof (prove)\nusing this:\n  set (Lxy init {y, x}) = {x, y}\n  card (set (Lxy init {y, x})) = length (Lxy init {y, x})\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. length (Lxy init {y, x}) = 2", "by simp"], ["proof (state)\nthis:\n  length (Lxy init {y, x}) = 2\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "have lengthLxy:\" length  (Lxy init {x, y}) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "using setLxy distinct_card[OF dLxy] xny"], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {x, y}\n  card (set (Lxy init {x, y})) = length (Lxy init {x, y})\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "by simp"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = 2\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "have aee: \"{x,y} = {y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {y, x}", "by auto"], ["proof (state)\nthis:\n  {x, y} = {y, x}\n\ngoal (1 subgoal):\n 1. \\<And>init qs a b.\n       \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n        a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {a, b}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {a, b}, is)))\n                          (Lxy qs {a, b}) =\n                         ALGxy A qs init a b", "from 1(2)"], ["proof (chain)\npicking this:\n  set rs \\<subseteq> set init", "show ?case"], ["proof (prove)\nusing this:\n  set rs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    ALGxy A rs init x y", "proof(induct rs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y}) =\n    ALGxy A [] init x y\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                T\\<^sub>p_on_rand' A\n                 (fst A (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y}) =\n                ALGxy A xs init x y;\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y}) =\n                         ALGxy A (xs @ [xa]) init x y", "case (snoc r rs)"], ["proof (state)\nthis:\n  set rs \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n  set (rs @ [r]) \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y}) =\n    ALGxy A [] init x y\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                T\\<^sub>p_on_rand' A\n                 (fst A (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y}) =\n                ALGxy A xs init x y;\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y}) =\n                         ALGxy A (xs @ [xa]) init x y", "have b: \"Pbefore_in x y A rs init = Pbefore_in x y A (Lxy rs {x,y}) (Lxy init {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pbefore_in x y A rs init =\n    Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})", "apply(rule relativeorder)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct init\n 2. rs \\<in> {xs. set xs \\<subseteq> set init}\n 3. (x, y)\n    \\<in> {(x, y).\n           x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n 4. x \\<noteq> y", "using snoc 1 xny"], ["proof (prove)\nusing this:\n  set rs \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n  set (rs @ [r]) \\<subseteq> set init\n  distinct init\n  set rs__ \\<subseteq> set init\n  x \\<in> set init\n  y \\<in> set init\n  x < y\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. distinct init\n 2. rs \\<in> {xs. set xs \\<subseteq> set init}\n 3. (x, y)\n    \\<in> {(x, y).\n           x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n 4. x \\<noteq> y", "by(simp_all)"], ["proof (state)\nthis:\n  Pbefore_in x y A rs init =\n  Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y}) =\n    ALGxy A [] init x y\n 2. \\<And>xa xs.\n       \\<lbrakk>set xs \\<subseteq> set init \\<Longrightarrow>\n                T\\<^sub>p_on_rand' A\n                 (fst A (Lxy init {x, y}) \\<bind>\n                  (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                 (Lxy xs {x, y}) =\n                ALGxy A xs init x y;\n        set (xs @ [xa]) \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_on_rand' A\n                          (fst A (Lxy init {x, y}) \\<bind>\n                           (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                          (Lxy (xs @ [xa]) {x, y}) =\n                         ALGxy A (xs @ [xa]) init x y", "show ?case (is \"?L (rs @ [r]) = ?R (rs @ [r])\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "proof(cases \"r\\<in>{x,y}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "case True"], ["proof (state)\nthis:\n  r \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "note xyrequest=this"], ["proof (state)\nthis:\n  r \\<in> {x, y}\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "let ?expr = \"E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s. snd A s r \\<bind>\n            (\\<lambda>(a, is').\n                return_pmf\n                 (real (t\\<^sub>p (fst s) r a)))))\""], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "let ?expr2 = \"ALG' A (rs @ [r]) init (length rs) y + ALG' A (rs @ [r]) init (length rs) x\""], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "from xyrequest"], ["proof (chain)\npicking this:\n  r \\<in> {x, y}", "have \"?L (rs @ [r]) = ?L rs + ?expr\""], ["proof (prove)\nusing this:\n  r \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))))", "by(simp add: Lxy_snoc T_on_rand'_append)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))))\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))))\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "have \"\\<dots> = ?L rs + ?expr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "proof(cases \"r=x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "case True"], ["proof (state)\nthis:\n  r = x\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "let ?projS =\"config'_rand A (fst A (Lxy init {x, y}) \\<bind> (\\<lambda>is. return_pmf (Lxy init {x, y}, is))) (Lxy rs {x, y})\""], ["proof (state)\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "let ?S = \"(config'_rand A (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"?projS \\<bind> (\\<lambda>s. snd A s r\n                           \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))\n              = ?projS \\<bind> (\\<lambda>s. return_pmf (real (index (fst s) r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r)))", "proof (rule bind_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "have \"snd A z r \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) = snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd A z r \\<bind>\n    (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n    snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd A z r = snd A z r\n 2. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "using nopaid[of z r]"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set_pmf (snd A z r). snd (fst z) = []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "by(simp add: split_def t\\<^sub>p_def)"], ["proof (state)\nthis:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "then"], ["proof (chain)\npicking this:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))", "show ?case"], ["proof (prove)\nusing this:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\n\ngoal (1 subgoal):\n 1. snd A z r \\<bind>\n    (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n    return_pmf (real (index (fst z) r))", "by(simp add: bind_return_pmf)"], ["proof (state)\nthis:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  return_pmf (real (index (fst z) r))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})", "qed simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r)))\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r)))\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (%b. (if b then 0::real else 1)) (Pbefore_in x y A (Lxy rs {x,y}) (Lxy init {x,y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    map_pmf (\\<lambda>b. if b then 0 else 1)\n     (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))", "unfolding Pbefore_in_def map_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>xa. return_pmf (x < y in fst xa)) \\<bind>\n    (\\<lambda>x. return_pmf (if x then 0 else 1))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>xa. return_pmf (if x < y in fst xa then 0 else 1))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 0 else 1)", "apply(simp add: aee)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 0 else 1)", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 0 else 1)", "case (1 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 0 else 1)", "have \" (if x < y in fst z then 0 else 1) = (index (fst z) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y in fst z then 0 else 1) = index (fst z) x", "apply(rule before_in_index1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (fst z) = {x, y}\n 2. length (fst z) = 2\n 3. x \\<noteq> y", "using 1 config_rand_set setLxy"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (3 subgoals):\n 1. set (fst z) = {x, y}\n 2. length (fst z) = 2\n 3. x \\<noteq> y", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (fst z) = 2\n 2. x \\<noteq> y", "using 1 config_rand_length lengthLxy"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init\n  length (Lxy init {x, y}) = 2\n\ngoal (2 subgoals):\n 1. length (fst z) = 2\n 2. x \\<noteq> y", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "using xny"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by simp"], ["proof (state)\nthis:\n  (if x < y in fst z then 0 else 1) = index (fst z) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 0 else 1)", "with True"], ["proof (chain)\npicking this:\n  r = x\n  (if x < y in fst z then 0 else 1) = index (fst z) x", "show ?case"], ["proof (prove)\nusing this:\n  r = x\n  (if x < y in fst z then 0 else 1) = index (fst z) x\n\ngoal (1 subgoal):\n 1. return_pmf (real (index (fst z) r)) =\n    return_pmf (if x < y in fst z then 0 else 1)", "by(auto)"], ["proof (state)\nthis:\n  return_pmf (real (index (fst z) r)) =\n  return_pmf (if x < y in fst z then 0 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n  map_pmf (\\<lambda>b. if b then 0 else 1)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n  map_pmf (\\<lambda>b. if b then 0 else 1)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (%b. (if b then 0::real else 1)) (Pbefore_in x y A rs init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>b. if b then 0 else 1)\n     (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n    map_pmf (\\<lambda>b. if b then 0 else 1) (Pbefore_in x y A rs init)", "by(simp add: b)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 0 else 1)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n  map_pmf (\\<lambda>b. if b then 0 else 1) (Pbefore_in x y A rs init)\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 0 else 1)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n  map_pmf (\\<lambda>b. if b then 0 else 1) (Pbefore_in x y A rs init)\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0)) ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>b. if b then 0 else 1) (Pbefore_in x y A rs init) =\n    map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "apply(simp add: Pbefore_in_def map_pmf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>xa. if x < y in fst xa then 0 else 1)\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs) =\n    map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "proof (rule map_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   rs) \\<Longrightarrow>\n       (if x < y in fst xa then 0 else 1) =\n       real (if y < x in fst xa then 1 else 0)", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   rs) \\<Longrightarrow>\n       (if x < y in fst xa then 0 else 1) =\n       real (if y < x in fst xa then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "have set_z: \"set (fst z) = set init\""], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "using config_rand_set"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n\ngoal (1 subgoal):\n 1. set (fst z) = set init", "by fast"], ["proof (state)\nthis:\n  set (fst z) = set init\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   rs) \\<Longrightarrow>\n       (if x < y in fst xa then 0 else 1) =\n       real (if y < x in fst xa then 1 else 0)", "have \"(\\<not> x < y in fst z) = y < x in fst z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x < y in fst z) = y < x in fst z", "apply(subst not_before_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> set (fst z)\n 2. y \\<in> set (fst z)\n 3. (y < x in fst z \\<or> x = y) = y < x in fst z", "using set_z 1(3,4) xny"], ["proof (prove)\nusing this:\n  set (fst z) = set init\n  x \\<in> set init\n  y \\<in> set init\n  x \\<noteq> y\n\ngoal (3 subgoals):\n 1. x \\<in> set (fst z)\n 2. y \\<in> set (fst z)\n 3. (y < x in fst z \\<or> x = y) = y < x in fst z", "by(simp_all)"], ["proof (state)\nthis:\n  (\\<not> x < y in fst z) = y < x in fst z\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   rs) \\<Longrightarrow>\n       (if x < y in fst xa then 0 else 1) =\n       real (if y < x in fst xa then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<not> x < y in fst z) = y < x in fst z", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> x < y in fst z) = y < x in fst z\n\ngoal (1 subgoal):\n 1. (if x < y in fst z then 0 else 1) =\n    real (if y < x in fst z then 1 else 0)", "by(simp add: )"], ["proof (state)\nthis:\n  (if x < y in fst z then 0 else 1) = real (if y < x in fst z then 1 else 0)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs", "qed simp"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 0 else 1) (Pbefore_in x y A rs init) =\n  map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "have a: \"?projS \\<bind> (\\<lambda>s. snd A s x\n                           \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a))))\n                  = map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0)) ?S\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a)))) =\n    map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "using True"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n  r = x\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s x \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a)))) =\n    map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s x \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) x a)))) =\n  map_pmf (\\<lambda>xa. real (if y < x in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (2 subgoals):\n 1. r = x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)\n 2. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "from True"], ["proof (chain)\npicking this:\n  r = x", "show ?thesis"], ["proof (prove)\nusing this:\n  r = x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "apply(simp add: ALG'_refl nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = x \\<Longrightarrow>\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    ALG' A (rs @ [x]) init (length rs) y", "unfolding ALG'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = x \\<Longrightarrow>\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s x \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) x a))))) =\n    E (map_pmf (\\<lambda>xa. real (ALG y (rs @ [x]) (length rs) xa))\n        (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take (length rs) (rs @ [x]))))", "by(simp add: a)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> x\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "with xyrequest"], ["proof (chain)\npicking this:\n  r \\<in> {x, y}\n  r \\<noteq> x", "have request: \"r=y\""], ["proof (prove)\nusing this:\n  r \\<in> {x, y}\n  r \\<noteq> x\n\ngoal (1 subgoal):\n 1. r = y", "by blast"], ["proof (state)\nthis:\n  r = y\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "let ?projS =\"config'_rand A (fst A (Lxy init {x, y}) \\<bind> (\\<lambda>is. return_pmf (Lxy init {x, y}, is))) (Lxy rs {x, y})\""], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "let ?S = \"(config'_rand A (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"?projS \\<bind> (\\<lambda>s. snd A s r\n                           \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))\n              = ?projS \\<bind> (\\<lambda>s. return_pmf (real (index (fst s) r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s r \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r)))", "proof (rule bind_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "have \"snd A z r \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) = snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd A z r \\<bind>\n    (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n    snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd A z r = snd A z r\n 2. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "using nopaid[of z r]"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set_pmf (snd A z r). snd (fst z) = []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (snd A z r) \\<Longrightarrow>\n       (case x of\n        (a, is') \\<Rightarrow> return_pmf (real (t\\<^sub>p (fst z) r a))) =\n       return_pmf (real (index (fst z) r))", "by(simp add: split_def t\\<^sub>p_def)"], ["proof (state)\nthis:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\n\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       snd A xa r \\<bind>\n       (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst xa) r a))) =\n       return_pmf (real (index (fst xa) r))", "then"], ["proof (chain)\npicking this:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))", "show ?case"], ["proof (prove)\nusing this:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  snd A z r \\<bind> (\\<lambda>x. return_pmf (real (index (fst z) r)))\n\ngoal (1 subgoal):\n 1. snd A z r \\<bind>\n    (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n    return_pmf (real (index (fst z) r))", "by(simp add: bind_return_pmf)"], ["proof (state)\nthis:\n  snd A z r \\<bind>\n  (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst z) r a))) =\n  return_pmf (real (index (fst z) r))\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})", "qed simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r)))\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r)))\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (%b. (if b then 1::real else 0)) (Pbefore_in x y A (Lxy rs {x,y}) (Lxy init {x,y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    map_pmf (\\<lambda>b. if b then 1 else 0)\n     (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))", "unfolding Pbefore_in_def map_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>xa. return_pmf (x < y in fst xa)) \\<bind>\n    (\\<lambda>x. return_pmf (if x then 1 else 0))", "apply(simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>xa. return_pmf (if x < y in fst xa then 1 else 0))", "apply(rule bind_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 1 else 0)", "apply(simp add: aee)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 1 else 0)", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 1 else 0)", "case (1 z)"], ["proof (state)\nthis:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 1 else 0)", "have \" (if x < y in fst z then 1 else 0) = (index (fst z) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y in fst z then 1 else 0) = index (fst z) y", "apply(rule before_in_index2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (fst z) = {x, y}\n 2. length (fst z) = 2\n 3. x \\<noteq> y", "using 1 config_rand_set setLxy"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     set (fst x) = set ?init\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (3 subgoals):\n 1. set (fst z) = {x, y}\n 2. length (fst z) = 2\n 3. x \\<noteq> y", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (fst z) = 2\n 2. x \\<noteq> y", "using 1 config_rand_length lengthLxy"], ["proof (prove)\nusing this:\n  z \\<in> set_pmf\n           (Partial_Cost_Model.config'_rand A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy rs {x, y}))\n  \\<forall>x\\<in>set_pmf\n                  (Partial_Cost_Model.config'_rand ?A\n                    (fst ?A ?init \\<bind>\n                     (\\<lambda>is. return_pmf (?init, is)))\n                    ?qs).\n     length (fst x) = length ?init\n  length (Lxy init {x, y}) = 2\n\ngoal (2 subgoals):\n 1. length (fst z) = 2\n 2. x \\<noteq> y", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "using xny"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by simp"], ["proof (state)\nthis:\n  (if x < y in fst z then 1 else 0) = index (fst z) y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A (Lxy init {x, y}) \\<bind>\n                    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                   (Lxy rs {x, y})) \\<Longrightarrow>\n       return_pmf (real (index (fst xa) r)) =\n       return_pmf (if x < y in fst xa then 1 else 0)", "with request"], ["proof (chain)\npicking this:\n  r = y\n  (if x < y in fst z then 1 else 0) = index (fst z) y", "show ?case"], ["proof (prove)\nusing this:\n  r = y\n  (if x < y in fst z then 1 else 0) = index (fst z) y\n\ngoal (1 subgoal):\n 1. return_pmf (real (index (fst z) r)) =\n    return_pmf (if x < y in fst z then 1 else 0)", "by(auto)"], ["proof (state)\nthis:\n  return_pmf (real (index (fst z) r)) =\n  return_pmf (if x < y in fst z then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n  map_pmf (\\<lambda>b. if b then 1 else 0)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s. return_pmf (real (index (fst s) r))) =\n  map_pmf (\\<lambda>b. if b then 1 else 0)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y}))\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (%b. (if b then 1::real else 0)) (Pbefore_in x y A rs init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>b. if b then 1 else 0)\n     (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n    map_pmf (\\<lambda>b. if b then 1 else 0) (Pbefore_in x y A rs init)", "by(simp add: b)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 1 else 0)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n  map_pmf (\\<lambda>b. if b then 1 else 0) (Pbefore_in x y A rs init)\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 1 else 0)\n   (Pbefore_in x y A (Lxy rs {x, y}) (Lxy init {x, y})) =\n  map_pmf (\\<lambda>b. if b then 1 else 0) (Pbefore_in x y A rs init)\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "have \"\\<dots> = map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0)) ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>b. if b then 1 else 0) (Pbefore_in x y A rs init) =\n    map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "apply(simp add: Pbefore_in_def map_pmf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>xa. if x < y in fst xa then 1 else 0)\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs) =\n    map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "apply (rule map_pmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs =\n    Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs\n 2. \\<And>xa.\n       xa \\<in> set_pmf\n                 (Partial_Cost_Model.config'_rand A\n                   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n                   rs) \\<Longrightarrow>\n       (if x < y in fst xa then 1 else 0) =\n       real (if x < y in fst xa then 1 else 0)", "by simp_all"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then 1 else 0) (Pbefore_in x y A rs init) =\n  map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "finally"], ["proof (chain)\npicking this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "have a: \"?projS \\<bind> (\\<lambda>s. snd A s y\n                           \\<bind> (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a))))\n                  = map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0)) ?S\""], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a)))) =\n    map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "using request"], ["proof (prove)\nusing this:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s r \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a)))) =\n  map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n  r = y\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.config'_rand A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) \\<bind>\n    (\\<lambda>s.\n        snd A s y \\<bind>\n        (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a)))) =\n    map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n     (Partial_Cost_Model.config'_rand A\n       (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.config'_rand A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) \\<bind>\n  (\\<lambda>s.\n      snd A s y \\<bind>\n      (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) y a)))) =\n  map_pmf (\\<lambda>xa. real (if x < y in fst xa then 1 else 0))\n   (Partial_Cost_Model.config'_rand A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) rs)\n\ngoal (1 subgoal):\n 1. r \\<noteq> x \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "from request"], ["proof (chain)\npicking this:\n  r = y", "show ?thesis"], ["proof (prove)\nusing this:\n  r = y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s r \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "apply(simp add: ALG'_refl nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = y \\<Longrightarrow>\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    ALG' A (rs @ [y]) init (length rs) x", "unfolding ALG'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = y \\<Longrightarrow>\n    E (Partial_Cost_Model.config'_rand A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy rs {x, y}) \\<bind>\n       (\\<lambda>s.\n           snd A s y \\<bind>\n           (\\<lambda>(a, is').\n               return_pmf (real (t\\<^sub>p (fst s) y a))))) =\n    E (map_pmf (\\<lambda>xa. real (ALG x (rs @ [y]) (length rs) xa))\n        (Partial_Cost_Model.config'_rand A\n          (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n          (take (length rs) (rs @ [y]))))", "by(simp add: a)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  E (Partial_Cost_Model.config'_rand A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy rs {x, y}) \\<bind>\n     (\\<lambda>s.\n         snd A s r \\<bind>\n         (\\<lambda>(a, is'). return_pmf (real (t\\<^sub>p (fst s) r a))))) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "have \"\\<dots> = ?R rs + ?expr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x) =\n    ALGxy A rs init x y +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "using snoc"], ["proof (prove)\nusing this:\n  set rs \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n  set (rs @ [r]) \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x) =\n    ALGxy A rs init x y +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x)", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x) =\n  ALGxy A rs init x y +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x) =\n  ALGxy A rs init x y +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x)\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "from True"], ["proof (chain)\npicking this:\n  r \\<in> {x, y}", "have \"\\<dots> = ?R (rs@[r])\""], ["proof (prove)\nusing this:\n  r \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. ALGxy A rs init x y +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x) =\n    ALGxy A (rs @ [r]) init x y", "apply(subst ALGxy_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    ALGxy A rs init x y +\n    (ALG' A (rs @ [r]) init (length rs) y +\n     ALG' A (rs @ [r]) init (length rs) x) =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "by(auto)"], ["proof (state)\nthis:\n  ALGxy A rs init x y +\n  (ALG' A (rs @ [r]) init (length rs) y +\n   ALG' A (rs @ [r]) init (length rs) x) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal (2 subgoals):\n 1. r \\<in> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y\n 2. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "case False"], ["proof (state)\nthis:\n  r \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "then"], ["proof (chain)\npicking this:\n  r \\<notin> {x, y}", "have \"?L (rs @ [r]) = ?L rs\""], ["proof (prove)\nusing this:\n  r \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})", "apply(subst Lxy_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (if r \\<in> {x, y} then Lxy rs {x, y} @ [r] else Lxy rs {x, y}) =\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y})", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y})\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y})\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "have \"\\<dots> = ?R rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    ALGxy A rs init x y", "using snoc"], ["proof (prove)\nusing this:\n  set rs \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n  set (rs @ [r]) \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy rs {x, y}) =\n    ALGxy A rs init x y", "by(simp)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "have \"\\<dots> = ?R (rs @ [r])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A rs init x y = ALGxy A (rs @ [r]) init x y", "apply(subst ALGxy_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy A rs init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "using False"], ["proof (prove)\nusing this:\n  r \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. ALGxy A rs init x y =\n    ALGxy A rs init x y +\n    (if r \\<in> {y, x}\n     then ALG' A (rs @ [r]) init (length rs) y +\n          ALG' A (rs @ [r]) init (length rs) x\n     else 0)", "by(simp)"], ["proof (state)\nthis:\n  ALGxy A rs init x y = ALGxy A (rs @ [r]) init x y\n\ngoal (1 subgoal):\n 1. r \\<notin> {x, y} \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy (rs @ [r]) {x, y}) =\n    ALGxy A (rs @ [r]) init x y", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy (rs @ [r]) {x, y}) =\n  ALGxy A (rs @ [r]) init x y\n\ngoal (1 subgoal):\n 1. set [] \\<subseteq> set init \\<Longrightarrow>\n    T\\<^sub>p_on_rand' A\n     (fst A (Lxy init {x, y}) \\<bind>\n      (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n     (Lxy [] {x, y}) =\n    ALGxy A [] init x y", "qed (simp add: ALGxy_def)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A (Lxy init {x, y}) \\<bind>\n    (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n   (Lxy rs {x, y}) =\n  ALGxy A rs init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma umf_pair: assumes\n   0: \"pairwise A\"\n  assumes 1: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n  assumes 2: \"set qs \\<subseteq> set init\"\n  assumes 3: \"distinct init\"\n  assumes 4: \"\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x))\"\n   shows \"T\\<^sub>p_on_rand A init qs\n      = (\\<Sum>(x,y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}. T\\<^sub>p_on_rand A (Lxy init {x,y}) (Lxy qs {x,y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "have \" T\\<^sub>p_on_rand A init qs = (\\<Sum>(x,y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}. ALGxy A qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y)", "by(simp only: umformung[OF 1 2 3 4])"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}. T\\<^sub>p_on_rand A (Lxy init {x,y}) (Lxy qs {x,y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy A qs init x y) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> ALGxy A qs init x y) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> ALGxy A qs init x y) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}))", "using 0[unfolded pairwise_def] 2 3"], ["proof (prove)\nusing this:\n  \\<forall>init.\n     distinct init \\<longrightarrow>\n     (\\<forall>qs\\<in>{xs. set xs \\<subseteq> set init}.\n         \\<forall>(x, y)\n                  \\<in>{(x, y).\n                        x \\<in> set init \\<and>\n                        y \\<in> set init \\<and> x < y}.\n            T\\<^sub>p_on_rand' A\n             (fst A (Lxy init {x, y}) \\<bind>\n              (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n             (Lxy qs {x, y}) =\n            ALGxy A qs init x y)\n  set qs \\<subseteq> set init\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of (x, y) \\<Rightarrow> ALGxy A qs init x y) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy A qs init x y) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"List Factoring for OPT\""], ["", "(* calculates given a list of swaps, elements x and y and a current state\n  how many swaps between x and y there are *)"], ["", "fun ALG_P :: \"nat list \\<Rightarrow> 'a  \\<Rightarrow> 'a  \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n  \"ALG_P [] x y xs = (0::nat)\"\n| \"ALG_P (s#ss) x y xs = (if Suc s < length (swaps ss xs)\n                          then (if ((swaps ss xs)!s=x \\<and> (swaps ss xs)!(Suc s)=y) \\<or> ((swaps ss xs)!s=y \\<and> (swaps ss xs)!(Suc s)=x)\n                                then 1\n                                else 0)\n                          else 0) + ALG_P ss x y xs\""], ["", "(* nat list ersetzen durch (a::ordered) list *)"], ["", "lemma ALG_P_erwischt_alle:\n  assumes dinit: \"distinct init\" \n  shows\n  \"\\<forall>l< length sws. Suc (sws!l) < length init \\<Longrightarrow> length sws\n        = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set (init::('a::linorder) list) \\<and> y\\<in>set init \\<and> x<y}. ALG_P sws x y init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l<length sws. Suc (sws ! l) < length init \\<Longrightarrow>\n    length sws =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P sws x y init)", "proof (induct sws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<forall>l<length ss. Suc (ss ! l) < length init \\<Longrightarrow>\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n  \\<forall>l<length (s # ss). Suc ((s # ss) ! l) < length init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  \\<forall>l<length ss. Suc (ss ! l) < length init \\<Longrightarrow>\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n  \\<forall>l<length (s # ss). Suc ((s # ss) ! l) < length init", "have isininit: \"Suc s < length init\""], ["proof (prove)\nusing this:\n  \\<forall>l<length ss. Suc (ss ! l) < length init \\<Longrightarrow>\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n  \\<forall>l<length (s # ss). Suc ((s # ss) ! l) < length init\n\ngoal (1 subgoal):\n 1. Suc s < length init", "by auto"], ["proof (state)\nthis:\n  Suc s < length init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from Cons"], ["proof (chain)\npicking this:\n  \\<forall>l<length ss. Suc (ss ! l) < length init \\<Longrightarrow>\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n  \\<forall>l<length (s # ss). Suc ((s # ss) ! l) < length init", "have \"\\<forall>l<length ss. Suc (ss ! l)  < length init\""], ["proof (prove)\nusing this:\n  \\<forall>l<length ss. Suc (ss ! l) < length init \\<Longrightarrow>\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n  \\<forall>l<length (s # ss). Suc ((s # ss) ! l) < length init\n\ngoal (1 subgoal):\n 1. \\<forall>l<length ss. Suc (ss ! l) < length init", "by auto"], ["proof (state)\nthis:\n  \\<forall>l<length ss. Suc (ss ! l) < length init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "note iH=Cons(1)[OF this]"], ["proof (state)\nthis:\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "let ?expr = \"(\\<lambda>x y. (if Suc s < length (swaps ss init)\n                          then (if ((swaps ss init)!s=x \\<and> (swaps ss init)!(Suc s)=y) \\<or> ((swaps ss init)!s=y \\<and> (swaps ss init)!(Suc s)=x)\n                                then 1::nat\n                                else 0)\n                          else 0))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "let ?expr2 = \"(\\<lambda>x y. (if ((swaps ss init)!s=x \\<and> (swaps ss init)!(Suc s)=y) \\<or> ((swaps ss init)!s=y \\<and> (swaps ss init)!(Suc s)=x)\n                                then 1\n                                else 0))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "let ?expr3 = \"(%x y.  ((swaps ss init)!s=x \\<and> (swaps ss init)!(Suc s)=y)\n                    \\<or> ((swaps ss init)!s=y \\<and> (swaps ss init)!(Suc s)=x))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "let ?co' = \"swaps ss init\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from dinit"], ["proof (chain)\npicking this:\n  distinct init", "have dco: \"distinct ?co'\""], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. distinct (swaps ss init)", "by auto"], ["proof (state)\nthis:\n  distinct (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "let ?expr4 = \"(\\<lambda>z. (if z\\<in>{(x,y). ?expr3 x y}\n                                then 1\n                                else 0))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have scoinit: \"set ?co' = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swaps ss init) = set init", "by auto"], ["proof (state)\nthis:\n  set (swaps ss init) = set init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from isininit"], ["proof (chain)\npicking this:\n  Suc s < length init", "have isT: \"Suc s < length ?co'\""], ["proof (prove)\nusing this:\n  Suc s < length init\n\ngoal (1 subgoal):\n 1. Suc s < length (swaps ss init)", "by auto"], ["proof (state)\nthis:\n  Suc s < length (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  Suc s < length (swaps ss init)", "have isT2: \"Suc s < length init\""], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss init)\n\ngoal (1 subgoal):\n 1. Suc s < length init", "by auto"], ["proof (state)\nthis:\n  Suc s < length init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  Suc s < length init", "have isT3: \"s < length init\""], ["proof (prove)\nusing this:\n  Suc s < length init\n\ngoal (1 subgoal):\n 1. s < length init", "by auto"], ["proof (state)\nthis:\n  s < length init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  s < length init", "have isT6: \"s < length ?co'\""], ["proof (prove)\nusing this:\n  s < length init\n\ngoal (1 subgoal):\n 1. s < length (swaps ss init)", "by auto"], ["proof (state)\nthis:\n  s < length (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from isT2"], ["proof (chain)\npicking this:\n  Suc s < length init", "have isT7: \"Suc s < length ?co'\""], ["proof (prove)\nusing this:\n  Suc s < length init\n\ngoal (1 subgoal):\n 1. Suc s < length (swaps ss init)", "by auto"], ["proof (state)\nthis:\n  Suc s < length (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from isT6"], ["proof (chain)\npicking this:\n  s < length (swaps ss init)", "have a: \"?co'!s \\<in> set ?co'\""], ["proof (prove)\nusing this:\n  s < length (swaps ss init)\n\ngoal (1 subgoal):\n 1. swaps ss init ! s \\<in> set (swaps ss init)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  swaps ss init ! s \\<in> set (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  swaps ss init ! s \\<in> set (swaps ss init)", "have a: \"?co'!s \\<in> set init\""], ["proof (prove)\nusing this:\n  swaps ss init ! s \\<in> set (swaps ss init)\n\ngoal (1 subgoal):\n 1. swaps ss init ! s \\<in> set init", "by auto"], ["proof (state)\nthis:\n  swaps ss init ! s \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "from isT7"], ["proof (chain)\npicking this:\n  Suc s < length (swaps ss init)", "have \"?co'! (Suc s) \\<in> set ?co'\""], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss init)\n\ngoal (1 subgoal):\n 1. swaps ss init ! Suc s \\<in> set (swaps ss init)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  swaps ss init ! Suc s \\<in> set (swaps ss init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "then"], ["proof (chain)\npicking this:\n  swaps ss init ! Suc s \\<in> set (swaps ss init)", "have b: \"?co'!(Suc s) \\<in> set init\""], ["proof (prove)\nusing this:\n  swaps ss init ! Suc s \\<in> set (swaps ss init)\n\ngoal (1 subgoal):\n 1. swaps ss init ! Suc s \\<in> set init", "by auto"], ["proof (state)\nthis:\n  swaps ss init ! Suc s \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have  \"{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}\n                          \\<inter> {(x,y). ?expr3 x y}\n     = {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y\n                              \\<and>  (?co'!s=x \\<and> ?co'!(Suc s)=y\n                                  \\<or> ?co'!s=y \\<and> ?co'!(Suc s)=x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and>\n     (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n      swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y).\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n    swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y).\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n    swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y\n                              \\<and>  ?co'!s=x \\<and> ?co'!(Suc s)=y }\n                           \\<union>\n                  {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y\n                              \\<and>   ?co'!s=y \\<and> ?co'!(Suc s)=x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and>\n     (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n      swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)} =\n    {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n    swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)} =\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   (swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n    swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x)} =\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = {(x,y). x<y \\<and> ?co'!s=x \\<and> ?co'!(Suc s)=y}\n                           \\<union>\n                  {(x,y). x<y \\<and> ?co'!s=y \\<and> ?co'!(Suc s)=x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}", "using a b"], ["proof (prove)\nusing this:\n  swaps ss init ! s \\<in> set init\n  swaps ss init ! Suc s \\<in> set init\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x \\<in> set init \\<and>\n     y \\<in> set init \\<and>\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}", "by(auto)"], ["proof (state)\nthis:\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x \\<in> set init \\<and>\n   y \\<in> set init \\<and>\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "finally"], ["proof (chain)\npicking this:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y).\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}", "have c1: \"{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y} \\<inter> {(x,y). ?expr3 x y}\n      = {(x,y). x<y \\<and> ?co'!s=x \\<and> ?co'!(Suc s)=y}\n                           \\<union>\n                  {(x,y). x<y \\<and> ?co'!s=y \\<and> ?co'!(Suc s)=x}\""], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y).\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}", "."], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y).\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have c2: \"card ({(x,y). x<y \\<and> ?co'!s=x \\<and> ?co'!(Suc s)=y}\n                           \\<union>\n                  {(x,y). x<y \\<and> ?co'!s=y \\<and> ?co'!(Suc s)=x}) = 1\" (is \"card (?A \\<union> ?B) = 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "proof (cases \"?co'!s<?co'!(Suc s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1\n 2. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "case True"], ["proof (state)\nthis:\n  swaps ss init ! s < swaps ss init ! Suc s\n\ngoal (2 subgoals):\n 1. swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1\n 2. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "then"], ["proof (chain)\npicking this:\n  swaps ss init ! s < swaps ss init ! Suc s", "have a: \"?A = { (?co'!s, ?co'!(Suc s)) }\"\n          and b: \"?B = {} \""], ["proof (prove)\nusing this:\n  swaps ss init ! s < swaps ss init ! Suc s\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} =\n    {(swaps ss init ! s, swaps ss init ! Suc s)} &&&\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} =\n  {(swaps ss init ! s, swaps ss init ! Suc s)}\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {}\n\ngoal (2 subgoals):\n 1. swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1\n 2. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "have c: \"?A \\<union> ?B = { (?co'!s, ?co'!(Suc s)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! s, swaps ss init ! Suc s)}", "apply(simp only: a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(swaps ss init ! s, swaps ss init ! Suc s)} \\<union> {} =\n    {(swaps ss init ! s, swaps ss init ! Suc s)}", "by simp"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(swaps ss init ! s, swaps ss init ! Suc s)}\n\ngoal (2 subgoals):\n 1. swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1\n 2. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "have \"card (?A \\<union> ?B) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "unfolding c"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(swaps ss init ! s, swaps ss init ! Suc s)} = 1", "by auto"], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (2 subgoals):\n 1. swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1\n 2. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "then"], ["proof (chain)\npicking this:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "."], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "case False"], ["proof (state)\nthis:\n  \\<not> swaps ss init ! s < swaps ss init ! Suc s\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "then"], ["proof (chain)\npicking this:\n  \\<not> swaps ss init ! s < swaps ss init ! Suc s", "have a: \"?A = {}\""], ["proof (prove)\nusing this:\n  \\<not> swaps ss init ! s < swaps ss init ! Suc s\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "have b: \"?B = { (?co'!(Suc s), ?co'!s) } \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "from dco distinct_conv_nth[of \"?co'\"]"], ["proof (chain)\npicking this:\n  distinct (swaps ss init)\n  distinct (swaps ss init) =\n  (\\<forall>i<length (swaps ss init).\n      \\<forall>j<length (swaps ss init).\n         i \\<noteq> j \\<longrightarrow>\n         swaps ss init ! i \\<noteq> swaps ss init ! j)", "have \"swaps ss init ! s \\<noteq> swaps ss init ! (Suc s)\""], ["proof (prove)\nusing this:\n  distinct (swaps ss init)\n  distinct (swaps ss init) =\n  (\\<forall>i<length (swaps ss init).\n      \\<forall>j<length (swaps ss init).\n         i \\<noteq> j \\<longrightarrow>\n         swaps ss init ! i \\<noteq> swaps ss init ! j)\n\ngoal (1 subgoal):\n 1. swaps ss init ! s \\<noteq> swaps ss init ! Suc s", "using isT2 isT3"], ["proof (prove)\nusing this:\n  distinct (swaps ss init)\n  distinct (swaps ss init) =\n  (\\<forall>i<length (swaps ss init).\n      \\<forall>j<length (swaps ss init).\n         i \\<noteq> j \\<longrightarrow>\n         swaps ss init ! i \\<noteq> swaps ss init ! j)\n  Suc s < length init\n  s < length init\n\ngoal (1 subgoal):\n 1. swaps ss init ! s \\<noteq> swaps ss init ! Suc s", "by simp"], ["proof (state)\nthis:\n  swaps ss init ! s \\<noteq> swaps ss init ! Suc s\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "with False"], ["proof (chain)\npicking this:\n  \\<not> swaps ss init ! s < swaps ss init ! Suc s\n  swaps ss init ! s \\<noteq> swaps ss init ! Suc s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> swaps ss init ! s < swaps ss init ! Suc s\n  swaps ss init ! s \\<noteq> swaps ss init ! Suc s\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(swaps ss init ! Suc s, swaps ss init ! s)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(swaps ss init ! Suc s, swaps ss init ! s)}\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "have c: \"?A \\<union> ?B = { (?co'!(Suc s), ?co'!s) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "apply(simp only: a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<union> {(swaps ss init ! Suc s, swaps ss init ! s)} =\n    {(swaps ss init ! Suc s, swaps ss init ! s)}", "by simp"], ["proof (state)\nthis:\n  {(x, y).\n   x < y \\<and>\n   swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n  {(x, y).\n   x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x} =\n  {(swaps ss init ! Suc s, swaps ss init ! s)}\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "have \"card (?A \\<union> ?B) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "unfolding c"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(swaps ss init ! Suc s, swaps ss init ! s)} = 1", "by auto"], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. \\<not> swaps ss init ! s < swaps ss init ! Suc s \\<Longrightarrow>\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "then"], ["proof (chain)\npicking this:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "."], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have yeah: \"(\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr x y) = (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"(\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr x y)\n        = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr2 x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n          swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n       then 1 else 0)", "using isT"], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss init)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n          swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n       then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n        swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n        swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = (\\<Sum>z\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr2 (fst z) (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n          swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n       then 1 else 0) =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if swaps ss init ! s = fst z \\<and>\n          swaps ss init ! Suc s = snd z \\<or>\n          swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n       then 1 else 0)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n        swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = fst z \\<and> swaps ss init ! Suc s = snd z \\<or>\n        swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n        swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = fst z \\<and> swaps ss init ! Suc s = snd z \\<or>\n        swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = (\\<Sum>z\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr4 z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if swaps ss init ! s = fst z \\<and>\n          swaps ss init ! Suc s = snd z \\<or>\n          swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n       then 1 else 0) =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if z \\<in> {(x, y).\n                   swaps ss init ! s = x \\<and>\n                   swaps ss init ! Suc s = y \\<or>\n                   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n       then 1 else 0)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = fst z \\<and> swaps ss init ! Suc s = snd z \\<or>\n        swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if z \\<in> {(x, y).\n                 swaps ss init ! s = x \\<and>\n                 swaps ss init ! Suc s = y \\<or>\n                 swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if swaps ss init ! s = fst z \\<and> swaps ss init ! Suc s = snd z \\<or>\n        swaps ss init ! s = snd z \\<and> swaps ss init ! Suc s = fst z\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if z \\<in> {(x, y).\n                 swaps ss init ! s = x \\<and>\n                 swaps ss init ! Suc s = y \\<or>\n                 swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = (\\<Sum>z\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}\n                          \\<inter>{(x,y). ?expr3 x y} . 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if z \\<in> {(x, y).\n                   swaps ss init ! s = x \\<and>\n                   swaps ss init ! Suc s = y \\<or>\n                   swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n       then 1 else 0) =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and>\n                  y \\<in> set init \\<and> x < y} \\<inter>\n                 {(x, y).\n                  swaps ss init ! s = x \\<and>\n                  swaps ss init ! Suc s = y \\<or>\n                  swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n       1)", "apply(rule sum.inter_restrict[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if z \\<in> {(x, y).\n                 swaps ss init ! s = x \\<and>\n                 swaps ss init ! Suc s = y \\<or>\n                 swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<inter>\n               {(x, y).\n                swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n     1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if z \\<in> {(x, y).\n                 swaps ss init ! s = x \\<and>\n                 swaps ss init ! Suc s = y \\<or>\n                 swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}\n     then 1 else 0) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<inter>\n               {(x, y).\n                swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n     1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = card ({(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}\n                          \\<inter> {(x,y). ?expr3 x y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and>\n                  y \\<in> set init \\<and> x < y} \\<inter>\n                 {(x, y).\n                  swaps ss init ! s = x \\<and>\n                  swaps ss init ! Suc s = y \\<or>\n                  swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n       1) =\n    card\n     ({(x, y).\n       x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n      {(x, y).\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<inter>\n               {(x, y).\n                swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n     1) =\n  card\n   ({(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<inter>\n               {(x, y).\n                swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}.\n     1) =\n  card\n   ({(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = card ({(x,y). x<y \\<and> ?co'!s=x \\<and> ?co'!(Suc s)=y}\n                           \\<union>\n                  {(x,y). x<y \\<and> ?co'!s=y \\<and> ?co'!(Suc s)=x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n      {(x, y).\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})", "by(simp only: c1)"], ["proof (state)\nthis:\n  card\n   ({(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "also"], ["proof (state)\nthis:\n  card\n   ({(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y).\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n     swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "have \"\\<dots> = (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "using c2"], ["proof (prove)\nusing this:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. card\n     ({(x, y).\n       x < y \\<and>\n       swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n      {(x, y).\n       x < y \\<and>\n       swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n    1", "by auto"], ["proof (state)\nthis:\n  card\n   ({(x, y).\n     x < y \\<and>\n     swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y} \\<union>\n    {(x, y).\n     x < y \\<and> swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x}) =\n  1\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  1\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) =\n    1", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) =\n  1\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"length (s # ss) = 1 + length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (s # ss) = 1 + length ss", "by auto"], ["proof (state)\nthis:\n  length (s # ss) = 1 + length ss\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  length (s # ss) = 1 + length ss\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = 1 + (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P ss x y init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + length ss =\n    1 +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P ss x y init)", "using iH"], ["proof (prove)\nusing this:\n  length ss =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P ss x y init)\n\ngoal (1 subgoal):\n 1. 1 + length ss =\n    1 +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P ss x y init)", "by auto"], ["proof (state)\nthis:\n  1 + length ss =\n  1 +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  1 + length ss =\n  1 +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr x y)\n            + (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P ss x y init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P ss x y init) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P ss x y init)", "by(simp only: yeah)"], ["proof (state)\nthis:\n  1 +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  1 +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ?expr x y + ALG_P ss x y init)\"\n    (is \"?A + ?B = ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       if Suc s < length (swaps ss init)\n       then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n               swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n            then 1 else 0\n       else 0) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P ss x y init) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (if Suc s < length (swaps ss init)\n        then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n             then 1 else 0\n        else 0) +\n       ALG_P ss x y init)", "by (simp add: sum.distrib split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (if Suc s < length (swaps ss init)\n      then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n              swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n           then 1 else 0\n      else 0) +\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     if Suc s < length (swaps ss init)\n     then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n             swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n          then 1 else 0\n     else 0) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P ss x y init) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (if Suc s < length (swaps ss init)\n      then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n              swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n           then 1 else 0\n      else 0) +\n     ALG_P ss x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (s#ss) x y init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (if Suc s < length (swaps ss init)\n        then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n                swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n             then 1 else 0\n        else 0) +\n       ALG_P ss x y init) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P (s # ss) x y init)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (if Suc s < length (swaps ss init)\n      then if swaps ss init ! s = x \\<and> swaps ss init ! Suc s = y \\<or>\n              swaps ss init ! s = y \\<and> swaps ss init ! Suc s = x\n           then 1 else 0\n      else 0) +\n     ALG_P ss x y init) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P (s # ss) x y init)\n\ngoal (2 subgoals):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)\n 2. \\<And>a sws.\n       \\<lbrakk>\\<forall>l<length sws.\n                   Suc (sws ! l) < length init \\<Longrightarrow>\n                length sws =\n                (\\<Sum>(x, y)\n                       \\<in>{(x, y).\n                             x \\<in> set init \\<and>\n                             y \\<in> set init \\<and> x < y}.\n                   ALG_P sws x y init);\n        \\<forall>l<length (a # sws).\n           Suc ((a # sws) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> length (a # sws) =\n                         (\\<Sum>(x, y)\n                                \\<in>{(x, y).\nx \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n                            ALG_P (a # sws) x y init)", "finally"], ["proof (chain)\npicking this:\n  length (s # ss) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P (s # ss) x y init)", "show ?case"], ["proof (prove)\nusing this:\n  length (s # ss) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P (s # ss) x y init)\n\ngoal (1 subgoal):\n 1. length (s # ss) =\n    (\\<Sum> | case  of\n              (x, y) \\<Rightarrow>\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n       case  of (x, y) \\<Rightarrow> ALG_P (s # ss) x y init)", "."], ["proof (state)\nthis:\n  length (s # ss) =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x < y.\n     case  of (x, y) \\<Rightarrow> ALG_P (s # ss) x y init)\n\ngoal (1 subgoal):\n 1. \\<forall>l<length []. Suc ([] ! l) < length init \\<Longrightarrow>\n    length [] =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P [] x y init)", "qed (simp)"], ["", "(* thesame with paid exchanges *)"], ["", "lemma t\\<^sub>p_sumofALGALGP:\nassumes \"distinct s\" \"(qs!i)\\<in>set s\"\n  and \"\\<forall>l< length (snd a). Suc ((snd a)!l) < length s\"\nshows \"t\\<^sub>p s (qs!i) a = (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s,())) \n      + (\\<Sum>(x,y)\\<in>{(x::('a::linorder),y). x \\<in> set s \\<and> y\\<in>set s \\<and> x<y}. ALG_P (snd a) x y s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "(* paid exchanges *)"], ["proof (state)\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "have pe: \"length (snd a)\n        = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set s \\<and> y\\<in>set s \\<and> x<y}. ALG_P (snd a) x y s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd a) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "apply(rule ALG_P_erwischt_alle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct s\n 2. \\<forall>l<length (snd a). Suc (snd a ! l) < length s", "by(fact)+"], ["proof (state)\nthis:\n  length (snd a) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n     ALG_P (snd a) x y s)\n\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "(* access cost *)"], ["proof (state)\nthis:\n  length (snd a) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n     ALG_P (snd a) x y s)\n\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "have ac: \"index (swaps (snd a) s) (qs ! i) = (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s,()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "have \"index (swaps (snd a) s) (qs ! i) \n        = (\\<Sum>e\\<in>set (swaps (snd a) s). if e < (qs ! i) in (swaps (snd a) s) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set (swaps (snd a) s).\n       if e < qs ! i in swaps (snd a) s then 1 else 0)", "apply(rule index_sum)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (swaps (snd a) s)\n 2. qs ! i \\<in> set (swaps (snd a) s)", "using assms"], ["proof (prove)\nusing this:\n  distinct s\n  qs ! i \\<in> set s\n  \\<forall>l<length (snd a). Suc (snd a ! l) < length s\n\ngoal (2 subgoals):\n 1. distinct (swaps (snd a) s)\n 2. qs ! i \\<in> set (swaps (snd a) s)", "by(simp_all)"], ["proof (state)\nthis:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set (swaps (snd a) s).\n     if e < qs ! i in swaps (snd a) s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "also"], ["proof (state)\nthis:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set (swaps (snd a) s).\n     if e < qs ! i in swaps (snd a) s then 1 else 0)\n\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "have \"\\<dots> = (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s,()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set (swaps (snd a) s).\n       if e < qs ! i in swaps (snd a) s then 1 else 0) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set (swaps (snd a) s).\n     if e < qs ! i in swaps (snd a) s then 1 else 0) =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))\n\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "finally"], ["proof (chain)\npicking this:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "show ?thesis"], ["proof (prove)\nusing this:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))\n\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))", "."], ["proof (state)\nthis:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index (swaps (snd a) s) (qs ! i) =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ()))\n\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p s (qs ! i) a =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "unfolding t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (mf, sws) = a in index (swaps sws s) (qs ! i) + length sws) =\n    (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s)", "apply (simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (swaps (snd a) s) (qs ! i) + length (snd a) =\n    (\\<Sum>e\\<in>set s. if e < qs ! i in swaps (snd a) s then 1 else 0) +\n    (\\<Sum>x\\<in>{p. fst p \\<in> set s \\<and>\n                     snd p \\<in> set s \\<and> fst p < snd p}.\n       ALG_P (snd a) (fst x) (snd x) s)", "unfolding ac pe"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n       ALG_P (snd a) x y s) =\n    (\\<Sum>e\\<in>set s. if e < qs ! i in swaps (snd a) s then 1 else 0) +\n    (\\<Sum>x\\<in>{p. fst p \\<in> set s \\<and>\n                     snd p \\<in> set s \\<and> fst p < snd p}.\n       ALG_P (snd a) (fst x) (snd x) s)", "by (simp add: split_def)"], ["proof (state)\nthis:\n  t\\<^sub>p s (qs ! i) a =\n  (\\<Sum>e\\<in>set s. ALG e qs i (swaps (snd a) s, ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y). x \\<in> set s \\<and> y \\<in> set s \\<and> x < y}.\n     ALG_P (snd a) x y s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* given a Strategy Strat to serve request sequence qs on initial list init how many\n  swaps between elements x and y occur during the ith step *)"], ["", "definition \"ALG_P' Strat qs init i x y = ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)\""], ["", "(* if n is in bound, Strat may be too long, that does not matter *)"], ["", "lemma ALG_P'_rest: \"n < length qs \\<Longrightarrow> n < length Strat \\<Longrightarrow> \n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "assume qs: \"n < length qs\""], ["proof (state)\nthis:\n  n < length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "assume S: \"n < length Strat\""], ["proof (state)\nthis:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "then"], ["proof (chain)\npicking this:\n  n < length Strat", "have lS: \"length (take n Strat) = n\""], ["proof (prove)\nusing this:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. length (take n Strat) = n", "by auto"], ["proof (state)\nthis:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "have \"(take n Strat @ [Strat ! n]) ! n =\n      (take n Strat @ (Strat ! n) # []) ! length (take n Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n =\n    (take n Strat @ [Strat ! n]) ! length (take n Strat)", "using lS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n =\n    (take n Strat @ [Strat ! n]) ! length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n =\n  (take n Strat @ [Strat ! n]) ! length (take n Strat)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n =\n  (take n Strat @ [Strat ! n]) ! length (take n Strat)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = Strat ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! length (take n Strat) = Strat ! n", "by(rule nth_append_length)"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! length (take n Strat) = Strat ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "finally"], ["proof (chain)\npicking this:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n", "have tt: \"(take n Strat @ [Strat ! n]) ! n = Strat ! n\""], ["proof (prove)\nusing this:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n\n\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n = Strat ! n", "."], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "obtain rest where rest: \"Strat = (take n Strat @ [Strat ! n] @ rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        Strat = take n Strat @ [Strat ! n] @ rest \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using S"], ["proof (prove)\nusing this:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        Strat = take n Strat @ [Strat ! n] @ rest \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>rest.\n                Strat = take n Strat @ Strat ! n # rest \\<Longrightarrow>\n                thesis;\n     n < length Strat\\<rbrakk>\n    \\<Longrightarrow> thesis", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>rest.\n                Strat = take n Strat @ Strat ! n # rest \\<Longrightarrow>\n                thesis;\n     n < length Strat\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  Strat = take n Strat @ [Strat ! n] @ rest\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "have \"steps' init (take n qs @ [qs ! n])\n       (take n Strat @ [Strat ! n]) n\n      = steps' init (take n qs)\n       (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n    steps' init (take n qs) (take n Strat) n", "apply(rule steps'_rests[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = \n      steps' init (take n qs @ [qs ! n])\n       (take n Strat @ ([Strat ! n] @ rest)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n", "apply(rule steps'_rests)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n                      ALG_P' (take n Strat @ [Strat ! n])\n                       (take n qs @ [qs ! n]) init n x y", "finally"], ["proof (chain)\npicking this:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n", "show ?thesis"], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n\n\ngoal (1 subgoal):\n 1. ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y", "unfolding ALG_P'_def tt"], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n\n\ngoal (1 subgoal):\n 1. ALG_P (snd (Strat ! n)) x y\n     (steps' init (take n qs @ [qs ! n]) Strat n) =\n    ALG_P (snd (Strat ! n)) x y\n     (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n)", "using rest"], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n] @ rest) n\n  Strat = take n Strat @ [Strat ! n] @ rest\n\ngoal (1 subgoal):\n 1. ALG_P (snd (Strat ! n)) x y\n     (steps' init (take n qs @ [qs ! n]) Strat n) =\n    ALG_P (snd (Strat ! n)) x y\n     (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n]) n)", "by auto"], ["proof (state)\nthis:\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* verallgemeinert ALG_P'_rest, sollte mergen! *)"], ["", "lemma ALG_P'_rest2: \"n < length qs \\<Longrightarrow> n < length Strat \\<Longrightarrow> \n  ALG_P' Strat qs init n x y =\n    ALG_P' (Strat@r1) (qs@r2) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "assume qs: \"n < length qs\""], ["proof (state)\nthis:\n  n < length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "assume S: \"n < length Strat\""], ["proof (state)\nthis:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "have tt: \"Strat ! n = (Strat @ r1) ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Strat ! n = (Strat @ r1) ! n", "using S"], ["proof (prove)\nusing this:\n  n < length Strat\n\ngoal (1 subgoal):\n 1. Strat ! n = (Strat @ r1) ! n", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  Strat ! n = (Strat @ r1) ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "have \"steps' init (take n qs) (take n Strat) n = steps' init ((take n qs) @ drop n qs) ((take n Strat) @ (drop n Strat)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "apply(rule steps'_rests)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "then"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "have A: \"steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "have \"steps' init (take n qs) (take n Strat) n = steps' init ((take n qs) @ ((drop n qs)@r2)) ((take n Strat) @((drop n Strat)@r1)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs @ drop n qs @ r2)\n     (take n Strat @ drop n Strat @ r1) n", "apply(rule steps'_rests)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using S qs"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ r2)\n   (take n Strat @ drop n Strat @ r1) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "then"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ r2)\n   (take n Strat @ drop n Strat @ r1) n", "have B: \"steps' init (take n qs) (take n Strat) n = steps' init (qs@r2) (Strat@r1) n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (take n qs @ drop n qs @ r2)\n   (take n Strat @ drop n Strat @ r1) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n =\n    steps' init (qs @ r2) (Strat @ r1) n", "by (metis append_assoc List.append_take_drop_id)"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ r2) (Strat @ r1) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "from A B"], ["proof (chain)\npicking this:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ r2) (Strat @ r1) n", "have C: \"steps' init qs Strat n = steps' init (qs@r2) (Strat@r1) n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n  steps' init (take n qs) (take n Strat) n =\n  steps' init (qs @ r2) (Strat @ r1) n\n\ngoal (1 subgoal):\n 1. steps' init qs Strat n = steps' init (qs @ r2) (Strat @ r1) n", "by auto"], ["proof (state)\nthis:\n  steps' init qs Strat n = steps' init (qs @ r2) (Strat @ r1) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length qs; n < length Strat\\<rbrakk>\n    \\<Longrightarrow> ALG_P' Strat qs init n x y =\n                      ALG_P' (Strat @ r1) (qs @ r2) init n x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_P' Strat qs init n x y = ALG_P' (Strat @ r1) (qs @ r2) init n x y", "unfolding ALG_P'_def tt"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_P (snd ((Strat @ r1) ! n)) x y (steps' init qs Strat n) =\n    ALG_P (snd ((Strat @ r1) ! n)) x y\n     (steps' init (qs @ r2) (Strat @ r1) n)", "using C"], ["proof (prove)\nusing this:\n  steps' init qs Strat n = steps' init (qs @ r2) (Strat @ r1) n\n\ngoal (1 subgoal):\n 1. ALG_P (snd ((Strat @ r1) ! n)) x y (steps' init qs Strat n) =\n    ALG_P (snd ((Strat @ r1) ! n)) x y\n     (steps' init (qs @ r2) (Strat @ r1) n)", "by auto"], ["proof (state)\nthis:\n  ALG_P' Strat qs init n x y = ALG_P' (Strat @ r1) (qs @ r2) init n x y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* total number of swaps of elements x and y during execution of Strategy Strat *)"], ["", "definition ALG_Pxy  where\n  \"ALG_Pxy Strat qs init x y = (\\<Sum>i<length qs. ALG_P' Strat qs init i x y)\""], ["", "lemma wegdamit: \"length A < length Strat \\<Longrightarrow> b \\<notin> {x,y} \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y\n    = ALGxy_det Strat A init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "assume bn: \"b \\<notin> {x,y}\""], ["proof (state)\nthis:\n  b \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have \"(A @ [b]) ! (length A) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A @ [b]) ! length A = b", "by auto"], ["proof (state)\nthis:\n  (A @ [b]) ! length A = b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "assume l: \"length A < length Strat\""], ["proof (state)\nthis:\n  length A < length Strat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "term \"%i. ALG'_det Strat (A @ [b]) init i y\""], ["proof (state)\nthis:\n  length A < length Strat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have e: \"\\<And>i. i<length A \\<Longrightarrow> (A @ [b]) ! i = A ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length A \\<Longrightarrow> (A @ [b]) ! i = A ! i", "by(auto simp: nth_append)"], ["proof (state)\nthis:\n  ?i < length A \\<Longrightarrow> (A @ [b]) ! ?i = A ! ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have \"(\\<Sum>i\\<in> {..< length (A @ [b])}.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) = (\\<Sum>i\\<in> {..< Suc(length (A))}.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (A @ [b]).\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) =\n    (\\<Sum>i<Suc (length A).\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length (A @ [b]).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<Suc (length A).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (A @ [b]).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<Suc (length A).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have \"\\<dots> = (\\<Sum>i\\<in> {..< (length (A))}.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) + ( if (A @ [b]) ! (length A) \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init (length A) y +\n             ALG'_det Strat (A @ [b]) init (length A) x\n        else 0) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc (length A).\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) =\n    (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) +\n    (if (A @ [b]) ! length A \\<in> {y, x}\n     then ALG'_det Strat (A @ [b]) init (length A) y +\n          ALG'_det Strat (A @ [b]) init (length A) x\n     else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc (length A).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) +\n  (if (A @ [b]) ! length A \\<in> {y, x}\n   then ALG'_det Strat (A @ [b]) init (length A) y +\n        ALG'_det Strat (A @ [b]) init (length A) x\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "(* abspalten des letzten glieds *)"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc (length A).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) +\n  (if (A @ [b]) ! length A \\<in> {y, x}\n   then ALG'_det Strat (A @ [b]) init (length A) y +\n        ALG'_det Strat (A @ [b]) init (length A) x\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc (length A).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) +\n  (if (A @ [b]) ! length A \\<in> {y, x}\n   then ALG'_det Strat (A @ [b]) init (length A) y +\n        ALG'_det Strat (A @ [b]) init (length A) x\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have \"\\<dots> = (\\<Sum>i\\<in> {..< (length (A))}.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) +\n    (if (A @ [b]) ! length A \\<in> {y, x}\n     then ALG'_det Strat (A @ [b]) init (length A) y +\n          ALG'_det Strat (A @ [b]) init (length A) x\n     else 0) =\n    (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0)", "using bn"], ["proof (prove)\nusing this:\n  b \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) +\n    (if (A @ [b]) ! length A \\<in> {y, x}\n     then ALG'_det Strat (A @ [b]) init (length A) y +\n          ALG'_det Strat (A @ [b]) init (length A) x\n     else 0) =\n    (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) +\n  (if (A @ [b]) ! length A \\<in> {y, x}\n   then ALG'_det Strat (A @ [b]) init (length A) y +\n        ALG'_det Strat (A @ [b]) init (length A) x\n   else 0) =\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) +\n  (if (A @ [b]) ! length A \\<in> {y, x}\n   then ALG'_det Strat (A @ [b]) init (length A) y +\n        ALG'_det Strat (A @ [b]) init (length A) x\n   else 0) =\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "have \"\\<dots> = (\\<Sum>i\\<in> {..< (length (A))}.\n          if A ! i \\<in> {y, x}\n          then ALG'_det Strat A init i y +\n              ALG'_det Strat A init i x\n              else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length A.\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) =\n    (\\<Sum>i<length A.\n        if A ! i \\<in> {y, x}\n        then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length A} = {..<length A}\n 2. \\<And>xa.\n       xa \\<in> {..<length A} \\<Longrightarrow>\n       (if (A @ [b]) ! xa \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init xa y +\n             ALG'_det Strat (A @ [b]) init xa x\n        else 0) =\n       (if A ! xa \\<in> {y, x}\n        then ALG'_det Strat A init xa y + ALG'_det Strat A init xa x else 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length A} \\<Longrightarrow>\n       (if (A @ [b]) ! xa \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init xa y +\n             ALG'_det Strat (A @ [b]) init xa x\n        else 0) =\n       (if A ! xa \\<in> {y, x}\n        then ALG'_det Strat A init xa y + ALG'_det Strat A init xa x else 0)", "using l ALG'_det_append[where qs=A] e"], ["proof (prove)\nusing this:\n  length A < length Strat\n  \\<lbrakk>?n < length ?Strat; ?n < length A\\<rbrakk>\n  \\<Longrightarrow> ALG'_det ?Strat (A @ ?a) ?init ?n ?x =\n                    ALG'_det ?Strat A ?init ?n ?x\n  ?i < length A \\<Longrightarrow> (A @ [b]) ! ?i = A ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length A} \\<Longrightarrow>\n       (if (A @ [b]) ! xa \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init xa y +\n             ALG'_det Strat (A @ [b]) init xa x\n        else 0) =\n       (if A ! xa \\<in> {y, x}\n        then ALG'_det Strat A init xa y + ALG'_det Strat A init xa x else 0)", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>i<length A.\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if A ! i \\<in> {y, x}\n      then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length A < length Strat; b \\<notin> {x, y}\\<rbrakk>\n    \\<Longrightarrow> ALGxy_det Strat (A @ [b]) init x y =\n                      ALGxy_det Strat A init x y", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length (A @ [b]).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if A ! i \\<in> {y, x}\n      then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (A @ [b]).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if A ! i \\<in> {y, x}\n      then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (A @ [b]) init x y = ALGxy_det Strat A init x y", "unfolding ALGxy_det_def"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (A @ [b]).\n      if (A @ [b]) ! i \\<in> {y, x}\n      then ALG'_det Strat (A @ [b]) init i y +\n           ALG'_det Strat (A @ [b]) init i x\n      else 0) =\n  (\\<Sum>i<length A.\n      if A ! i \\<in> {y, x}\n      then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (A @ [b]).\n        if (A @ [b]) ! i \\<in> {y, x}\n        then ALG'_det Strat (A @ [b]) init i y +\n             ALG'_det Strat (A @ [b]) init i x\n        else 0) =\n    (\\<Sum>i<length A.\n        if A ! i \\<in> {y, x}\n        then ALG'_det Strat A init i y + ALG'_det Strat A init i x else 0)", "by simp"], ["proof (state)\nthis:\n  ALGxy_det Strat (A @ [b]) init x y = ALGxy_det Strat A init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ALG_P_split: \"length qs < length Strat \\<Longrightarrow> ALG_Pxy Strat (qs@[q]) init x y = ALG_Pxy Strat qs init x y\n            +  ALG_P' Strat (qs@[q]) init (length qs) x y \""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs < length Strat \\<Longrightarrow>\n    ALG_Pxy Strat (qs @ [q]) init x y =\n    ALG_Pxy Strat qs init x y + ALG_P' Strat (qs @ [q]) init (length qs) x y", "unfolding ALG_Pxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs < length Strat \\<Longrightarrow>\n    (\\<Sum>i<length (qs @ [q]). ALG_P' Strat (qs @ [q]) init i x y) =\n    (\\<Sum>i<length qs. ALG_P' Strat qs init i x y) +\n    ALG_P' Strat (qs @ [q]) init (length qs) x y", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs < length Strat \\<Longrightarrow>\n    (\\<Sum>i<length qs. ALG_P' Strat (qs @ [q]) init i x y) =\n    (\\<Sum>i<length qs. ALG_P' Strat qs init i x y)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length qs < length Strat \\<Longrightarrow>\n    {..<length qs} = {..<length qs}\n 2. \\<And>xa.\n       \\<lbrakk>length qs < length Strat; xa \\<in> {..<length qs}\\<rbrakk>\n       \\<Longrightarrow> ALG_P' Strat (qs @ [q]) init xa x y =\n                         ALG_P' Strat qs init xa x y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>length qs < length Strat; xa \\<in> {..<length qs}\\<rbrakk>\n       \\<Longrightarrow> ALG_P' Strat (qs @ [q]) init xa x y =\n                         ALG_P' Strat qs init xa x y", "using ALG_P'_rest2[symmetric, of _ qs Strat \"[]\" \"[q]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length qs; ?n < length Strat\\<rbrakk>\n  \\<Longrightarrow> ALG_P' (Strat @ []) (qs @ [q]) ?init ?n ?x ?y =\n                    ALG_P' Strat qs ?init ?n ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>length qs < length Strat; xa \\<in> {..<length qs}\\<rbrakk>\n       \\<Longrightarrow> ALG_P' Strat (qs @ [q]) init xa x y =\n                         ALG_P' Strat qs init xa x y", "by(simp)"], ["", "lemma swap0in2:  assumes \"set l = {x,y}\" \"x\\<noteq>y\" \"length l = 2\" \"dist_perm l l\"\n  shows\n    \"x < y in (swap 0) l = (~ x < y in l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap 0 l = (\\<not> x < y in l)", "proof (cases \"x < y in l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "case True"], ["proof (state)\nthis:\n  x < y in l\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "then"], ["proof (chain)\npicking this:\n  x < y in l", "have a: \"index l x < index l y\""], ["proof (prove)\nusing this:\n  x < y in l\n\ngoal (1 subgoal):\n 1. index l x < index l y", "unfolding before_in_def"], ["proof (prove)\nusing this:\n  index l x < index l y \\<and> y \\<in> set l\n\ngoal (1 subgoal):\n 1. index l x < index l y", "by simp"], ["proof (state)\nthis:\n  index l x < index l y\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have drin: \"x\\<in>set l\" \"y\\<in>set l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set l &&& y \\<in> set l", "by auto"], ["proof (state)\nthis:\n  x \\<in> set l\n  y \\<in> set l\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  length l = 2", "have b: \"index l y < 2\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  length l = 2\n\ngoal (1 subgoal):\n 1. index l y < 2", "by simp"], ["proof (state)\nthis:\n  index l y < 2\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from a b"], ["proof (chain)\npicking this:\n  index l x < index l y\n  index l y < 2", "have k: \"index l x = 0\" \"index l y = 1\""], ["proof (prove)\nusing this:\n  index l x < index l y\n  index l y < 2\n\ngoal (1 subgoal):\n 1. index l x = 0 &&& index l y = 1", "by auto"], ["proof (state)\nthis:\n  index l x = 0\n  index l y = 1\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have g: \"x = l ! 0\" \"y = l ! 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = l ! 0 &&& y = l ! 1", "using k nth_index assms(1)"], ["proof (prove)\nusing this:\n  index l x = 0\n  index l y = 1\n  ?x \\<in> set ?xs \\<Longrightarrow> ?xs ! index ?xs ?x = ?x\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. x = l ! 0 &&& y = l ! 1", "by force+"], ["proof (state)\nthis:\n  x = l ! 0\n  y = l ! 1\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"x < y in swap 0 l\n      = (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0)\n            \\<or>  x = l ! Suc 0 \\<and> y = l ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap 0 l =\n    (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0)", "apply(rule before_in_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist_perm l ?ys\n 2. Suc 0 < length l", "apply(fact assms(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length l", "using assms(3)"], ["proof (prove)\nusing this:\n  length l = 2\n\ngoal (1 subgoal):\n 1. Suc 0 < length l", "by simp"], ["proof (state)\nthis:\n  x < y in swap 0 l =\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "also"], ["proof (state)\nthis:\n  x < y in swap 0 l =\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"\\<dots> = (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0)\n            \\<or>  x = l ! Suc 0 \\<and> y = l ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0)", "using True"], ["proof (prove)\nusing this:\n  x < y in l\n\ngoal (1 subgoal):\n 1. (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0)", "by simp"], ["proof (state)\nthis:\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0) =\n  (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "also"], ["proof (state)\nthis:\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0) =\n  (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"\\<dots> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    False", "using g assms(2)"], ["proof (prove)\nusing this:\n  x = l ! 0\n  y = l ! 1\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    False", "by auto"], ["proof (state)\nthis:\n  (\\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0) =\n  False\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "finally"], ["proof (chain)\npicking this:\n  x < y in swap 0 l = False", "have \"~ x < y in (swap 0) l\""], ["proof (prove)\nusing this:\n  x < y in swap 0 l = False\n\ngoal (1 subgoal):\n 1. \\<not> x < y in swap 0 l", "by simp"], ["proof (state)\nthis:\n  \\<not> x < y in swap 0 l\n\ngoal (2 subgoals):\n 1. x < y in l \\<Longrightarrow> x < y in swap 0 l = (\\<not> x < y in l)\n 2. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "then"], ["proof (chain)\npicking this:\n  \\<not> x < y in swap 0 l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x < y in swap 0 l\n\ngoal (1 subgoal):\n 1. x < y in swap 0 l = (\\<not> x < y in l)", "using True"], ["proof (prove)\nusing this:\n  \\<not> x < y in swap 0 l\n  x < y in l\n\ngoal (1 subgoal):\n 1. x < y in swap 0 l = (\\<not> x < y in l)", "by auto"], ["proof (state)\nthis:\n  x < y in swap 0 l = (\\<not> x < y in l)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "case False"], ["proof (state)\nthis:\n  \\<not> x < y in l\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  x \\<noteq> y", "have \"index l y \\<noteq> index l x\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. index l y \\<noteq> index l x", "by simp"], ["proof (state)\nthis:\n  index l y \\<noteq> index l x\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "with False assms(1,2)"], ["proof (chain)\npicking this:\n  \\<not> x < y in l\n  set l = {x, y}\n  x \\<noteq> y\n  index l y \\<noteq> index l x", "have a: \"index l y < index l x\""], ["proof (prove)\nusing this:\n  \\<not> x < y in l\n  set l = {x, y}\n  x \\<noteq> y\n  index l y \\<noteq> index l x\n\ngoal (1 subgoal):\n 1. index l y < index l x", "by (metis before_in_def insert_iff linorder_neqE_nat)"], ["proof (state)\nthis:\n  index l y < index l x\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from assms(1)"], ["proof (chain)\npicking this:\n  set l = {x, y}", "have drin: \"x\\<in>set l\" \"y\\<in>set l\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set l &&& y \\<in> set l", "by auto"], ["proof (state)\nthis:\n  x \\<in> set l\n  y \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from assms(1,3)"], ["proof (chain)\npicking this:\n  set l = {x, y}\n  length l = 2", "have b: \"index l x < 2\""], ["proof (prove)\nusing this:\n  set l = {x, y}\n  length l = 2\n\ngoal (1 subgoal):\n 1. index l x < 2", "by simp"], ["proof (state)\nthis:\n  index l x < 2\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "from a b"], ["proof (chain)\npicking this:\n  index l y < index l x\n  index l x < 2", "have k: \"index l x = 1\" \"index l y = 0\""], ["proof (prove)\nusing this:\n  index l y < index l x\n  index l x < 2\n\ngoal (1 subgoal):\n 1. index l x = 1 &&& index l y = 0", "by auto"], ["proof (state)\nthis:\n  index l x = 1\n  index l y = 0\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "then"], ["proof (chain)\npicking this:\n  index l x = 1\n  index l y = 0", "have g: \"x = l ! 1\" \"y = l ! 0\""], ["proof (prove)\nusing this:\n  index l x = 1\n  index l y = 0\n\ngoal (1 subgoal):\n 1. x = l ! 1 &&& y = l ! 0", "using k nth_index assms(1)"], ["proof (prove)\nusing this:\n  index l x = 1\n  index l y = 0\n  index l x = 1\n  index l y = 0\n  ?x \\<in> set ?xs \\<Longrightarrow> ?xs ! index ?xs ?x = ?x\n  set l = {x, y}\n\ngoal (1 subgoal):\n 1. x = l ! 1 &&& y = l ! 0", "by force+"], ["proof (state)\nthis:\n  x = l ! 1\n  y = l ! 0\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"x < y in swap 0 l\n      = (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0)\n            \\<or>  x = l ! Suc 0 \\<and> y = l ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap 0 l =\n    (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0)", "apply(rule before_in_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist_perm l ?ys\n 2. Suc 0 < length l", "apply(fact assms(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length l", "using assms(3)"], ["proof (prove)\nusing this:\n  length l = 2\n\ngoal (1 subgoal):\n 1. Suc 0 < length l", "by simp"], ["proof (state)\nthis:\n  x < y in swap 0 l =\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "also"], ["proof (state)\nthis:\n  x < y in swap 0 l =\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"\\<dots> = (x = l ! Suc 0 \\<and> y = l ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    (x = l ! Suc 0 \\<and> y = l ! 0)", "using False"], ["proof (prove)\nusing this:\n  \\<not> x < y in l\n\ngoal (1 subgoal):\n 1. (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n     x = l ! Suc 0 \\<and> y = l ! 0) =\n    (x = l ! Suc 0 \\<and> y = l ! 0)", "by simp"], ["proof (state)\nthis:\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0) =\n  (x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "also"], ["proof (state)\nthis:\n  (x < y in l \\<and> \\<not> (x = l ! 0 \\<and> y = l ! Suc 0) \\<or>\n   x = l ! Suc 0 \\<and> y = l ! 0) =\n  (x = l ! Suc 0 \\<and> y = l ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "have \"\\<dots> = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = l ! Suc 0 \\<and> y = l ! 0) = True", "using g"], ["proof (prove)\nusing this:\n  x = l ! 1\n  y = l ! 0\n\ngoal (1 subgoal):\n 1. (x = l ! Suc 0 \\<and> y = l ! 0) = True", "by auto"], ["proof (state)\nthis:\n  (x = l ! Suc 0 \\<and> y = l ! 0) = True\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "finally"], ["proof (chain)\npicking this:\n  x < y in swap 0 l = True", "have \"x < y in (swap 0) l\""], ["proof (prove)\nusing this:\n  x < y in swap 0 l = True\n\ngoal (1 subgoal):\n 1. x < y in swap 0 l", "by simp"], ["proof (state)\nthis:\n  x < y in swap 0 l\n\ngoal (1 subgoal):\n 1. \\<not> x < y in l \\<Longrightarrow>\n    x < y in swap 0 l = (\\<not> x < y in l)", "then"], ["proof (chain)\npicking this:\n  x < y in swap 0 l", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in swap 0 l\n\ngoal (1 subgoal):\n 1. x < y in swap 0 l = (\\<not> x < y in l)", "using False"], ["proof (prove)\nusing this:\n  x < y in swap 0 l\n  \\<not> x < y in l\n\ngoal (1 subgoal):\n 1. x < y in swap 0 l = (\\<not> x < y in l)", "by auto"], ["proof (state)\nthis:\n  x < y in swap 0 l = (\\<not> x < y in l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma before_in_swap2:\n \"dist_perm xs ys \\<Longrightarrow> Suc n < size xs \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow>\n  x < y in (swap n xs) \\<longleftrightarrow>\n  (~ x < y in xs \\<and> (y = xs!n \\<and> x = xs!Suc n)\n      \\<or> x < y in xs \\<and> ~(y = xs!Suc n \\<and> x = xs!n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist_perm xs ys; Suc n < length xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x < y in swap n xs =\n                      (\\<not> x < y in xs \\<and>\n                       y = xs ! n \\<and> x = xs ! Suc n \\<or>\n                       x < y in xs \\<and>\n                       \\<not> (y = xs ! Suc n \\<and> x = xs ! n))", "apply(simp add:before_in_def index_swap_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist_perm xs ys; Suc n < length xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (x = xs ! Suc n \\<longrightarrow>\n                       (xs ! Suc n = xs ! n \\<longrightarrow>\n                        y \\<noteq> xs ! n \\<and>\n                        (y \\<noteq> xs ! n \\<longrightarrow>\n                         (Suc n < index xs y \\<and> y \\<in> set ys) =\n                         (index xs (xs ! n) < index xs y \\<and>\n                          y \\<in> set ys))) \\<and>\n                       (xs ! Suc n \\<noteq> xs ! n \\<longrightarrow>\n                        y \\<noteq> xs ! Suc n \\<longrightarrow>\n                        (y = xs ! n \\<longrightarrow>\n                         xs ! n \\<in> set ys) \\<and>\n                        (y \\<noteq> xs ! n \\<longrightarrow>\n                         (n < index xs y \\<and> y \\<in> set ys) =\n                         (index xs (xs ! Suc n) < index xs y \\<and>\n                          y \\<in> set ys)))) \\<and>\n                      (x \\<noteq> xs ! Suc n \\<longrightarrow>\n                       (x = xs ! n \\<longrightarrow>\n                        (y = xs ! Suc n \\<longrightarrow>\n                         xs ! Suc n \\<noteq> xs ! n) \\<and>\n                        (y \\<noteq> xs ! Suc n \\<longrightarrow>\n                         (y = xs ! n \\<longrightarrow>\n                          xs ! n \\<noteq> xs ! Suc n) \\<and>\n                         (y \\<noteq> xs ! n \\<longrightarrow>\n                          (Suc n < index xs y \\<and> y \\<in> set ys) =\n                          (index xs (xs ! n) < index xs y \\<and>\n                           y \\<in> set ys)))) \\<and>\n                       (x \\<noteq> xs ! n \\<longrightarrow>\n                        (y = xs ! Suc n \\<longrightarrow>\n                         (xs ! Suc n = xs ! n \\<longrightarrow>\n                          (index xs x < Suc n \\<and> xs ! n \\<in> set ys) =\n                          (index xs x < index xs (xs ! n) \\<and>\n                           xs ! n \\<in> set ys)) \\<and>\n                         (xs ! Suc n \\<noteq> xs ! n \\<longrightarrow>\n                          (index xs x < n \\<and> xs ! Suc n \\<in> set ys) =\n                          (index xs x < index xs (xs ! Suc n) \\<and>\n                           xs ! Suc n \\<in> set ys))) \\<and>\n                        (y \\<noteq> xs ! Suc n \\<longrightarrow>\n                         y = xs ! n \\<longrightarrow>\n                         (index xs x < Suc n \\<and> xs ! n \\<in> set ys) =\n                         (index xs x < index xs (xs ! n) \\<and>\n                          xs ! n \\<in> set ys))))", "by (metis Suc_lessD Suc_lessI index_nth_id less_Suc_eq nth_mem yes)"], ["", "lemma projected_paid_same_effect: \n  assumes\n   d: \"dist_perm s1 s1\"  \n  and ee: \"x\\<noteq>y\"  \n  and f: \"set s2 = {x, y}\"  \n  and g: \"length s2 = 2\"  \n  and h: \"dist_perm s2 s2\"  \n  shows \"x < y in s1 = x < y in s2 \\<Longrightarrow>\n  x < y in swaps acs s1 = x < y in (swap 0 ^^ ALG_P acs x y s1) s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in s1 = x < y in s2 \\<Longrightarrow>\n    x < y in swaps acs s1 = x < y in (swap 0 ^^ ALG_P acs x y s1) s2", "proof (induct acs)"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y in s1 = x < y in s2 \\<Longrightarrow>\n    x < y in swaps [] s1 = x < y in (swap 0 ^^ ALG_P [] x y s1) s2\n 2. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "case Nil"], ["proof (state)\nthis:\n  x < y in s1 = x < y in s2\n\ngoal (2 subgoals):\n 1. x < y in s1 = x < y in s2 \\<Longrightarrow>\n    x < y in swaps [] s1 = x < y in (swap 0 ^^ ALG_P [] x y s1) s2\n 2. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "then"], ["proof (chain)\npicking this:\n  x < y in s1 = x < y in s2", "show ?case"], ["proof (prove)\nusing this:\n  x < y in s1 = x < y in s2\n\ngoal (1 subgoal):\n 1. x < y in swaps [] s1 = x < y in (swap 0 ^^ ALG_P [] x y s1) s2", "by auto"], ["proof (state)\nthis:\n  x < y in swaps [] s1 = x < y in (swap 0 ^^ ALG_P [] x y s1) s2\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "case (Cons s ss)"], ["proof (state)\nthis:\n  x < y in s1 = x < y in s2 \\<Longrightarrow>\n  x < y in swaps ss s1 = x < y in (swap 0 ^^ ALG_P ss x y s1) s2\n  x < y in s1 = x < y in s2\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "from d"], ["proof (chain)\npicking this:\n  dist_perm s1 s1", "have dd: \"dist_perm (swaps ss s1) (swaps ss s1)\""], ["proof (prove)\nusing this:\n  dist_perm s1 s1\n\ngoal (1 subgoal):\n 1. dist_perm (swaps ss s1) (swaps ss s1)", "by simp"], ["proof (state)\nthis:\n  dist_perm (swaps ss s1) (swaps ss s1)\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "from f"], ["proof (chain)\npicking this:\n  set s2 = {x, y}", "have ff: \"set ((swap 0 ^^ ALG_P ss x y s1) s2) = {x, y}\""], ["proof (prove)\nusing this:\n  set s2 = {x, y}\n\ngoal (1 subgoal):\n 1. set ((swap 0 ^^ ALG_P ss x y s1) s2) = {x, y}", "by (metis foldr_replicate swaps_inv)"], ["proof (state)\nthis:\n  set ((swap 0 ^^ ALG_P ss x y s1) s2) = {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "from g"], ["proof (chain)\npicking this:\n  length s2 = 2", "have gg: \"length ((swap 0 ^^ ALG_P ss x y s1) s2) = 2\""], ["proof (prove)\nusing this:\n  length s2 = 2\n\ngoal (1 subgoal):\n 1. length ((swap 0 ^^ ALG_P ss x y s1) s2) = 2", "by (metis foldr_replicate swaps_inv)"], ["proof (state)\nthis:\n  length ((swap 0 ^^ ALG_P ss x y s1) s2) = 2\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "from h"], ["proof (chain)\npicking this:\n  dist_perm s2 s2", "have hh: \"dist_perm ((swap 0 ^^ ALG_P ss x y s1) s2) ((swap 0 ^^ ALG_P ss x y s1) s2)\""], ["proof (prove)\nusing this:\n  dist_perm s2 s2\n\ngoal (1 subgoal):\n 1. dist_perm ((swap 0 ^^ ALG_P ss x y s1) s2)\n     ((swap 0 ^^ ALG_P ss x y s1) s2)", "by (metis foldr_replicate swaps_inv)"], ["proof (state)\nthis:\n  dist_perm ((swap 0 ^^ ALG_P ss x y s1) s2)\n   ((swap 0 ^^ ALG_P ss x y s1) s2)\n\ngoal (1 subgoal):\n 1. \\<And>a acs.\n       \\<lbrakk>x < y in s1 = x < y in s2 \\<Longrightarrow>\n                x < y in swaps acs s1 =\n                x < y in (swap 0 ^^ ALG_P acs x y s1) s2;\n        x < y in s1 = x < y in s2\\<rbrakk>\n       \\<Longrightarrow> x < y in swaps (a # acs) s1 =\n                         x < y in (swap 0 ^^ ALG_P (a # acs) x y s1) s2", "show ?case (is \"?LHS = ?RHS\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "proof (cases \"Suc s < length (swaps ss s1) \\<and> (((swaps ss s1)!s=x \\<and> (swaps ss s1)!(Suc s)=y) \\<or> ((swaps ss s1)!s=y \\<and> (swaps ss s1)!(Suc s)=x))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "case True"], ["proof (state)\nthis:\n  Suc s < length (swaps ss s1) \\<and>\n  (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n   swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "from True"], ["proof (chain)\npicking this:\n  Suc s < length (swaps ss s1) \\<and>\n  (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n   swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)", "have 1:\" Suc s < length (swaps ss s1)\"\n          and 2: \"(swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y\n            \\<or>  swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)\""], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss s1) \\<and>\n  (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n   swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)\n\ngoal (1 subgoal):\n 1. Suc s < length (swaps ss s1) &&&\n    swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n    swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x", "by auto"], ["proof (state)\nthis:\n  Suc s < length (swaps ss s1)\n  swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n  swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "from True"], ["proof (chain)\npicking this:\n  Suc s < length (swaps ss s1) \\<and>\n  (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n   swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)", "have \"ALG_P (s # ss) x y s1 =  1 + ALG_P ss x y s1\""], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss s1) \\<and>\n  (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n   swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x)\n\ngoal (1 subgoal):\n 1. ALG_P (s # ss) x y s1 = 1 + ALG_P ss x y s1", "by auto"], ["proof (state)\nthis:\n  ALG_P (s # ss) x y s1 = 1 + ALG_P ss x y s1\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "then"], ["proof (chain)\npicking this:\n  ALG_P (s # ss) x y s1 = 1 + ALG_P ss x y s1", "have \"?RHS = x < y in (swap 0) ((swap 0 ^^ ALG_P ss x y s1) s2)\""], ["proof (prove)\nusing this:\n  ALG_P (s # ss) x y s1 = 1 + ALG_P ss x y s1\n\ngoal (1 subgoal):\n 1. x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n    x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2)", "by auto"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n  x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n  x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = (~ x < y in ((swap 0 ^^ ALG_P ss x y s1) s2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2) =\n    (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2)", "apply(rule swap0in2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set ((swap 0 ^^ ALG_P ss x y s1) s2) = {x, y}\n 2. x \\<noteq> y\n 3. length ((swap 0 ^^ ALG_P ss x y s1) s2) = 2\n 4. dist_perm ((swap 0 ^^ ALG_P ss x y s1) s2)\n     ((swap 0 ^^ ALG_P ss x y s1) s2)", "by(fact)+"], ["proof (state)\nthis:\n  x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2) =\n  (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  x < y in swap 0 ((swap 0 ^^ ALG_P ss x y s1) s2) =\n  (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = (~ x < y in swaps ss s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2) =\n    (\\<not> x < y in swaps ss s1)", "using Cons"], ["proof (prove)\nusing this:\n  x < y in s1 = x < y in s2 \\<Longrightarrow>\n  x < y in swaps ss s1 = x < y in (swap 0 ^^ ALG_P ss x y s1) s2\n  x < y in s1 = x < y in s2\n\ngoal (1 subgoal):\n 1. (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2) =\n    (\\<not> x < y in swaps ss s1)", "by auto"], ["proof (state)\nthis:\n  (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2) =\n  (\\<not> x < y in swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  (\\<not> x < y in (swap 0 ^^ ALG_P ss x y s1) s2) =\n  (\\<not> x < y in swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = x < y in (swap s) (swaps ss s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x < y in swaps ss s1) = x < y in swap s (swaps ss s1)", "using 1  2 before_in_swap"], ["proof (prove)\nusing this:\n  Suc s < length (swaps ss s1)\n  swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n  swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x\n  \\<lbrakk>dist_perm ?xs ?ys; Suc ?n < length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y in swap ?n ?xs =\n                    (?x < ?y in ?xs \\<and>\n                     \\<not> (?x = ?xs ! ?n \\<and> ?y = ?xs ! Suc ?n) \\<or>\n                     ?x = ?xs ! Suc ?n \\<and> ?y = ?xs ! ?n)\n\ngoal (1 subgoal):\n 1. (\\<not> x < y in swaps ss s1) = x < y in swap s (swaps ss s1)", "by (metis Suc_lessD before_id dd lessI no_before_inI)"], ["proof (state)\nthis:\n  (\\<not> x < y in swaps ss s1) = x < y in swap s (swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "(* bad *)"], ["proof (state)\nthis:\n  (\\<not> x < y in swaps ss s1) = x < y in swap s (swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  (\\<not> x < y in swaps ss s1) = x < y in swap s (swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = ?LHS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap s (swaps ss s1) = x < y in swaps (s # ss) s1", "by auto"], ["proof (state)\nthis:\n  x < y in swap s (swaps ss s1) = x < y in swaps (s # ss) s1\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<and>\n    (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n     swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n 2. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "finally"], ["proof (chain)\npicking this:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 = x < y in swaps (s # ss) s1", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 = x < y in swaps (s # ss) s1\n\ngoal (1 subgoal):\n 1. x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "by simp"], ["proof (state)\nthis:\n  x < y in swaps (s # ss) s1 = x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "case False"], ["proof (state)\nthis:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "note F=this"], ["proof (state)\nthis:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "then"], ["proof (chain)\npicking this:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))", "have \"ALG_P (s # ss) x y s1 =  ALG_P ss x y s1\""], ["proof (prove)\nusing this:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))\n\ngoal (1 subgoal):\n 1. ALG_P (s # ss) x y s1 = ALG_P ss x y s1", "by auto"], ["proof (state)\nthis:\n  ALG_P (s # ss) x y s1 = ALG_P ss x y s1\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "then"], ["proof (chain)\npicking this:\n  ALG_P (s # ss) x y s1 = ALG_P ss x y s1", "have \"?RHS = x < y in ((swap 0 ^^ ALG_P ss x y s1) s2)\""], ["proof (prove)\nusing this:\n  ALG_P (s # ss) x y s1 = ALG_P ss x y s1\n\ngoal (1 subgoal):\n 1. x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n    x < y in (swap 0 ^^ ALG_P ss x y s1) s2", "by auto"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n  x < y in (swap 0 ^^ ALG_P ss x y s1) s2\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 =\n  x < y in (swap 0 ^^ ALG_P ss x y s1) s2\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = x < y in swaps ss s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in (swap 0 ^^ ALG_P ss x y s1) s2 = x < y in swaps ss s1", "using Cons"], ["proof (prove)\nusing this:\n  x < y in s1 = x < y in s2 \\<Longrightarrow>\n  x < y in swaps ss s1 = x < y in (swap 0 ^^ ALG_P ss x y s1) s2\n  x < y in s1 = x < y in s2\n\ngoal (1 subgoal):\n 1. x < y in (swap 0 ^^ ALG_P ss x y s1) s2 = x < y in swaps ss s1", "by auto"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P ss x y s1) s2 = x < y in swaps ss s1\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  x < y in (swap 0 ^^ ALG_P ss x y s1) s2 = x < y in swaps ss s1\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = x < y in (swap s) (swaps ss s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "proof (cases \"Suc s < length (swaps ss s1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n 2. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "case True"], ["proof (state)\nthis:\n  Suc s < length (swaps ss s1)\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n 2. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "with F"], ["proof (chain)\npicking this:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))\n  Suc s < length (swaps ss s1)", "have g: \"swaps ss s1 ! s \\<noteq> x \\<or>\n         swaps ss s1 ! Suc s \\<noteq> y\" and\n        h: \"swaps ss s1 ! s \\<noteq> y \\<or>\n         swaps ss s1 ! Suc s \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<not> (Suc s < length (swaps ss s1) \\<and>\n          (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n           swaps ss s1 ! s = y \\<and> swaps ss s1 ! Suc s = x))\n  Suc s < length (swaps ss s1)\n\ngoal (1 subgoal):\n 1. swaps ss s1 ! s \\<noteq> x \\<or> swaps ss s1 ! Suc s \\<noteq> y &&&\n    swaps ss s1 ! s \\<noteq> y \\<or> swaps ss s1 ! Suc s \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  swaps ss s1 ! s \\<noteq> x \\<or> swaps ss s1 ! Suc s \\<noteq> y\n  swaps ss s1 ! s \\<noteq> y \\<or> swaps ss s1 ! Suc s \\<noteq> x\n\ngoal (2 subgoals):\n 1. Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n 2. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "unfolding before_in_swap[OF dd True, of x y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 =\n    (x < y in swaps ss s1 \\<and>\n     \\<not> (x = swaps ss s1 ! s \\<and> y = swaps ss s1 ! Suc s) \\<or>\n     x = swaps ss s1 ! Suc s \\<and> y = swaps ss s1 ! s)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 =\n    (x < y in swaps ss s1 \\<and>\n     (x = swaps ss s1 ! s \\<longrightarrow>\n      y \\<noteq> swaps ss s1 ! Suc s) \\<or>\n     x = swaps ss s1 ! Suc s \\<and> y = swaps ss s1 ! s)", "using g h"], ["proof (prove)\nusing this:\n  swaps ss s1 ! s \\<noteq> x \\<or> swaps ss s1 ! Suc s \\<noteq> y\n  swaps ss s1 ! s \\<noteq> y \\<or> swaps ss s1 ! Suc s \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 =\n    (x < y in swaps ss s1 \\<and>\n     (x = swaps ss s1 ! s \\<longrightarrow>\n      y \\<noteq> swaps ss s1 ! Suc s) \\<or>\n     x = swaps ss s1 ! Suc s \\<and> y = swaps ss s1 ! s)", "by auto"], ["proof (state)\nthis:\n  x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n\ngoal (1 subgoal):\n 1. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "case False"], ["proof (state)\nthis:\n  \\<not> Suc s < length (swaps ss s1)\n\ngoal (1 subgoal):\n 1. \\<not> Suc s < length (swaps ss s1) \\<Longrightarrow>\n    x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc s < length (swaps ss s1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Suc s < length (swaps ss s1)\n\ngoal (1 subgoal):\n 1. x < y in swaps ss s1 = x < y in swap s (swaps ss s1)", "unfolding swap_def"], ["proof (prove)\nusing this:\n  \\<not> Suc s\n         < length\n            (foldr\n              (\\<lambda>n xs.\n                  if Suc n < length xs\n                  then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n              ss s1)\n\ngoal (1 subgoal):\n 1. x < y\n    in foldr\n        (\\<lambda>n xs.\n            if Suc n < length xs then xs[n := xs ! Suc n, Suc n := xs ! n]\n            else xs)\n        ss s1 =\n    x < y\n    in (if Suc s\n           < length\n              (foldr\n                (\\<lambda>n xs.\n                    if Suc n < length xs\n                    then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                ss s1)\n        then (foldr\n               (\\<lambda>n xs.\n                   if Suc n < length xs\n                   then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n               ss s1)\n             [s := foldr\n                    (\\<lambda>n xs.\n                        if Suc n < length xs\n                        then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                    ss s1 !\n                   Suc s,\n              Suc s :=\n                foldr\n                 (\\<lambda>n xs.\n                     if Suc n < length xs\n                     then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n                 ss s1 !\n                s]\n        else foldr\n              (\\<lambda>n xs.\n                  if Suc n < length xs\n                  then xs[n := xs ! Suc n, Suc n := xs ! n] else xs)\n              ss s1)", "by(simp)"], ["proof (state)\nthis:\n  x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "also"], ["proof (state)\nthis:\n  x < y in swaps ss s1 = x < y in swap s (swaps ss s1)\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "have \"\\<dots> = ?LHS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in swap s (swaps ss s1) = x < y in swaps (s # ss) s1", "by auto"], ["proof (state)\nthis:\n  x < y in swap s (swaps ss s1) = x < y in swaps (s # ss) s1\n\ngoal (1 subgoal):\n 1. \\<not> (Suc s < length (swaps ss s1) \\<and>\n            (swaps ss s1 ! s = x \\<and> swaps ss s1 ! Suc s = y \\<or>\n             swaps ss s1 ! s = y \\<and>\n             swaps ss s1 ! Suc s = x)) \\<Longrightarrow>\n    x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "finally"], ["proof (chain)\npicking this:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 = x < y in swaps (s # ss) s1", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2 = x < y in swaps (s # ss) s1\n\ngoal (1 subgoal):\n 1. x < y in swaps (s # ss) s1 =\n    x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2", "by simp"], ["proof (state)\nthis:\n  x < y in swaps (s # ss) s1 = x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in swaps (s # ss) s1 = x < y in (swap 0 ^^ ALG_P (s # ss) x y s1) s2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_steps':\n  \"length qs = length as \\<Longrightarrow> steps s qs as = steps' s qs as (length as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    Partial_Cost_Model.steps s qs as = steps' s qs as (length as)", "by (induct qs as arbitrary: s rule: list_induct2) (auto)"], ["", "lemma T1_7': \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs \\<Longrightarrow> length Strat = length qs\n      \\<Longrightarrow> n\\<le>length qs \\<Longrightarrow>  \n      x\\<noteq>(y::('a::linorder)) \\<Longrightarrow>\n      x\\<in> set init \\<Longrightarrow> y \\<in> set init \\<Longrightarrow> distinct init \\<Longrightarrow>\n      set qs \\<subseteq> set init \\<Longrightarrow>\n      (\\<exists>Strat2 sws. \n        \\<^cancel>\\<open>T\\<^sub>p_opt (Lxy init {x,y}) (Lxy (take n qs) {x,y}) \\<le> T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2\n          \\<and>\\<close>  length Strat2 = length (Lxy (take n qs) {x,y})\n          \\<and>     (x < y in (steps' init (take n qs) (take n Strat) n))\n              = (x < y in (swaps sws (steps' (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2 (length Strat2))))\n          \\<and> T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x,y}) Strat2 + length sws =            \n          ALGxy_det Strat (take n qs) init x y + ALG_Pxy Strat (take n qs) init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take n qs) {x, y}) \\<and>\n                         x < y in steps' init (take n qs) (take n Strat) n =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take n qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take n qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take n qs) init x y +\n                         ALG_Pxy Strat (take n qs) init x y", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n   length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n   x \\<in> set init; y \\<in> set init; distinct init;\n   set qs \\<subseteq> set init\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Strat2 sws.\n                       length Strat2 =\n                       length (Lxy (take n qs) {x, y}) \\<and>\n                       x < y in steps' init (take n qs) (take n Strat) n =\n                       x < y\n                       in swaps sws\n                           (steps' (Lxy init {x, y})\n                             (Lxy (take n qs) {x, y}) Strat2\n                             (length Strat2)) \\<and>\n                       T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                        Strat2 +\n                       length sws =\n                       ALGxy_det Strat (take n qs) init x y +\n                       ALG_Pxy Strat (take n qs) init x y\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  Suc n \\<le> length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from Suc(3,4)"], ["proof (chain)\npicking this:\n  length Strat = length qs\n  Suc n \\<le> length qs", "have ns: \"n < length qs\""], ["proof (prove)\nusing this:\n  length Strat = length qs\n  Suc n \\<le> length qs\n\ngoal (1 subgoal):\n 1. n < length qs", "by simp"], ["proof (state)\nthis:\n  n < length qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  n < length qs", "have n: \"n \\<le> length qs\""], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. n \\<le> length qs", "by simp"], ["proof (state)\nthis:\n  n \\<le> length qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from Suc(1)[OF Suc(2) Suc(3) n Suc(5) Suc(6) Suc(7) Suc(8) Suc(9) ]"], ["proof (chain)\npicking this:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take n qs) {x, y}) \\<and>\n     x < y in steps' init (take n qs) (take n Strat) n =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take n qs) init x y +\n     ALG_Pxy Strat (take n qs) init x y", "obtain Strat2 sws where \n  (*S2: \"T\\<^sub>p_opt (Lxy init {x,y}) (Lxy (take n qs) {x, y})\n     \\<le> T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2\"\n     and *) len: \"length Strat2 = length (Lxy (take n qs) {x, y})\"\n     and iff:\n      \"x < y in steps' init (take n qs) (take n Strat) n\n         =\n       x < y in swaps sws (steps' (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2 (length Strat2))\"   \n\n     and T_Strat2: \"T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2 + length sws =\n     ALGxy_det Strat (take n qs) init x y +\n     ALG_Pxy Strat (take n qs) init x y \""], ["proof (prove)\nusing this:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take n qs) {x, y}) \\<and>\n     x < y in steps' init (take n qs) (take n Strat) n =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take n qs) init x y +\n     ALG_Pxy Strat (take n qs) init x y\n\ngoal (1 subgoal):\n 1. (\\<And>Strat2 sws.\n        \\<lbrakk>length Strat2 = length (Lxy (take n qs) {x, y});\n         x < y in steps' init (take n qs) (take n Strat) n =\n         x < y\n         in swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2));\n         T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n         length sws =\n         ALGxy_det Strat (take n qs) init x y +\n         ALG_Pxy Strat (take n qs) init x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n  x < y in steps' init (take n qs) (take n Strat) n =\n  x < y\n  in swaps sws\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws =\n  ALGxy_det Strat (take n qs) init x y + ALG_Pxy Strat (take n qs) init x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from Suc(3-4)"], ["proof (chain)\npicking this:\n  length Strat = length qs\n  Suc n \\<le> length qs", "have nStrat: \"n < length Strat\""], ["proof (prove)\nusing this:\n  length Strat = length qs\n  Suc n \\<le> length qs\n\ngoal (1 subgoal):\n 1. n < length Strat", "by auto"], ["proof (state)\nthis:\n  n < length Strat\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from take_Suc_conv_app_nth[OF this]"], ["proof (chain)\npicking this:\n  take (Suc n) Strat = take n Strat @ [Strat ! n]", "have tak2: \"take (Suc n) Strat = take n Strat @ [Strat ! n]\""], ["proof (prove)\nusing this:\n  take (Suc n) Strat = take n Strat @ [Strat ! n]\n\ngoal (1 subgoal):\n 1. take (Suc n) Strat = take n Strat @ [Strat ! n]", "by auto"], ["proof (state)\nthis:\n  take (Suc n) Strat = take n Strat @ [Strat ! n]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from take_Suc_conv_app_nth[OF ns]"], ["proof (chain)\npicking this:\n  take (Suc n) qs = take n qs @ [qs ! n]", "have tak: \"take (Suc n) qs = take n qs @ [qs ! n]\""], ["proof (prove)\nusing this:\n  take (Suc n) qs = take n qs @ [qs ! n]\n\ngoal (1 subgoal):\n 1. take (Suc n) qs = take n qs @ [qs ! n]", "by auto"], ["proof (state)\nthis:\n  take (Suc n) qs = take n qs @ [qs ! n]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have aS: \"length (take n Strat) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n Strat) = n", "using Suc(3,4)"], ["proof (prove)\nusing this:\n  length Strat = length qs\n  Suc n \\<le> length qs\n\ngoal (1 subgoal):\n 1. length (take n Strat) = n", "by auto"], ["proof (state)\nthis:\n  length (take n Strat) = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have aQ: \"length (take n qs) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n qs) = n", "using Suc(4)"], ["proof (prove)\nusing this:\n  Suc n \\<le> length qs\n\ngoal (1 subgoal):\n 1. length (take n qs) = n", "by auto"], ["proof (state)\nthis:\n  length (take n qs) = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from aS aQ"], ["proof (chain)\npicking this:\n  length (take n Strat) = n\n  length (take n qs) = n", "have qQS: \"length (take n qs) = length (take n Strat)\""], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n  length (take n qs) = n\n\ngoal (1 subgoal):\n 1. length (take n qs) = length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  length (take n qs) = length (take n Strat)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have xyininit: \"x\\<in> set init\" \"y : set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set init &&& y \\<in> set init", "by fact+"], ["proof (state)\nthis:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  x \\<in> set init\n  y \\<in> set init", "have xysubs: \"{x,y} \\<subseteq> set init\""], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> set init", "by auto"], ["proof (state)\nthis:\n  {x, y} \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have dI:  \"distinct init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init", "by fact"], ["proof (state)\nthis:\n  distinct init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"set qs \\<subseteq> set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set qs \\<subseteq> set init", "by fact"], ["proof (state)\nthis:\n  set qs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  set qs \\<subseteq> set init", "have qsnset: \"qs ! n \\<in> set init\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init", "using ns"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n  n < length qs\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> set init", "by auto"], ["proof (state)\nthis:\n  qs ! n \\<in> set init\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from xyininit"], ["proof (chain)\npicking this:\n  x \\<in> set init\n  y \\<in> set init", "have ahjer: \"set (Lxy init {x, y}) = {x,y}\""], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "using xysubs"], ["proof (prove)\nusing this:\n  x \\<in> set init\n  y \\<in> set init\n  {x, y} \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. set (Lxy init {x, y}) = {x, y}", "by (simp add: Lxy_set_filter)"], ["proof (state)\nthis:\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "with Suc(5)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  set (Lxy init {x, y}) = {x, y}", "have ah: \"card (set (Lxy init {x, y})) = 2\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (Lxy init {x, y}) = {x, y}\n\ngoal (1 subgoal):\n 1. card (set (Lxy init {x, y})) = 2", "by simp"], ["proof (state)\nthis:\n  card (set (Lxy init {x, y})) = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "have ahjer3: \"distinct (Lxy init {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (Lxy init {x, y})", "apply(rule Lxy_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init", "by fact"], ["proof (state)\nthis:\n  distinct (Lxy init {x, y})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "from ah"], ["proof (chain)\npicking this:\n  card (set (Lxy init {x, y})) = 2", "have ahjer2: \"length (Lxy init {x,y}) = 2\""], ["proof (prove)\nusing this:\n  card (set (Lxy init {x, y})) = 2\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "using distinct_card[OF ahjer3]"], ["proof (prove)\nusing this:\n  card (set (Lxy init {x, y})) = 2\n  card (set (Lxy init {x, y})) = length (Lxy init {x, y})\n\ngoal (1 subgoal):\n 1. length (Lxy init {x, y}) = 2", "by simp"], ["proof (state)\nthis:\n  length (Lxy init {x, y}) = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n                 length Strat = length qs; n \\<le> length qs; x \\<noteq> y;\n                 x \\<in> set init; y \\<in> set init; distinct init;\n                 set qs \\<subseteq> set init\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Strat2 sws.\n                                     length Strat2 =\n                                     length (Lxy (take n qs) {x, y}) \\<and>\n                                     x < y\n                                     in steps' init (take n qs)\n   (take n Strat) n =\n                                     x < y\n                                     in swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) \\<and>\n                                     T\\<^sub>p (Lxy init {x, y})\n(Lxy (take n qs) {x, y}) Strat2 +\n                                     length sws =\n                                     ALGxy_det Strat (take n qs) init x y +\n                                     ALG_Pxy Strat (take n qs) init x y;\n        T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n        length Strat = length qs; Suc n \\<le> length qs; x \\<noteq> y;\n        x \\<in> set init; y \\<in> set init; distinct init;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Strat2 sws.\n                            length Strat2 =\n                            length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n                            x < y\n                            in steps' init (take (Suc n) qs)\n                                (take (Suc n) Strat) (Suc n) =\n                            x < y\n                            in swaps sws\n                                (steps' (Lxy init {x, y})\n                                  (Lxy (take (Suc n) qs) {x, y}) Strat2\n                                  (length Strat2)) \\<and>\n                            T\\<^sub>p (Lxy init {x, y})\n                             (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n                            length sws =\n                            ALGxy_det Strat (take (Suc n) qs) init x y +\n                            ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "proof (cases \"qs ! n \\<in> {x,y}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "case False"], ["proof (state)\nthis:\n  qs ! n \\<notin> {x, y}\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "with tak"], ["proof (chain)\npicking this:\n  take (Suc n) qs = take n qs @ [qs ! n]\n  qs ! n \\<notin> {x, y}", "have nixzutun: \"Lxy (take (Suc n) qs) {x,y}  = Lxy (take n qs) {x,y}\""], ["proof (prove)\nusing this:\n  take (Suc n) qs = take n qs @ [qs ! n]\n  qs ! n \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (take (Suc n) qs) {x, y} = Lxy (take n qs) {x, y}", "unfolding Lxy_def"], ["proof (prove)\nusing this:\n  take (Suc n) qs = take n qs @ [qs ! n]\n  qs ! n \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>z. z \\<in> {x, y}) (take (Suc n) qs) =\n    filter (\\<lambda>z. z \\<in> {x, y}) (take n qs)", "by simp"], ["proof (state)\nthis:\n  Lxy (take (Suc n) qs) {x, y} = Lxy (take n qs) {x, y}\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?m=\"ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y\""], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?L=\"replicate ?m 0 @ sws\""], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "fix xs::\"('a::linorder) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "fix m::nat"], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "fix q::'a"], ["proof (state)\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "assume \"q \\<notin> {x,y}\""], ["proof (state)\nthis:\n  q \\<notin> {x, y}\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  q \\<notin> {x, y}", "have 5: \"y \\<noteq> q\""], ["proof (prove)\nusing this:\n  q \\<notin> {x, y}\n\ngoal (1 subgoal):\n 1. y \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> q\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "assume 1: \"q \\<in> set xs\""], ["proof (state)\nthis:\n  q \\<in> set xs\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "assume 2: \"distinct xs\""], ["proof (state)\nthis:\n  distinct xs\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "assume 3: \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "assume 4: \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"(x < y in xs) = (x < y in (mtf2 m q xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in xs = x < y in mtf2 m q xs", "by (metis \"1\" \"2\" \"3\" \"4\" \\<open>q \\<notin> {x, y}\\<close> insertCI not_before_in set_mtf2 swapped_by_mtf2)"], ["proof (state)\nthis:\n  x < y in xs = x < y in mtf2 m q xs\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?q2 \\<notin> {x, y}; ?q2 \\<in> set ?xs2; distinct ?xs2;\n   x \\<in> set ?xs2; y \\<in> set ?xs2\\<rbrakk>\n  \\<Longrightarrow> x < y in ?xs2 = x < y in mtf2 ?m2 ?q2 ?xs2\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "note f=this"], ["proof (state)\nthis:\n  \\<lbrakk>?q2 \\<notin> {x, y}; ?q2 \\<in> set ?xs2; distinct ?xs2;\n   x \\<in> set ?xs2; y \\<in> set ?xs2\\<rbrakk>\n  \\<Longrightarrow> x < y in ?xs2 = x < y in mtf2 ?m2 ?q2 ?xs2\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* taktik, erstmal das mtf weg bekommen,\n       dann induct ?ber snd (Strat!n) *)"], ["proof (state)\nthis:\n  \\<lbrakk>?q2 \\<notin> {x, y}; ?q2 \\<in> set ?xs2; distinct ?xs2;\n   x \\<in> set ?xs2; y \\<in> set ?xs2\\<rbrakk>\n  \\<Longrightarrow> x < y in ?xs2 = x < y in mtf2 ?m2 ?q2 ?xs2\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"(x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n            = (x < y in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "unfolding tak2 tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n        (Suc n) =\n    x < y\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(simp only: steps'_append[OF qQS aQ] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in step (steps' init (take n qs) (take n Strat) n) (qs ! n)\n        (Strat ! n) =\n    x < y\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by (simp add: step_def split_def)"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = (x < y in (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n)) =\n    x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)", "apply(rule f[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. qs ! n \\<notin> {x, y}\n 2. qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n 3. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 4. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 5. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "apply(fact)"], ["proof (prove)\ngoal (4 subgoals):\n 1. qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n 2. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 3. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 4. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "using qsnset steps'_set[OF qQS] aS"], ["proof (prove)\nusing this:\n  qs ! n \\<in> set init\n  ?n \\<le> length (take n Strat) \\<Longrightarrow>\n  set (steps' ?s (take n qs) (take n Strat) ?n) = set ?s\n  length (take n Strat) = n\n\ngoal (4 subgoals):\n 1. qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n 2. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 3. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 4. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 2. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 3. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "using steps'_distinct[OF qQS] aS dI"], ["proof (prove)\nusing this:\n  length (take n Strat) = ?n \\<Longrightarrow>\n  distinct (steps' ?s (take n qs) (take n Strat) ?n) = distinct ?s\n  length (take n Strat) = n\n  distinct init\n\ngoal (3 subgoals):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 2. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 3. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 2. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "using steps'_set[OF qQS] aS xyininit"], ["proof (prove)\nusing this:\n  ?n \\<le> length (take n Strat) \\<Longrightarrow>\n  set (steps' ?s (take n qs) (take n Strat) ?n) = set ?s\n  length (take n Strat) = n\n  x \\<in> set init\n  y \\<in> set init\n\ngoal (2 subgoals):\n 1. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 2. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))", "by simp_all"], ["proof (state)\nthis:\n  x < y\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)) =\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  x < y\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)) =\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> =  x < y in (swap 0 ^^ ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n                                    (swaps sws (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 (length Strat2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(rule projected_paid_same_effect)"], ["proof (prove)\ngoal (6 subgoals):\n 1. dist_perm (steps' init (take n qs) (take n Strat) n)\n     (steps' init (take n qs) (take n Strat) n)\n 2. x \\<noteq> y\n 3. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 4. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 5. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 6. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(rule steps'_dist_perm)"], ["proof (prove)\ngoal (8 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. length (take n Strat) = n\n 3. dist_perm init init\n 4. x \\<noteq> y\n 5. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 6. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 7. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 8. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(fact qQS)"], ["proof (prove)\ngoal (7 subgoals):\n 1. length (take n Strat) = n\n 2. dist_perm init init\n 3. x \\<noteq> y\n 4. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 5. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 6. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 7. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(fact aS)"], ["proof (prove)\ngoal (6 subgoals):\n 1. dist_perm init init\n 2. x \\<noteq> y\n 3. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 4. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 5. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 6. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "using dI"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (6 subgoals):\n 1. dist_perm init init\n 2. x \\<noteq> y\n 3. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 4. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 5. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 6. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<noteq> y\n 2. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 3. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 4. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 5. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(fact Suc(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}\n 2. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 3. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) =\n    {x, y}\n 2. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 3. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(rule steps'_set[where s=\"Lxy init {x,y}\", unfolded ahjer])"], ["proof (prove)\ngoal (5 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 4. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 5. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (5 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 4. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 5. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. length Strat2 \\<le> length Strat2\n 2. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 3. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2\n 2. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 3. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)) =\n    2\n 2. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 3. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(rule steps'_length[where s=\"Lxy init {x,y}\", unfolded ahjer2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (4 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length Strat2 \\<le> length Strat2\n 2. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 3. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n 2. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))\n 2. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(rule steps'_distinct2[where s=\"Lxy init {x,y}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. distinct (Lxy init {x, y})\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (4 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. distinct (Lxy init {x, y})\n 4. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length Strat2 \\<le> length Strat2\n 2. distinct (Lxy init {x, y})\n 3. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (Lxy init {x, y})\n 2. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "using iff"], ["proof (prove)\nusing this:\n  x < y in steps' init (take n qs) (take n Strat) n =\n  x < y\n  in swaps sws\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take n qs) (take n Strat) n =\n    x < y\n    in swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))", "have umfa: \"x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in (swap 0 ^^ ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n      (swaps sws (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 (length Strat2)))\""], ["proof (prove)\nusing this:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "."], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "from Suc(3,4)"], ["proof (chain)\npicking this:\n  length Strat = length qs\n  Suc n \\<le> length qs", "have lS: \"length (take n Strat) = n\""], ["proof (prove)\nusing this:\n  length Strat = length qs\n  Suc n \\<le> length qs\n\ngoal (1 subgoal):\n 1. length (take n Strat) = n", "by auto"], ["proof (state)\nthis:\n  length (take n Strat) = n\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"(take n Strat @ [Strat ! n]) ! n =\n              (take n Strat @ (Strat ! n) # []) ! length (take n Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n =\n    (take n Strat @ [Strat ! n]) ! length (take n Strat)", "using lS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n =\n    (take n Strat @ [Strat ! n]) ! length (take n Strat)", "by auto"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n =\n  (take n Strat @ [Strat ! n]) ! length (take n Strat)\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n =\n  (take n Strat @ [Strat ! n]) ! length (take n Strat)\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = Strat ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! length (take n Strat) = Strat ! n", "by(rule nth_append_length)"], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! length (take n Strat) = Strat ! n\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n", "have tt: \"(take n Strat @ [Strat ! n]) ! n = Strat ! n\""], ["proof (prove)\nusing this:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n\n\ngoal (1 subgoal):\n 1. (take n Strat @ [Strat ! n]) ! n = Strat ! n", "."], ["proof (state)\nthis:\n  (take n Strat @ [Strat ! n]) ! n = Strat ! n\n\ngoal (2 subgoals):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y\n 2. qs ! n \\<notin> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(rule exI[where x=\"Strat2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(rule exI[where x=\"?L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n          (length Strat2)) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "unfolding nixzutun"], ["proof (prove)\ngoal (1 subgoal):\n 1. length Strat2 = length (Lxy (take n qs) {x, y}) \\<and>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. length Strat2 = length (Lxy (take n qs) {x, y})\n 2. x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))\n 3. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 4. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(fact)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))\n 2. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 3. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "proof goal_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))\n 2. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 3. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 1"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (3 subgoals):\n 1. x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))\n 2. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 3. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "unfolding tak2 tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))", "apply(simp add: step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "unfolding ALG_P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd ((take n Strat @ [Strat ! n]) ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "unfolding tt"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "using aS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp only: steps'_rests[OF qQS, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n Strat) = n \\<Longrightarrow>\n    x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "using 1(1) umfa"], ["proof (prove)\nusing this:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. length (take n Strat) = n \\<Longrightarrow>\n    x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in swaps\n      (replicate\n        (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n          y)\n        0 @\n       sws)\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 2"], ["proof (state)\nthis:\n  x < y\n  in swaps\n      (replicate\n        (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n          y)\n        0 @\n       sws)\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps\n        (replicate\n          (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n\n            x y)\n          0 @\n         sws)\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  x < y\n  in swaps\n      (replicate\n        (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n          y)\n        0 @\n       sws)\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))", "show ?case"], ["proof (prove)\nusing this:\n  x < y\n  in swaps\n      (replicate\n        (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n          y)\n        0 @\n       sws)\n      (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n        (length Strat2))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "apply(simp add: step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "unfolding ALG_P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd ((take n Strat @ [Strat ! n]) ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "unfolding tt"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "using aS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n           n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "apply(simp only: steps'_rests[OF qQS, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y\n             in (swap 0 ^^\n                 ALG_P (snd (Strat ! n)) x y\n                  (steps' init (take n qs) (take n Strat) n))\n                 (swaps sws\n                   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                     (length Strat2)));\n     length (take n Strat) = n\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                          (Suc n)", "using umfa[symmetric]"], ["proof (prove)\nusing this:\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y\n             in (swap 0 ^^\n                 ALG_P (snd (Strat ! n)) x y\n                  (steps' init (take n qs) (take n Strat) n))\n                 (swaps sws\n                   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                     (length Strat2)));\n     length (take n Strat) = n\\<rbrakk>\n    \\<Longrightarrow> x < y\n                      in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                          (Suc n)", "by auto"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have ns2: \"n < length (take n qs @ [qs ! n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length (take n qs @ [qs ! n])", "using ns"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. n < length (take n qs @ [qs ! n])", "by auto"], ["proof (state)\nthis:\n  n < length (take n qs @ [qs ! n])\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have er: \"length (take n qs) < length Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n qs) < length Strat", "using Suc.prems(2) aQ ns"], ["proof (prove)\nusing this:\n  length Strat = length qs\n  length (take n qs) = n\n  n < length qs\n\ngoal (1 subgoal):\n 1. length (take n qs) < length Strat", "by linarith"], ["proof (state)\nthis:\n  length (take n qs) < length Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2\n      + length (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n      = ( T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2 + length sws)\n          + ALG_P' Strat (take n qs @ [qs ! n])  init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length sws +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> =  ALGxy_det Strat (take n qs) init x y +\n                  ALG_Pxy Strat (take n qs) init x y +\n                  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length sws +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "unfolding T_Strat2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take n qs) init x y +\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take n qs) init x y +\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = ALGxy_det Strat (take (Suc n) qs) init x y\n              + ALG_Pxy Strat (take (Suc n) qs) init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "unfolding tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take n qs @ [qs ! n]) init x y +\n    ALG_Pxy Strat (take n qs @ [qs ! n]) init x y", "unfolding wegdamit[OF er False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take n qs) init x y +\n    ALG_Pxy Strat (take n qs @ [qs ! n]) init x y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_Pxy Strat (take n qs @ [qs ! n]) init x y", "unfolding ALG_P_split[of \"take n qs\" Strat \"qs ! n\" init x y, unfolded aQ, OF nStrat]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by(simp)"], ["proof (state)\nthis:\n  ALGxy_det Strat (take n qs) init x y +\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "unfolding tak"], ["proof (prove)\nusing this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  ALGxy_det Strat (take n qs @ [qs ! n]) init x y +\n  ALG_Pxy Strat (take n qs @ [qs ! n]) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take n qs @ [qs ! n]) init x y +\n    ALG_Pxy Strat (take n qs @ [qs ! n]) init x y", "using ALG_P'_rest[OF ns nStrat]"], ["proof (prove)\nusing this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  ALGxy_det Strat (take n qs @ [qs ! n]) init x y +\n  ALG_Pxy Strat (take n qs @ [qs ! n]) init x y\n  ALG_P' Strat (take n qs @ [qs ! n]) ?init n ?x ?y =\n  ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) ?init n ?x ?y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length\n     (replicate\n       (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x\n         y)\n       0 @\n      sws) =\n    ALGxy_det Strat (take n qs @ [qs ! n]) init x y +\n    ALG_Pxy Strat (take n qs @ [qs ! n]) init x y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  length\n   (replicate\n     (ALG_P' (take n Strat @ [Strat ! n]) (take n qs @ [qs ! n]) init n x y)\n     0 @\n    sws) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n     x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take (Suc n) qs) init x y +\n     ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "case True"], ["proof (state)\nthis:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "note qsinxy=this"], ["proof (state)\nthis:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  qs ! n \\<in> {x, y}", "have yeh: \"Lxy (take (Suc n) qs) {x, y} = Lxy (take n qs) {x,y} @ [qs!n]\""], ["proof (prove)\nusing this:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. Lxy (take (Suc n) qs) {x, y} = Lxy (take n qs) {x, y} @ [qs ! n]", "unfolding tak Lxy_def"], ["proof (prove)\nusing this:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>z. z \\<in> {x, y}) (take n qs @ [qs ! n]) =\n    filter (\\<lambda>z. z \\<in> {x, y}) (take n qs) @ [qs ! n]", "by auto"], ["proof (state)\nthis:\n  Lxy (take (Suc n) qs) {x, y} = Lxy (take n qs) {x, y} @ [qs ! n]\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "from True"], ["proof (chain)\npicking this:\n  qs ! n \\<in> {x, y}", "have garar: \"(take n qs @ [qs ! n]) ! n \\<in> {y, x}\""], ["proof (prove)\nusing this:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. (take n qs @ [qs ! n]) ! n \\<in> {y, x}", "using tak[symmetric]"], ["proof (prove)\nusing this:\n  qs ! n \\<in> {x, y}\n  take n qs @ [qs ! n] = take (Suc n) qs\n\ngoal (1 subgoal):\n 1. (take n qs @ [qs ! n]) ! n \\<in> {y, x}", "by(auto)"], ["proof (state)\nthis:\n  (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have aer: \"\\<forall>i<n.\n        ((take n qs @ [qs ! n]) ! i \\<in> {y, x})\n          = (take n qs ! i \\<in> {y, x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n       (take n qs ! i \\<in> {y, x})", "using ns"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n       (take n qs ! i \\<in> {y, x})", "by (metis less_SucI nth_take tak)"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n     (take n qs ! i \\<in> {y, x})\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* erst definiere ich die zwischenzeitlichen Configurationen\n               ?xs  \\<rightarrow> ?xs'  \\<rightarrow> ?xs''\n        und\n        ?ys \\<rightarrow> ?ys' \\<rightarrow> ?ys'' \\<rightarrow> ?ys'''\n\n        und einige Eigenschaften ?ber sie\n    *)\n\n    (* what is the mtf action taken by Strat? *)"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n     (take n qs ! i \\<in> {y, x})\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?Strat_mft =  \"fst (Strat ! n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?Strat_sws =  \"snd (Strat ! n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* what is the configuration before the step? *)"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?xs = \"steps' init (take n qs) (take n Strat) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* what is the configuration before the mtf *)"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?xs' = \"(swaps (snd (Strat!n)) ?xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?xs'' = \"steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?xs''2 = \"mtf2 ?Strat_mft (qs!n) ?xs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* position of requested element *)"], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?no_swap_occurs = \"(x < y in ?xs') = (x < y in ?xs''2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?mtf=\"(if ?no_swap_occurs then 0 else 1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?m=\"ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?L=\"replicate ?m 0 @ sws\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?newStrat=\"Strat2@[(?mtf,?L)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"?xs'' =  step ?xs (qs!n) (Strat!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n)", "unfolding tak tak2"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) (take n Strat @ [Strat ! n])\n     (Suc n) =\n    step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n)", "apply(rule steps'_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. length (take n qs) = n", "by fact+"], ["proof (state)\nthis:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = mtf2 (fst (Strat!n)) (qs!n) (swaps (snd (Strat!n)) ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n) =\n    mtf2 (fst (Strat ! n)) (qs ! n)\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) = Strat ! n\n     in mtf2 k (qs ! n)\n         (swaps sws (steps' init (take n qs) (take n Strat) n))) =\n    mtf2 (fst (Strat ! n)) (qs ! n)\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by (auto simp: split_def)"], ["proof (state)\nthis:\n  step (steps' init (take n qs) (take n Strat) n) (qs ! n) (Strat ! n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "have A: \"?xs'' = mtf2 (fst (Strat!n)) (qs!n) ?xs'\""], ["proof (prove)\nusing this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    mtf2 (fst (Strat ! n)) (qs ! n)\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "."], ["proof (state)\nthis:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?ys = \"(steps' (Lxy init {x, y})\n                  (Lxy (take n qs) {x, y}) Strat2 (length Strat2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?ys' = \"( swaps sws (steps' (Lxy init {x, y})\n                  (Lxy (take n qs) {x, y}) Strat2 (length Strat2)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?ys'' = \" (swap 0 ^^ ALG_P (snd (Strat!n)) x y ?xs) ?ys'\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "let ?ys''' = \"(steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) ?newStrat (length ?newStrat))\""], ["proof (state)\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have gr: \"Lxy (take n qs @ [qs ! n]) {x, y} = \n        Lxy (take n qs) {x, y} @ [qs ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lxy (take n qs @ [qs ! n]) {x, y} = Lxy (take n qs) {x, y} @ [qs ! n]", "unfolding Lxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>z. z \\<in> {x, y}) (take n qs @ [qs ! n]) =\n    filter (\\<lambda>z. z \\<in> {x, y}) (take n qs) @ [qs ! n]", "using True"], ["proof (prove)\nusing this:\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>z. z \\<in> {x, y}) (take n qs @ [qs ! n]) =\n    filter (\\<lambda>z. z \\<in> {x, y}) (take n qs) @ [qs ! n]", "by(simp)"], ["proof (state)\nthis:\n  Lxy (take n qs @ [qs ! n]) {x, y} = Lxy (take n qs) {x, y} @ [qs ! n]\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"steps' init (take n qs @ [qs ! n]) Strat n\n      = steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n", "by simp"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "apply(subst steps'_rests[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)\n 3. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "using aS qQS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n  length (take n qs) = length (take n Strat)\n\ngoal (3 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)\n 3. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "by(simp_all)"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n", "have t: \"steps' init (take n qs @ [qs ! n]) Strat n\n        = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "."], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have gge: \"swaps (replicate ?m 0) ?ys'\n        =  (swap 0 ^^ ALG_P (snd (Strat!n)) x y ?xs) ?ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "unfolding ALG_P'_def t"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps\n     (replicate\n       (ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n       0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by simp"], ["proof (state)\nthis:\n  swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have gg: \"length ?newStrat = Suc (length Strat2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    Suc (length Strat2)", "by auto"], ["proof (state)\nthis:\n  length\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) =\n  Suc (length Strat2)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"?ys''' =  step ?ys (qs!n) (?mtf,?L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])\n     (length\n       (Strat2 @\n        [(if x < y\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n) =\n             x < y\n             in mtf2 (fst (Strat ! n)) (qs ! n)\n                 (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n          then 0 else 1,\n          replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n          sws)])) =\n    step\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)", "unfolding tak gr"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y} @ [qs ! n])\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])\n     (length\n       (Strat2 @\n        [(if x < y\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n) =\n             x < y\n             in mtf2 (fst (Strat ! n)) (qs ! n)\n                 (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n          then 0 else 1,\n          replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n          sws)])) =\n    step\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)", "unfolding gg"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y} @ [qs ! n])\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])\n     (Suc (length Strat2)) =\n    step\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)", "apply(rule steps'_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length (Lxy (take n qs) {x, y}) = length Strat2", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (2 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length (Lxy (take n qs) {x, y}) = length Strat2", "by auto"], ["proof (state)\nthis:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  step\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  step\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = mtf2 ?mtf (qs!n) (swaps ?L ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps\n       (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (k, sws) =\n           (if x < y\n               in swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n) =\n               x < y\n               in mtf2 (fst (Strat ! n)) (qs ! n)\n                   (swaps (snd (Strat ! n))\n                     (steps' init (take n qs) (take n Strat) n))\n            then 0 else 1,\n            replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n            sws)\n     in mtf2 k (qs ! n)\n         (swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n             (length Strat2)))) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps\n       (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by (simp add: split_def)"], ["proof (state)\nthis:\n  step\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps\n     (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  step\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps\n     (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = mtf2 ?mtf (qs!n) (swaps (replicate ?m 0) ?ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps\n       (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by (simp)"], ["proof (state)\nthis:\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps\n     (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps\n     (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = mtf2 ?mtf (qs!n) ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "using gge"], ["proof (prove)\nusing this:\n  swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by (simp)"], ["proof (state)\nthis:\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   (swaps (replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))", "have B: \"?ys''' = mtf2 ?mtf (qs!n) ?ys''\""], ["proof (prove)\nusing this:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])\n     (length\n       (Strat2 @\n        [(if x < y\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n) =\n             x < y\n             in mtf2 (fst (Strat ! n)) (qs ! n)\n                 (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n          then 0 else 1,\n          replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n          sws)])) =\n    mtf2\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1)\n     (qs ! n)\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "."], ["proof (state)\nthis:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 3: \"set ?ys' = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    {x, y}", "apply(simp add: swaps_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)) =\n    {x, y}", "apply(subst steps'_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. set (Lxy init {x, y}) = {x, y}", "using ahjer len"], ["proof (prove)\nusing this:\n  set (Lxy init {x, y}) = {x, y}\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (3 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. set (Lxy init {x, y}) = {x, y}", "by(simp_all)"], ["proof (state)\nthis:\n  set (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have k: \"?ys'' = swaps (replicate (ALG_P (snd (Strat!n)) x y ?xs) 0) ?ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    swaps\n     (replicate\n       (ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n       0)\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by (auto)"], ["proof (state)\nthis:\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  swaps\n   (replicate\n     (ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n     0)\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 6: \"set ?ys'' = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swaps\n          (replicate\n            (ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n            0)\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}", "using 3 swaps_inv"], ["proof (prove)\nusing this:\n  set (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  {x, y}\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. set (swaps\n          (replicate\n            (ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n            0)\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}", "by metis"], ["proof (state)\nthis:\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 7: \"set ?ys''' = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) =\n    {x, y}", "unfolding B"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mtf2\n          (if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1)\n          (qs ! n)\n          ((swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2))))) =\n    {x, y}", "using set_mtf2 6"], ["proof (prove)\nusing this:\n  set (mtf2 ?n ?x ?xs) = set ?xs\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. set (mtf2\n          (if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1)\n          (qs ! n)\n          ((swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2))))) =\n    {x, y}", "by metis"], ["proof (state)\nthis:\n  set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 22: \"x \\<in> set ?ys''\" \"y \\<in> set ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ((swap 0 ^^\n                  ALG_P (snd (Strat ! n)) x y\n                   (steps' init (take n qs) (take n Strat) n))\n                  (swaps sws\n                    (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                      Strat2 (length Strat2)))) &&&\n    y \\<in> set ((swap 0 ^^\n                  ALG_P (snd (Strat ! n)) x y\n                   (steps' init (take n qs) (take n Strat) n))\n                  (swaps sws\n                    (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                      Strat2 (length Strat2))))", "using 6"], ["proof (prove)\nusing this:\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set ((swap 0 ^^\n                  ALG_P (snd (Strat ! n)) x y\n                   (steps' init (take n qs) (take n Strat) n))\n                  (swaps sws\n                    (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                      Strat2 (length Strat2)))) &&&\n    y \\<in> set ((swap 0 ^^\n                  ALG_P (snd (Strat ! n)) x y\n                   (steps' init (take n qs) (take n Strat) n))\n                  (swaps sws\n                    (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                      Strat2 (length Strat2))))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n  y \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 23: \"x \\<in> set ?ys'''\" \"y \\<in> set ?ys'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])\n                  (length\n                    (Strat2 @\n                     [(if x < y\n                          in swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n) =\n                          x < y\n                          in mtf2 (fst (Strat ! n)) (qs ! n)\n                              (swaps (snd (Strat ! n))\n                                (steps' init (take n qs) (take n Strat) n))\n                       then 0 else 1,\n                       replicate\n                        (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                       sws)]))) &&&\n    y \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])\n                  (length\n                    (Strat2 @\n                     [(if x < y\n                          in swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n) =\n                          x < y\n                          in mtf2 (fst (Strat ! n)) (qs ! n)\n                              (swaps (snd (Strat ! n))\n                                (steps' init (take n qs) (take n Strat) n))\n                       then 0 else 1,\n                       replicate\n                        (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                       sws)])))", "using 7"], ["proof (prove)\nusing this:\n  set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])\n                  (length\n                    (Strat2 @\n                     [(if x < y\n                          in swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n) =\n                          x < y\n                          in mtf2 (fst (Strat ! n)) (qs ! n)\n                              (swaps (snd (Strat ! n))\n                                (steps' init (take n qs) (take n Strat) n))\n                       then 0 else 1,\n                       replicate\n                        (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                       sws)]))) &&&\n    y \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])\n                  (length\n                    (Strat2 @\n                     [(if x < y\n                          in swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n) =\n                          x < y\n                          in mtf2 (fst (Strat ! n)) (qs ! n)\n                              (swaps (snd (Strat ! n))\n                                (steps' init (take n qs) (take n Strat) n))\n                       then 0 else 1,\n                       replicate\n                        (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                       sws)])))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n  y \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 26: \"(qs!n) \\<in> set ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs ! n\n    \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))", "using 6 True"], ["proof (prove)\nusing this:\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. qs ! n\n    \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))", "by auto"], ["proof (state)\nthis:\n  qs ! n\n  \\<in> set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"distinct ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))", "apply(rule steps'_distinct2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. distinct (Lxy init {x, y})", "using len ahjer3"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n  distinct (Lxy init {x, y})\n\ngoal (3 subgoals):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2\n 2. length Strat2 \\<le> length Strat2\n 3. distinct (Lxy init {x, y})", "by(simp)+"], ["proof (state)\nthis:\n  distinct\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  distinct\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))", "have 9: \"distinct ?ys'\""], ["proof (prove)\nusing this:\n  distinct\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "using swaps_inv"], ["proof (prove)\nusing this:\n  distinct\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2))\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by metis"], ["proof (state)\nthis:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))", "have 27: \"distinct ?ys''\""], ["proof (prove)\nusing this:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "unfolding k"], ["proof (prove)\nusing this:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps\n       (replicate\n         (ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n         0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "using swaps_inv"], ["proof (prove)\nusing this:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps\n       (replicate\n         (ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n         0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by metis"], ["proof (state)\nthis:\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "from 3 Suc(5)"], ["proof (chain)\npicking this:\n  set (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  {x, y}\n  x \\<noteq> y", "have \"card (set ?ys') = 2\""], ["proof (prove)\nusing this:\n  set (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  {x, y}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card\n     (set (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    2", "by auto"], ["proof (state)\nthis:\n  card\n   (set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  2\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  card\n   (set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  2", "have 4: \"length ?ys' = 2\""], ["proof (prove)\nusing this:\n  card\n   (set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  2\n\ngoal (1 subgoal):\n 1. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2", "using distinct_card[OF 9]"], ["proof (prove)\nusing this:\n  card\n   (set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  2\n  card\n   (set (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  length\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. length\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))) =\n    2", "by simp"], ["proof (state)\nthis:\n  length\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  2\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"length ?ys'' = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (swaps\n       (replicate\n         (ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n         0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2", "using 4 swaps_inv"], ["proof (prove)\nusing this:\n  length\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))) =\n  2\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. length\n     (swaps\n       (replicate\n         (ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n         0)\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2", "by metis"], ["proof (state)\nthis:\n  length\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  2\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 5: \"dist_perm ?ys' ?ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "using 9"], ["proof (prove)\nusing this:\n  distinct\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. dist_perm\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by auto"], ["proof (state)\nthis:\n  dist_perm\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have sxs: \"set ?xs = set init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (steps' init (take n qs) (take n Strat) n) = set init", "apply(rule steps'_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "using qQS n Suc(3)"], ["proof (prove)\nusing this:\n  length (take n qs) = length (take n Strat)\n  n \\<le> length qs\n  length Strat = length qs\n\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "by(auto)"], ["proof (state)\nthis:\n  set (steps' init (take n qs) (take n Strat) n) = set init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have sxs': \"set ?xs' = set ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n)) =\n    set (steps' init (take n qs) (take n Strat) n)", "using swaps_inv"], ["proof (prove)\nusing this:\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. set (swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n)) =\n    set (steps' init (take n qs) (take n Strat) n)", "by metis"], ["proof (state)\nthis:\n  set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)) =\n  set (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have sxs'': \"set ?xs'' = set ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)) =\n    set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))) =\n    set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "using set_mtf2"], ["proof (prove)\nusing this:\n  set (mtf2 ?n ?x ?xs) = set ?xs\n\ngoal (1 subgoal):\n 1. set (mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))) =\n    set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by metis"], ["proof (state)\nthis:\n  set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)) =\n  set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 24: \"x \\<in> set ?xs'\" \"y\\<in>set ?xs'\" \"(qs!n) \\<in> set ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n)) &&&\n    y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n)) &&&\n    qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))", "using xysubs True sxs sxs'"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  qs ! n \\<in> {x, y}\n  set (steps' init (take n qs) (take n Strat) n) = set init\n  set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)) =\n  set (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n)) &&&\n    y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n)) &&&\n    qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  y \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  qs ! n\n  \\<in> set (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 28: \"x \\<in> set ?xs''\" \"y\\<in>set ?xs''\" \"(qs!n) \\<in> set ?xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                  (Suc n)) &&&\n    y \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                  (Suc n)) &&&\n    qs ! n\n    \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))", "using xysubs True sxs sxs' sxs''"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> set init\n  qs ! n \\<in> {x, y}\n  set (steps' init (take n qs) (take n Strat) n) = set init\n  set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)) =\n  set (steps' init (take n qs) (take n Strat) n)\n  set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)) =\n  set (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. x \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                  (Suc n)) &&&\n    y \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat)\n                  (Suc n)) &&&\n    qs ! n\n    \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  y \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  qs ! n\n  \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 0: \"dist_perm init init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm init init", "using dI"], ["proof (prove)\nusing this:\n  distinct init\n\ngoal (1 subgoal):\n 1. dist_perm init init", "by auto"], ["proof (state)\nthis:\n  dist_perm init init\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have 1: \"dist_perm ?xs ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_perm (steps' init (take n qs) (take n Strat) n)\n     (steps' init (take n qs) (take n Strat) n)", "apply(rule steps'_dist_perm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. length (take n Strat) = n\n 3. dist_perm init init", "by fact+"], ["proof (state)\nthis:\n  dist_perm (steps' init (take n qs) (take n Strat) n)\n   (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "then"], ["proof (chain)\npicking this:\n  dist_perm (steps' init (take n qs) (take n Strat) n)\n   (steps' init (take n qs) (take n Strat) n)", "have 25: \"distinct ?xs'\""], ["proof (prove)\nusing this:\n  dist_perm (steps' init (take n qs) (take n Strat) n)\n   (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "using swaps_inv"], ["proof (prove)\nusing this:\n  dist_perm (steps' init (take n qs) (take n Strat) n)\n   (steps' init (take n qs) (take n Strat) n)\n  set (swaps ?sws ?xs) = set ?xs \\<and>\n  length (swaps ?sws ?xs) = length ?xs \\<and>\n  distinct (swaps ?sws ?xs) = distinct ?xs\n\ngoal (1 subgoal):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by metis"], ["proof (state)\nthis:\n  distinct\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* aus der Induktionsvorraussetzung (iff) wei? ich bereits\n        dass die Ordnung erhalten wird bis zum nten Schritt,\n        mit Theorem \"projected_paid_same_effect\" kann ich auch die paid exchanges abarbeiten ...*)"], ["proof (state)\nthis:\n  distinct\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "from projected_paid_same_effect[OF 1 Suc(5) 3 4 5, OF iff, where acs=\"snd (Strat ! n)\"]"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))", "have aaa: \"x < y in ?xs'  = x < y in ?ys''\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "."], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "(* ... was nun noch fehlt ist, dass die moveToFront anweisungen von Strat\n        und Strat2 sich in gleicher Art auf die Ordnung von x und y auswirken\n    *)"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have t: \"?mtf = (if (x<y in ?xs') = (x<y in ?xs'') then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y\n        in mtf2 (fst (Strat ! n)) (qs ! n)\n            (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n     then 0 else 1) =\n    (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n     then 0 else 1)", "by (simp add: A)"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n   then 0 else 1)\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "have central: \"x < y in ?xs'' = x < y  in ?ys'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "proof (cases \"(x<y in ?xs') = (x<y in ?xs'')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "case True"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "then"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have \"?mtf = 0\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y\n        in mtf2 (fst (Strat ! n)) (qs ! n)\n            (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n     then 0 else 1) =\n    0", "using t"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n   then 0 else 1)\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y\n        in mtf2 (fst (Strat ! n)) (qs ! n)\n            (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n     then 0 else 1) =\n    0", "by auto"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  0\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with B"], ["proof (chain)\npicking this:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  0", "have \"?ys''' = ?ys''\""], ["proof (prove)\nusing this:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  0\n\ngoal (1 subgoal):\n 1. steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])\n     (length\n       (Strat2 @\n        [(if x < y\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n) =\n             x < y\n             in mtf2 (fst (Strat ! n)) (qs ! n)\n                 (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n          then 0 else 1,\n          replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n          sws)])) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "by auto"], ["proof (state)\nthis:\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with aaa True"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "by auto"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "case False"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "then"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have k: \"?mtf = 1\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y\n        in mtf2 (fst (Strat ! n)) (qs ! n)\n            (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n     then 0 else 1) =\n    1", "using t"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n   then 0 else 1)\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n) =\n        x < y\n        in mtf2 (fst (Strat ! n)) (qs ! n)\n            (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n     then 0 else 1) =\n    1", "by auto"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  1\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "from False"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have i: \"(x<y in ?xs') = (~x<y in ?xs'')\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n    (\\<not> x < y\n            in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have gn: \"\\<And>a b. a\\<in>{x,y} \\<Longrightarrow> b\\<in>{x,y} \\<Longrightarrow> set ?ys'' = {x,y} \\<Longrightarrow>\n                  a\\<noteq>b \\<Longrightarrow> distinct ?ys'' \\<Longrightarrow>\n                  a<b in ?ys'' \\<Longrightarrow> ~a<b in mtf2 1 b ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "case (1 a b)"], ["proof (state)\nthis:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  a \\<noteq> b\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from 1"], ["proof (chain)\npicking this:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  a \\<noteq> b\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))", "have f: \"set ?ys'' = {a,b}\""], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  a \\<noteq> b\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {a, b}", "by auto"], ["proof (state)\nthis:\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "with 1"], ["proof (chain)\npicking this:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  a \\<noteq> b\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {a, b}", "have i: \"card (set ?ys'') = 2\""], ["proof (prove)\nusing this:\n  a \\<in> {x, y}\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n  a \\<noteq> b\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {a, b}\n\ngoal (1 subgoal):\n 1. card\n     (set ((swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2))))) =\n    2", "by auto"], ["proof (state)\nthis:\n  card\n   (set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2))))) =\n  2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from 1(5)"], ["proof (chain)\npicking this:\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))", "have \"dist_perm ?ys'' ?ys''\""], ["proof (prove)\nusing this:\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. dist_perm\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by auto"], ["proof (state)\nthis:\n  dist_perm\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from i distinct_card 1(5)"], ["proof (chain)\npicking this:\n  card\n   (set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2))))) =\n  2\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))", "have g: \"length ?ys'' = 2\""], ["proof (prove)\nusing this:\n  card\n   (set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2))))) =\n  2\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  distinct\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. length\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2", "by metis"], ["proof (state)\nthis:\n  length\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "with 1(6)"], ["proof (chain)\npicking this:\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  length\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  2", "have d: \"index ?ys'' b = 1\""], ["proof (prove)\nusing this:\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  length\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  2\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     b =\n    1", "using before_in_index2 f 1(4)"], ["proof (prove)\nusing this:\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  length\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  2\n  \\<lbrakk>set ?l = {?x, ?y}; length ?l = 2; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> (if ?x < ?y in ?l then 1 else 0) = index ?l ?y\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {a, b}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     b =\n    1", "by fastforce"], ["proof (state)\nthis:\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   b =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from 1(2,3)"], ["proof (chain)\npicking this:\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}", "have e: \"b \\<in> set ?ys''\""], ["proof (prove)\nusing this:\n  b \\<in> {x, y}\n  set ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  {x, y}\n\ngoal (1 subgoal):\n 1. b \\<in> set ((swap 0 ^^\n                  ALG_P (snd (Strat ! n)) x y\n                   (steps' init (take n qs) (take n Strat) n))\n                  (swaps sws\n                    (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                      Strat2 (length Strat2))))", "by auto"], ["proof (state)\nthis:\n  b \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from d e"], ["proof (chain)\npicking this:\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   b =\n  1\n  b \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))", "have p: \"mtf2 1 b ?ys'' = swap 0 ?ys''\""], ["proof (prove)\nusing this:\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   b =\n  1\n  b \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n\ngoal (1 subgoal):\n 1. mtf2 1 b\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    swap 0\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "unfolding mtf2_def"], ["proof (prove)\nusing this:\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   b =\n  1\n  b \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n\ngoal (1 subgoal):\n 1. (if b \\<in> set ((swap 0 ^^\n                      ALG_P (snd (Strat ! n)) x y\n                       (steps' init (take n qs) (take n Strat) n))\n                      (swaps sws\n                        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n                          Strat2 (length Strat2))))\n     then swaps\n           [index\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n             b -\n            1..<\n            index\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n             b]\n           ((swap 0 ^^\n             ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n             (swaps sws\n               (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                 (length Strat2))))\n     else (swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2)))) =\n    swap 0\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by auto"], ["proof (state)\nthis:\n  mtf2 1 b\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  swap 0\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "have q: \"a < b in swap 0 ?ys'' = (\\<not> a < b in ?ys'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b\n    in swap 0\n        ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    (\\<not> a < b\n            in (swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))", "apply(rule swap0in2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {a, b}\n 2. a \\<noteq> b\n 3. length\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2\n 4. dist_perm\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))", "by(fact)+"], ["proof (state)\nthis:\n  a < b\n  in swap 0\n      ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  (\\<not> a < b\n          in (swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {x, y}; b \\<in> {x, y};\n        set ((swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2)))) =\n        {x, y};\n        a \\<noteq> b;\n        distinct\n         ((swap 0 ^^\n           ALG_P (snd (Strat ! n)) x y\n            (steps' init (take n qs) (take n Strat) n))\n           (swaps sws\n             (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n               (length Strat2))));\n        a < b\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\\<rbrakk>\n       \\<Longrightarrow> \\<not> a < b\n                                in mtf2 1 b\n                                    ((swap 0 ^^\nALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n(swaps sws\n  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n    (length Strat2))))", "from 1(6) p q"], ["proof (chain)\npicking this:\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  mtf2 1 b\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  swap 0\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in swap 0\n      ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  (\\<not> a < b\n          in (swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2))))", "show ?case"], ["proof (prove)\nusing this:\n  a < b\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  mtf2 1 b\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))) =\n  swap 0\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  a < b\n  in swap 0\n      ((swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))) =\n  (\\<not> a < b\n          in (swap 0 ^^\n              ALG_P (snd (Strat ! n)) x y\n               (steps' init (take n qs) (take n Strat) n))\n              (swaps sws\n                (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                  (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<not> a < b\n           in mtf2 1 b\n               ((swap 0 ^^\n                 ALG_P (snd (Strat ! n)) x y\n                  (steps' init (take n qs) (take n Strat) n))\n                 (swaps sws\n                   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                     (length Strat2))))", "by metis"], ["proof (state)\nthis:\n  \\<not> a < b\n         in mtf2 1 b\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {x, y}; ?b \\<in> {x, y};\n   set ((swap 0 ^^\n         ALG_P (snd (Strat ! n)) x y\n          (steps' init (take n qs) (take n Strat) n))\n         (swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n             (length Strat2)))) =\n   {x, y};\n   ?a \\<noteq> ?b;\n   distinct\n    ((swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))));\n   ?a < ?b\n   in (swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?a < ?b\n                           in mtf2 1 ?b\n                               ((swap 0 ^^\n                                 ALG_P (snd (Strat ! n)) x y\n                                  (steps' init (take n qs) (take n Strat)\n                                    n))\n                                 (swaps sws\n                                   (steps' (Lxy init {x, y})\n                                     (Lxy (take n qs) {x, y}) Strat2\n                                     (length Strat2))))\n\ngoal (1 subgoal):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<noteq>\n    x < y\n    in steps' init (take (Suc n) qs) (take (Suc n) Strat)\n        (Suc n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "proof (cases \"x<y in ?xs'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "case True"], ["proof (state)\nthis:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with aaa"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)", "have st: \"x < y in ?ys''\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "from True False"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have \"~ x<y in ?xs''\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n  x < y\n  in swaps (snd (Strat ! n))\n      (steps' init (take n qs) (take n Strat) n) \\<noteq>\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "by auto"], ["proof (state)\nthis:\n  \\<not> x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with Suc(5) 28 not_before_in A"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  y \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  qs ! n\n  \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  \\<not> x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have \"y < x in ?xs''\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  y \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  qs ! n\n  \\<in> set (steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  \\<not> x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. y < x in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "by metis"], ["proof (state)\nthis:\n  y < x in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with A"], ["proof (chain)\npicking this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  y < x in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have \"y < x in mtf2 (fst (Strat!n)) (qs!n) ?xs'\""], ["proof (prove)\nusing this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  y < x in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. y < x\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by auto"], ["proof (state)\nthis:\n  y < x\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "(*from True swapped_by_mtf2*)"], ["proof (state)\nthis:\n  y < x\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have itisy: \"y = (qs!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = qs ! n", "apply(rule swapped_by_mtf2[where xs= ?xs'])"], ["proof (prove)\ngoal (6 subgoals):\n 1. qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n 2. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 3. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 4. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 5. ?x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 6. y < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 2. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 3. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 4. ?x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 5. y < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 2. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 3. ?x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 4. y < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact 24)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 2. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 3. y < x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact 24)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 2. y < x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by(fact)+"], ["proof (state)\nthis:\n  y = qs ! n\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have \"~x<y in mtf2 1 y ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in mtf2 1 y\n               ((swap 0 ^^\n                 ALG_P (snd (Strat ! n)) x y\n                  (steps' init (take n qs) (take n Strat) n))\n                 (swaps sws\n                   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                     (length Strat2))))", "apply(rule gn)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x \\<in> {x, y}\n 2. y \\<in> {x, y}\n 3. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 4. x \\<noteq> y\n 5. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 6. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. y \\<in> {x, y}\n 2. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 3. x \\<noteq> y\n 4. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 5. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 2. x \\<noteq> y\n 3. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 4. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp add: 6)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<noteq> y\n 2. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 3. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "by(fact)+"], ["proof (state)\nthis:\n  \\<not> x < y\n         in mtf2 1 y\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "then"], ["proof (chain)\npicking this:\n  \\<not> x < y\n         in mtf2 1 y\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))", "have ts: \"~x<y in ?ys'''\""], ["proof (prove)\nusing this:\n  \\<not> x < y\n         in mtf2 1 y\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)])\n               (length\n                 (Strat2 @\n                  [(if x < y\n                       in swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n) =\n                       x < y\n                       in mtf2 (fst (Strat ! n)) (qs ! n)\n                           (swaps (snd (Strat ! n))\n                             (steps' init (take n qs) (take n Strat) n))\n                    then 0 else 1,\n                    replicate\n                     (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                    sws)]))", "using B itisy k"], ["proof (prove)\nusing this:\n  \\<not> x < y\n         in mtf2 1 y\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  y = qs ! n\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  1\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)])\n               (length\n                 (Strat2 @\n                  [(if x < y\n                       in swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n) =\n                       x < y\n                       in mtf2 (fst (Strat ! n)) (qs ! n)\n                           (swaps (snd (Strat ! n))\n                             (steps' init (take n qs) (take n Strat) n))\n                    then 0 else 1,\n                    replicate\n                     (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                    sws)]))", "by auto"], ["proof (state)\nthis:\n  \\<not> x < y\n         in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have ii: \"(x<y in ?ys'') = (~x<y in ?ys''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    (\\<not> x < y\n            in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))", "using st ts"], ["proof (prove)\nusing this:\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  \\<not> x < y\n         in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    (\\<not> x < y\n            in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))\n\ngoal (2 subgoals):\n 1. x < y\n    in swaps (snd (Strat ! n))\n        (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))\n 2. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "from i ii aaa"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "by metis"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "case False"], ["proof (state)\nthis:\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with aaa"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)", "have st: \"~ x < y in ?ys''\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in (swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2)))", "by auto"], ["proof (state)\nthis:\n  \\<not> x < y\n         in (swap 0 ^^\n             ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n             (swaps sws\n               (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                 (length Strat2)))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with Suc(5) 22 not_before_in"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n  y \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> x < y\n         in (swap 0 ^^\n             ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n             (swaps sws\n               (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                 (length Strat2)))", "have st: \"y < x in ?ys''\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n  y \\<in> set ((swap 0 ^^\n                ALG_P (snd (Strat ! n)) x y\n                 (steps' init (take n qs) (take n Strat) n))\n                (swaps sws\n                  (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                    (length Strat2))))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  \\<not> x < y\n         in (swap 0 ^^\n             ALG_P (snd (Strat ! n)) x y\n              (steps' init (take n qs) (take n Strat) n))\n             (swaps sws\n               (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                 (length Strat2)))\n\ngoal (1 subgoal):\n 1. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "by metis"], ["proof (state)\nthis:\n  y < x\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "from i False"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)", "have kl: \"x<y in ?xs''\""], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "by auto"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with A"], ["proof (chain)\npicking this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)", "have \"x < y in mtf2 (fst (Strat!n)) (qs!n) ?xs'\""], ["proof (prove)\nusing this:\n  steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  mtf2 (fst (Strat ! n)) (qs ! n)\n   (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n)\n\ngoal (1 subgoal):\n 1. x < y\n    in mtf2 (fst (Strat ! n)) (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in mtf2 (fst (Strat ! n)) (qs ! n)\n      (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "from False Suc(5) 24 not_before_in"], ["proof (chain)\npicking this:\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)\n  x \\<noteq> y\n  x \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  y \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  qs ! n\n  \\<in> set (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)", "have \"y < x in ?xs'\""], ["proof (prove)\nusing this:\n  \\<not> x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n)\n  x \\<noteq> y\n  x \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  y \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n  qs ! n\n  \\<in> set (swaps (snd (Strat ! n))\n              (steps' init (take n qs) (take n Strat) n))\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. y < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)", "by metis"], ["proof (state)\nthis:\n  y < x\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have itisx: \"x = (qs!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = qs ! n", "apply(rule swapped_by_mtf2[where xs= ?xs'])"], ["proof (prove)\ngoal (6 subgoals):\n 1. qs ! n\n    \\<in> set (swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n))\n 2. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 3. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 4. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 5. ?x < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 6. x < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct\n     (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))\n 2. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 3. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 4. ?x < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 5. x < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?x \\<in> set (swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n))\n 2. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 3. ?x < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 4. x < ?x\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact 24(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> set (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n 2. y < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 3. x < y\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "apply(fact 24)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y < x\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n 2. x < y\n    in mtf2 ?n (qs ! n)\n        (swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n))", "by(fact)+"], ["proof (state)\nthis:\n  x = qs ! n\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "have \"~y<x in mtf2 1 x ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in mtf2 1 x\n               ((swap 0 ^^\n                 ALG_P (snd (Strat ! n)) x y\n                  (steps' init (take n qs) (take n Strat) n))\n                 (swaps sws\n                   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                     (length Strat2))))", "apply(rule gn)"], ["proof (prove)\ngoal (6 subgoals):\n 1. y \\<in> {x, y}\n 2. x \\<in> {x, y}\n 3. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 4. y \\<noteq> x\n 5. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 6. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x \\<in> {x, y}\n 2. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 3. y \\<noteq> x\n 4. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 5. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 2. y \\<noteq> x\n 3. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 4. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(simp add: 6)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<noteq> x\n 2. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 3. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "apply(metis Suc(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n 2. y < x\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2)))", "by(fact)+"], ["proof (state)\nthis:\n  \\<not> y < x\n         in mtf2 1 x\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "then"], ["proof (chain)\npicking this:\n  \\<not> y < x\n         in mtf2 1 x\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))", "have \"~y<x in ?ys'''\""], ["proof (prove)\nusing this:\n  \\<not> y < x\n         in mtf2 1 x\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)])\n               (length\n                 (Strat2 @\n                  [(if x < y\n                       in swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n) =\n                       x < y\n                       in mtf2 (fst (Strat ! n)) (qs ! n)\n                           (swaps (snd (Strat ! n))\n                             (steps' init (take n qs) (take n Strat) n))\n                    then 0 else 1,\n                    replicate\n                     (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                    sws)]))", "using itisx k B"], ["proof (prove)\nusing this:\n  \\<not> y < x\n         in mtf2 1 x\n             ((swap 0 ^^\n               ALG_P (snd (Strat ! n)) x y\n                (steps' init (take n qs) (take n Strat) n))\n               (swaps sws\n                 (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                   (length Strat2))))\n  x = qs ! n\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  1\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)])\n               (length\n                 (Strat2 @\n                  [(if x < y\n                       in swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n) =\n                       x < y\n                       in mtf2 (fst (Strat ! n)) (qs ! n)\n                           (swaps (snd (Strat ! n))\n                             (steps' init (take n qs) (take n Strat) n))\n                    then 0 else 1,\n                    replicate\n                     (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                    sws)]))", "by auto"], ["proof (state)\nthis:\n  \\<not> y < x\n         in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with Suc(5) not_before_in 23"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  x \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n  y \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n  \\<not> y < x\n         in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))", "have \"x<y in ?ys'''\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<lbrakk>?x \\<in> set ?xs; ?y \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> (\\<not> ?x < ?y in ?xs) = (?y < ?x in ?xs \\<or> ?x = ?y)\n  x \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n  y \\<in> set (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))\n  \\<not> y < x\n         in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))\n\ngoal (1 subgoal):\n 1. x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "by metis"], ["proof (state)\nthis:\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with st"], ["proof (chain)\npicking this:\n  y < x\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))", "have \"(x<y in ?ys'') = (~x<y in ?ys''')\""], ["proof (prove)\nusing this:\n  y < x\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    (\\<not> x < y\n            in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))", "using  B k"], ["proof (prove)\nusing this:\n  y < x\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n  steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)])\n   (length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)])) =\n  mtf2\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1)\n   (qs ! n)\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n  (if x < y\n      in swaps (snd (Strat ! n))\n          (steps' init (take n qs) (take n Strat) n) =\n      x < y\n      in mtf2 (fst (Strat ! n)) (qs ! n)\n          (swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n))\n   then 0 else 1) =\n  1\n\ngoal (1 subgoal):\n 1. x < y\n    in (swap 0 ^^\n        ALG_P (snd (Strat ! n)) x y\n         (steps' init (take n qs) (take n Strat) n))\n        (swaps sws\n          (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n            (length Strat2))) =\n    (\\<not> x < y\n            in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])\n                (length\n                  (Strat2 @\n                   [(if x < y\n                        in swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n) =\n                        x < y\n                        in mtf2 (fst (Strat ! n)) (qs ! n)\n                            (swaps (snd (Strat ! n))\n                              (steps' init (take n qs) (take n Strat) n))\n                     then 0 else 1,\n                     replicate\n                      (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                     sws)])))", "by auto"], ["proof (state)\nthis:\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))\n\ngoal (1 subgoal):\n 1. \\<not> x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<Longrightarrow>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "with i aaa"], ["proof (chain)\npicking this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  (\\<not> x < y\n          in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n))\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2))) =\n  (\\<not> x < y\n          in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n              (Strat2 @\n               [(if x < y\n                    in swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n) =\n                    x < y\n                    in mtf2 (fst (Strat ! n)) (qs ! n)\n                        (swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n))\n                 then 0 else 1,\n                 replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                  0 @\n                 sws)])\n              (length\n                (Strat2 @\n                 [(if x < y\n                      in swaps (snd (Strat ! n))\n                          (steps' init (take n qs) (take n Strat) n) =\n                      x < y\n                      in mtf2 (fst (Strat ! n)) (qs ! n)\n                          (swaps (snd (Strat ! n))\n                            (steps' init (take n qs) (take n Strat) n))\n                   then 0 else 1,\n                   replicate\n                    (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n                   sws)])))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))", "by metis"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. qs ! n \\<in> {x, y} \\<Longrightarrow>\n    \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(rule exI[where x=\"?newStrat\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>swsa.\n       length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]) =\n       length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n       x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n       x < y\n       in swaps swsa\n           (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n             (Strat2 @\n              [(if x < y\n                   in swaps (snd (Strat ! n))\n                       (steps' init (take n qs) (take n Strat) n) =\n                   x < y\n                   in mtf2 (fst (Strat ! n)) (qs ! n)\n                       (swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n))\n                then 0 else 1,\n                replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                 0 @\n                sws)])\n             (length\n               (Strat2 @\n                [(if x < y\n                     in swaps (snd (Strat ! n))\n                         (steps' init (take n qs) (take n Strat) n) =\n                     x < y\n                     in mtf2 (fst (Strat ! n)) (qs ! n)\n                         (swaps (snd (Strat ! n))\n                           (steps' init (take n qs) (take n Strat) n))\n                  then 0 else 1,\n                  replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                   0 @\n                  sws)]))) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]) +\n       length swsa =\n       ALGxy_det Strat (take (Suc n) qs) init x y +\n       ALG_Pxy Strat (take (Suc n) qs) init x y", "apply(rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n    x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take (Suc n) qs) {x, y})\n 2. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take (Suc n) qs) {x, y})\n 2. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take (Suc n) qs) {x, y})", "unfolding yeh"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take n qs) {x, y} @ [qs ! n])", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (1 subgoal):\n 1. length\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) =\n    length (Lxy (take n qs) {x, y} @ [qs ! n])", "by(simp)"], ["proof (state)\nthis:\n  length\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) =\n  length (Lxy (take (Suc n) qs) {x, y})\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)]))) \\<and>\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)])))\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)])))\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "(* hier beweise ich also, dass die ordnung von x und y in der projezierten\n             Ausf?hrung (von Strat2) der Ordnung von x und y in der Ausf?hrung\n             von Strat entspricht *)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)])))\n 2. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "from central"], ["proof (chain)\npicking this:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))", "show ?case"], ["proof (prove)\nusing this:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n      (Strat2 @\n       [(if x < y\n            in swaps (snd (Strat ! n))\n                (steps' init (take n qs) (take n Strat) n) =\n            x < y\n            in mtf2 (fst (Strat ! n)) (qs ! n)\n                (swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n))\n         then 0 else 1,\n         replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n         sws)])\n      (length\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)]))\n\ngoal (1 subgoal):\n 1. x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n    x < y\n    in swaps []\n        (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])\n          (length\n            (Strat2 @\n             [(if x < y\n                  in swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n) =\n                  x < y\n                  in mtf2 (fst (Strat ! n)) (qs ! n)\n                      (swaps (snd (Strat ! n))\n                        (steps' init (take n qs) (take n Strat) n))\n               then 0 else 1,\n               replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n                0 @\n               sws)])))", "by auto"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in swaps []\n      (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)])))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "(* nun muss noch bewiesen werden, dass die Kosten sich richtig aufspalten:\n             Kosten f?r Strat2 + |sws|\n             = blocking kosten von x,y + paid exchange kosten von x,y\n          *)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have j: \"ALGxy_det Strat (take (Suc n) qs) init x y =\n            ALGxy_det Strat (take n qs) init x y \n                  + (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"ALGxy_det Strat (take (Suc n) qs) init x y =\n              (\\<Sum>i\\<in>{..<length (take n qs @ [qs ! n])}.\n              if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs @ [qs ! n]) init i y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init i x\n              else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    (\\<Sum>i<length (take n qs @ [qs ! n]).\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0)", "unfolding ALGxy_det_def tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs @ [qs ! n]).\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) =\n    (\\<Sum>i<length (take n qs @ [qs ! n]).\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0)", "by auto"], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  (\\<Sum>i<length (take n qs @ [qs ! n]).\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  (\\<Sum>i<length (take n qs @ [qs ! n]).\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots>\n              =  (\\<Sum>i\\<in>{..<Suc n}.\n              if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs @ [qs ! n]) init i y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init i x\n              else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs @ [qs ! n]).\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) =\n    (\\<Sum>i<Suc n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0)", "using ns"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs @ [qs ! n]).\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) =\n    (\\<Sum>i<Suc n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs @ [qs ! n]).\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) =\n  (\\<Sum>i<Suc n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs @ [qs ! n]).\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) =\n  (\\<Sum>i<Suc n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<n}.\n               if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n               then ALG'_det Strat (take n qs @ [qs ! n]) init i y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init i x\n               else 0)\n               + (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n                  then ALG'_det Strat (take n qs @ [qs ! n]) init n y\n                    + ALG'_det Strat (take n qs @ [qs ! n]) init n x\n                  else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) =\n    (\\<Sum>i<n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n     then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n          ALG'_det Strat (take n qs @ [qs ! n]) init n x\n     else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) =\n  (\\<Sum>i<n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n   then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init n x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) =\n  (\\<Sum>i<n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n   then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init n x\n   else 0)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..< n}.\n              if take n qs ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs @ [qs ! n]) init i y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init i x\n              else 0)\n                + ALG'_det Strat (take n qs @ [qs ! n]) init n y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init n x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n     then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n          ALG'_det Strat (take n qs @ [qs ! n]) init n x\n     else 0) =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x", "using aer"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n     (take n qs ! i \\<in> {y, x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n     then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n          ALG'_det Strat (take n qs @ [qs ! n]) init n x\n     else 0) =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x", "using garar"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     ((take n qs @ [qs ! n]) ! i \\<in> {y, x}) =\n     (take n qs ! i \\<in> {y, x})\n  (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n     then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n          ALG'_det Strat (take n qs @ [qs ! n]) init n x\n     else 0) =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n   then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init n x\n   else 0) =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if (take n qs @ [qs ! n]) ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  (if (take n qs @ [qs ! n]) ! n \\<in> {y, x}\n   then ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init n x\n   else 0) =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..< n}.\n              if take n qs ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs @ [qs ! n]) init i y\n                + ALG'_det Strat (take n qs @ [qs ! n]) init i x\n              else 0)\n                + ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "have \"ALG'_det Strat qs init n y\n                = ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y =\n    ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y", "unfolding tak[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y =\n    ALG'_det Strat (take (Suc n) qs @ drop (Suc n) qs) init n y", "by auto"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "have \"\\<dots> = ALG'_det Strat (take n qs @ [qs ! n]) init n y \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y =\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y", "apply(rule ALG'_det_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < length Strat\n 2. n < length (take n qs @ [qs ! n])", "using nStrat ns"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. n < length Strat\n 2. n < length (take n qs @ [qs ! n])", "by(auto)"], ["proof (state)\nthis:\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "finally"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y", "have 1: \"ALG'_det Strat qs init n y = ALG'_det Strat (take n qs @ [qs ! n]) init n y\""], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y =\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y", "."], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "have \"ALG'_det Strat qs init n x\n                  = ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n x =\n    ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x", "unfolding tak[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n x =\n    ALG'_det Strat (take (Suc n) qs @ drop (Suc n) qs) init n x", "by auto"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "have \"\\<dots> = ALG'_det Strat (take n qs @ [qs ! n]) init n x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x =\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x", "apply(rule ALG'_det_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < length Strat\n 2. n < length (take n qs @ [qs ! n])", "using nStrat ns"], ["proof (prove)\nusing this:\n  n < length Strat\n  n < length qs\n\ngoal (2 subgoals):\n 1. n < length Strat\n 2. n < length (take n qs @ [qs ! n])", "by(auto)"], ["proof (state)\nthis:\n  ALG'_det Strat ((take n qs @ [qs ! n]) @ drop (Suc n) qs) init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "finally"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x", "have 2: \"ALG'_det Strat qs init n x = ALG'_det Strat (take n qs @ [qs ! n]) init n x\""], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n x =\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x", "."], ["proof (state)\nthis:\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "from 1 2"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x", "show ?thesis"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y\n  ALG'_det Strat qs init n x =\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n    ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n y +\n  ALG'_det Strat (take n qs @ [qs ! n]) init n x =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..< n}.\n              if take n qs ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs) init i y\n                  + ALG'_det Strat (take n qs) init i x\n              else 0)\n              + ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x =\n    (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if qs ! i = y \\<or> qs ! i = x\n        then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init i x\n        else 0) =\n    (\\<Sum>i<n.\n        if qs ! i = y \\<or> qs ! i = x\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<n} = {..<n}\n 2. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       (if qs ! xa = y \\<or> qs ! xa = x\n        then ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init xa x\n        else 0) =\n       (if qs ! xa = y \\<or> qs ! xa = x\n        then ALG'_det Strat (take n qs) init xa y +\n             ALG'_det Strat (take n qs) init xa x\n        else 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       (if qs ! xa = y \\<or> qs ! xa = x\n        then ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n             ALG'_det Strat (take n qs @ [qs ! n]) init xa x\n        else 0) =\n       (if qs ! xa = y \\<or> qs ! xa = x\n        then ALG'_det Strat (take n qs) init xa y +\n             ALG'_det Strat (take n qs) init xa x\n        else 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow>\n       (qs ! xa = y \\<longrightarrow>\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa x =\n        ALG'_det Strat (take n qs) init xa y +\n        ALG'_det Strat (take n qs) init xa x) \\<and>\n       (qs ! xa = x \\<longrightarrow>\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa x =\n        ALG'_det Strat (take n qs) init xa y +\n        ALG'_det Strat (take n qs) init xa x)", "using ALG'_det_append[where qs=\"take n qs\"] Suc.prems(2) ns"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length ?Strat; ?n < length (take n qs)\\<rbrakk>\n  \\<Longrightarrow> ALG'_det ?Strat (take n qs @ ?a) ?init ?n ?x =\n                    ALG'_det ?Strat (take n qs) ?init ?n ?x\n  length Strat = length qs\n  n < length qs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow>\n       (qs ! xa = y \\<longrightarrow>\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa x =\n        ALG'_det Strat (take n qs) init xa y +\n        ALG'_det Strat (take n qs) init xa x) \\<and>\n       (qs ! xa = x \\<longrightarrow>\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa y +\n        ALG'_det Strat (take n qs @ [qs ! n]) init xa x =\n        ALG'_det Strat (take n qs) init xa y +\n        ALG'_det Strat (take n qs) init xa x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs @ [qs ! n]) init i y +\n           ALG'_det Strat (take n qs @ [qs ! n]) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x =\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = (\\<Sum>i\\<in>{..< length(take n qs)}.\n              if take n qs ! i \\<in> {y, x}\n              then ALG'_det Strat (take n qs) init i y\n                   + ALG'_det Strat (take n qs) init i x\n              else 0)\n              + ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x =\n    (\\<Sum>i<length (take n qs).\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "using aQ"], ["proof (prove)\nusing this:\n  length (take n qs) = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x =\n    (\\<Sum>i<length (take n qs).\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x =\n  (\\<Sum>i<length (take n qs).\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x =\n  (\\<Sum>i<length (take n qs).\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "have \"\\<dots> = ALGxy_det Strat (take n qs) init x y \n                  + (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "unfolding ALGxy_det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x =\n    (\\<Sum>i<length (take n qs).\n        if take n qs ! i \\<in> {y, x}\n        then ALG'_det Strat (take n qs) init i y +\n             ALG'_det Strat (take n qs) init i x\n        else 0) +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs).\n      if take n qs ! i \\<in> {y, x}\n      then ALG'_det Strat (take n qs) init i y +\n           ALG'_det Strat (take n qs) init i x\n      else 0) +\n  ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "finally"], ["proof (chain)\npicking this:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y =\n    ALGxy_det Strat (take n qs) init x y +\n    (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)", "."], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "(* \n              aaa:      x < y in ?xs'  = x < y in ?ys''\n              central:  x < y in ?xs'' = x < y  in ?ys''' \n           *)"], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have list: \"?ys' = swaps sws (steps (Lxy init {x, y})  (Lxy (take n qs) {x, y}) Strat2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)) =\n    swaps sws\n     (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n       Strat2)", "unfolding steps_steps'[OF len[symmetric], of \"(Lxy init {x, y})\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)) =\n    swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2))", "by simp"], ["proof (state)\nthis:\n  swaps sws\n   (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n     (length Strat2)) =\n  swaps sws\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have j2: \"steps' init (take n qs @ [qs ! n]) Strat n\n                  = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "have \"steps' init (take n qs @ [qs ! n]) Strat n\n                = steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "also"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "have \"\\<dots> = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "apply(rule steps'_rests[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (take n Strat)", "using aS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. n \\<le> length (take n Strat)", "by simp"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) (take n Strat @ drop n Strat) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "finally"], ["proof (chain)\npicking this:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n", "show ?thesis"], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs @ [qs ! n]) Strat n =\n    steps' init (take n qs) (take n Strat) n", "."], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have arghschonwieder: \"steps' init (take n qs) (take n Strat) n\n                  = steps' init qs Strat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "have \"steps' init qs Strat n\n                = steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init qs Strat n =\n    steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "by auto"], ["proof (state)\nthis:\n  steps' init qs Strat n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "also"], ["proof (state)\nthis:\n  steps' init qs Strat n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "have \"\\<dots> = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "apply(rule steps'_rests[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (take n Strat)", "using aS"], ["proof (prove)\nusing this:\n  length (take n Strat) = n\n\ngoal (1 subgoal):\n 1. n \\<le> length (take n Strat)", "by simp"], ["proof (state)\nthis:\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "finally"], ["proof (chain)\npicking this:\n  steps' init qs Strat n = steps' init (take n qs) (take n Strat) n", "show ?thesis"], ["proof (prove)\nusing this:\n  steps' init qs Strat n = steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "by simp"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have indexe: \"((swap 0 ^^ ?m) (swaps sws \n                      (steps (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2))) \n              = ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "unfolding ALG_P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y\n      (steps' init (take n qs @ [qs ! n]) Strat n))\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2)))", "unfolding list"], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y\n      (steps' init (take n qs @ [qs ! n]) Strat n))\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2))", "using j2"], ["proof (prove)\nusing this:\n  steps' init (take n qs @ [qs ! n]) Strat n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y\n      (steps' init (take n qs @ [qs ! n]) Strat n))\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)) =\n    (swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2))", "by auto"], ["proof (state)\nthis:\n  (swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n   (swaps sws\n     (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n       Strat2)) =\n  (swap 0 ^^\n   ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n   (swaps sws\n     (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n       (length Strat2)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have blocky: \"ALG'_det Strat qs init n y\n                = (if y < qs ! n in ?xs' then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y =\n    (if y < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "unfolding ALG'_det_def ALG.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y < qs ! n\n        in fst (swaps (snd (Strat ! n)) (steps' init qs Strat n), ())\n     then 1 else 0) =\n    (if y < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "by(auto simp: arghschonwieder split_def)"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y =\n  (if y < qs ! n\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have blockx: \"ALG'_det Strat qs init n x\n                = (if x < qs ! n in ?xs' then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n x =\n    (if x < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "unfolding ALG'_det_def ALG.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < qs ! n\n        in fst (swaps (snd (Strat ! n)) (steps' init qs Strat n), ())\n     then 1 else 0) =\n    (if x < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "by(auto simp: arghschonwieder split_def)"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n x =\n  (if x < qs ! n\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have index_is_blocking_cost: \"index  ((swap 0 ^^ ?m) (swaps sws\n                        (steps (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2))) (qs ! n)\n                      = ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "proof (cases \"x= qs!n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "case True"], ["proof (state)\nthis:\n  x = qs ! n\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  x = qs ! n", "have \"ALG'_det Strat qs init n x = 0\""], ["proof (prove)\nusing this:\n  x = qs ! n\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n x = 0", "unfolding blockx"], ["proof (prove)\nusing this:\n  x = qs ! n\n\ngoal (1 subgoal):\n 1. (if x < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = qs ! n \\<Longrightarrow>\n    \\<not> qs ! n < qs ! n\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n)", "using before_in_irefl"], ["proof (prove)\nusing this:\n  ?x < ?x in ?xs = False\n\ngoal (1 subgoal):\n 1. x = qs ! n \\<Longrightarrow>\n    \\<not> qs ! n < qs ! n\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n)", "by metis"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n x = 0\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n x = 0", "have \"ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n                  = (if y < x in ?xs' then 1 else 0)\""], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n x = 0\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n    (if y < x\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "unfolding blocky"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n x = 0\n\ngoal (1 subgoal):\n 1. (if y < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) +\n    ALG'_det Strat qs init n x =\n    (if y < x\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "using True"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n x = 0\n  x = qs ! n\n\ngoal (1 subgoal):\n 1. (if y < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) +\n    ALG'_det Strat qs init n x =\n    (if y < x\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  (if y < x\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  (if y < x\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = (if ~y < x in ?xs' then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y < x\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    (if \\<not> y < x\n               in swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n)\n     then 0 else 1)", "by auto"], ["proof (state)\nthis:\n  (if y < x\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0) =\n  (if \\<not> y < x\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  (if y < x\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0) =\n  (if \\<not> y < x\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = (if x < y in ?xs' then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<not> y < x\n               in swaps (snd (Strat ! n))\n                   (steps' init (take n qs) (take n Strat) n)\n     then 0 else 1) =\n    (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 0 else 1)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> y < x\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) \\<longrightarrow>\n    x < y\n    in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)", "by (meson 24 Suc.prems(4) not_before_in)"], ["proof (state)\nthis:\n  (if \\<not> y < x\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1) =\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  (if \\<not> y < x\n             in swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1) =\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = (if x < y in ?ys'' then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 0 else 1) =\n    (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 0 else 1)", "using aaa"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 0 else 1) =\n    (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1) =\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 0 else 1) =\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 0 else 1)\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = index ?ys'' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 0 else 1) =\n    index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     x", "apply(rule before_in_index1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 2. length\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2\n 3. x \\<noteq> y", "by(fact)+"], ["proof (state)\nthis:\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 0 else 1) =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   x\n\ngoal (2 subgoals):\n 1. x = qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n 2. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "finally"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   x", "show ?thesis"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   x\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "unfolding indexe"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   x\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "using True"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   x\n  x = qs ! n\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "by auto"], ["proof (state)\nthis:\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) =\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> qs ! n\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> qs ! n", "have q: \"y = qs!n\""], ["proof (prove)\nusing this:\n  x \\<noteq> qs ! n\n\ngoal (1 subgoal):\n 1. y = qs ! n", "using qsinxy"], ["proof (prove)\nusing this:\n  x \\<noteq> qs ! n\n  qs ! n \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. y = qs ! n", "by auto"], ["proof (state)\nthis:\n  y = qs ! n\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  y = qs ! n", "have \"ALG'_det Strat qs init n y = 0\""], ["proof (prove)\nusing this:\n  y = qs ! n\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y = 0", "unfolding blocky"], ["proof (prove)\nusing this:\n  y = qs ! n\n\ngoal (1 subgoal):\n 1. (if y < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = qs ! n \\<Longrightarrow>\n    \\<not> qs ! n < qs ! n\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n)", "using before_in_irefl"], ["proof (prove)\nusing this:\n  ?x < ?x in ?xs = False\n\ngoal (1 subgoal):\n 1. y = qs ! n \\<Longrightarrow>\n    \\<not> qs ! n < qs ! n\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n)", "by metis"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "then"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n y = 0", "have \"ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n                  = (if x < y in ?xs' then 1 else 0)\""], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y = 0\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n    (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "unfolding blockx"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y = 0\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y +\n    (if x < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "using q"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y = 0\n  y = qs ! n\n\ngoal (1 subgoal):\n 1. ALG'_det Strat qs init n y +\n    (if x < qs ! n\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = (if x < y in ?ys'' then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 1 else 0)", "using aaa"], ["proof (prove)\nusing this:\n  x < y\n  in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n) =\n  x < y\n  in (swap 0 ^^\n      ALG_P (snd (Strat ! n)) x y\n       (steps' init (take n qs) (take n Strat) n))\n      (swaps sws\n        (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n          (length Strat2)))\n\ngoal (1 subgoal):\n 1. (if x < y\n        in swaps (snd (Strat ! n))\n            (steps' init (take n qs) (take n Strat) n)\n     then 1 else 0) =\n    (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0) =\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "also"], ["proof (state)\nthis:\n  (if x < y\n      in swaps (snd (Strat ! n)) (steps' init (take n qs) (take n Strat) n)\n   then 1 else 0) =\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = index ?ys'' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y\n        in (swap 0 ^^\n            ALG_P (snd (Strat ! n)) x y\n             (steps' init (take n qs) (take n Strat) n))\n            (swaps sws\n              (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n                (length Strat2)))\n     then 1 else 0) =\n    index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     y", "apply(rule before_in_index2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set ((swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))) =\n    {x, y}\n 2. length\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2)))) =\n    2\n 3. x \\<noteq> y", "by(fact)+"], ["proof (state)\nthis:\n  (if x < y\n      in (swap 0 ^^\n          ALG_P (snd (Strat ! n)) x y\n           (steps' init (take n qs) (take n Strat) n))\n          (swaps sws\n            (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n              (length Strat2)))\n   then 1 else 0) =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   y\n\ngoal (1 subgoal):\n 1. x \\<noteq> qs ! n \\<Longrightarrow>\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "finally"], ["proof (chain)\npicking this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   y", "show ?thesis"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   y\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "unfolding indexe"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   y\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "using q"], ["proof (prove)\nusing this:\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x =\n  index\n   ((swap 0 ^^\n     ALG_P (snd (Strat ! n)) x y (steps' init (take n qs) (take n Strat) n))\n     (swaps sws\n       (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n         (length Strat2))))\n   y\n  y = qs ! n\n\ngoal (1 subgoal):\n 1. index\n     ((swap 0 ^^\n       ALG_P (snd (Strat ! n)) x y\n        (steps' init (take n qs) (take n Strat) n))\n       (swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2\n           (length Strat2))))\n     (qs ! n) =\n    ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "by auto"], ["proof (state)\nthis:\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) =\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) =\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have jj: \"ALG_Pxy Strat (take (Suc n) qs) init x y =\n                ALG_Pxy Strat (take n qs) init x y\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"ALG_Pxy Strat (take (Suc n) qs) init x y\n                  = (\\<Sum>i<length (take (Suc n) qs). ALG_P' Strat (take (Suc n) qs) init i x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    (\\<Sum>i<length (take (Suc n) qs).\n        ALG_P' Strat (take (Suc n) qs) init i x y)", "unfolding ALG_Pxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take (Suc n) qs).\n        ALG_P' Strat (take (Suc n) qs) init i x y) =\n    (\\<Sum>i<length (take (Suc n) qs).\n        ALG_P' Strat (take (Suc n) qs) init i x y)", "by simp"], ["proof (state)\nthis:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  (\\<Sum>i<length (take (Suc n) qs).\n      ALG_P' Strat (take (Suc n) qs) init i x y)\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  (\\<Sum>i<length (take (Suc n) qs).\n      ALG_P' Strat (take (Suc n) qs) init i x y)\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = (\\<Sum>i< Suc n. ALG_P' Strat (take (Suc n) qs) init i x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take (Suc n) qs).\n        ALG_P' Strat (take (Suc n) qs) init i x y) =\n    (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y)", "unfolding tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs @ [qs ! n]).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n    (\\<Sum>i<Suc n. ALG_P' Strat (take n qs @ [qs ! n]) init i x y)", "using ns"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs @ [qs ! n]).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n    (\\<Sum>i<Suc n. ALG_P' Strat (take n qs @ [qs ! n]) init i x y)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take (Suc n) qs).\n      ALG_P' Strat (take (Suc n) qs) init i x y) =\n  (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y)\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take (Suc n) qs).\n      ALG_P' Strat (take (Suc n) qs) init i x y) =\n  (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y)\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y)\n                  + ALG_P' Strat (take (Suc n) qs) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y) =\n    (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n    ALG_P' Strat (take (Suc n) qs) init n x y", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y) =\n  (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n  ALG_P' Strat (take (Suc n) qs) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc n. ALG_P' Strat (take (Suc n) qs) init i x y) =\n  (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n  ALG_P' Strat (take (Suc n) qs) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs @ [qs ! n]) init i x y)\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n    ALG_P' Strat (take (Suc n) qs) init n x y =\n    (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "unfolding tak"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "using ns"], ["proof (prove)\nusing this:\n  n < length qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n  ALG_P' Strat (take (Suc n) qs) init n x y =\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ALG_P' Strat (take (Suc n) qs) init i x y) +\n  ALG_P' Strat (take (Suc n) qs) init n x y =\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) \n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y\" (is \"?A + ?B = ?A' + ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"?A = ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length (take n qs)} = {..<length (take n qs)}\n 2. \\<And>xa.\n       xa \\<in> {..<length (take n qs)} \\<Longrightarrow>\n       ALG_P' Strat (take n qs @ [qs ! n]) init xa x y =\n       ALG_P' Strat (take n qs) init xa x y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length (take n qs)} \\<Longrightarrow>\n       ALG_P' Strat (take n qs @ [qs ! n]) init xa x y =\n       ALG_P' Strat (take n qs) init xa x y", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length (take n qs)} \\<Longrightarrow>\n       ALG_P' Strat (take n qs @ [qs ! n]) init xa x y =\n       ALG_P' Strat (take n qs) init xa x y", "case 1"], ["proof (state)\nthis:\n  x_ \\<in> {..<length (take n qs)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<length (take n qs)} \\<Longrightarrow>\n       ALG_P' Strat (take n qs @ [qs ! n]) init xa x y =\n       ALG_P' Strat (take n qs) init xa x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALG_P' Strat (take n qs @ [qs ! n]) init x_ x y =\n    ALG_P' Strat (take n qs) init x_ x y", "apply(rule ALG_P'_rest2[symmetric, where ?r1.0=\"[]\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x_ < length (take n qs)\n 2. x_ < length Strat", "using 1"], ["proof (prove)\nusing this:\n  x_ \\<in> {..<length (take n qs)}\n\ngoal (2 subgoals):\n 1. x_ < length (take n qs)\n 2. x_ < length Strat", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ < length Strat", "using 1 nStrat"], ["proof (prove)\nusing this:\n  x_ \\<in> {..<length (take n qs)}\n  n < length Strat\n\ngoal (1 subgoal):\n 1. x_ < length Strat", "by(simp)"], ["proof (state)\nthis:\n  ALG_P' Strat (take n qs @ [qs ! n]) init x_ x y =\n  ALG_P' Strat (take n qs) init x_ x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs).\n        ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs).\n      ALG_P' Strat (take n qs @ [qs ! n]) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "have \"\\<dots> = ALG_Pxy Strat (take n qs) init x y\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "unfolding ALG_Pxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length (take n qs). ALG_P' Strat (take n qs) init i x y) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "finally"], ["proof (chain)\npicking this:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "show ?thesis"], ["proof (prove)\nusing this:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALG_Pxy Strat (take (Suc n) qs) init x y =\n    ALG_Pxy Strat (take n qs) init x y +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "."], ["proof (state)\nthis:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have tw: \"length (Lxy (take n qs) {x, y}) = length Strat2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy (take n qs) {x, y})\n\ngoal (1 subgoal):\n 1. length (Lxy (take n qs) {x, y}) = length Strat2", "by auto"], ["proof (state)\nthis:\n  length (Lxy (take n qs) {x, y}) = length Strat2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"T\\<^sub>p (Lxy init {x,y}) (Lxy (take (Suc n) qs) {x, y}) ?newStrat + length []\n                 = T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2\n                  + t\\<^sub>p (steps (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2) (qs ! n) (?mtf,?L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n       Strat2)\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)", "unfolding yeh"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y} @ [qs ! n])\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n       Strat2)\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)", "by(simp add: T_append[OF tw, of \"(Lxy init) {x,y}\"])"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = \n                 T\\<^sub>p (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2\n                  + length sws\n                  + index ((swap 0 ^^ ?m) (swaps sws\n                        (steps (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2))) (qs ! n)\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n       Strat2)\n     (qs ! n)\n     (if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n    T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length sws +\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y", "by(simp add: t\\<^sub>p_def)"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "(* now use iH *)"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n     Strat2)\n   (qs ! n)\n   (if x < y\n       in swaps (snd (Strat ! n))\n           (steps' init (take n qs) (take n Strat) n) =\n       x < y\n       in mtf2 (fst (Strat ! n)) (qs ! n)\n           (swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n))\n    then 0 else 1,\n    replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @ sws) =\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = (ALGxy_det Strat (take n qs) init x y \n                  + index ((swap 0 ^^ ?m) (swaps sws\n                        (steps (Lxy init {x,y}) (Lxy (take n qs) {x, y}) Strat2))) (qs ! n))\n                  + (ALG_Pxy Strat (take n qs) init x y\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 +\n    length sws +\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) +\n    ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n    ALGxy_det Strat (take n qs) init x y +\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y)", "by (simp only: T_Strat2)"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take n qs) init x y +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "(* the current cost are equal to the blocking costs: *)"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take n qs) init x y +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take n qs) {x, y}) Strat2 + length sws +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y =\n  ALGxy_det Strat (take n qs) init x y +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "from index_is_blocking_cost"], ["proof (chain)\npicking this:\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) =\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x", "have \"\\<dots> = (ALGxy_det Strat (take n qs) init x y \n                  + ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n                  + (ALG_Pxy Strat (take n qs) init x y\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\""], ["proof (prove)\nusing this:\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) =\n  ALG'_det Strat qs init n y + ALG'_det Strat qs init n x\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y +\n    index\n     ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n       (swaps sws\n         (Partial_Cost_Model.steps (Lxy init {x, y})\n           (Lxy (take n qs) {x, y}) Strat2)))\n     (qs ! n) +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n    ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y)", "by auto"], ["proof (state)\nthis:\n  ALGxy_det Strat (take n qs) init x y +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n  ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  ALGxy_det Strat (take n qs) init x y +\n  index\n   ((swap 0 ^^ ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n     (swaps sws\n       (Partial_Cost_Model.steps (Lxy init {x, y}) (Lxy (take n qs) {x, y})\n         Strat2)))\n   (qs ! n) +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n  ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = ALGxy_det Strat (take (Suc n) qs) init x y \n                  + (ALG_Pxy Strat (take n qs) init x y\n                  + ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y)", "using j"], ["proof (prove)\nusing this:\n  ALGxy_det Strat (take (Suc n) qs) init x y =\n  ALGxy_det Strat (take n qs) init x y +\n  (ALG'_det Strat qs init n y + ALG'_det Strat qs init n x)\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n    ALG'_det Strat qs init n x +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y)", "by auto"], ["proof (state)\nthis:\n  ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "also"], ["proof (state)\nthis:\n  ALGxy_det Strat (take n qs) init x y + ALG'_det Strat qs init n y +\n  ALG'_det Strat qs init n x +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "have \"\\<dots> = ALGxy_det Strat (take (Suc n) qs) init x y \n                  + ALG_Pxy Strat (take (Suc n) qs) init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "using jj"], ["proof (prove)\nusing this:\n  ALG_Pxy Strat (take (Suc n) qs) init x y =\n  ALG_Pxy Strat (take n qs) init x y +\n  ALG_P' Strat (take n qs @ [qs ! n]) init n x y\n\ngoal (1 subgoal):\n 1. ALGxy_det Strat (take (Suc n) qs) init x y +\n    (ALG_Pxy Strat (take n qs) init x y +\n     ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "by auto"], ["proof (state)\nthis:\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  (ALG_Pxy Strat (take n qs) init x y +\n   ALG_P' Strat (take n qs @ [qs ! n]) init n x y) =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n     (Strat2 @\n      [(if x < y\n           in swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n) =\n           x < y\n           in mtf2 (fst (Strat ! n)) (qs ! n)\n               (swaps (snd (Strat ! n))\n                 (steps' init (take n qs) (take n Strat) n))\n        then 0 else 1,\n        replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n        sws)]) +\n    length [] =\n    ALGxy_det Strat (take (Suc n) qs) init x y +\n    ALG_Pxy Strat (take (Suc n) qs) init x y", "."], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n  x < y\n  in swaps []\n      (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n        (Strat2 @\n         [(if x < y\n              in swaps (snd (Strat ! n))\n                  (steps' init (take n qs) (take n Strat) n) =\n              x < y\n              in mtf2 (fst (Strat ! n)) (qs ! n)\n                  (swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n))\n           then 0 else 1,\n           replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n           sws)])\n        (length\n          (Strat2 @\n           [(if x < y\n                in swaps (snd (Strat ! n))\n                    (steps' init (take n qs) (take n Strat) n) =\n                x < y\n                in mtf2 (fst (Strat ! n)) (qs ! n)\n                    (swaps (snd (Strat ! n))\n                      (steps' init (take n qs) (take n Strat) n))\n             then 0 else 1,\n             replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n             sws)]))) \\<and>\n  T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y})\n   (Strat2 @\n    [(if x < y\n         in swaps (snd (Strat ! n))\n             (steps' init (take n qs) (take n Strat) n) =\n         x < y\n         in mtf2 (fst (Strat ! n)) (qs ! n)\n             (swaps (snd (Strat ! n))\n               (steps' init (take n qs) (take n Strat) n))\n      then 0 else 1,\n      replicate (ALG_P' Strat (take n qs @ [qs ! n]) init n x y) 0 @\n      sws)]) +\n  length [] =\n  ALGxy_det Strat (take (Suc n) qs) init x y +\n  ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n     x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take (Suc n) qs) init x y +\n     ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take (Suc n) qs) {x, y}) \\<and>\n     x < y in steps' init (take (Suc n) qs) (take (Suc n) Strat) (Suc n) =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take (Suc n) qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take (Suc n) qs) init x y +\n     ALG_Pxy Strat (take (Suc n) qs) init x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y", "case 0"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  0 \\<le> length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n     length Strat = length qs; 0 \\<le> length qs; x \\<noteq> y;\n     x \\<in> set init; y \\<in> set init; distinct init;\n     set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Strat2 sws.\n                         length Strat2 =\n                         length (Lxy (take 0 qs) {x, y}) \\<and>\n                         x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n                         x < y\n                         in swaps sws\n                             (steps' (Lxy init {x, y})\n                               (Lxy (take 0 qs) {x, y}) Strat2\n                               (length Strat2)) \\<and>\n                         T\\<^sub>p (Lxy init {x, y})\n                          (Lxy (take 0 qs) {x, y}) Strat2 +\n                         length sws =\n                         ALGxy_det Strat (take 0 qs) init x y +\n                         ALG_Pxy Strat (take 0 qs) init x y", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  0 \\<le> length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  0 \\<le> length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<exists>Strat2 sws.\n       length Strat2 = length (Lxy (take 0 qs) {x, y}) \\<and>\n       x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n       x < y\n       in swaps sws\n           (steps' (Lxy init {x, y}) (Lxy (take 0 qs) {x, y}) Strat2\n             (length Strat2)) \\<and>\n       T\\<^sub>p (Lxy init {x, y}) (Lxy (take 0 qs) {x, y}) Strat2 +\n       length sws =\n       ALGxy_det Strat (take 0 qs) init x y +\n       ALG_Pxy Strat (take 0 qs) init x y", "apply (simp add: Lxy_def ALGxy_det_def ALG_Pxy_def T_opt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat =\n             \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs};\n     length Strat = length qs; x \\<noteq> y; x \\<in> set init;\n     y \\<in> set init; distinct init; set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> x < y in init =\n                      x < y in filter (\\<lambda>z. z = x \\<or> z = y) init", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat =\n             \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs};\n     length Strat = length qs; x \\<noteq> y; x \\<in> set init;\n     y \\<in> set init; distinct init; set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> x < y in init =\n                      x < y in filter (\\<lambda>z. z = x \\<or> z = y) init", "case 1"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  length Strat = length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T\\<^sub>p init qs Strat =\n             \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs};\n     length Strat = length qs; x \\<noteq> y; x \\<in> set init;\n     y \\<in> set init; distinct init; set qs \\<subseteq> set init\\<rbrakk>\n    \\<Longrightarrow> x < y in init =\n                      x < y in filter (\\<lambda>z. z = x \\<or> z = y) init", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y in init = x < y in filter (\\<lambda>z. z = x \\<or> z = y) init", "apply(rule Lxy_mono[unfolded Lxy_def, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set init \\<and> y \\<in> set init\n 2. distinct init", "using 1"], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat =\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  length Strat = length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (2 subgoals):\n 1. x \\<in> set init \\<and> y \\<in> set init\n 2. distinct init", "by auto"], ["proof (state)\nthis:\n  x < y in init = x < y in filter (\\<lambda>z. z = x \\<or> z = y) init\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take 0 qs) {x, y}) \\<and>\n     x < y in steps' init (take 0 qs) (take 0 Strat) 0 =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take 0 qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take 0 qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take 0 qs) init x y +\n     ALG_Pxy Strat (take 0 qs) init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T1_7:\nassumes \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\" \"length Strat = length qs\"\n  \"x \\<noteq> (y::('a::linorder))\" \"x\\<in> set init\" \"y \\<in> set init\" \"distinct init\"\n  \"set qs \\<subseteq> set init\"\nshows \"T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "have A:\"length qs \\<le> length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs \\<le> length qs", "by auto"], ["proof (state)\nthis:\n  length qs \\<le> length qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "have B:\"  x \\<noteq> y \""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "using assms"], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  x \\<noteq> y\n  x \\<in> set init\n  y \\<in> set init\n  distinct init\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "from T1_7'[OF assms(1,2), of \"length qs\" x y, OF A B assms(4-7)]"], ["proof (chain)\npicking this:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take (length qs) qs) {x, y}) \\<and>\n     x < y\n     in steps' init (take (length qs) qs) (take (length qs) Strat)\n         (length qs) =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take (length qs) qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take (length qs) qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take (length qs) qs) init x y +\n     ALG_Pxy Strat (take (length qs) qs) init x y", "obtain Strat2 sws where \n      len: \"length Strat2 = length (Lxy qs {x, y})\"\n     and \"x < y in steps' init qs (take (length qs) Strat)\n         (length qs) = x < y in swaps sws (steps' (Lxy init {x,y})\n           (Lxy qs {x, y}) Strat2 (length Strat2))\"\n     and Tp: \"T\\<^sub>p (Lxy init {x,y}) (Lxy qs {x, y}) Strat2 + length sws\n        =  ALGxy_det Strat qs init x y \n         + ALG_Pxy Strat qs init x y\""], ["proof (prove)\nusing this:\n  \\<exists>Strat2 sws.\n     length Strat2 = length (Lxy (take (length qs) qs) {x, y}) \\<and>\n     x < y\n     in steps' init (take (length qs) qs) (take (length qs) Strat)\n         (length qs) =\n     x < y\n     in swaps sws\n         (steps' (Lxy init {x, y}) (Lxy (take (length qs) qs) {x, y}) Strat2\n           (length Strat2)) \\<and>\n     T\\<^sub>p (Lxy init {x, y}) (Lxy (take (length qs) qs) {x, y}) Strat2 +\n     length sws =\n     ALGxy_det Strat (take (length qs) qs) init x y +\n     ALG_Pxy Strat (take (length qs) qs) init x y\n\ngoal (1 subgoal):\n 1. (\\<And>Strat2 sws.\n        \\<lbrakk>length Strat2 = length (Lxy qs {x, y});\n         x < y in steps' init qs (take (length qs) Strat) (length qs) =\n         x < y\n         in swaps sws\n             (steps' (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n               (length Strat2));\n         T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2 + length sws =\n         ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length Strat2 = length (Lxy qs {x, y})\n  x < y in steps' init qs (take (length qs) Strat) (length qs) =\n  x < y\n  in swaps sws\n      (steps' (Lxy init {x, y}) (Lxy qs {x, y}) Strat2 (length Strat2))\n  T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2 + length sws =\n  ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "have \"T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y}) \\<le> T\\<^sub>p (Lxy init {x,y}) (Lxy qs {x, y}) Strat2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) as |as.\n                length as = length (Lxy qs {x, y})}\n    \\<le> T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2", "apply(rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n    \\<in> {T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) as |as.\n           length as = length (Lxy qs {x, y})}\n 2. bdd_below\n     {T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) as |as.\n      length as = length (Lxy qs {x, y})}", "using len"], ["proof (prove)\nusing this:\n  length Strat2 = length (Lxy qs {x, y})\n\ngoal (2 subgoals):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n    \\<in> {T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) as |as.\n           length as = length (Lxy qs {x, y})}\n 2. bdd_below\n     {T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) as |as.\n      length as = length (Lxy qs {x, y})}", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n  \\<le> T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n  \\<le> T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "have \"\\<dots> \\<le> ALGxy_det Strat qs init x y \n         + ALG_Pxy Strat qs init x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "using Tp"], ["proof (prove)\nusing this:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2 + length sws =\n  ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p (Lxy init {x, y}) (Lxy qs {x, y}) Strat2\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n    \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y", "."], ["proof (state)\nthis:\n  T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})\n  \\<le> ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_snoc: \"length rs = length as\n       \\<Longrightarrow>  T init (rs@[r]) (as@[a])\n        = T init rs as + t\\<^sub>p (steps' init rs as (length rs)) r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rs = length as \\<Longrightarrow>\n    T\\<^sub>p init (rs @ [r]) (as @ [a]) =\n    T\\<^sub>p init rs as + t\\<^sub>p (steps' init rs as (length rs)) r a", "apply(induct rs as arbitrary: init rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>init.\n       T\\<^sub>p init ([] @ [r]) ([] @ [a]) =\n       T\\<^sub>p init [] [] + t\\<^sub>p (steps' init [] [] (length [])) r a\n 2. \\<And>x xs y ys init.\n       \\<lbrakk>length xs = length ys;\n        \\<And>init.\n           T\\<^sub>p init (xs @ [r]) (ys @ [a]) =\n           T\\<^sub>p init xs ys +\n           t\\<^sub>p (steps' init xs ys (length xs)) r a\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init ((x # xs) @ [r]) ((y # ys) @ [a]) =\n                         T\\<^sub>p init (x # xs) (y # ys) +\n                         t\\<^sub>p\n                          (steps' init (x # xs) (y # ys) (length (x # xs)))\n                          r a", "by simp_all"], ["", "lemma steps'_snoc: \"length rs = length as \\<Longrightarrow> n = (length as)\n       \\<Longrightarrow> steps' init (rs@[r]) (as@[a]) (Suc n) = step (steps' init rs as n) r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length rs = length as; n = length as\\<rbrakk>\n    \\<Longrightarrow> steps' init (rs @ [r]) (as @ [a]) (Suc n) =\n                      step (steps' init rs as n) r a", "apply(induct rs as arbitrary: init n r a rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>init n r a.\n       n = length [] \\<Longrightarrow>\n       steps' init ([] @ [r]) ([] @ [a]) (Suc n) =\n       step (steps' init [] [] n) r a\n 2. \\<And>x xs y ys init n r a.\n       \\<lbrakk>length xs = length ys;\n        \\<And>init n r a.\n           n = length ys \\<Longrightarrow>\n           steps' init (xs @ [r]) (ys @ [a]) (Suc n) =\n           step (steps' init xs ys n) r a;\n        n = length (y # ys)\\<rbrakk>\n       \\<Longrightarrow> steps' init ((x # xs) @ [r]) ((y # ys) @ [a])\n                          (Suc n) =\n                         step (steps' init (x # xs) (y # ys) n) r a", "by (simp_all)"], ["", "lemma steps'_take:\n  assumes \"n<length qs\" \"length qs = length Strat\" \n  shows \"steps' init (take n qs) (take n Strat) n\n      = steps' init qs Strat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "have \"steps' init qs Strat n =\n    steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init qs Strat n =\n    steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n", "by simp"], ["proof (state)\nthis:\n  steps' init qs Strat n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "also"], ["proof (state)\nthis:\n  steps' init qs Strat n =\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "have \"\\<dots> = steps' init (take n qs) (take n Strat) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "apply(subst steps'_rests[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)\n 3. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "using assms"], ["proof (prove)\nusing this:\n  n < length qs\n  length qs = length Strat\n\ngoal (3 subgoals):\n 1. length (take n qs) = length (take n Strat)\n 2. n \\<le> length (take n Strat)\n 3. steps' init (take n qs) (take n Strat) n =\n    steps' init (take n qs) (take n Strat) n", "by auto"], ["proof (state)\nthis:\n  steps' init (take n qs @ drop n qs) (take n Strat @ drop n Strat) n =\n  steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "finally"], ["proof (chain)\npicking this:\n  steps' init qs Strat n = steps' init (take n qs) (take n Strat) n", "show ?thesis"], ["proof (prove)\nusing this:\n  steps' init qs Strat n = steps' init (take n qs) (take n Strat) n\n\ngoal (1 subgoal):\n 1. steps' init (take n qs) (take n Strat) n = steps' init qs Strat n", "by simp"], ["proof (state)\nthis:\n  steps' init (take n qs) (take n Strat) n = steps' init qs Strat n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Tp_darstellung: \"length qs = length Strat\n        \\<Longrightarrow> T\\<^sub>p init qs Strat =\n        (\\<Sum>i\\<in>{..<length qs}. t\\<^sub>p (steps' init qs Strat i) (qs!i) (Strat!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "assume a[simp]: \"length qs = length Strat\""], ["proof (state)\nthis:\n  length qs = length Strat\n\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "{"], ["proof (state)\nthis:\n  length qs = length Strat\n\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "have \"n\\<le>length qs\n        \\<Longrightarrow> T\\<^sub>p init (take n qs) (take n Strat) =\n        (\\<Sum>i\\<in>{..<n}. t\\<^sub>p (steps' init qs Strat i) (qs!i) (Strat!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length qs \\<Longrightarrow>\n    T\\<^sub>p init (take n qs) (take n Strat) =\n    (\\<Sum>i<n. t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> length qs \\<Longrightarrow>\n    T\\<^sub>p init (take 0 qs) (take 0 Strat) =\n    (\\<Sum>i<0. t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length qs \\<Longrightarrow>\n                T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length qs\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init (take (Suc n) qs)\n                          (take (Suc n) Strat) =\n                         (\\<Sum>i<Suc n.\n                             t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                              (Strat ! i))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length qs \\<Longrightarrow>\n                T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length qs\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init (take (Suc n) qs)\n                          (take (Suc n) Strat) =\n                         (\\<Sum>i<Suc n.\n                             t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                              (Strat ! i))", "apply(simp add: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length Strat\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init (take n qs @ [qs ! n])\n                          (take n Strat @ [Strat ! n]) =\n                         (\\<Sum>i<n.\n                             t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                              (Strat ! i)) +\n                         t\\<^sub>p (steps' init qs Strat n) (qs ! n)\n                          (Strat ! n)", "apply(subst T_snoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length Strat\\<rbrakk>\n       \\<Longrightarrow> length (take n qs) = length (take n Strat)\n 2. \\<And>n.\n       \\<lbrakk>T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length Strat\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init (take n qs) (take n Strat) +\n                         t\\<^sub>p\n                          (steps' init (take n qs) (take n Strat)\n                            (length (take n qs)))\n                          (qs ! n) (Strat ! n) =\n                         (\\<Sum>i<n.\n                             t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                              (Strat ! i)) +\n                         t\\<^sub>p (steps' init qs Strat n) (qs ! n)\n                          (Strat ! n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>T\\<^sub>p init (take n qs) (take n Strat) =\n                (\\<Sum>i<n.\n                    t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                     (Strat ! i));\n        Suc n \\<le> length Strat\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p init (take n qs) (take n Strat) +\n                         t\\<^sub>p\n                          (steps' init (take n qs) (take n Strat)\n                            (length (take n qs)))\n                          (qs ! n) (Strat ! n) =\n                         (\\<Sum>i<n.\n                             t\\<^sub>p (steps' init qs Strat i) (qs ! i)\n                              (Strat ! i)) +\n                         t\\<^sub>p (steps' init qs Strat n) (qs ! n)\n                          (Strat ! n)", "by(simp add: min_def steps'_take)"], ["proof (state)\nthis:\n  n \\<le> length qs \\<Longrightarrow>\n  T\\<^sub>p init (take n qs) (take n Strat) =\n  (\\<Sum>i<n. t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "}"], ["proof (state)\nthis:\n  ?n2 \\<le> length qs \\<Longrightarrow>\n  T\\<^sub>p init (take ?n2 qs) (take ?n2 Strat) =\n  (\\<Sum>i<?n2. t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. length qs = length Strat \\<Longrightarrow>\n    T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "from a this[of \"length qs\"]"], ["proof (chain)\npicking this:\n  length qs = length Strat\n  length qs \\<le> length qs \\<Longrightarrow>\n  T\\<^sub>p init (take (length qs) qs) (take (length qs) Strat) =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "show ?thesis"], ["proof (prove)\nusing this:\n  length qs = length Strat\n  length qs \\<le> length qs \\<Longrightarrow>\n  T\\<^sub>p init (take (length qs) qs) (take (length qs) Strat) =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Gleichung 1.8 in Borodin *)"], ["", "lemma umformung_OPT':\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\"\n  assumes qsStrat: \"length qs = length Strat\"\n  assumes noStupid: \"\\<And>x l. x<length Strat \\<Longrightarrow> l< length (snd (Strat ! x)) \\<Longrightarrow> Suc ((snd (Strat ! x))!l)  < length init\"\n  shows \"T\\<^sub>p init qs Strat = \n    (\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "(* have config_dist: \"\\<forall>n. \\<forall>xa \\<in> set_pmf (config\\<^sub>p (I, S) qs init n). distinct (snd xa)\"\n      using dist config_rand_distinct by metis\n*) \n\n  (* ersten Teil umformen: *)"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"(\\<Sum>i\\<in>{..<length qs}.\n    (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\n                = (\\<Sum>i\\<in>{..<length qs}. \n               (\\<Sum>z\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) (fst z) (snd z) (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>i<length qs.\n        \\<Sum>z\\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))", "by(auto simp: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>i<length qs.\n      \\<Sum>z\\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>i<length qs.\n      \\<Sum>z\\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots>\n       = (\\<Sum>z\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                (\\<Sum>i\\<in>{..<length qs}. ALG_P (snd (Strat!i)) (fst z) (snd z) (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>z\\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) (fst z) (snd z)\n           (steps' init qs Strat i)) =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))", "by(rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>z\\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i)) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>z\\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i)) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                (\\<Sum>i\\<in>{..<length qs}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) (fst z) (snd z)\n           (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))", "by(auto simp: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) (fst z) (snd z) (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_Pxy Strat qs init x y)", "unfolding ALG_P'_def ALG_Pxy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i<length qs.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i<length qs.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)", "have paid_part: \"(\\<Sum>i\\<in>{..<length qs}.\n    (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\n      = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                ALG_Pxy Strat qs init x y)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_Pxy Strat qs init x y)", "."], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "(* zweiten Teil umformen: *)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "let ?config = \"(%i. swaps (snd (Strat!i)) (steps' init qs Strat i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"(\\<Sum>i\\<in>{..<length qs}. \n                (\\<Sum>e\\<in>set init. ALG e qs i (?config i, ())))\n        = (\\<Sum>e\\<in>set init. \n            (\\<Sum>i\\<in>{..<length qs}. ALG e qs i (?config i, ())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>e\\<in>set init.\n          ALG e qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>e\\<in>set init.\n       \\<Sum>i<length qs.\n          ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>i<length qs.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>i<length qs.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>e\\<in>set init.\n          (\\<Sum>y\\<in>set init.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG e qs i (?config i,()))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set init.\n       \\<Sum>i<length qs.\n          ALG e qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>e\\<in>set init.\n       \\<Sum>y\\<in>set init.\n         \\<Sum>i | i < length qs \\<and> qs ! i = y.\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> set init\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>i<length qs. ALG x qs i (?config i, ()))\n                = sum (%i. ALG x qs i (?config i, ())) {i. i<length qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i | i < length qs.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by (simp add: lessThan_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs.\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs.\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = sum (%i. ALG x qs i (?config i, ())) \n                        (\\<Union>y\\<in>{y. y \\<in> set init}. {i. i < length qs \\<and> qs ! i = y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                     {i. i < length qs \\<and> qs ! i = y}).\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {i. i < length qs} =\n    (\\<Union>y\\<in>{y. y \\<in> set init}.\n        {i. i < length qs \\<and> qs ! i = y})\n 2. \\<And>xa.\n       xa \\<in> (\\<Union>y\\<in>{y. y \\<in> set init}.\n                    {i. i < length qs \\<and> qs ! i = y}) \\<Longrightarrow>\n       ALG x qs xa\n        (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ()) =\n       ALG x qs xa (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ())", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. {i. i < length qs} =\n    (\\<Union>y\\<in>{y. y \\<in> set init}.\n        {i. i < length qs \\<and> qs ! i = y})\n 2. \\<And>xa.\n       xa \\<in> (\\<Union>y\\<in>{y. y \\<in> set init}.\n                    {i. i < length qs \\<and> qs ! i = y}) \\<Longrightarrow>\n       ALG x qs xa\n        (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ()) =\n       ALG x qs xa (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ())", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {i. i < length qs} =\n    (\\<Union>y\\<in>{y. y \\<in> set init}.\n        {i. i < length qs \\<and> qs ! i = y})\n 2. \\<And>xa.\n       xa \\<in> (\\<Union>y\\<in>{y. y \\<in> set init}.\n                    {i. i < length qs \\<and> qs ! i = y}) \\<Longrightarrow>\n       ALG x qs xa\n        (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ()) =\n       ALG x qs xa (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ())", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs} =\n    (\\<Union>y\\<in>{y. y \\<in> set init}.\n        {i. i < length qs \\<and> qs ! i = y})", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x < length qs \\<Longrightarrow> qs ! x \\<in> set init", "using inlist"], ["proof (prove)\nusing this:\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>x. x < length qs \\<Longrightarrow> qs ! x \\<in> set init", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs} =\n  (\\<Union>y\\<in>{y. y \\<in> set init}.\n      {i. i < length qs \\<and> qs ! i = y})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<Union>y\\<in>{y. y \\<in> set init}.\n                    {i. i < length qs \\<and> qs ! i = y}) \\<Longrightarrow>\n       ALG x qs xa\n        (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ()) =\n       ALG x qs xa (swaps (snd (Strat ! xa)) (steps' init qs Strat xa), ())", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs.\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs.\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = sum (%t. sum (%i. ALG x qs i (?config i, ())) {i. i<length qs \\<and> qs ! i = t}) {y. y\\<in> set init}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                     {i. i < length qs \\<and> qs ! i = y}).\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>t\\<in>{y. y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = t.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.UNION_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {y. y \\<in> set init}\n 2. \\<forall>i\\<in>{y. y \\<in> set init}.\n       finite {ia. ia < length qs \\<and> qs ! ia = i}\n 3. \\<forall>i\\<in>{y. y \\<in> set init}.\n       \\<forall>j\\<in>{y. y \\<in> set init}.\n          i \\<noteq> j \\<longrightarrow>\n          {ia. ia < length qs \\<and> qs ! ia = i} \\<inter>\n          {i. i < length qs \\<and> qs ! i = j} =\n          {}", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set init.\n       \\<forall>j\\<in>set init.\n          i \\<noteq> j \\<longrightarrow>\n          {ia. ia < length qs \\<and> qs ! ia = i} \\<inter>\n          {i. i < length qs \\<and> qs ! i = j} =\n          {}", "by force"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>{y. y \\<in> set init}.\n                   {i. i < length qs \\<and> qs ! i = y}).\n     ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = (\\<Sum>y\\<in>set init. \\<Sum>i | i < length qs \\<and> qs ! i = y.\n                       ALG x qs i (?config i, ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>{y. y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = t.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>{y. y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = t.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (2 subgoals):\n 1. set init = set init\n 2. \\<And>x.\n       x \\<in> set init \\<Longrightarrow>\n       (\\<Sum>i<length qs.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (\\<Sum>y\\<in>set init.\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length qs.\n      ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length qs.\n      ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "."], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>y\\<in>set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. set init = set init", "qed (simp)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>i<length qs.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>i<length qs.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> (set init \\<times> set init).\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG x qs i (?config i, ())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set init.\n       \\<Sum>y\\<in>set init.\n         \\<Sum>i | i < length qs \\<and> qs ! i = y.\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by (rule sum.cartesian_product)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set init.\n     \\<Sum>y\\<in>set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> {(x,y). x\\<in>set init \\<and> y\\<in> set init}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG x qs i (?config i, ())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>set init \\<times> set init.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have E4: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x\\<in>set init \\<and> y\\<in> set init \\<and> x\\<noteq>y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG x qs i (?config i, ())))\" (is \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f x y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "let ?M = \"{(x,y). x\\<in>set init \\<and> y\\<in> set init \\<and> x=y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have A: \"?L = ?R \\<union> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init} =\n    {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init} =\n  {(x, y).\n   x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have B: \"{} = ?R \\<inter> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} =\n    {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "by auto"], ["proof (state)\nthis:\n  {} =\n  {(x, y).\n   x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R \\<union> ?M. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(simp only: A)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?M. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n 2. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n 3. {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y} =\n    {}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)\n 3. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n 4. {(x, y).\n     x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y} =\n    {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>(x,y)\\<in> ?M. ?f x y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    0", "apply(rule sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i = y.\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       0", "by (auto simp add: split_def before_in_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x = y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow> x \\<in> set init \\<and> y \\<in> set init.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  0", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow> x \\<in> set init \\<and> y \\<in> set init.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum> | case  of\n            (x, y) \\<Rightarrow>\n              x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y.\n     case  of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\\<in>{(x, y). x \\<in> set init \\<and> y \\<in> set init}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=y}. ALG x qs i (?config i, ()))\n           + (\\<Sum>i\\<in>{i. i<length qs \\<and> qs!i=x}. ALG y qs i (?config i, ())) )\"\n            (is \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f x y +  ?f y x)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "let ?R' = \"{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> y<x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have A: \"?L = ?R \\<union> ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<union>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x \\<noteq> y} =\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<union>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have \"{} = ?R \\<inter> ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  {} =\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have C: \"?R' = (%(x,y). (y, x)) ` ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    (\\<lambda>(x, y). (y, x)) `\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n  (\\<lambda>(x, y). (y, x)) `\n  {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have D: \"(\\<Sum>(x,y)\\<in> ?R'. ?f x y) = (\\<Sum>(x,y)\\<in> ?R. ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>(x,y)\\<in> ?R'. ?f x y) = (\\<Sum>(x,y)\\<in> (%(x,y). (y, x)) ` ?R. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>(\\<lambda>(x, y). (y, x)) `\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(simp only: C)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>(\\<lambda>(x, y). (y, x)) `\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>(\\<lambda>(x, y). (y, x)) `\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>z\\<in> (%(x,y). (y, x)) ` ?R. (%(x,y). ?f x y) z) = (\\<Sum>z\\<in>?R. ((%(x,y). ?f x y) \\<circ> (%(x,y). (y, x))) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n                 {(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       case z of\n       (x, y) \\<Rightarrow>\n         \\<Sum>i | i < length qs \\<and> qs ! i = y.\n           ALG x qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    sum ((\\<lambda>(x, y).\n             \\<Sum>i | i < length qs \\<and> qs ! i = y.\n               ALG x qs i\n                (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n                 ())) \\<circ>\n         (\\<lambda>(x, y). (y, x)))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "apply(rule sum.reindex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). (y, x))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "by(fact swap_inj_on)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n               {(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n               ())) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>(\\<lambda>(x, y). (y, x)) `\n               {(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n               ())) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = (\\<Sum>z\\<in>?R. (%(x,y). ?f y x) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>(x, y).\n             \\<Sum>i | i < length qs \\<and> qs ! i = y.\n               ALG x qs i\n                (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n                 ())) \\<circ>\n         (\\<lambda>(x, y). (y, x)))\n     {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    (\\<Sum>z\\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       case z of\n       (x, y) \\<Rightarrow>\n         \\<Sum>i | i < length qs \\<and> qs ! i = x.\n           ALG y qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       ((\\<lambda>(x, y).\n            \\<Sum>i | i < length qs \\<and> qs ! i = y.\n              ALG x qs i\n               (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n                ())) \\<circ>\n        (\\<lambda>(x, y). (y, x)))\n        x =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i = x.\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(auto)"], ["proof (state)\nthis:\n  sum ((\\<lambda>(x, y).\n           \\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i),\n               ())) \\<circ>\n       (\\<lambda>(x, y). (y, x)))\n   {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>z\\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     case z of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x.\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x.\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have \"(\\<Sum>(x,y)\\<in> ?L. ?f x y) = (\\<Sum>(x,y)\\<in> ?R \\<union> ?R'. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x < y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(simp only: A)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?R'. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x < y} \\<union>\n                {(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n 3. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    {}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)\n 3. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n 4. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} \\<inter>\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x} =\n    {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}", "apply(rule finite_subset[where B=\"set init \\<times> set init\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}\n    \\<subseteq> set init \\<times> set init\n 2. finite (set init \\<times> set init)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x < y} \\<union>\n              {(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y) + (\\<Sum>(x,y)\\<in> ?R. ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by(simp only: D)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x.\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> y < x}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x.\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "have \"\\<dots> = (\\<Sum>(x,y)\\<in> ?R. ?f x y + ?f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = x.\n         ALG y qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "by(simp add: split_def sum.distrib[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = x.\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and>\n                 y \\<in> set init \\<and> x \\<noteq> y}.\n       \\<Sum>i | i < length qs \\<and> qs ! i = y.\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and>\n               y \\<in> set init \\<and> x \\<noteq> y}.\n     \\<Sum>i | i < length qs \\<and> qs ! i = y.\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have E5: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n            (\\<Sum>i\\<in>{i. i<length qs \\<and> (qs!i=y \\<or> qs!i=x)}. ALG y qs i (?config i, ()) + ALG x qs i (?config i, ())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "then"], ["proof (chain)\npicking this:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}", "obtain a b where x: \"x=(a,b)\" and a: \"a \\<in> set init\" \"b \\<in> set init\" \"a < b\""], ["proof (prove)\nusing this:\n  x \\<in> {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = (a, b); a \\<in> set init; b \\<in> set init;\n         a < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "then"], ["proof (chain)\npicking this:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b", "have \"a\\<noteq>b\""], ["proof (prove)\nusing this:\n  x = (a, b)\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> b", "have disj: \"{i. i < length qs \\<and> qs ! i = b} \\<inter> {i. i < length qs \\<and> qs ! i = a} = {}\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> qs ! i = b} \\<inter>\n    {i. i < length qs \\<and> qs ! i = a} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> qs ! i = b} \\<inter>\n  {i. i < length qs \\<and> qs ! i = a} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have unio: \"{i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)}\n            = {i. i < length qs \\<and> qs ! i = b} \\<union> {i. i < length qs \\<and> qs ! i = a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)} =\n    {i. i < length qs \\<and> qs ! i = b} \\<union>\n    {i. i < length qs \\<and> qs ! i = a}", "by auto"], ["proof (state)\nthis:\n  {i. i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a)} =\n  {i. i < length qs \\<and> qs ! i = b} \\<union>\n  {i. i < length qs \\<and> qs ! i = a}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "let ?f=\"%i. ALG b qs i (?config i, ()) +\n               ALG a qs i (?config i, ())\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "let ?B=\"{i. i < length qs \\<and> qs ! i = b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "let ?A=\"{i. i < length qs \\<and> qs ! i = a}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"(\\<Sum>i\\<in>?B \\<union> ?A. ?f i)\n               = (\\<Sum>i\\<in>?B. ?f i) + (\\<Sum>i\\<in>?A. ?f i) - (\\<Sum>i\\<in>?B \\<inter> ?A. ?f i) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(rule sum_Un_nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {i. i < length qs \\<and> qs ! i = b}\n 2. finite {i. i < length qs \\<and> qs ! i = a}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = (\\<Sum>i\\<in>?B. ALG b qs i (?config i, ()) + ALG a qs i (?config i, ()))\n                    + (\\<Sum>i\\<in>?A. ALG b qs i (?config i, ()) + ALG a qs i (?config i, ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "using disj"], ["proof (prove)\nusing this:\n  {i. i < length qs \\<and> qs ! i = b} \\<inter>\n  {i. i < length qs \\<and> qs ! i = a} =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) -\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<inter>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "have \"\\<dots> = (\\<Sum>i\\<in>?B. ALG a qs i (?config i, ()))\n                  + (\\<Sum>i\\<in>?A. ALG b qs i (?config i, ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by (auto simp: split_def before_in_def)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n             ALG x qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n          (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n             ALG y qs i\n              (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n    (case x of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "unfolding x"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n               {i. i < length qs \\<and> qs ! i = a}.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n     ALG a qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n     ALG b qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. (case (a, b) of\n     (x, y) \\<Rightarrow>\n       (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n          ALG x qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n       (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n          ALG y qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n    (case (a, b) of\n     (x, y) \\<Rightarrow>\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n         ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "apply(simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       (if b < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0) +\n       (if a < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0)) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       if a < b in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       if b < a in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) \\<Longrightarrow>\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       if a < b in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       if b < a in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) =\n    (\\<Sum>i | i < length qs \\<and> (qs ! i = b \\<or> qs ! i = a).\n       (if b < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0) +\n       (if a < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0))", "unfolding unio"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       (if b < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0) +\n       (if a < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0)) =\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       if a < b in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       if b < a in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) \\<Longrightarrow>\n    (\\<Sum>i | i < length qs \\<and> qs ! i = b.\n       if a < b in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) +\n    (\\<Sum>i | i < length qs \\<and> qs ! i = a.\n       if b < a in swaps (snd (Strat ! i)) (steps' init qs Strat i) then 1\n       else 0) =\n    (\\<Sum>i\\<in>{i. i < length qs \\<and> qs ! i = b} \\<union>\n                 {i. i < length qs \\<and> qs ! i = a}.\n       (if b < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0) +\n       (if a < qs ! i in swaps (snd (Strat ! i)) (steps' init qs Strat i)\n        then 1 else 0))", "by simp"], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i\n         (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i\n         (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     (\\<Sum>i | i < length qs \\<and> qs ! i = y.\n        ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n     (\\<Sum>i | i < length qs \\<and> qs ! i = x.\n        ALG y qs i\n         (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have E6: \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                  ALGxy_det Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n         ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n         ALG x qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y)", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (case x of (x, y) \\<Rightarrow> ALGxy_det Strat qs init x y)", "unfolding ALGxy_det_alternativ"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n            ALG'_det Strat qs init i y + ALG'_det Strat qs init i x)", "unfolding ALG'_det_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y} =\n    {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}\n 2. \\<And>x.\n       x \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<Sum>i | i < length qs \\<and> qs ! i \\<in> {y, x}.\n            ALG y qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n            ALG x qs i\n             (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     \\<Sum>i | i < length qs \\<and> (qs ! i = y \\<or> qs ! i = x).\n       ALG y qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ()) +\n       ALG x qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y)", "have blockingpart: \"(\\<Sum>i<length qs. \n                         \\<Sum>e\\<in>set init.\n                              ALG e qs i (?config i, ()))\n                 = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. \n                         ALGxy_det Strat qs init x y) \""], ["proof (prove)\nusing this:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>e\\<in>set init.\n          ALG e qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y)", "."], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "from Tp_darstellung[OF qsStrat]"], ["proof (chain)\npicking this:\n  T\\<^sub>p ?init qs Strat =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' ?init qs Strat i) (qs ! i) (Strat ! i))", "have E0: \"T\\<^sub>p init qs Strat =\n        (\\<Sum>i\\<in>{..<length qs}. t\\<^sub>p (steps' init qs Strat i) (qs!i) (Strat!i))\""], ["proof (prove)\nusing this:\n  T\\<^sub>p ?init qs Strat =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' ?init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<length qs}. \n                (\\<Sum>e\\<in>set (steps' init qs Strat i). ALG e qs i (swaps (snd (Strat!i)) (steps' init qs Strat i),()))\n+ (\\<Sum>(x,y)\\<in>{(x,(y::('a::linorder))). x \\<in> set (steps' init qs Strat i) \\<and> y\\<in>set (steps' init qs Strat i) \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i)) =\n    (\\<Sum>i<length qs.\n        (\\<Sum>e\\<in>set (steps' init qs Strat i).\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n        (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set (steps' init qs Strat i) \\<and>\n                     y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n           ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} = {..<length qs}\n 2. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       t\\<^sub>p (steps' init qs Strat x) (qs ! x) (Strat ! x) =\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       t\\<^sub>p (steps' init qs Strat x) (qs ! x) (Strat ! x) =\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "apply (rule t\\<^sub>p_sumofALGALGP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       distinct (steps' init qs Strat x)\n 2. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       qs ! x \\<in> set (steps' init qs Strat x)\n 3. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       \\<forall>l<length (snd (Strat ! x)).\n          Suc (snd (Strat ! x) ! l) < length (steps' init qs Strat x)", "apply(rule steps'_distinct2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow> length qs = length Strat\n 2. \\<And>x. x \\<in> {..<length qs} \\<Longrightarrow> x \\<le> length Strat\n 3. \\<And>x. x \\<in> {..<length qs} \\<Longrightarrow> distinct init\n 4. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       qs ! x \\<in> set (steps' init qs Strat x)\n 5. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       \\<forall>l<length (snd (Strat ! x)).\n          Suc (snd (Strat ! x) ! l) < length (steps' init qs Strat x)", "using dist qsStrat"], ["proof (prove)\nusing this:\n  distinct init\n  length qs = length Strat\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow> length qs = length Strat\n 2. \\<And>x. x \\<in> {..<length qs} \\<Longrightarrow> x \\<le> length Strat\n 3. \\<And>x. x \\<in> {..<length qs} \\<Longrightarrow> distinct init\n 4. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       qs ! x \\<in> set (steps' init qs Strat x)\n 5. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       \\<forall>l<length (snd (Strat ! x)).\n          Suc (snd (Strat ! x) ! l) < length (steps' init qs Strat x)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set (steps' init qs Strat x)\n 2. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l)\n                            < length (steps' init qs Strat x)", "apply(subst steps'_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> length qs = length Strat\n 2. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length Strat\n 3. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set init\n 4. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l)\n                            < length (steps' init qs Strat x)", "using dist qsStrat inlist"], ["proof (prove)\nusing this:\n  distinct init\n  length qs = length Strat\n  set qs \\<subseteq> set init\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> length qs = length Strat\n 2. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length Strat\n 3. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set init\n 4. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init;\n        length qs = length Strat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l)\n                            < length (steps' init qs Strat x)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> qs ! x \\<in> set init\n 2. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l)\n                            < length (steps' init qs Strat x)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l)\n                            < length (steps' init qs Strat x)", "apply(subst steps'_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> length qs = length Strat\n 2. \\<And>x l.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length Strat\n 3. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l) < length init", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l) < length init", "using noStupid"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < length Strat; ?l < length (snd (Strat ! ?x))\\<rbrakk>\n  \\<Longrightarrow> Suc (snd (Strat ! ?x) ! ?l) < length init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < length Strat; distinct init; length qs = length Strat;\n        set qs \\<subseteq> set init\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l<length (snd (Strat ! x)).\n                            Suc (snd (Strat ! x) ! l) < length init", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i)) =\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set (steps' init qs Strat i).\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set (steps' init qs Strat i) \\<and>\n                   y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      t\\<^sub>p (steps' init qs Strat i) (qs ! i) (Strat ! i)) =\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set (steps' init qs Strat i).\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set (steps' init qs Strat i) \\<and>\n                   y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<length qs}. \n                (\\<Sum>e\\<in>set init. ALG e qs i (swaps (snd (Strat!i)) (steps' init qs Strat i),()))\n+ (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        (\\<Sum>e\\<in>set (steps' init qs Strat i).\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n        (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set (steps' init qs Strat i) \\<and>\n                     y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n           ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n    (\\<Sum>i<length qs.\n        (\\<Sum>e\\<in>set init.\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n        (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<length qs} = {..<length qs}\n 2. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n       (\\<Sum>e\\<in>set init.\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n       (\\<Sum>e\\<in>set init.\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n       (\\<Sum>e\\<in>set init.\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> {..<length qs}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n       (\\<Sum>e\\<in>set init.\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "then"], ["proof (chain)\npicking this:\n  x \\<in> {..<length qs}", "have \"set (steps' init qs Strat x) = set init\""], ["proof (prove)\nusing this:\n  x \\<in> {..<length qs}\n\ngoal (1 subgoal):\n 1. set (steps' init qs Strat x) = set init", "apply(subst steps'_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> {..<length qs} \\<Longrightarrow> length qs = length Strat\n 2. x \\<in> {..<length qs} \\<Longrightarrow> x \\<le> length Strat\n 3. x \\<in> {..<length qs} \\<Longrightarrow> set init = set init", "using dist qsStrat 1"], ["proof (prove)\nusing this:\n  distinct init\n  length qs = length Strat\n  x \\<in> {..<length qs}\n\ngoal (3 subgoals):\n 1. x \\<in> {..<length qs} \\<Longrightarrow> length qs = length Strat\n 2. x \\<in> {..<length qs} \\<Longrightarrow> x \\<le> length Strat\n 3. x \\<in> {..<length qs} \\<Longrightarrow> set init = set init", "by(simp_all)"], ["proof (state)\nthis:\n  set (steps' init qs Strat x) = set init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length qs} \\<Longrightarrow>\n       (\\<Sum>e\\<in>set (steps' init qs Strat x).\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(xa, y).\n                    xa \\<in> set (steps' init qs Strat x) \\<and>\n                    y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n       (\\<Sum>e\\<in>set init.\n          ALG e qs x\n           (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n       (\\<Sum>(xa, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "then"], ["proof (chain)\npicking this:\n  set (steps' init qs Strat x) = set init", "show ?case"], ["proof (prove)\nusing this:\n  set (steps' init qs Strat x) = set init\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>set (steps' init qs Strat x).\n       ALG e qs x (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n    (\\<Sum>(xa, y)\n           \\<in>{(xa, y).\n                 xa \\<in> set (steps' init qs Strat x) \\<and>\n                 y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n       ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n    (\\<Sum>e\\<in>set init.\n       ALG e qs x (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n    (\\<Sum>(xa, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>set (steps' init qs Strat x).\n     ALG e qs x (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n  (\\<Sum>(xa, y)\n         \\<in>{(xa, y).\n               xa \\<in> set (steps' init qs Strat x) \\<and>\n               y \\<in> set (steps' init qs Strat x) \\<and> xa < y}.\n     ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x)) =\n  (\\<Sum>e\\<in>set init.\n     ALG e qs x (swaps (snd (Strat ! x)) (steps' init qs Strat x), ())) +\n  (\\<Sum>(xa, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_P (snd (Strat ! x)) xa y (steps' init qs Strat x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set (steps' init qs Strat i).\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set (steps' init qs Strat i) \\<and>\n                   y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set init.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set (steps' init qs Strat i).\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set (steps' init qs Strat i) \\<and>\n                   y \\<in> set (steps' init qs Strat i) \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set init.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>i\\<in>{..<length qs}. \n                (\\<Sum>e\\<in>set init. ALG e qs i (swaps (snd (Strat!i)) (steps' init qs Strat i), ())))\n               + (\\<Sum>i\\<in>{..<length qs}. \n               (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        (\\<Sum>e\\<in>set init.\n           ALG e qs i\n            (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n        (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n    (\\<Sum>i<length qs.\n        \\<Sum>e\\<in>set init.\n          ALG e qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))", "by (simp add: sum.distrib split_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set init.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      (\\<Sum>e\\<in>set init.\n         ALG e qs i\n          (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n      (\\<Sum>(x, y)\n             \\<in>{(x, y).\n                   x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n         ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))) =\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. \n                         ALGxy_det Strat qs init x y)\n               + (\\<Sum>i\\<in>{..<length qs}. \n               (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. ALG_P (snd (Strat!i)) x y (steps' init qs Strat i)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length qs.\n        \\<Sum>e\\<in>set init.\n          ALG e qs i\n           (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n    (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y) +\n    (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))", "by(simp only: blockingpart)"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length qs.\n      \\<Sum>e\\<in>set init.\n        ALG e qs i (swaps (snd (Strat ! i)) (steps' init qs Strat i), ())) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i))\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. \n                         ALGxy_det Strat qs init x y)\n               + (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n                ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y) +\n    (\\<Sum>i<length qs.\n        \\<Sum>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n          ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_Pxy Strat qs init x y)", "by(simp only: paid_part)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>i<length qs.\n      \\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        ALG_P (snd (Strat ! i)) x y (steps' init qs Strat i)) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> = (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. \n                         ALGxy_det Strat qs init x y\n               +   ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALG_Pxy Strat qs init x y) =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "by (simp add: sum.distrib split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALG_Pxy Strat qs init x y) =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nn_contains_Inf:\n  fixes S :: \"nat set\"\n  assumes nn: \"S \\<noteq> {}\"\n  shows \"Inf S \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> S \\<in> S", "using assms Inf_nat_def LeastI"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n  \\<Sqinter> ?X = (LEAST n. n \\<in> ?X)\n  ?P ?k \\<Longrightarrow> ?P (LEAST x. ?P x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> S \\<in> S", "by force"], ["", "lemma steps_length: \"length qs = length as \\<Longrightarrow> length (steps s qs as) = length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length as \\<Longrightarrow>\n    length (Partial_Cost_Model.steps s qs as) = length s", "apply(induct qs as arbitrary: s rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. length (Partial_Cost_Model.steps s [] []) = length s\n 2. \\<And>x xs y ys s.\n       \\<lbrakk>length xs = length ys;\n        \\<And>s.\n           length (Partial_Cost_Model.steps s xs ys) = length s\\<rbrakk>\n       \\<Longrightarrow> length\n                          (Partial_Cost_Model.steps s (x # xs) (y # ys)) =\n                         length s", "by simp_all"], ["", "(* shows that OPT does not use paid exchanges that do not have an effect *)"], ["", "lemma OPT_noStupid:\n  fixes Strat\n  assumes [simp]: \"length Strat = length qs\"\n  assumes opt: \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\"\n  assumes init_nempty: \"init\\<noteq>[]\"\n  shows \"\\<And>x l. x < length Strat \\<Longrightarrow>\n        l < length (snd (Strat ! x)) \\<Longrightarrow>\n       Suc ((snd (Strat ! x))!l) < length init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x))\\<rbrakk>\n       \\<Longrightarrow> Suc (snd (Strat ! x) ! l) < length init", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 x l)"], ["proof (state)\nthis:\n  x < length Strat\n  l < length (snd (Strat ! x))\n  \\<not> Suc (snd (Strat ! x) ! l) < length init\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "(* construct a Stratgy that leaves out that paid exchange *)"], ["proof (state)\nthis:\n  x < length Strat\n  l < length (snd (Strat ! x))\n  \\<not> Suc (snd (Strat ! x) ! l) < length init\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "let ?sws' = \"take l (snd (Strat!x)) @ drop (Suc l) (snd (Strat!x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Strat' = \"take x Strat @ (fst (Strat!x),?sws') # drop (Suc x) Strat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "from 1(1)"], ["proof (chain)\npicking this:\n  x < length Strat", "have valid: \"length ?Strat' = length qs\""], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (1 subgoal):\n 1. length\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) =\n    length qs", "by simp"], ["proof (state)\nthis:\n  length\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  length qs\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "from valid"], ["proof (chain)\npicking this:\n  length\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  length qs", "have isin: \"T\\<^sub>p init qs ?Strat' \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\""], ["proof (prove)\nusing this:\n  length\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  length qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)\n    \\<in> {T\\<^sub>p init qs as |as. length as = length qs}", "by blast"], ["proof (state)\nthis:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat)\n  \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "from 1(1,2)"], ["proof (chain)\npicking this:\n  x < length Strat\n  l < length (snd (Strat ! x))", "have lsws': \"length (snd (Strat!x)) = length ?sws' + 1\""], ["proof (prove)\nusing this:\n  x < length Strat\n  l < length (snd (Strat ! x))\n\ngoal (1 subgoal):\n 1. length (snd (Strat ! x)) =\n    length (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) + 1", "by (simp)"], ["proof (state)\nthis:\n  length (snd (Strat ! x)) =\n  length (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) + 1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have a: \"(take x ?Strat') = (take x Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) =\n    take x Strat", "using 1(1)"], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (1 subgoal):\n 1. take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) =\n    take x Strat", "by(auto simp add: min_def take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take x\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  take x Strat\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have b: \"(drop (Suc x) Strat) = (drop (Suc x) ?Strat')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc x) Strat =\n    drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)", "using 1(1)"], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (1 subgoal):\n 1. drop (Suc x) Strat =\n    drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)", "by(auto simp add: min_def take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  drop (Suc x) Strat =\n  drop (Suc x)\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have aa: \"(take l (snd (Strat!x))) = (take l (snd (?Strat'!x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take l (snd (Strat ! x)) =\n    take l\n     (snd ((take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x))", "using 1(1,2)"], ["proof (prove)\nusing this:\n  x < length Strat\n  l < length (snd (Strat ! x))\n\ngoal (1 subgoal):\n 1. take l (snd (Strat ! x)) =\n    take l\n     (snd ((take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x))", "by(auto simp add: min_def take_Suc_conv_app_nth nth_append)"], ["proof (state)\nthis:\n  take l (snd (Strat ! x)) =\n  take l\n   (snd ((take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat) !\n         x))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have bb: \"(drop (Suc l) (snd (Strat!x))) = (drop l (snd (?Strat'!x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc l) (snd (Strat ! x)) =\n    drop l\n     (snd ((take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x))", "using 1(1,2)"], ["proof (prove)\nusing this:\n  x < length Strat\n  l < length (snd (Strat ! x))\n\ngoal (1 subgoal):\n 1. drop (Suc l) (snd (Strat ! x)) =\n    drop l\n     (snd ((take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x))", "by(auto simp add: min_def take_Suc_conv_app_nth nth_append )"], ["proof (state)\nthis:\n  drop (Suc l) (snd (Strat ! x)) =\n  drop l\n   (snd ((take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat) !\n         x))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(swaps (snd (Strat ! x)) (steps init (take x qs) (take x Strat)))\n      = (swaps (take l (snd (Strat ! x)) @ (snd (Strat ! x))!l # drop (Suc l) (snd (Strat ! x))) (steps init (take x qs) (take x Strat)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (snd (Strat ! x))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n    swaps\n     (take l (snd (Strat ! x)) @\n      snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "unfolding id_take_nth_drop[OF 1(2), symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps (snd (Strat ! x))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n    swaps (snd (Strat ! x))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "by simp"], ["proof (state)\nthis:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps\n   (take l (snd (Strat ! x)) @\n    snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps\n   (take l (snd (Strat ! x)) @\n    snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"...\n      = (swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) (steps init (take x qs) (take x Strat)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaps\n     (take l (snd (Strat ! x)) @\n      snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n    swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "using 1(3)"], ["proof (prove)\nusing this:\n  \\<not> Suc (snd (Strat ! x) ! l) < length init\n\ngoal (1 subgoal):\n 1. swaps\n     (take l (snd (Strat ! x)) @\n      snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n    swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "by(simp add: swap_def steps_length)"], ["proof (state)\nthis:\n  swaps\n   (take l (snd (Strat ! x)) @\n    snd (Strat ! x) ! l # drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "have noeffect: \"(swaps (snd (Strat ! x)) (steps init (take x qs) (take x Strat)))\n      = (swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) (steps init (take x qs) (take x Strat)))\""], ["proof (prove)\nusing this:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. swaps (snd (Strat ! x))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n    swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n     (Partial_Cost_Model.steps init (take x qs) (take x Strat))", "."], ["proof (state)\nthis:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have c: \"t\\<^sub>p (steps init (take x qs) (take x Strat)) (qs ! x) (Strat ! x) = \n        t\\<^sub>p (steps init (take x qs) (take x ?Strat')) (qs ! x) (?Strat' ! x) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n     (qs ! x) (Strat ! x) =\n    t\\<^sub>p\n     (Partial_Cost_Model.steps init (take x qs)\n       (take x\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (qs ! x)\n     ((take x Strat @\n       (fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n       drop (Suc x) Strat) !\n      x) +\n    1", "unfolding a t\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (mf, sws) = Strat ! x\n     in index\n         (swaps sws\n           (Partial_Cost_Model.steps init (take x qs) (take x Strat)))\n         (qs ! x) +\n        length sws) =\n    (let (mf, sws) =\n           (take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x\n     in index\n         (swaps sws\n           (Partial_Cost_Model.steps init (take x qs) (take x Strat)))\n         (qs ! x) +\n        length sws) +\n    1", "using 1(1,2)"], ["proof (prove)\nusing this:\n  x < length Strat\n  l < length (snd (Strat ! x))\n\ngoal (1 subgoal):\n 1. (let (mf, sws) = Strat ! x\n     in index\n         (swaps sws\n           (Partial_Cost_Model.steps init (take x qs) (take x Strat)))\n         (qs ! x) +\n        length sws) =\n    (let (mf, sws) =\n           (take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat) !\n           x\n     in index\n         (swaps sws\n           (Partial_Cost_Model.steps init (take x qs) (take x Strat)))\n         (qs ! x) +\n        length sws) +\n    1", "apply(simp add: min_def split_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length qs; l < length (snd (Strat ! x))\\<rbrakk>\n    \\<Longrightarrow> index\n                       (swaps (snd (Strat ! x))\n                         (Partial_Cost_Model.steps init (take x qs)\n                           (take x Strat)))\n                       (qs ! x) +\n                      length (snd (Strat ! x)) =\n                      Suc (index\n                            (swaps (take l (snd (Strat ! x)))\n                              (swaps (drop (Suc l) (snd (Strat ! x)))\n                                (Partial_Cost_Model.steps init (take x qs)\n                                  (take x Strat))))\n                            (qs ! x) +\n                           length (snd (Strat ! x)) -\n                           Suc 0)", "unfolding noeffect"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length qs; l < length (snd (Strat ! x))\\<rbrakk>\n    \\<Longrightarrow> index\n                       (swaps\n                         (take l (snd (Strat ! x)) @\n                          drop (Suc l) (snd (Strat ! x)))\n                         (Partial_Cost_Model.steps init (take x qs)\n                           (take x Strat)))\n                       (qs ! x) +\n                      length (snd (Strat ! x)) =\n                      Suc (index\n                            (swaps (take l (snd (Strat ! x)))\n                              (swaps (drop (Suc l) (snd (Strat ! x)))\n                                (Partial_Cost_Model.steps init (take x qs)\n                                  (take x Strat))))\n                            (qs ! x) +\n                           length (snd (Strat ! x)) -\n                           Suc 0)", "by(simp)"], ["proof (state)\nthis:\n  t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n   (qs ! x) (Strat ! x) =\n  t\\<^sub>p\n   (Partial_Cost_Model.steps init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (qs ! x)\n   ((take x Strat @\n     (fst (Strat ! x),\n      take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n     drop (Suc x) Strat) !\n    x) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat)\n        = T\\<^sub>p init (take x qs) (take x ?Strat') + \n              t\\<^sub>p (steps init (take x qs) (take x Strat)) (qs ! x) (Strat ! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n    T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n     (qs ! x) (Strat ! x)", "using 1(1) a"], ["proof (prove)\nusing this:\n  x < length Strat\n  take x\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  take x Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n    T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n     (qs ! x) (Strat ! x)", "by(simp add: take_Suc_conv_app_nth T_append)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n   (qs ! x) (Strat ! x)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n   (qs ! x) (Strat ! x)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p init (take x qs) (take x ?Strat')  + \n              t\\<^sub>p (steps init (take x qs) (take x ?Strat')) (qs ! x) (?Strat' ! x) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n     (qs ! x) (Strat ! x) =\n    T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps init (take x qs)\n       (take x\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (qs ! x)\n     ((take x Strat @\n       (fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n       drop (Suc x) Strat) !\n      x) +\n    1", "unfolding c"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    (t\\<^sub>p\n      (Partial_Cost_Model.steps init (take x qs)\n        (take x\n          (take x Strat @\n           (fst (Strat ! x),\n            take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n           drop (Suc x) Strat)))\n      (qs ! x)\n      ((take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat) !\n       x) +\n     1) =\n    T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps init (take x qs)\n       (take x\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (qs ! x)\n     ((take x Strat @\n       (fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n       drop (Suc x) Strat) !\n      x) +\n    1", "by(simp)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n   (qs ! x) (Strat ! x) =\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (qs ! x)\n   ((take x Strat @\n     (fst (Strat ! x),\n      take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n     drop (Suc x) Strat) !\n    x) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n   (qs ! x) (Strat ! x) =\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (qs ! x)\n   ((take x Strat @\n     (fst (Strat ! x),\n      take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n     drop (Suc x) Strat) !\n    x) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p init (take (Suc x) qs) (take (Suc x) ?Strat')  + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps init (take x qs)\n       (take x\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (qs ! x)\n     ((take x Strat @\n       (fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n       drop (Suc x) Strat) !\n      x) +\n    1 =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "using 1(1) a"], ["proof (prove)\nusing this:\n  x < length Strat\n  take x\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) =\n  take x Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    t\\<^sub>p\n     (Partial_Cost_Model.steps init (take x qs)\n       (take x\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (qs ! x)\n     ((take x Strat @\n       (fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n       drop (Suc x) Strat) !\n      x) +\n    1 =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "by(simp add: min_def take_Suc_conv_app_nth T_append nth_append)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take x qs)\n   (take x\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  t\\<^sub>p\n   (Partial_Cost_Model.steps init (take x qs)\n     (take x\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (qs ! x)\n   ((take x Strat @\n     (fst (Strat ! x),\n      take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n     drop (Suc x) Strat) !\n    x) +\n  1 =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1", "have bef: \"T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat)\n      = T\\<^sub>p init (take (Suc x) qs) (take (Suc x) ?Strat') + 1\""], ["proof (prove)\nusing this:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "."], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "let ?interstate = \"(steps init (take (Suc x) qs) (take (Suc x) Strat))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "let ?interstate' = \"(steps init (take (Suc x) qs) (take (Suc x) ?Strat'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have state: \"?interstate' = ?interstate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) =\n    Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat)", "using 1(1)"], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (1 subgoal):\n 1. Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) =\n    Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat)", "apply(simp add: take_Suc_conv_app_nth min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length qs \\<Longrightarrow>\n    Partial_Cost_Model.steps init (take x qs @ [qs ! x])\n     (take x Strat @\n      [(fst (Strat ! x),\n        take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))]) =\n    Partial_Cost_Model.steps init (take x qs @ [qs ! x])\n     (take x Strat @ [Strat ! x])", "apply(simp add: steps_append step_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length qs \\<Longrightarrow>\n    mtf2 (fst (Strat ! x)) (qs ! x)\n     (swaps (take l (snd (Strat ! x)))\n       (swaps (drop (Suc l) (snd (Strat ! x)))\n         (Partial_Cost_Model.steps init (take x qs) (take x Strat)))) =\n    mtf2 (fst (Strat ! x)) (qs ! x)\n     (swaps (snd (Strat ! x))\n       (Partial_Cost_Model.steps init (take x qs) (take x Strat)))", "using noeffect"], ["proof (prove)\nusing this:\n  swaps (snd (Strat ! x))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat)) =\n  swaps (take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x)))\n   (Partial_Cost_Model.steps init (take x qs) (take x Strat))\n\ngoal (1 subgoal):\n 1. x < length qs \\<Longrightarrow>\n    mtf2 (fst (Strat ! x)) (qs ! x)\n     (swaps (take l (snd (Strat ! x)))\n       (swaps (drop (Suc l) (snd (Strat ! x)))\n         (Partial_Cost_Model.steps init (take x qs) (take x Strat)))) =\n    mtf2 (fst (Strat ! x)) (qs ! x)\n     (swaps (snd (Strat ! x))\n       (Partial_Cost_Model.steps init (take x qs) (take x Strat)))", "by simp"], ["proof (state)\nthis:\n  Partial_Cost_Model.steps init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) =\n  Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"T\\<^sub>p init qs Strat\n      = T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)  (take (Suc x) Strat @ drop (Suc x) Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n     (take (Suc x) Strat @ drop (Suc x) Strat)", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x) Strat @ drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x) Strat @ drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat)\n            + T\\<^sub>p ?interstate (drop (Suc x) qs) (drop (Suc x) Strat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n     (take (Suc x) Strat @ drop (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat)", "apply(subst T_append2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take (Suc x) qs) = length (take (Suc x) Strat)\n 2. T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat)", "by(simp_all)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x) Strat @ drop (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n   (drop (Suc x) qs) (drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x) Strat @ drop (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n   (drop (Suc x) qs) (drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> =  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) ?Strat')\n            + T\\<^sub>p ?interstate' (drop (Suc x) qs) (drop (Suc x) ?Strat') + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "unfolding bef state"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "using 1(1)"], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs) (drop (Suc x) Strat) =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "by(simp add: min_def nth_append)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n   (drop (Suc x) qs) (drop (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (drop (Suc x) qs)\n   (drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs) (take (Suc x) Strat) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs) (take (Suc x) Strat))\n   (drop (Suc x) qs) (drop (Suc x) Strat) =\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (drop (Suc x) qs)\n   (drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)  (take (Suc x) ?Strat' @ drop (Suc x) ?Strat') + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 =\n    T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat) @\n      drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "apply(subst T_append2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take (Suc x) qs) =\n    length\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat))\n 2. T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "using 1(1)"], ["proof (prove)\nusing this:\n  x < length Strat\n\ngoal (2 subgoals):\n 1. length (take (Suc x) qs) =\n    length\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat))\n 2. T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 =\n    T\\<^sub>p init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    T\\<^sub>p\n     (Partial_Cost_Model.steps init (take (Suc x) qs)\n       (take (Suc x)\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)))\n     (drop (Suc x) qs)\n     (drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1", "by(simp_all add: min_def)"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (drop (Suc x) qs)\n   (drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1 =\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) @\n    drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  T\\<^sub>p\n   (Partial_Cost_Model.steps init (take (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)))\n   (drop (Suc x) qs)\n   (drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1 =\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) @\n    drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p init qs ?Strat' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n     (take (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat) @\n      drop (Suc x)\n       (take x Strat @\n        (fst (Strat ! x),\n         take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n        drop (Suc x) Strat)) +\n    1 =\n    T\\<^sub>p init qs\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) +\n    1", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p init (take (Suc x) qs @ drop (Suc x) qs)\n   (take (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) @\n    drop (Suc x)\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat)) +\n  1 =\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p init qs Strat =\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1", "have better: \"T\\<^sub>p init qs ?Strat' + 1 = T\\<^sub>p init qs Strat\""], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat =\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) +\n    1 =\n    T\\<^sub>p init qs Strat", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1 =\n  T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"T\\<^sub>p init qs ?Strat' + 1 = T\\<^sub>p init qs Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs\n     (take x Strat @\n      (fst (Strat ! x),\n       take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n      drop (Suc x) Strat) +\n    1 =\n    T\\<^sub>p init qs Strat", "by (fact better)"], ["proof (state)\nthis:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1 =\n  T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1 =\n  T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = T\\<^sub>p_opt init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs", "by (fact opt)"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "from cInf_lower[OF isin]"], ["proof (chain)\npicking this:\n  bdd_below\n   {T\\<^sub>p init qs as |as. length as = length qs} \\<Longrightarrow>\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)", "have \"\\<dots>  \\<le>  T\\<^sub>p init qs ?Strat'\""], ["proof (prove)\nusing this:\n  bdd_below\n   {T\\<^sub>p init qs as |as. length as = length qs} \\<Longrightarrow>\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs\n    \\<le> T\\<^sub>p init qs\n           (take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat)", "unfolding T_opt_def"], ["proof (prove)\nusing this:\n  bdd_below\n   {T\\<^sub>p init qs as |as. length as = length qs} \\<Longrightarrow>\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n    \\<le> T\\<^sub>p init qs\n           (take x Strat @\n            (fst (Strat ! x),\n             take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n            drop (Suc x) Strat)", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p_opt init qs\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x));\n        \\<not> Suc (snd (Strat ! x) ! l) < length init\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)", "show \"False\""], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)\n\ngoal (1 subgoal):\n 1. False", "using init_nempty"], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs\n   (take x Strat @\n    (fst (Strat ! x),\n     take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n    drop (Suc x) Strat) +\n  1\n  \\<le> T\\<^sub>p init qs\n         (take x Strat @\n          (fst (Strat ! x),\n           take l (snd (Strat ! x)) @ drop (Suc l) (snd (Strat ! x))) #\n          drop (Suc x) Strat)\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Gleichung 1.8 in Borodin *)"], ["", "lemma umformung_OPT:\n  assumes inlist: \"set qs \\<subseteq> set init\"\n  assumes dist: \"distinct init\" \n  assumes a: \"T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat\"\n  assumes b: \" length qs = length Strat\"\n  assumes c: \"init\\<noteq>[]\"\n  shows \"T\\<^sub>p_opt init qs = \n    (\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat", "by(fact a)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_opt init qs = T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "have \"\\<dots> =\n    (\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "apply(rule umformung_OPT')"], ["proof (prove)\ngoal (4 subgoals):\n 1. set qs \\<subseteq> set init\n 2. distinct init\n 3. length qs = length Strat\n 4. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x))\\<rbrakk>\n       \\<Longrightarrow> Suc (snd (Strat ! x) ! l) < length init", "apply(fact)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x))\\<rbrakk>\n       \\<Longrightarrow> Suc (snd (Strat ! x) ! l) < length init", "using OPT_noStupid[OF b[symmetric] a[symmetric] c]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < length Strat; ?l < length (snd (Strat ! ?x))\\<rbrakk>\n  \\<Longrightarrow> Suc (snd (Strat ! ?x) ! ?l) < length init\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>x < length Strat; l < length (snd (Strat ! x))\\<rbrakk>\n       \\<Longrightarrow> Suc (snd (Strat ! x) ! l) < length init", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt init qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt init qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "."], ["proof (state)\nthis:\n  T\\<^sub>p_opt init qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary OPT_zerlegen: \n  assumes\n        dist: \"distinct init\"\n  and c: \"init\\<noteq>[]\"\n    and setqsinit: \"set qs \\<subseteq> set init\"\n  shows \"(\\<Sum>(x,y)\\<in>{(x,y::('a::linorder)). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. (T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})))\n        \\<le> T\\<^sub>p_opt init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "have \"T\\<^sub>p_opt init qs \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt init qs\n    \\<in> {T\\<^sub>p init qs as |as. length as = length qs}", "unfolding T_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n    \\<in> {T\\<^sub>p init qs as |as. length as = length qs}", "apply(rule nn_contains_Inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {T\\<^sub>p init qs as |as. length as = length qs} \\<noteq> {}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. length as = length qs", "by (rule Ex_list_of_length)"], ["proof (state)\nthis:\n  T\\<^sub>p_opt init qs\n  \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "then"], ["proof (chain)\npicking this:\n  T\\<^sub>p_opt init qs\n  \\<in> {T\\<^sub>p init qs as |as. length as = length qs}", "obtain Strat where a: \"T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\"\n                       and b: \"length Strat = length qs\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_opt init qs\n  \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs;\n         length Strat = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding T_opt_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> {T\\<^sub>p init qs as |as. length as = length qs}\n  \\<in> {T\\<^sub>p init qs as |as. length as = length qs}\n\ngoal (1 subgoal):\n 1. (\\<And>Strat.\n        \\<lbrakk>T\\<^sub>p init qs Strat =\n                 \\<Sqinter> {T\\<^sub>p init qs as |as.\n                             length as = length qs};\n         length Strat = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "have \"(\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n       T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x, y})) \\<le> (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}.\n          ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n             ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case i of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n       \\<le> (case i of\n              (x, y) \\<Rightarrow>\n                ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n                         \\<le> ALGxy_det Strat qs init a b +\n                               ALG_Pxy Strat qs init a b", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n                         \\<le> ALGxy_det Strat qs init a b +\n                               ALG_Pxy Strat qs init a b", "case (1 a b)"], ["proof (state)\nthis:\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n                         \\<le> ALGxy_det Strat qs init a b +\n                               ALG_Pxy Strat qs init a b", "then"], ["proof (chain)\npicking this:\n  a \\<in> set init\n  b \\<in> set init\n  a < b", "have \"a\\<noteq>b\""], ["proof (prove)\nusing this:\n  a \\<in> set init\n  b \\<in> set init\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set init; b \\<in> set init; a < b\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n                         \\<le> ALGxy_det Strat qs init a b +\n                               ALG_Pxy Strat qs init a b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n    \\<le> ALGxy_det Strat qs init a b + ALG_Pxy Strat qs init a b", "apply(rule T1_7[OF a b])"], ["proof (prove)\ngoal (5 subgoals):\n 1. a \\<noteq> b\n 2. a \\<in> set init\n 3. b \\<in> set init\n 4. distinct init\n 5. set qs \\<subseteq> set init", "by(fact)+"], ["proof (state)\nthis:\n  T\\<^sub>p_opt (Lxy init {a, b}) (Lxy qs {a, b})\n  \\<le> ALGxy_det Strat qs init a b + ALG_Pxy Strat qs init a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "from umformung_OPT[OF setqsinit dist] a b c"], ["proof (chain)\npicking this:\n  \\<lbrakk>T\\<^sub>p_opt init qs = T\\<^sub>p init qs ?Strat;\n   length qs = length ?Strat; init \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_opt init qs =\n                    (\\<Sum>(x, y)\n                           \\<in>{(x, y).\n                                 x \\<in> set init \\<and>\n                                 y \\<in> set init \\<and> x < y}.\n                       ALGxy_det ?Strat qs init x y +\n                       ALG_Pxy ?Strat qs init x y)\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  init \\<noteq> []", "have \"\\<dots> = T\\<^sub>p init qs Strat\""], ["proof (prove)\nusing this:\n  \\<lbrakk>T\\<^sub>p_opt init qs = T\\<^sub>p init qs ?Strat;\n   length qs = length ?Strat; init \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> T\\<^sub>p_opt init qs =\n                    (\\<Sum>(x, y)\n                           \\<in>{(x, y).\n                                 x \\<in> set init \\<and>\n                                 y \\<in> set init \\<and> x < y}.\n                       ALGxy_det ?Strat qs init x y +\n                       ALG_Pxy ?Strat qs init x y)\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n  length Strat = length qs\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y) =\n    T\\<^sub>p init qs Strat", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y) =\n  T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     ALGxy_det Strat qs init x y + ALG_Pxy Strat qs init x y) =\n  T\\<^sub>p init qs Strat\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "from a"], ["proof (chain)\npicking this:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs", "have \"\\<dots> = T\\<^sub>p_opt init qs\""], ["proof (prove)\nusing this:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs", "by simp"], ["proof (state)\nthis:\n  T\\<^sub>p init qs Strat = T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "."], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Factoring Lemma\""], ["", "lemma cardofpairs: \"S \\<noteq> [] \\<Longrightarrow> sorted S \\<Longrightarrow> distinct S \\<Longrightarrow> card {(x,y). x \\<in> set S \\<and> y\\<in>set S \\<and> x<y} = ((length S)*(length S-1)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> []; sorted S; distinct S\\<rbrakk>\n    \\<Longrightarrow> real\n                       (card\n                         {(x, y).\n                          x \\<in> set S \\<and>\n                          y \\<in> set S \\<and> x < y}) =\n                      real (length S * (length S - 1)) / 2", "proof (induct S rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "case (cons s ss)"], ["proof (state)\nthis:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "then"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)", "have \"sorted ss\" \"distinct ss\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n\ngoal (1 subgoal):\n 1. sorted ss &&& distinct ss", "by auto"], ["proof (state)\nthis:\n  sorted ss\n  distinct ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "from cons(2)[OF this(1) this(2)]"], ["proof (chain)\npicking this:\n  real\n   (card\n     {a. case a of\n         (x, y) \\<Rightarrow>\n           x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2", "have iH: \"card {(x, y) . x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n    = (length ss * (length ss-1)) / 2\""], ["proof (prove)\nusing this:\n  real\n   (card\n     {a. case a of\n         (x, y) \\<Rightarrow>\n           x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2\n\ngoal (1 subgoal):\n 1. real\n     (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}) =\n    real (length ss * (length ss - 1)) / 2", "by auto"], ["proof (state)\nthis:\n  real (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "from cons"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)", "have sss: \"s \\<notin> set ss\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n\ngoal (1 subgoal):\n 1. s \\<notin> set ss", "by auto"], ["proof (state)\nthis:\n  s \\<notin> set ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "from cons"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)", "have tt: \"(\\<forall>y\\<in>set (s#ss). s \\<le> y)\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (s # ss). s \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (s # ss). s \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "with cons"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n  \\<forall>y\\<in>set (s # ss). s \\<le> y", "have tt': \"(\\<forall>y\\<in>set ss. s < y)\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n  \\<forall>y\\<in>set (s # ss). s \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ss. s < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> [];\n     \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n     \\<Longrightarrow> real\n                        (card\n                          {a. case a of\n                              (x, y) \\<Rightarrow>\n                                x \\<in> set ss \\<and>\n                                y \\<in> set ss \\<and> x < y}) =\n                       real (length ss * (length ss - 1)) / 2;\n     sorted (s # ss); distinct (s # ss);\n     \\<forall>y\\<in>set (s # ss). s \\<le> y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set ss. s < y", "from sss"], ["proof (chain)\npicking this:\n  s \\<notin> set ss", "have \"(\\<forall>y\\<in>set ss. s \\<noteq> y)\""], ["proof (prove)\nusing this:\n  s \\<notin> set ss\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ss. s \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ss. s \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> [];\n     \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n     \\<Longrightarrow> real\n                        (card\n                          {a. case a of\n                              (x, y) \\<Rightarrow>\n                                x \\<in> set ss \\<and>\n                                y \\<in> set ss \\<and> x < y}) =\n                       real (length ss * (length ss - 1)) / 2;\n     sorted (s # ss); distinct (s # ss);\n     \\<forall>y\\<in>set (s # ss). s \\<le> y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set ss. s < y", "with tt"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set (s # ss). s \\<le> y\n  \\<forall>y\\<in>set ss. s \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (s # ss). s \\<le> y\n  \\<forall>y\\<in>set ss. s \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ss. s < y", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ss. s < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ss. s < y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set ss. s < y", "have \"{(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y}\n          = {(x, y) . x = s \\<and> y \\<in> set ss}\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ss. s < y\n\ngoal (1 subgoal):\n 1. {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {(x, y). x = s \\<and> y \\<in> set ss}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n  {(x, y). x = s \\<and> y \\<in> set ss}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n  {(x, y). x = s \\<and> y \\<in> set ss}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = {s}\\<times>(set ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x = s \\<and> y \\<in> set ss} = {s} \\<times> set ss", "by auto"], ["proof (state)\nthis:\n  {(x, y). x = s \\<and> y \\<in> set ss} = {s} \\<times> set ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "finally"], ["proof (chain)\npicking this:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss", "have \"{(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y} = {s}\\<times>(set ss)\""], ["proof (prove)\nusing this:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss\n\ngoal (1 subgoal):\n 1. {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss", "."], ["proof (state)\nthis:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "then"], ["proof (chain)\npicking this:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss", "have \"card {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y}\n          = card (set ss)\""], ["proof (prove)\nusing this:\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = {s} \\<times> set ss\n\ngoal (1 subgoal):\n 1. card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = card (set ss)", "by(auto)"], ["proof (state)\nthis:\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = card (set ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = card (set ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "from cons distinct_card"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs", "have \"\\<dots> = length ss\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  \\<lbrakk>sorted ss; distinct ss\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {a. case a of\n                           (x, y) \\<Rightarrow>\n                             x \\<in> set ss \\<and>\n                             y \\<in> set ss \\<and> x < y}) =\n                    real (length ss * (length ss - 1)) / 2\n  sorted (s # ss)\n  distinct (s # ss)\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card (set ss) = length ss", "by auto"], ["proof (state)\nthis:\n  card (set ss) = length ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "finally"], ["proof (chain)\npicking this:\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = length ss", "have step: \"card {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y} =\n            length ss\""], ["proof (prove)\nusing this:\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = length ss\n\ngoal (1 subgoal):\n 1. card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = length ss", "."], ["proof (state)\nthis:\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = length ss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have uni: \"{(x, y) . x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y}\n      = {(x, y) . x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n        \\<union> {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n    {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}", "using tt"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (s # ss). s \\<le> y\n\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n    {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n  {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have disj: \"{(x, y) . x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n        \\<inter> {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "using sss"], ["proof (prove)\nusing this:\n  s \\<notin> set ss\n\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "by(auto)"], ["proof (state)\nthis:\n  {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"card {(x, y) . x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y}\n    = card ({(x, y) . x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n        \\<union> {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {(x, y).\n      x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n    card\n     ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n      {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y})", "using uni"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n  {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n\ngoal (1 subgoal):\n 1. card\n     {(x, y).\n      x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n    card\n     ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n      {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y})", "by auto"], ["proof (state)\nthis:\n  card\n   {(x, y). x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n  card\n   ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  card\n   {(x, y). x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y} =\n  card\n   ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = card {(x, y) . x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n          + card {(x, y) . x = s \\<and> y \\<in> set ss \\<and> x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n      {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n    card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n    card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}", "apply(rule card_Un_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n 2. finite {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n 3. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(rule finite_subset[where B=\"(set ss) \\<times> (set ss)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}\n    \\<subseteq> set ss \\<times> set ss\n 2. finite (set ss \\<times> set ss)\n 3. finite {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n 4. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set ss \\<times> set ss)\n 2. finite {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n 3. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n 2. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(rule finite_subset[where B=\"{s} \\<times> (set ss)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n    \\<subseteq> {s} \\<times> set ss\n 2. finite ({s} \\<times> set ss)\n 3. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ({s} \\<times> set ss)\n 2. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "using disj"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n  {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n  {}\n\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<inter>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} =\n    {}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card\n   ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n  card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  card\n   ({(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} \\<union>\n    {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n  card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length ss * (length ss-1)) / 2\n                  + length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n      card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n    real (length ss * (length ss - 1)) / 2 + real (length ss)", "using iH step"], ["proof (prove)\nusing this:\n  real (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2\n  card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y} = length ss\n\ngoal (1 subgoal):\n 1. real\n     (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n      card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n    real (length ss * (length ss - 1)) / 2 + real (length ss)", "by auto"], ["proof (state)\nthis:\n  real\n   (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n    card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2 + real (length ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real\n   (card {(x, y). x \\<in> set ss \\<and> y \\<in> set ss \\<and> x < y} +\n    card {(x, y). x = s \\<and> y \\<in> set ss \\<and> x < y}) =\n  real (length ss * (length ss - 1)) / 2 + real (length ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length ss * (length ss-1) + 2*length ss) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length ss * (length ss - 1)) / 2 + real (length ss) =\n    real (length ss * (length ss - 1) + 2 * length ss) / 2", "by auto"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1)) / 2 + real (length ss) =\n  real (length ss * (length ss - 1) + 2 * length ss) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1)) / 2 + real (length ss) =\n  real (length ss * (length ss - 1) + 2 * length ss) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length ss * (length ss-1) + length ss * 2) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length ss * (length ss - 1) + 2 * length ss) / 2 =\n    real (length ss * (length ss - 1) + length ss * 2) / 2", "by auto"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1) + 2 * length ss) / 2 =\n  real (length ss * (length ss - 1) + length ss * 2) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1) + 2 * length ss) / 2 =\n  real (length ss * (length ss - 1) + length ss * 2) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length ss * (length ss-1+2)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length ss * (length ss - 1) + length ss * 2) / 2 =\n    real (length ss * (length ss - 1 + 2)) / 2", "by simp"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1) + length ss * 2) / 2 =\n  real (length ss * (length ss - 1 + 2)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1) + length ss * 2) / 2 =\n  real (length ss * (length ss - 1 + 2)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length ss * (length ss+1)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length ss * (length ss - 1 + 2)) / 2 =\n    real (length ss * (length ss + 1)) / 2", "using cons(1)"], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. real (length ss * (length ss - 1 + 2)) / 2 =\n    real (length ss * (length ss + 1)) / 2", "by simp"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1 + 2)) / 2 =\n  real (length ss * (length ss + 1)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real (length ss * (length ss - 1 + 2)) / 2 =\n  real (length ss * (length ss + 1)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = ((length ss+1) * length ss) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length ss * (length ss + 1)) / 2 =\n    real ((length ss + 1) * length ss) / 2", "by auto"], ["proof (state)\nthis:\n  real (length ss * (length ss + 1)) / 2 =\n  real ((length ss + 1) * length ss) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "also"], ["proof (state)\nthis:\n  real (length ss * (length ss + 1)) / 2 =\n  real ((length ss + 1) * length ss) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "have \"\\<dots> = (length (s#ss) * (length (s#ss)-1)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((length ss + 1) * length ss) / 2 =\n    real (length (s # ss) * (length (s # ss) - 1)) / 2", "by auto"], ["proof (state)\nthis:\n  real ((length ss + 1) * length ss) / 2 =\n  real (length (s # ss) * (length (s # ss) - 1)) / 2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> real\n                           (card\n                             {(x, y).\n                              x \\<in> set xs \\<and>\n                              y \\<in> set xs \\<and> x < y}) =\n                          real (length xs * (length xs - 1)) / 2;\n        sorted (x # xs); distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set (x # xs) \\<and>\n                             y \\<in> set (x # xs) \\<and> xa < y}) =\n                         real (length (x # xs) * (length (x # xs) - 1)) / 2", "finally"], ["proof (chain)\npicking this:\n  real\n   (card\n     {(x, y).\n      x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y}) =\n  real (length (s # ss) * (length (s # ss) - 1)) / 2", "show ?case"], ["proof (prove)\nusing this:\n  real\n   (card\n     {(x, y).\n      x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y}) =\n  real (length (s # ss) * (length (s # ss) - 1)) / 2\n\ngoal (1 subgoal):\n 1. real\n     (card\n       {a. case a of\n           (x, y) \\<Rightarrow>\n             x \\<in> set (s # ss) \\<and>\n             y \\<in> set (s # ss) \\<and> x < y}) =\n    real (length (s # ss) * (length (s # ss) - 1)) / 2", "by auto"], ["proof (state)\nthis:\n  real\n   (card\n     {a. case a of\n         (x, y) \\<Rightarrow>\n           x \\<in> set (s # ss) \\<and> y \\<in> set (s # ss) \\<and> x < y}) =\n  real (length (s # ss) * (length (s # ss) - 1)) / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2", "case single"], ["proof (state)\nthis:\n  sorted [x_]\n  distinct [x_]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sorted [x]; distinct [x]\\<rbrakk>\n       \\<Longrightarrow> real\n                          (card\n                            {(xa, y).\n                             xa \\<in> set [x] \\<and>\n                             y \\<in> set [x] \\<and> xa < y}) =\n                         real (length [x] * (length [x] - 1)) / 2", "thus ?case"], ["proof (prove)\nusing this:\n  sorted [x_]\n  distinct [x_]\n\ngoal (1 subgoal):\n 1. real\n     (card\n       {a. case a of\n           (xa, y) \\<Rightarrow>\n             xa \\<in> set [x_] \\<and> y \\<in> set [x_] \\<and> xa < y}) =\n    real (length [x_] * (length [x_] - 1)) / 2", "by(simp cong: conj_cong)"], ["proof (state)\nthis:\n  real\n   (card\n     {a. case a of\n         (xa, y) \\<Rightarrow>\n           xa \\<in> set [x_] \\<and> y \\<in> set [x_] \\<and> xa < y}) =\n  real (length [x_] * (length [x_] - 1)) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "(* factoring lemma *)"], ["", "lemma factoringlemma_withconstant:\n    fixes A\n          and b::real\n          and c::real\n      assumes c: \"c \\<ge> 1\"\n      assumes dist: \"\\<forall>e\\<in>S0. distinct e\"\n      assumes notempty: \"\\<forall>e\\<in>S0. length e > 0\"\n      (* A has pairwise property *)\n      assumes pw: \"pairwise A\"\n      (* A is c-competitive on list of length 2 *) \n      assumes on2: \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \\<forall>(x,y)\\<in>{(x,y). x \\<in> set s0 \\<and> y\\<in>set s0 \\<and> x<y}. T\\<^sub>p_on_rand A (Lxy s0 {x,y}) (Lxy qs {x,y})  \\<le> c * (T\\<^sub>p_opt (Lxy s0 {x,y}) (Lxy qs {x,y})) + b\" \n      assumes nopaid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n      assumes 4: \"\\<And>init qs. distinct init \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> (\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x)))\" \n      (* then A is c-competitive on arbitrary list lengths *)\n      shows \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0.  \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \n              T\\<^sub>p_on_rand A s0 qs \\<le> c * real (T\\<^sub>p_opt s0 qs) + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0\\<in>S0.\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "proof (standard, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "case (1 init)"], ["proof (state)\nthis:\n  init \\<in> S0\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have d: \"distinct init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct init", "using  dist 1"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>S0. distinct e\n  init \\<in> S0\n\ngoal (1 subgoal):\n 1. distinct init", "by auto"], ["proof (state)\nthis:\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have d2: \"init \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<noteq> []", "using  notempty 1"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>S0. 0 < length e\n  init \\<in> S0\n\ngoal (1 subgoal):\n 1. init \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "obtain b where on3: \"\\<forall>qs\\<in>{x. set x \\<subseteq> set init}. \\<forall>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. T\\<^sub>p_on_rand A  (Lxy init {x,y}) (Lxy qs {x,y}) \\<le> c * (T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})) + b\"\n        and b: \"b\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n                    \\<forall>(x, y)\n                             \\<in>{(x, y).\n                                   x \\<in> set init \\<and>\n                                   y \\<in> set init \\<and> x < y}.\n                       T\\<^sub>p_on_rand' A\n                        (fst A (Lxy init {x, y}) \\<bind>\n                         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                        (Lxy qs {x, y})\n                       \\<le> c *\n                             real\n                              (T\\<^sub>p_opt (Lxy init {x, y})\n                                (Lxy qs {x, y})) +\n                             b;\n         0 \\<le> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using on2 1"], ["proof (prove)\nusing this:\n  \\<forall>s0\\<in>S0.\n     \\<exists>b\\<ge>0.\n        \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n           \\<forall>(x, y)\n                    \\<in>{(x, y).\n                          x \\<in> set s0 \\<and>\n                          y \\<in> set s0 \\<and> x < y}.\n              T\\<^sub>p_on_rand' A\n               (fst A (Lxy s0 {x, y}) \\<bind>\n                (\\<lambda>is. return_pmf (Lxy s0 {x, y}, is)))\n               (Lxy qs {x, y})\n              \\<le> c *\n                    real (T\\<^sub>p_opt (Lxy s0 {x, y}) (Lxy qs {x, y})) +\n                    b\n  init \\<in> S0\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n                    \\<forall>(x, y)\n                             \\<in>{(x, y).\n                                   x \\<in> set init \\<and>\n                                   y \\<in> set init \\<and> x < y}.\n                       T\\<^sub>p_on_rand' A\n                        (fst A (Lxy init {x, y}) \\<bind>\n                         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n                        (Lxy qs {x, y})\n                       \\<le> c *\n                             real\n                              (T\\<^sub>p_opt (Lxy init {x, y})\n                                (Lxy qs {x, y})) +\n                             b;\n         0 \\<le> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n     \\<forall>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_on_rand' A\n         (fst A (Lxy init {x, y}) \\<bind>\n          (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n         (Lxy qs {x, y})\n        \\<le> c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "{"], ["proof (state)\nthis:\n  \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n     \\<forall>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_on_rand' A\n         (fst A (Lxy init {x, y}) \\<bind>\n          (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n         (Lxy qs {x, y})\n        \\<le> c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "fix qs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "assume drin: \"set qs \\<subseteq> set init\""], ["proof (state)\nthis:\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have \"T\\<^sub>p_on_rand A init qs =\n(\\<Sum>(x,y)\\<in>{(x, y) . x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand A (Lxy init {x,y}) (Lxy qs {x, y})) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))", "apply(rule umf_pair)"], ["proof (prove)\ngoal (5 subgoals):\n 1. List_Factoring.pairwise A\n 2. \\<And>is s q.\n       \\<forall>((free, paid), uu_)\\<in>set_pmf (snd A (s, is) q). paid = []\n 3. set qs \\<subseteq> set init\n 4. distinct init\n 5. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       finite\n        (set_pmf\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take x qs)))", "apply(fact)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       finite\n        (set_pmf\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take x qs)))", "using 4[of init qs] drin d"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n   ?x < length qs\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (set_pmf\n                       (Partial_Cost_Model.config'_rand A\n                         (fst A init \\<bind>\n                          (\\<lambda>is. return_pmf (init, is)))\n                         (take ?x qs)))\n  set qs \\<subseteq> set init\n  distinct init\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length qs \\<Longrightarrow>\n       finite\n        (set_pmf\n          (Partial_Cost_Model.config'_rand A\n            (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is)))\n            (take x qs)))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "(* 1.4 *)"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "also"], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs =\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have \"\\<dots> \\<le> (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. c * (T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})) + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_on_rand' A\n        (fst A (Lxy init {x, y}) \\<bind>\n         (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n        (Lxy qs {x, y}))\n    \\<le> (\\<Sum>(x, y)\n                 \\<in>{(x, y).\n                       x \\<in> set init \\<and>\n                       y \\<in> set init \\<and> x < y}.\n             c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b)", "apply(rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case i of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}))\n       \\<le> (case i of\n              (x, y) \\<Rightarrow>\n                c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                b)", "using on3 drin"], ["proof (prove)\nusing this:\n  \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n     \\<forall>(x, y)\n              \\<in>{(x, y).\n                    x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_on_rand' A\n         (fst A (Lxy init {x, y}) \\<bind>\n          (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n         (Lxy qs {x, y})\n        \\<le> c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b\n  set qs \\<subseteq> set init\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {(x, y).\n                x \\<in> set init \\<and>\n                y \\<in> set init \\<and> x < y} \\<Longrightarrow>\n       (case i of\n        (x, y) \\<Rightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A (Lxy init {x, y}) \\<bind>\n            (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n           (Lxy qs {x, y}))\n       \\<le> (case i of\n              (x, y) \\<Rightarrow>\n                c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n                b)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b)\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_on_rand' A\n      (fst A (Lxy init {x, y}) \\<bind>\n       (\\<lambda>is. return_pmf (Lxy init {x, y}, is)))\n      (Lxy qs {x, y}))\n  \\<le> (\\<Sum>(x, y)\n               \\<in>{(x, y).\n                     x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n           c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b)\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have \"\\<dots> = c * (\\<Sum>(x,y)\\<in>{(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y}. T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x,y})) + b*(((length init)*(length init-1)) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "fix S::\"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "assume dis: \"distinct S\""], ["proof (state)\nthis:\n  distinct S\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "assume d2: \"S \\<noteq> []\""], ["proof (state)\nthis:\n  S \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "then"], ["proof (chain)\npicking this:\n  S \\<noteq> []", "have d3: \"sort S \\<noteq> []\""], ["proof (prove)\nusing this:\n  S \\<noteq> []\n\ngoal (1 subgoal):\n 1. sort S \\<noteq> []", "by (metis length_0_conv length_sort)"], ["proof (state)\nthis:\n  sort S \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "have \"card {(x,y). x \\<in> set S \\<and> y\\<in>set S \\<and> x<y}\n            = card {(x,y). x \\<in> set (sort S) \\<and> y\\<in>set (sort S) \\<and> x<y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y} =\n    card\n     {(x, y). x \\<in> set (sort S) \\<and> y \\<in> set (sort S) \\<and> x < y}", "by auto"], ["proof (state)\nthis:\n  card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y} =\n  card\n   {(x, y). x \\<in> set (sort S) \\<and> y \\<in> set (sort S) \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "also"], ["proof (state)\nthis:\n  card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y} =\n  card\n   {(x, y). x \\<in> set (sort S) \\<and> y \\<in> set (sort S) \\<and> x < y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "have \"\\<dots> = (length (sort S) * (length (sort S) - 1)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (card\n       {(x, y).\n        x \\<in> set (sort S) \\<and> y \\<in> set (sort S) \\<and> x < y}) =\n    real (length (sort S) * (length (sort S) - 1)) / 2", "apply(rule cardofpairs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. sort S \\<noteq> []\n 2. sorted (sort S)\n 3. distinct (sort S)", "using dis d2 d3"], ["proof (prove)\nusing this:\n  distinct S\n  S \\<noteq> []\n  sort S \\<noteq> []\n\ngoal (3 subgoals):\n 1. sort S \\<noteq> []\n 2. sorted (sort S)\n 3. distinct (sort S)", "by (simp_all)"], ["proof (state)\nthis:\n  real\n   (card\n     {(x, y).\n      x \\<in> set (sort S) \\<and> y \\<in> set (sort S) \\<and> x < y}) =\n  real (length (sort S) * (length (sort S) - 1)) / 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "finally"], ["proof (chain)\npicking this:\n  real (card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y}) =\n  real (length (sort S) * (length (sort S) - 1)) / 2", "have \"card {(x, y) . x \\<in> set S \\<and> y \\<in> set S \\<and> x < y} =\n              (length (sort S) * (length (sort S) - 1)) / 2 \""], ["proof (prove)\nusing this:\n  real (card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y}) =\n  real (length (sort S) * (length (sort S) - 1)) / 2\n\ngoal (1 subgoal):\n 1. real (card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y}) =\n    real (length (sort S) * (length (sort S) - 1)) / 2", "."], ["proof (state)\nthis:\n  real (card {(x, y). x \\<in> set S \\<and> y \\<in> set S \\<and> x < y}) =\n  real (length (sort S) * (length (sort S) - 1)) / 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distinct ?S2; ?S2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {(x, y).\n                        x \\<in> set ?S2 \\<and>\n                        y \\<in> set ?S2 \\<and> x < y}) =\n                    real (length (sort ?S2) * (length (sort ?S2) - 1)) / 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "with d d2"], ["proof (chain)\npicking this:\n  distinct init\n  init \\<noteq> []\n  \\<lbrakk>distinct ?S2; ?S2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {(x, y).\n                        x \\<in> set ?S2 \\<and>\n                        y \\<in> set ?S2 \\<and> x < y}) =\n                    real (length (sort ?S2) * (length (sort ?S2) - 1)) / 2", "have e: \"card {(x,y). x \\<in> set init \\<and> y\\<in>set init \\<and> x<y} = ((length init)*(length init-1)) / 2\""], ["proof (prove)\nusing this:\n  distinct init\n  init \\<noteq> []\n  \\<lbrakk>distinct ?S2; ?S2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> real\n                     (card\n                       {(x, y).\n                        x \\<in> set ?S2 \\<and>\n                        y \\<in> set ?S2 \\<and> x < y}) =\n                    real (length (sort ?S2) * (length (sort ?S2) - 1)) / 2\n\ngoal (1 subgoal):\n 1. real\n     (card\n       {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}) =\n    real (length init * (length init - 1)) / 2", "by auto"], ["proof (state)\nthis:\n  real\n   (card {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}) =\n  real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "show ?thesis  (is \"(\\<Sum>(x,y)\\<in>?S. c * (?T x y) + b) = c * ?R + b*?T2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "have \"(\\<Sum>(x,y)\\<in>?S. c * (?T x y) + b) =\n              c * (\\<Sum>(x,y)\\<in>?S. (?T x y)) + (\\<Sum>(x,y)\\<in>?S. b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       b)", "by(simp add: split_def sum.distrib sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "have \"\\<dots> = c * (\\<Sum>(x,y)\\<in>?S. (?T x y)) + b*?T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       b) =\n    c *\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n    b * (real (length init * (length init - 1)) / 2)", "using e"], ["proof (prove)\nusing this:\n  real\n   (card {(x, y). x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}) =\n  real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. c *\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       b) =\n    c *\n    (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n    b * (real (length init * (length init - 1)) / 2)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     b) =\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  b * (real (length init * (length init - 1)) / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n    c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)", "by(simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "also"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     c * real (T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) + b) =\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "have \"\\<dots> \\<le> c * T\\<^sub>p_opt init qs + (b*((length init)*(length init-1)) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "have \"(\\<Sum>(x, y)\\<in>{(x, y) . x \\<in> set init \\<and>\n              y \\<in> set init \\<and> x < y}. T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x, y}))\n              \\<le>  T\\<^sub>p_opt init qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "using OPT_zerlegen drin d d2"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?init; ?init \\<noteq> [];\n   set ?qs \\<subseteq> set ?init\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>(x, y)\n                           \\<in>{(x, y).\n                                 x \\<in> set ?init \\<and>\n                                 y \\<in> set ?init \\<and> x < y}.\n                       T\\<^sub>p_opt (Lxy ?init {x, y}) (Lxy ?qs {x, y}))\n                    \\<le> T\\<^sub>p_opt ?init ?qs\n  set qs \\<subseteq> set init\n  distinct init\n  init \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\n           \\<in>{(x, y).\n                 x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n       T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> T\\<^sub>p_opt init qs", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs", "have \"  real (\\<Sum>(x, y)\\<in>{(x, y) . x \\<in> set init \\<and>\n              y \\<in> set init \\<and> x < y}. T\\<^sub>p_opt (Lxy init {x,y}) (Lxy qs {x, y}))\n              \\<le>    (T\\<^sub>p_opt init qs)\""], ["proof (prove)\nusing this:\n  (\\<Sum>(x, y)\n         \\<in>{(x, y).\n               x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n     T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> T\\<^sub>p_opt init qs\n\ngoal (1 subgoal):\n 1. real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n    \\<le> real (T\\<^sub>p_opt init qs)", "by linarith"], ["proof (state)\nthis:\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> real (T\\<^sub>p_opt init qs)\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "with c"], ["proof (chain)\npicking this:\n  1 \\<le> c\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> real (T\\<^sub>p_opt init qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> c\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y}))\n  \\<le> real (T\\<^sub>p_opt init qs)\n\ngoal (1 subgoal):\n 1. c *\n    real\n     (\\<Sum>(x, y)\n            \\<in>{(x, y).\n                  x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n        T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n    b * (real (length init * (length init - 1)) / 2)\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "by(auto simp: split_def)"], ["proof (state)\nthis:\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n  \\<le> c * real (T\\<^sub>p_opt init qs) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c *\n  real\n   (\\<Sum>(x, y)\n          \\<in>{(x, y).\n                x \\<in> set init \\<and> y \\<in> set init \\<and> x < y}.\n      T\\<^sub>p_opt (Lxy init {x, y}) (Lxy qs {x, y})) +\n  b * (real (length init * (length init - 1)) / 2)\n  \\<le> c * real (T\\<^sub>p_opt init qs) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "finally"], ["proof (chain)\npicking this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n  \\<le> c * real (T\\<^sub>p_opt init qs) +\n        b * real (length init * (length init - 1)) / 2", "have f: \"T\\<^sub>p_on_rand A init qs \\<le> c * real (T\\<^sub>p_opt init qs) + (b*((length init)*(length init-1)) / 2)\""], ["proof (prove)\nusing this:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n  \\<le> c * real (T\\<^sub>p_opt init qs) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. T\\<^sub>p_on_rand' A\n     (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n    \\<le> c * real (T\\<^sub>p_opt init qs) +\n          b * real (length init * (length init - 1)) / 2", "."], ["proof (state)\nthis:\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n  \\<le> c * real (T\\<^sub>p_opt init qs) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "}"], ["proof (state)\nthis:\n  set ?qs2 \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs2\n  \\<le> c * real (T\\<^sub>p_opt init ?qs2) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "note all=this"], ["proof (state)\nthis:\n  set ?qs2 \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs2\n  \\<le> c * real (T\\<^sub>p_opt init ?qs2) +\n        b * real (length init * (length init - 1)) / 2\n\ngoal (1 subgoal):\n 1. \\<And>s0.\n       s0 \\<in> S0 \\<Longrightarrow>\n       \\<exists>b\\<ge>0.\n          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n             T\\<^sub>p_on_rand' A\n              (fst A s0 \\<bind> (\\<lambda>is. return_pmf (s0, is))) qs\n             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n          T\\<^sub>p_on_rand' A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n          \\<le> c * real (T\\<^sub>p_opt init qs) + b", "unfolding compet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n          T\\<^sub>p_on_rand' A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n          \\<le> c * real (T\\<^sub>p_opt init qs) + b", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<ge>0.\n       \\<forall>qs.\n          set qs \\<subseteq> set init \\<longrightarrow>\n          T\\<^sub>p_on_rand' A\n           (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n          \\<le> c * real (T\\<^sub>p_opt init qs) + b", "apply(rule exI[where x=\"(b*((length init)*(length init-1)) / 2)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b * real (length init * (length init - 1)) / 2 \\<and>\n    (\\<forall>qs.\n        set qs \\<subseteq> set init \\<longrightarrow>\n        T\\<^sub>p_on_rand' A\n         (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n        \\<le> c * real (T\\<^sub>p_opt init qs) +\n              b * real (length init * (length init - 1)) / 2)", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> b * real (length init * (length init - 1)) / 2\n 2. \\<And>qs.\n       set qs \\<subseteq> set init \\<Longrightarrow>\n       T\\<^sub>p_on_rand' A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n       \\<le> c * real (T\\<^sub>p_opt init qs) +\n             b * real (length init * (length init - 1)) / 2", "using notempty 1 b"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>S0. 0 < length e\n  init \\<in> S0\n  0 \\<le> b\n\ngoal (2 subgoals):\n 1. 0 \\<le> b * real (length init * (length init - 1)) / 2\n 2. \\<And>qs.\n       set qs \\<subseteq> set init \\<Longrightarrow>\n       T\\<^sub>p_on_rand' A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n       \\<le> c * real (T\\<^sub>p_opt init qs) +\n             b * real (length init * (length init - 1)) / 2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       set qs \\<subseteq> set init \\<Longrightarrow>\n       T\\<^sub>p_on_rand' A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n       \\<le> c * real (T\\<^sub>p_opt init qs) +\n             b * real (length init * (length init - 1)) / 2", "using all b"], ["proof (prove)\nusing this:\n  set ?qs2 \\<subseteq> set init \\<Longrightarrow>\n  T\\<^sub>p_on_rand' A\n   (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) ?qs2\n  \\<le> c * real (T\\<^sub>p_opt init ?qs2) +\n        b * real (length init * (length init - 1)) / 2\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       set qs \\<subseteq> set init \\<Longrightarrow>\n       T\\<^sub>p_on_rand' A\n        (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n       \\<le> c * real (T\\<^sub>p_opt init qs) +\n             b * real (length init * (length init - 1)) / 2", "by simp"], ["proof (state)\nthis:\n  \\<exists>b\\<ge>0.\n     \\<forall>qs\\<in>{x. set x \\<subseteq> set init}.\n        T\\<^sub>p_on_rand' A\n         (fst A init \\<bind> (\\<lambda>is. return_pmf (init, is))) qs\n        \\<le> c * real (T\\<^sub>p_opt init qs) + b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factoringlemma_withconstant':\n    fixes A\n          and b::real\n          and c::real\n      assumes c: \"c \\<ge> 1\"\n      assumes dist: \"\\<forall>e\\<in>S0. distinct e\"\n      assumes notempty: \"\\<forall>e\\<in>S0. length e > 0\"\n      (* A has pairwise property *)\n      assumes pw: \"pairwise A\"\n      (* A is c-competitive on list of length 2 *) \n      assumes on2: \"\\<forall>s0\\<in>S0. \\<exists>b\\<ge>0. \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}. \\<forall>(x,y)\\<in>{(x,y). x \\<in> set s0 \\<and> y\\<in>set s0 \\<and> x<y}. T\\<^sub>p_on_rand A (Lxy s0 {x,y}) (Lxy qs {x,y})  \\<le> c * (T\\<^sub>p_opt (Lxy s0 {x,y}) (Lxy qs {x,y})) + b\" \n      assumes nopaid: \"\\<And>is s q. \\<forall>((free,paid),_) \\<in> (snd A (s, is) q). paid=[]\"\n      assumes 4: \"\\<And>init qs. distinct init \\<Longrightarrow> set qs \\<subseteq> set init \\<Longrightarrow> (\\<And>x. x<length qs \\<Longrightarrow> finite (set_pmf (config'' A qs init x)))\" \n      (* then A is c-competitive on arbitrary list lengths *)\n      shows \"compet_rand A c S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Cost_Model.compet_rand A c S0", "unfolding compet_rand_def static_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S0.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' A\n              (fst A s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> c * real (T\\<^sub>p_opt s rs) + b", "using factoringlemma_withconstant[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init qs x.\n              \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n               x < length qs\\<rbrakk>\n              \\<Longrightarrow> distinct init;\n   \\<And>init qs x.\n      \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n       x < length qs\\<rbrakk>\n      \\<Longrightarrow> set qs \\<subseteq> set init;\n   \\<And>init qs x.\n      \\<lbrakk>distinct init; set qs \\<subseteq> set init;\n       x < length qs\\<rbrakk>\n      \\<Longrightarrow> x < length qs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>s0\\<in>S0.\n                       \\<exists>b\\<ge>0.\n                          \\<forall>qs\\<in>{x. set x \\<subseteq> set s0}.\n                             T\\<^sub>p_on_rand' A\n                              (fst A s0 \\<bind>\n                               (\\<lambda>is. return_pmf (s0, is)))\n                              qs\n                             \\<le> c * real (T\\<^sub>p_opt s0 qs) + b\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S0.\n       \\<exists>b\\<ge>0.\n          \\<forall>rs.\n             set rs \\<subseteq> set s \\<longrightarrow>\n             T\\<^sub>p_on_rand' A\n              (fst A s \\<bind> (\\<lambda>is. return_pmf (s, is))) rs\n             \\<le> c * real (T\\<^sub>p_opt s rs) + b", "by simp"], ["", "end"]]}