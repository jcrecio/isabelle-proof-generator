{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Tool/Autoref_Fix_Rel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma PRIO_TAGI: \"PRIO_TAG ma mi\"", "lemma CONSTRAINTI: \"CONSTRAINT f R\"", "lemma PREFER_tagI: \"P \\<Longrightarrow> PREFER_tag P\"", "lemma DEFER_tagI: \"P \\<Longrightarrow> DEFER_tag P\"", "lemmas SIDEI = PREFER_tagI DEFER_tagI", "lemma GEN_OP_tagI: \"P ==> GEN_OP_tag P\"", "lemma TYREL_RES: \"\\<lbrakk> TYREL_DOMAIN TYPE('a); TYREL (R::(_\\<times>'a) set) \\<rbrakk> \\<Longrightarrow> TYREL R\"", "lemma DOMAIN_OF_TYREL: \"TYREL (R::(_\\<times>'a) set) \n  \\<Longrightarrow> TYREL_DOMAIN TYPE('a)\"", "lemma TYRELI: \"TYREL (R::(_\\<times>'a) set)\"", "lemma ty_REL: \"TYREL (R::(_\\<times>'a) set)\""], "translations": [["", "lemma PRIO_TAGI: \"PRIO_TAG ma mi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRIO_TAG ma mi", "by simp"], ["", "abbreviation \"MAJOR_PRIO_TAG i \\<equiv> PRIO_TAG i 0\""], ["", "abbreviation \"MINOR_PRIO_TAG i \\<equiv> PRIO_TAG 0 i\""], ["", "abbreviation \"DFLT_PRIO_TAG \\<equiv> PRIO_TAG 0 0\""], ["", "text \\<open>Some standard tags\\<close>"], ["", "abbreviation \"PRIO_TAG_OPTIMIZATION \\<equiv> MINOR_PRIO_TAG 10\"\n  \\<comment> \\<open>Optimized version of an algorithm, with additional side-conditions\\<close>"], ["", "abbreviation \"PRIO_TAG_GEN_ALGO \\<equiv> MINOR_PRIO_TAG (- 10)\"\n  \\<comment> \\<open>Generic algorithm, considered to be less efficient than default algorithm\\<close>"], ["", "subsection \\<open>Solving Relator Constraints\\<close>"], ["", "text \\<open>\n  In this phase, we try to instantiate the annotated relators, using\n  the available refinement rules.\n\\<close>"], ["", "definition CONSTRAINT :: \"'a \\<Rightarrow> ('c\\<times>'a) set \\<Rightarrow> bool\" \n  where [simp]: \"CONSTRAINT f R \\<equiv> True\""], ["", "lemma CONSTRAINTI: \"CONSTRAINT f R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT f R", "by auto"], ["", "ML \\<open>\n  structure Autoref_Rules = Named_Thms ( \n    val name = @{binding autoref_rules_raw}\n    val description = \"Refinement Framework: \" ^\n        \"Automatic refinement rules\" \n  );\n\\<close>"], ["", "setup Autoref_Rules.setup"], ["", "text \\<open>Generic algorithm tags have to be defined here, as we need them for\n  relator fixing !\\<close>"], ["", "definition PREFER_tag :: \"bool \\<Rightarrow> bool\" \n  where [simp, autoref_tag_defs]: \"PREFER_tag x \\<equiv> x\""], ["", "definition DEFER_tag :: \"bool \\<Rightarrow> bool\" \n  where [simp, autoref_tag_defs]: \"DEFER_tag x \\<equiv> x\""], ["", "lemma PREFER_tagI: \"P \\<Longrightarrow> PREFER_tag P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> PREFER_tag P", "by simp"], ["", "lemma DEFER_tagI: \"P \\<Longrightarrow> DEFER_tag P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> DEFER_tag P", "by simp"], ["", "lemmas SIDEI = PREFER_tagI DEFER_tagI"], ["", "definition [simp, autoref_tag_defs]: \"GEN_OP_tag P == P\""], ["", "lemma GEN_OP_tagI: \"P ==> GEN_OP_tag P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> GEN_OP_tag P", "by simp"], ["", "abbreviation \"SIDE_GEN_OP P == PREFER_tag (GEN_OP_tag P)\""], ["", "text \\<open>Shortcut for assuming an operation in a generic algorithm lemma\\<close>"], ["", "abbreviation \"GEN_OP c a R \\<equiv> SIDE_GEN_OP ((c,OP a ::: R) \\<in> R)\""], ["", "definition TYREL :: \"('a\\<times>'b) set \\<Rightarrow> bool\" \n  where [simp]: \"TYREL R \\<equiv> True\""], ["", "definition TYREL_DOMAIN :: \"'a itself \\<Rightarrow> bool\" \n  where [simp]: \"TYREL_DOMAIN i \\<equiv> True\""], ["", "lemma TYREL_RES: \"\\<lbrakk> TYREL_DOMAIN TYPE('a); TYREL (R::(_\\<times>'a) set) \\<rbrakk> \\<Longrightarrow> TYREL R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TYREL_DOMAIN TYPE('a); TYREL R\\<rbrakk>\n    \\<Longrightarrow> TYREL R", "."], ["", "lemma DOMAIN_OF_TYREL: \"TYREL (R::(_\\<times>'a) set) \n  \\<Longrightarrow> TYREL_DOMAIN TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TYREL R \\<Longrightarrow> TYREL_DOMAIN TYPE('a)", "by simp"], ["", "lemma TYRELI: \"TYREL (R::(_\\<times>'a) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TYREL R", "by simp"], ["", "lemma ty_REL: \"TYREL (R::(_\\<times>'a) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TYREL R", "by simp"], ["", "ML \\<open>\n  \n  signature AUTOREF_FIX_REL = sig\n    \n    type constraint = (term * term) list * (term * term)\n    type thm_pairs = (constraint option * thm) list \n    type hom_net = (int * thm) Net.net\n\n    val thm_pairsD_init: Proof.context -> Proof.context\n    val thm_pairsD_get: Proof.context -> thm_pairs\n\n    val constraints_of_term: term -> (term * term) list\n    val constraints_of_goal: int -> thm -> (term * term) list\n\n    val mk_CONSTRAINT: term * term -> term \n    val mk_CONSTRAINT_rl: Proof.context -> constraint -> thm\n\n    val insert_CONSTRAINTS_tac: Proof.context -> tactic'\n\n    val constraint_of_thm: Proof.context -> thm -> constraint\n\n    datatype prio_relpos = \n      PR_FIRST \n    | PR_LAST \n    | PR_BEFORE of string \n    | PR_AFTER of string\n\n    val declare_prio: string -> term -> prio_relpos -> local_theory -> local_theory\n    val delete_prio: string -> local_theory -> local_theory\n\n    val print_prios: Proof.context -> unit\n\n    val compute_hom_net: thm_pairs -> Proof.context -> hom_net\n\n    val add_hom_rule: thm -> Context.generic -> Context.generic\n    val del_hom_rule: thm -> Context.generic -> Context.generic\n    val get_hom_rules: Proof.context -> thm list\n\n    val add_tyrel_rule: thm -> Context.generic -> Context.generic\n    val del_tyrel_rule: thm -> Context.generic -> Context.generic\n    val get_tyrel_rules: Proof.context -> thm list\n\n\n    val insert_tyrel_tac : Proof.context -> int -> int -> tactic'\n    val solve_tyrel_tac : Proof.context -> tactic'\n    val tyrel_tac : Proof.context -> itactic\n\n\n    val internal_hom_tac: Proof.context -> itactic\n    val internal_spec_tac: Proof.context -> itactic\n    val internal_solve_tac: Proof.context -> itactic\n\n    val guess_relators_tac: Proof.context -> itactic\n  \n    val pretty_constraint: Proof.context -> constraint -> Pretty.T\n    val pretty_constraints: Proof.context -> constraint list -> Pretty.T\n\n    val pretty_thm_pair: Proof.context -> (constraint option * thm) -> Pretty.T\n    val pretty_thm_pairs: Proof.context -> thm_pairs -> Pretty.T\n\n    val analyze: Proof.context -> int -> int -> thm -> bool\n    val pretty_failure: Proof.context -> int -> int -> thm -> Pretty.T\n\n    val try_solve_tac: Proof.context -> tactic'\n    val solve_step_tac: Proof.context -> tactic'\n    val phase: Autoref_Phases.phase\n\n    val setup: theory -> theory\n  end\n\n  structure Autoref_Fix_Rel :AUTOREF_FIX_REL = struct\n\n    type constraint = (term * term) list * (term * term)\n    type thm_pairs = (constraint option * thm) list \n    type hom_net = (int * thm) Net.net\n\n\n    (*********************)\n    (*    Constraints    *)\n    (*********************)\n    local\n      fun fix_loose_bvars env t = \n        if Term.is_open t then \n          let\n            val frees = tag_list 0 env \n              |> map (fn (i,(n,T)) => Free (\":\"^string_of_int i ^ \"_\" ^ n,T)) \n          in\n            subst_bounds (frees, t)\n          end\n        else t\n\n      fun constraints env @{mpat \"OP ?f ::: ?R\"} = \n          ( Term.is_open R andalso raise TERM (\"Loose bvar in relator\",[R]);\n            [(fix_loose_bvars env f,R)]\n          )\n        | constraints _ (Free _) = []\n        | constraints _ (Bound _) = []\n        | constraints env @{mpat \"?f ::: _\"} = constraints env f\n        | constraints env @{mpat \"?f$?x\"} \n          = constraints env x @ constraints env f\n        | constraints env @{mpat \"PROTECT (\\<lambda>x. PROTECT ?t)\"} \n          = constraints ((x,x_T)::env) t\n        | constraints _ @{mpat \"PROTECT PROTECT\"} = []\n        | constraints _ t = raise TERM (\"constraints_of_term\",[t])\n    in \n      val constraints_of_term = constraints [] \n    end\n\n    fun constraints_of_goal i st =\n      case Logic.concl_of_goal (Thm.prop_of st) i of\n        @{mpat \"Trueprop ((_,?a)\\<in>_)\"} => constraints_of_term a\n      | _ => raise THM (\"constraints_of_goal\",i,[st])\n\n\n    fun mk_CONSTRAINT (f,R) = let\n      val fT = fastype_of f\n      val RT = fastype_of R\n      val res = Const (@{const_name CONSTRAINT},fT --> RT --> HOLogic.boolT)\n        $f$R\n    in \n      res\n    end;\n\n    (* Types of f and R must match! *)\n    fun mk_CONSTRAINT_rl ctxt (ps,c) = let\n      val ps = map (mk_CONSTRAINT #> HOLogic.mk_Trueprop) ps\n      val c = mk_CONSTRAINT c |> HOLogic.mk_Trueprop\n      val g = Logic.list_implies (ps,c)\n    in\n      Goal.prove ctxt [] [] g\n        (K (resolve_tac ctxt @{thms CONSTRAINTI} 1))\n    end;\n\n    (* Internal use for hom-patterns, f and R are unified *)\n    fun mk_CONSTRAINT_rl_atom ctxt (f,R) = let\n      val ts = map (SOME o Thm.cterm_of ctxt) [f,R]\n      val idx = Term.maxidx_term f (Term.maxidx_of_term R) + 1\n    in \n      infer_instantiate' ctxt ts (Thm.incr_indexes idx @{thm CONSTRAINTI})\n    end;\n\n    fun insert_CONSTRAINTS_tac ctxt i st = let\n      val cs = constraints_of_goal i st \n      |> map (mk_CONSTRAINT #> HOLogic.mk_Trueprop #> Thm.cterm_of ctxt)\n    in\n      Refine_Util.insert_subgoals_tac cs i st\n    end\n\n    fun constraint_of_thm ctxt thm = let \n      exception NO_REL of term\n      open Autoref_Tagging\n\n      fun extract_entry t = \n        case Logic.strip_imp_concl (strip_all_body t) of\n          @{mpat \"Trueprop ((_,?f)\\<in>_)\"} => SOME (fst (strip_app f),t)\n        | _ => NONE\n\n      fun relator_of t = let\n        (*val _ = tracing (Syntax.string_of_term @{context} t)*)\n\n        val t = strip_all_body t\n        val prems = Logic.strip_imp_prems t\n        val concl = Logic.strip_imp_concl t\n      in\n        case concl of \n          @{mpat \"Trueprop ((_,?t)\\<in>?R)\"} => let\n            val (f,args) = strip_app t\n          in\n            case f of \n              @{mpat \"OP ?f:::?rel\"} => (f,rel)\n            | _ => let\n                val rels = map_filter extract_entry prems\n                fun find_rel t = case filter (fn (t',_) => t=t') rels of\n                  [(_,t)] => snd (relator_of t)\n                | _ => raise NO_REL t\n\n                val argrels = map find_rel args\n                val rel = fold Relators.mk_fun_rel (rev argrels) R\n              in\n                (f,rel)\n              end\n          end\n        | _ => raise THM (\"constraint_of_thm: Invalid concl\",~1,[thm])\n      end\n\n      val (f,rel) = relator_of (Thm.prop_of thm) \n        handle exc as (NO_REL t) => (\n          warning (\n            \"Could not infer unique higher-order relator for \"\n            ^ \"refinement rule: \\n\"\n            ^ Thm.string_of_thm ctxt thm\n            ^ \"\\n for argument: \" \n            ^ Syntax.string_of_term ctxt t\n          ); \n          Exn.reraise exc)\n\n      (* Extract GEN_OP-tags *)\n      fun \n        genop_cs @{mpat \"Trueprop (SIDE_GEN_OP ((_,OP ?f ::: _) \\<in> ?R))\"} = \n          if has_Var f then NONE else SOME (f,R)\n      | genop_cs _ = NONE\n\n      val gen_ops = Thm.prems_of thm\n        |> map_filter genop_cs\n\n    in\n      (gen_ops,(f,rel))\n    end\n\n    (*********************)\n    (*    Priorities     *)\n    (*********************)\n    structure Rel_Prio_List = Prio_List (\n      type item = string * term\n      val eq = (op =) o apply2 fst \n    )\n\n    structure Rel_Prio = Generic_Data (\n      type T = Rel_Prio_List.T\n      val empty = Rel_Prio_List.empty\n      val merge = Rel_Prio_List.merge\n      val extend = I\n    )\n\n    fun pretty_rel_prio ctxt (s,t) = Pretty.block [\n      Pretty.str s, Pretty.str \":\", Pretty.brk 1,\n      Syntax.pretty_term ctxt t\n    ]\n\n    fun print_prios ctxt = let\n      val rpl = Rel_Prio.get (Context.Proof ctxt)\n    in\n      (map (pretty_rel_prio ctxt) rpl)\n      |> Pretty.big_list \"Relator Priorities\"\n      |> Pretty.string_of\n      |> warning\n    end\n\n\n    datatype prio_relpos = \n      PR_FIRST \n    | PR_LAST \n    | PR_BEFORE of string \n    | PR_AFTER of string\n\n    fun declare_prio name pat0 relpos lthy = \n      let\n        val pat1 = Proof_Context.cert_term lthy pat0\n        val pat2 = singleton (Variable.export_terms (Proof_Context.augment pat1 lthy) lthy) pat1\n      in\n        lthy |> Local_Theory.declaration {syntax = false, pervasive = false}\n          (fn phi =>\n            let val item = (name, Morphism.term phi pat2) in\n              Rel_Prio.map (fn rpl =>\n                case relpos of\n                  PR_FIRST => Rel_Prio_List.add_first rpl item\n                | PR_LAST => Rel_Prio_List.add_last rpl item\n                | PR_BEFORE n => Rel_Prio_List.add_before rpl item (n,Term.dummy)\n                | PR_AFTER n => Rel_Prio_List.add_after rpl item (n,Term.dummy)\n              )\n            end)\n      end\n\n    fun delete_prio name = Local_Theory.declaration {syntax = false, pervasive = false}\n      (fn phi => Rel_Prio.map (Rel_Prio_List.delete (name, Term.dummy)))\n\n    local\n      fun relators_of R = let\n        fun f @{mpat \"?R1.0\\<rightarrow>?R2.0\"} = f R1 @ f R2\n          | f R = [R]\n      in\n        f R |> map Refine_Util.anorm_term |> distinct (op =)\n      end\n\n      fun dest_prio_tag @{mpat \"Trueprop (PRIO_TAG ?ma ?mi)\"} = \n            apply2 (#2 o HOLogic.dest_number) (ma,mi)\n        | dest_prio_tag t = raise TERM (\"dest_prio_tag\",[t])\n\n      fun get_tagged_prios thm = let\n        val prems = Thm.prems_of thm\n        fun r [] = (0,0)\n          | r (prem::prems) = (\n              case try dest_prio_tag prem of\n                NONE => r prems\n              | SOME p => p\n            ) \n\n      in\n        r prems\n      end\n\n      fun prio_order_of ctxt (SOME (_,(_,R)),thm) = \n        let\n          val rels = relators_of R\n          val hom = length rels\n          val (major_prio,minor_prio) = get_tagged_prios thm\n\n          val rpl = Rel_Prio.get (Context.Proof ctxt)\n          val matches = Pattern.matches (Proof_Context.theory_of ctxt)\n          fun prefer ((_,p1),(_,p2)) = matches (p2,p1)\n          fun prio_of R \n            = Rel_Prio_List.prio_of (fn (_,pat) => matches (pat,R)) prefer rpl \n              + 1\n          val prio = fold (fn R => fn s => prio_of R + s) rels 0\n        in\n          (major_prio, (hom,(prio,minor_prio)))\n        end\n      | prio_order_of _ _ = raise Match\n\n      val prio_order = \n        prod_ord\n          (rev_order o int_ord)\n          (prod_ord \n            int_ord\n            (prod_ord (rev_order o int_ord) (rev_order o int_ord)))\n\n      fun annotate_thm_pair ctxt (SOME (ps,(f,R)),thm) = \n        let\n          open Autoref_Tagging  Conv\n\n          fun warn () = warning (\"Error annotating refinement theorem: \"\n            ^ Thm.string_of_thm ctxt thm\n          )\n\n          val R_cert = Thm.cterm_of ctxt R\n\n          fun cnv ctxt ct = (case Thm.term_of ct of\n            @{mpat \"OP _ ::: _\"} => all_conv\n          | @{mpat \"OP _\"} => mk_rel_ANNOT_conv ctxt R_cert\n          | @{mpat \"_ $ _\"} => arg1_conv (cnv ctxt)\n          | _ => mk_OP_conv then_conv mk_rel_ANNOT_conv ctxt R_cert\n\n          ) ct\n\n          (*val _ = tracing (\"ANNOT: \" ^ @{make_string} thm)*)\n          val thm = (fconv_rule (rhs_conv cnv ctxt)) thm\n          val thm = case try (fconv_rule (rhs_conv cnv ctxt)) thm of\n            NONE => (warn (); thm)\n          | SOME thm => thm\n          (*val _ = tracing (\"RES: \" ^ @{make_string} thm)*)\n\n        in\n          (SOME (ps,(f,R)),thm)\n        end\n      | annotate_thm_pair _ p = p\n\n    in\n      fun compute_thm_pairs ctxt = let\n        val rules = Autoref_Rules.get ctxt\n        fun add_o p = (prio_order_of ctxt p,p)\n\n        val pairs = rules\n          |> map (fn thm => (try (constraint_of_thm ctxt) thm,thm))\n        val spairs = filter (is_some o #1) pairs\n          |> map add_o \n          |> sort (prio_order o apply2 #1)\n          |> map #2\n        val npairs = filter (is_none o #1) pairs\n      in\n        spairs@npairs |> map (annotate_thm_pair ctxt)\n      end\n    end\n\n    structure thm_pairsD = Autoref_Data (\n      type T = thm_pairs\n      val compute = compute_thm_pairs\n      val prereq = []\n    )\n\n    val thm_pairsD_init = thm_pairsD.init\n    val thm_pairsD_get = thm_pairsD.get\n\n    structure hom_rules = Named_Sorted_Thms (\n      val name = @{binding autoref_hom}\n      val description = \"Autoref: Homogenity rules\"\n      val sort = K I\n      val transform = K (\n        fn thm => case Thm.concl_of thm of \n          @{mpat \"Trueprop (CONSTRAINT _ _)\"} => [thm]\n        | _ => raise THM (\"Invalid homogenity rule\",~1,[thm])\n      )\n    )\n  \n    val add_hom_rule = hom_rules.add_thm\n    val del_hom_rule = hom_rules.del_thm\n    val get_hom_rules = hom_rules.get\n\n    local\n      open Relators\n      fun \n        repl @{mpat \"?R\\<rightarrow>?S\"} ctab = let\n          val (R,ctab) = repl R ctab\n          val (S,ctab) = repl S ctab\n        in (mk_fun_rel R S,ctab) end\n      | repl R ctab = let\n          val (args,R) = strip_relAPP R\n          val (args,ctab) = fold_map repl args ctab \n          val (ctxt,tab) = ctab\n\n          val (R,(ctxt,tab)) = case Termtab.lookup tab R of\n            SOME R => (R,(ctxt,tab))\n          | NONE => let\n              val aT = fastype_of R |> strip_type |> #2 \n                |> HOLogic.dest_setT |> HOLogic.dest_prodT |> #2\n              val (cT,ctxt) = yield_singleton Variable.invent_types @{sort type} ctxt\n              val cT = TFree cT\n              val T = map fastype_of args ---> HOLogic.mk_setT (HOLogic.mk_prodT (cT,aT))\n              val (R',ctxt) = yield_singleton Variable.variant_fixes \"R\" ctxt\n              val R' = list_relAPP args (Free (R',T))\n              val tab = Termtab.update (R,R') tab\n            in (R',(ctxt,tab)) end\n        in \n          (R,(ctxt,tab))   \n        end\n\n      fun hom_pat_of_rel ctxt R = let\n        val (R,(ctxt',_)) = repl R (ctxt,Termtab.empty)\n        val R = singleton (Variable.export_terms ctxt' ctxt) R\n      in\n        Refine_Util.anorm_term R\n      end\n\n    in\n      fun compute_hom_net pairs ctxt = let\n        val cs = map_filter #1 pairs\n        val cs' = map (fn (_,(f,R)) => (f,hom_pat_of_rel ctxt R)) cs\n        val thms = get_hom_rules ctxt @ map (mk_CONSTRAINT_rl_atom ctxt) cs'\n        val thms = map (Thm.cprop_of #> Thm.trivial) thms\n        val net = Tactic.build_net thms\n      in\n        net\n      end\n    end\n\n    structure hom_netD = Autoref_Data (\n      type T = hom_net\n      fun compute ctxt = compute_hom_net (thm_pairsD.get ctxt) ctxt\n      val prereq = [ thm_pairsD.init ]\n    )\n\n    structure tyrel_rules = Named_Sorted_Thms (\n      val name = @{binding autoref_tyrel}\n      val description = \"Autoref: Type-based relator fixing rules\"\n      val sort = K I\n\n      val transform = K (\n        fn thm => case Thm.prop_of thm of \n          @{mpat \"Trueprop (TYREL _)\"} => [thm]\n        | _ => raise THM (\"Invalid tyrel-rule\",~1,[thm])\n      )\n    )\n\n    val add_tyrel_rule = tyrel_rules.add_thm\n    val del_tyrel_rule = tyrel_rules.del_thm\n    val get_tyrel_rules = tyrel_rules.get\n\n    local\n      (*fun rel_annots @{mpat \"_ ::: ?R\"} = [R]\n        | rel_annots @{mpat \"?f$?x\"} = rel_annots f @ rel_annots x\n        | rel_annots @{mpat \"PROTECT (\\<lambda>_. PROTECT ?t)\"} = rel_annots t\n        | rel_annots @{mpat \"PROTECT PROTECT\"} = []\n        | rel_annots (Free _) = []\n        | rel_annots (Bound _) = []\n        | rel_annots t = raise TERM (\"rel_annots\",[t])\n      *)\n\n      fun add_relators t acc = let\n        open Relators\n        val (args,_) = strip_relAPP t\n        val res = fold add_relators args acc\n        val res = insert (op =) t res\n      in\n        res\n      end\n  \n      fun add_relators_of_subgoal st i acc = \n        case Logic.concl_of_goal (Thm.prop_of st) i of\n          @{mpat \"Trueprop (CONSTRAINT _ ?R)\"} => add_relators R acc\n        | _ => acc\n  \n    in\n\n      fun insert_tyrel_tac ctxt i j k st = let\n        fun get_constraint t = let\n          val T = fastype_of t\n          val res = Const (@{const_name TYREL}, T --> HOLogic.boolT) $ t\n        in\n          res |> HOLogic.mk_Trueprop |> Thm.cterm_of ctxt\n        end\n        \n        val relators = fold (add_relators_of_subgoal st) (i upto j) []\n        val tyrels = map get_constraint relators\n      in\n        Refine_Util.insert_subgoals_tac tyrels k st\n      end\n    end\n\n    fun solve_tyrel_tac ctxt = let\n      fun mk_tac rl = resolve_tac ctxt @{thms TYREL_RES} \n        THEN' match_tac ctxt [rl RS @{thm DOMAIN_OF_TYREL}]\n        THEN' resolve_tac ctxt [rl]\n\n      val tac = FIRST' (map mk_tac (tyrel_rules.get ctxt))\n    in\n      DETERM o tac ORELSE' (TRY o resolve_tac ctxt @{thms TYRELI})\n    end\n    \n    fun tyrel_tac ctxt i j =\n      (insert_tyrel_tac ctxt i j\n      THEN_ALL_NEW_FWD solve_tyrel_tac ctxt) i\n\n\n\n    fun internal_hom_tac ctxt = let\n      val hom_net = hom_netD.get ctxt\n    in\n      Seq.INTERVAL (TRY o DETERM o resolve_from_net_tac ctxt hom_net)    \n    end\n\n    fun internal_spec_tac ctxt = let\n      val pairs = thm_pairsD.get ctxt\n      val net = pairs\n        |> map_filter (fst #> map_option (snd #> mk_CONSTRAINT_rl_atom ctxt))\n        |> Tactic.build_net\n    in \n      fn i => fn j => REPEAT (CHANGED \n        (Seq.INTERVAL (DETERM o Anti_Unification.specialize_net_tac ctxt net) i j)\n      )\n    end\n\n    fun apply_to_constraints tac = let\n      fun no_CONSTRAINT_tac i st = \n        case Logic.concl_of_goal (Thm.prop_of st) i of\n          @{mpat \"Trueprop (CONSTRAINT _ _)\"} => Seq.empty\n        | _ => Seq.single st  \n\n    in\n      Seq.INTERVAL (no_CONSTRAINT_tac ORELSE' tac)\n    end\n\n    fun internal_solve_tac ctxt = let\n      val pairs = thm_pairsD.get ctxt\n      val net = pairs\n        |> map_filter (fst #> map_option (mk_CONSTRAINT_rl ctxt))\n        |> Tactic.build_net\n\n      val s_tac = SOLVED' (REPEAT_ALL_NEW (resolve_from_net_tac ctxt net))\n    in \n      apply_to_constraints s_tac\n      ORELSE_INTERVAL \n      apply_to_constraints (TRY o DETERM o s_tac)\n    end\n\n    fun guess_relators_tac ctxt = let\n      val pairs = thm_pairsD.get ctxt\n      val net = pairs\n        |> map_filter (fst #> map_option (mk_CONSTRAINT_rl ctxt))\n        |> Tactic.build_net\n\n      val hom_net = hom_netD.get ctxt\n\n      fun hom_tac i j = Seq.INTERVAL \n        (TRY o DETERM o resolve_from_net_tac ctxt hom_net) i j\n\n      fun spec_tac i j = \n        REPEAT (CHANGED \n          (Seq.INTERVAL (DETERM o Anti_Unification.specialize_net_tac ctxt net) i j)\n        )\n\n      val solve_tac = let \n        val s_tac = SOLVED' (REPEAT_ALL_NEW (resolve_from_net_tac ctxt net))\n      in   \n        apply_to_constraints s_tac\n        ORELSE_INTERVAL \n        apply_to_constraints (TRY o DETERM o s_tac)\n      end\n    in\n      Seq.INTERVAL (insert_CONSTRAINTS_tac ctxt)\n      THEN_INTERVAL hom_tac\n      THEN_INTERVAL spec_tac\n      THEN_INTERVAL (tyrel_tac ctxt)\n      THEN_INTERVAL solve_tac\n    end\n\n\n    (*********************)\n    (*  Pretty Printing  *)\n    (*********************)\n\n    fun pretty_constraint_atom ctxt (f,R) = Pretty.block \n      [ Syntax.pretty_term ctxt f,\n        Pretty.str \" :: \",\n        Syntax.pretty_typ ctxt (fastype_of f),\n        Pretty.str \" ::: \",\n        Syntax.pretty_term ctxt R]\n\n    fun pretty_constraint ctxt (ps,(f,R)) = \n      case ps of \n        [] => pretty_constraint_atom ctxt (f,R)\n      | _ => Pretty.block [\n               map (pretty_constraint_atom ctxt) ps \n               |> Pretty.separate \"; \" \n               |> Pretty.enclose \"\\<lbrakk>\" \"\\<rbrakk>\",\n               Pretty.brk 1, Pretty.str \"\\<Longrightarrow>\", Pretty.brk 1,\n               pretty_constraint_atom ctxt (f,R)\n             ]\n\n\n    fun pretty_constraints ctxt l = Pretty.big_list \"Constraints\" \n      (map (pretty_constraint ctxt) l)\n\n    fun pretty_thm_pair ctxt (c,thm) = Pretty.block [\n      case c of \n        NONE => Pretty.str \"NONE\"\n      | SOME c => pretty_constraint ctxt c,\n      Pretty.brk 2, Pretty.str \"---\", Pretty.brk 2,\n      Thm.pretty_thm ctxt thm\n    ]\n\n    fun pretty_thm_pairs ctxt pairs = Pretty.big_list \"Thm-Pairs\"\n      (map (pretty_thm_pair ctxt) pairs)\n\n    local\n      fun unifies ctxt (t1, t2) = Term.could_unify (t1, t2) andalso\n        let\n          val idx1 = Term.maxidx_of_term t1\n          val t2 = Logic.incr_indexes ([], [], idx1 + 1) t2\n          val idx2 = Term.maxidx_of_term t2\n        in\n          can (Pattern.unify (Context.Proof ctxt) (t1,t2)) (Envir.empty idx2)\n        end\n\n      fun analyze_possible_problems ctxt (f,R) = let\n\n        fun strange_aux sf R = \n        ( \n          if sf then \n            let\n              val T = fastype_of R\n            in \n              case try (HOLogic.dest_prodT o HOLogic.dest_setT) T of\n                SOME _ => []\n              | NONE => [Pretty.block [\n                  Pretty.str \"Strange relator type, expected plain relation: \",\n                  Syntax.pretty_term (Config.put show_types true ctxt) R\n                ]]\n            end\n          else []\n        ) @ ( \n          case R of\n            @{mpat \"\\<langle>?R\\<rangle>?S\"} => strange_aux true R @ strange_aux false S\n          | Var (_,T) => (\n              case \n                try (HOLogic.dest_prodT o HOLogic.dest_setT) (#2 (strip_type T))\n              of\n                SOME (TFree _,_) => [Pretty.block [\n                  Pretty.str \"Fixed concrete type on schematic relator: \",\n                  Syntax.pretty_term (Config.put show_types true ctxt) R\n                ]]\n              | _ => []\n            )\n          | _ => []\n        )\n\n        val strange = case strange_aux true R of \n          [] => NONE\n        | l => SOME (Pretty.block l)\n\n        val folded_relator = let\n          fun \n            match (Type (name,args)) R = \n              let\n                val (Rargs,Rhd) = Relators.strip_relAPP R\n              in \n                if is_Var Rhd then []\n                else if length args <> length Rargs then\n                  [Pretty.block [ \n                    Pretty.str \"Type/relator arity mismatch:\",\n                    Pretty.brk 1,\n                    Pretty.block [\n                      Pretty.str name, Pretty.str \"/\", \n                      Pretty.str (string_of_int (length args))\n                    ],\n                    Pretty.brk 1,Pretty.str \"vs.\",Pretty.brk 1,\n                    Pretty.block [\n                      Syntax.pretty_term ctxt Rhd, Pretty.str \"/\", \n                      Pretty.str (string_of_int (length Rargs))\n                    ]\n                  ]]\n                else\n                  args ~~ Rargs |> map (uncurry match) |> flat\n\n              end\n          | match _ _ = []   \n\n        in \n          case match (fastype_of f) R of\n            [] => NONE \n          | l => SOME (Pretty.block (Pretty.fbreaks l @ [Pretty.fbrk,\n              Pretty.str (\"Explanation: This may be due to using polymorphic \"\n              ^ \"relators like Id on non-terminal types.\" \n              ^ \"A problem usually occurs when \"\n              ^ \"this relator has to be matched against a fully unfolded one.\"\n              ^ \"This warning is also issued on partially parametric relators \"\n              ^ \"like br. However, the refinement rules are usually set up to \"\n              ^ \"compensate for this, so this is probably not the cause for an \"\n              ^ \"unsolved constraint\")\n            ]))\n        end\n\n\n        val issues = [strange, folded_relator]\n          |> map_filter I\n      in\n        case issues of\n          [] => NONE\n        | l => SOME (Pretty.big_list \"Possible problems\" l)\n\n      end\n\n      fun pretty_try_candidates ctxt i st = if i > Thm.nprems_of st then\n        Pretty.str \"Goal number out of range\"\n      else\n        case Logic.concl_of_goal (Thm.prop_of st) i of\n          @{mpat \"Trueprop (CONSTRAINT ?f ?R)\"} =>\n            let\n              val pairs = thm_pairsD.get ctxt\n              val st = Drule.zero_var_indexes st\n\n              val pt_hd = Pretty.block [\n                Pretty.str \"Head: \", Pretty.fbrk,\n                pretty_constraint_atom ctxt (f,R)\n              ]\n\n              fun isc (SOME (ps,(fp,R)),_) = \n                    if unifies ctxt (f,fp) then SOME (ps,(fp,R)) else NONE\n                | isc _ = NONE\n\n              val candidates = pairs |> map_filter isc\n\n              fun try_c c = let\n                val pt1 = Pretty.block [\n                  Pretty.str \"Trying \",\n                  pretty_constraint ctxt c\n                ]\n\n                val rl = mk_CONSTRAINT_rl ctxt c \n                   |> Drule.zero_var_indexes\n                val res = (SOLVED' (resolve_tac ctxt [rl])) i st\n                  |> Seq.pull |> is_some\n\n                val pt2 = (if res then Pretty.str \"OK\" else Pretty.str \"ERR\")\n                  \n              in\n                Pretty.block [pt1,Pretty.fbrk,pt2]\n              end\n\n              val res = Pretty.block (\n                Pretty.fbreaks [pt_hd,\n                  Pretty.big_list \"Solving Attempts\" \n                    (map try_c candidates)]\n              )\n\n            in \n              res\n            end\n        | _ => Pretty.str \"Unexpected goal format\"\n\n\n      exception ERR of Pretty.T\n      fun analyze' ctxt i j st = let\n        val As = Logic.strip_horn (Thm.prop_of st) |> #1 \n          |> drop (i-1) |> take (j-i+1)\n          |> map (strip_all_body #> Logic.strip_imp_concl)\n        val Cs = map_filter (\n            fn @{mpat \"Trueprop (CONSTRAINT ?f ?R)\"} => SOME (f,R)\n             | @{mpat \"Trueprop ((_,_)\\<in>_)\"} => NONE\n             | t => raise ERR (Pretty.block [\n                 Pretty.str \"Internal: Unexpected goal format: \",\n                 Syntax.pretty_term ctxt t\n               ])\n          ) As\n\n        val Cs_problems = map (fn c => \n          case analyze_possible_problems ctxt c of\n            NONE => pretty_constraint_atom ctxt c\n          | SOME p => Pretty.block [pretty_constraint_atom ctxt c,Pretty.fbrk,p]\n        ) Cs\n \n        val Cs_pretty = Pretty.big_list \"Constraints\" Cs_problems\n      in\n        case Cs of [] => ()\n        | _ => raise ERR (Pretty.block [\n            Pretty.str \n              \"Could not infer all relators, some constraints remaining\",\n            Pretty.fbrk,\n            Cs_pretty,\n            Pretty.fbrk,\n            Pretty.block [\n              Pretty.str \"Trying to solve first constraint\",\n              Pretty.fbrk,\n              pretty_try_candidates ctxt i st\n            ]\n          ])\n      end\n\n    in\n      fun analyze ctxt i j st = can (analyze' ctxt i j) st\n\n      fun pretty_failure ctxt i j st = \n        (analyze' ctxt i j st; Pretty.str \"No failure\") handle ERR p => p\n\n      fun try_solve_tac ctxt i st =  \n        if i > Thm.nprems_of st then\n          (tracing \"Goal number out of range\"; Seq.empty)\n        else\n          case Logic.concl_of_goal (Thm.prop_of st) i of\n            @{mpat \"Trueprop (CONSTRAINT ?f ?R)\"} =>\n              let\n                val pairs = thm_pairsD.get ctxt\n                val st = Drule.zero_var_indexes st\n\n                val pt = Pretty.block [\n                  Pretty.str \"Head: \", Pretty.fbrk,\n                  pretty_constraint_atom ctxt (f,R)\n                ]\n                val _ = tracing (Pretty.string_of pt)\n\n                val _ = case analyze_possible_problems ctxt (f,R) of\n                  NONE => ()\n                | SOME p => tracing (Pretty.string_of p)\n            \n                fun isc (SOME (ps,(fp,R)),_) = \n                      if unifies ctxt (f,fp) then SOME (ps,(fp,R)) else NONE\n                  | isc _ = NONE\n\n                val net = pairs\n                  |> map_filter (fst #> map_option (mk_CONSTRAINT_rl ctxt))\n                  |> Tactic.build_net\n\n\n                val candidates = pairs |> map_filter isc\n\n                fun try_c c = let\n                  val _ = Pretty.block [\n                    Pretty.str \"Trying \",\n                    pretty_constraint ctxt c\n                  ] |> Pretty.string_of |> tracing\n\n                  val rl = mk_CONSTRAINT_rl ctxt c \n                     |> Drule.zero_var_indexes\n                  val res = (SOLVED' (resolve_tac ctxt [rl] \n                      THEN_ALL_NEW (REPEAT_ALL_NEW (resolve_from_net_tac ctxt net)))\n                    ) i st\n                    |> Seq.pull |> is_some\n\n                  val _ = (if res then Pretty.str \"OK\" else Pretty.str \"ERR\")\n                    |> Pretty.string_of |> tracing\n                in\n                  ()\n                end\n\n                val _ = map try_c candidates\n              in \n                Seq.single st\n              end\n\n          | _ => Seq.empty\n\n\n    end\n\n\n    fun solve_step_tac ctxt = let\n      val pairs = thm_pairsD.get ctxt\n      val net = pairs\n        |> map_filter (fst #> map_option (mk_CONSTRAINT_rl ctxt))\n        |> Tactic.build_net\n    in \n      resolve_from_net_tac ctxt net\n    end\n\n    val phase = {\n      init = thm_pairsD.init #> hom_netD.init,\n      tac = guess_relators_tac,\n      analyze = analyze,\n      pretty_failure = pretty_failure\n    }\n\n\n    val setup = hom_rules.setup #> tyrel_rules.setup\n  end\n\n\\<close>"], ["", "setup Autoref_Fix_Rel.setup"], ["", "end"]]}