{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Lib/Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma TERMI: \"TERM x\"", "lemma disjE1: \"\\<lbrakk> P \\<or> Q; P \\<Longrightarrow> R; \\<lbrakk>\\<not>P;Q\\<rbrakk> \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\"", "lemma disjE2: \"\\<lbrakk> P \\<or> Q; \\<lbrakk>P; \\<not>Q\\<rbrakk> \\<Longrightarrow> R; Q \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\"", "lemma imp_mp_iff[simp]: \n  \"a \\<and> (a \\<longrightarrow> b) \\<longleftrightarrow> a \\<and> b\" \n  \"(a \\<longrightarrow> b) \\<and> a \\<longleftrightarrow> a \\<and> b\"", "lemma atomize_Trueprop_eq[atomize]: \"(Trueprop x \\<equiv> Trueprop y) \\<equiv> Trueprop (x=y)\"", "lemma inter_compl_diff_conv[simp]: \"A \\<inter> -B = A - B\"", "lemma pair_set_inverse[simp]: \"{(a,b). P a b}\\<inverse> = {(b,a). P a b}\"", "lemma card_doubleton_eq_2_iff[simp]: \"card {a,b} = 2 \\<longleftrightarrow> a\\<noteq>b\"", "lemma length_ge_1_conv[iff]: \"Suc 0 \\<le> length l \\<longleftrightarrow> l\\<noteq>[]\"", "lemma obtain_list_from_elements:\n  assumes A: \"\\<forall>i<n. (\\<exists>li. P li i)\"\n  obtains l where\n    \"length l = n\"\n    \"\\<forall>i<n. P (l!i) i\"", "lemma distinct_sorted_mono:\n  assumes S: \"sorted l\"\n  assumes D: \"distinct l\"\n  assumes B: \"i<j\" \"j<length l\"\n  shows \"l!i < l!j\"", "lemma distinct_sorted_strict_mono_iff:\n  assumes \"distinct l\" \"sorted l\"\n  assumes \"i<length l\" \"j<length l\"\n  shows \"l!i<l!j \\<longleftrightarrow> i<j\"", "lemma distinct_sorted_mono_iff:\n  assumes \"distinct l\" \"sorted l\"\n  assumes \"i<length l\" \"j<length l\"\n  shows \"l!i\\<le>l!j \\<longleftrightarrow> i\\<le>j\"", "lemma map_eq_appendE: \n  assumes \"map f ls = fl@fl'\"\n  obtains l l' where \"ls=l@l'\" and \"map f l=fl\" and  \"map f l' = fl'\"", "lemma map_eq_append_conv: \"map f ls = fl@fl' \\<longleftrightarrow> (\\<exists>l l'. ls = l@l' \\<and> map f l = fl \\<and> map f l' = fl')\"", "lemmas append_eq_mapE = map_eq_appendE[OF sym]", "lemma append_eq_map_conv: \"fl@fl' = map f ls \\<longleftrightarrow> (\\<exists>l l'. ls = l@l' \\<and> map f l = fl \\<and> map f l' = fl')\"", "lemma distinct_mapI: \"distinct (map f l) \\<Longrightarrow> distinct l\"", "lemma map_distinct_upd_conv: \n  \"\\<lbrakk>i<length l; distinct l\\<rbrakk> \\<Longrightarrow> (map f l)[i := x] = map (f(l!i := x)) l\"\n  \\<comment> \\<open>Updating a mapped distinct list is equal to updating the \n    mapping function\\<close>", "lemma zip_inj: \"\\<lbrakk>length a = length b; length a' = length b'; zip a b = zip a' b'\\<rbrakk> \\<Longrightarrow> a=a' \\<and> b=b'\"", "lemma zip_eq_zip_same_len[simp]:\n  \"\\<lbrakk> length a = length b; length a' = length b' \\<rbrakk> \\<Longrightarrow>\n  zip a b = zip a' b' \\<longleftrightarrow> a=a' \\<and> b=b'\"", "lemma upt_merge[simp]: \"i\\<le>j \\<and> j\\<le>k \\<Longrightarrow> [i..<j]@[j..<k] = [i..<k]\"", "lemma snoc_eq_iff_butlast':\n  \"(ys = xs @ [x]) \\<longleftrightarrow> (ys \\<noteq> [] \\<and> butlast ys = xs \\<and> last ys = x)\"", "lemma list_match_lel_lel:\n  assumes \"c1 @ qs # c2 = c1' @ qs' # c2'\"\n  obtains\n    (left) c21' where \"c1 = c1' @ qs' # c21'\" \"c2' = c21' @ qs # c2\"\n  | (center) \"c1' = c1\" \"qs' = qs\" \"c2' = c2\"\n  | (right) c21 where \"c1' = c1 @ qs # c21\" \"c2 = c21 @ qs' # c2'\"", "lemma xy_in_set_cases[consumes 2, case_names EQ XY YX]:\n  assumes A: \"x\\<in>set l\" \"y\\<in>set l\"\n  and C:\n  \"!!l1 l2. \\<lbrakk> x=y; l=l1@y#l2 \\<rbrakk> \\<Longrightarrow> P\"\n  \"!!l1 l2 l3. \\<lbrakk> x\\<noteq>y; l=l1@x#l2@y#l3 \\<rbrakk> \\<Longrightarrow> P\"\n  \"!!l1 l2 l3. \\<lbrakk> x\\<noteq>y; l=l1@y#l2@x#l3 \\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma list_e_eq_lel[simp]:\n  \"[e] = l1@e'#l2 \\<longleftrightarrow> l1=[] \\<and> e'=e \\<and> l2=[]\"\n  \"l1@e'#l2 = [e] \\<longleftrightarrow> l1=[] \\<and> e'=e \\<and> l2=[]\"", "lemma list_ee_eq_leel[simp]:\n  \"([e1,e2] = l1@e1'#e2'#l2) \\<longleftrightarrow> (l1=[] \\<and> e1=e1' \\<and> e2=e2' \\<and> l2=[])\"\n  \"(l1@e1'#e2'#l2 = [e1,e2]) \\<longleftrightarrow> (l1=[] \\<and> e1=e1' \\<and> e2=e2' \\<and> l2=[])\"", "lemma rtrancl_reachable_induct[consumes 0, case_names base step]:\n  assumes I0: \"I \\<subseteq> INV\"\n  assumes IS: \"E``INV \\<subseteq> INV\"\n  shows \"E\\<^sup>*``I \\<subseteq> INV\"", "lemma acyclic_empty[simp, intro!]: \"acyclic {}\"", "lemma acyclic_union:\n  \"acyclic (A\\<union>B) \\<Longrightarrow> acyclic A\"\n  \"acyclic (A\\<union>B) \\<Longrightarrow> acyclic B\"", "lemma IdD: \"(a,b)\\<in>Id \\<Longrightarrow> a=b\"", "lemma CNV_I: \"CNV x x\"", "lemma CNV_eqD: \"CNV x y \\<Longrightarrow> x=y\"", "lemma CNV_meqD: \"CNV x y \\<Longrightarrow> x\\<equiv>y\"", "lemma ex_b_b_and_simp[simp]: \"(\\<exists>b. b \\<and> Q b) \\<longleftrightarrow> Q True\"", "lemma ex_b_not_b_and_simp[simp]: \"(\\<exists>b. \\<not>b \\<and> Q b) \\<longleftrightarrow> Q False\"", "lemma (in AC) left_commute[simp]: \"f x (f y z) = f y (f x z)\"", "lemmas (in AC) AC_simps = commute assoc left_commute", "lemma (in su_rel_fun) repr1: \"(A,f A)\\<in>F\"", "lemma (in su_rel_fun) repr2: \"(A,B)\\<in>F \\<Longrightarrow> B=f A\"", "lemma (in su_rel_fun) repr: \"(f A = B) = ((A,B)\\<in>F)\"", "lemma Ex_prod_contract: \"(\\<exists>a b. P a b) \\<longleftrightarrow> (\\<exists>z. P (fst z) (snd z))\"", "lemma All_prod_contract: \"(\\<forall>a b. P a b) \\<longleftrightarrow> (\\<forall>z. P (fst z) (snd z))\"", "lemma nat_geq_1_eq_neqz: \"x\\<ge>1 \\<longleftrightarrow> x\\<noteq>(0::nat)\"", "lemma nat_in_between_eq:\n  \"(a<b \\<and> b\\<le>Suc a) \\<longleftrightarrow> b = Suc a\"\n  \"(a\\<le>b \\<and> b<Suc a) \\<longleftrightarrow> b = a\"", "lemma Suc_n_minus_m_eq: \"\\<lbrakk> n\\<ge>m; m>1 \\<rbrakk> \\<Longrightarrow> Suc (n - m) = n - (m - 1)\"", "lemma Suc_to_right: \"Suc n = m \\<Longrightarrow> n = m - Suc 0\"", "lemma Suc_diff[simp]: \"\\<And>n m. n\\<ge>m \\<Longrightarrow> m\\<ge>1 \\<Longrightarrow> Suc (n - m) = n - (m - 1)\"", "lemma if_not_swap[simp]: \"(if \\<not>c then a else b) = (if c then b else a)\"", "lemma all_to_meta: \"Trueprop (\\<forall>a. P a) \\<equiv> (\\<And>a. P a)\"", "lemma imp_to_meta: \"Trueprop (P\\<longrightarrow>Q) \\<equiv> (P\\<Longrightarrow>Q)\"", "lemma iffI2: \"\\<lbrakk>P \\<Longrightarrow> Q; \\<not> P \\<Longrightarrow> \\<not> Q\\<rbrakk> \\<Longrightarrow> P \\<longleftrightarrow> Q\"", "lemma iffExI:\n  \"\\<lbrakk> \\<And>x. P x \\<Longrightarrow> Q x; \\<And>x. Q x \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> (\\<exists>x. P x) \\<longleftrightarrow> (\\<exists>x. Q x)\"", "lemma bex2I[intro?]: \"\\<lbrakk> (a,b)\\<in>S; (a,b)\\<in>S \\<Longrightarrow> P a b \\<rbrakk> \\<Longrightarrow> \\<exists>a b. (a,b)\\<in>S \\<and> P a b\"", "lemma cnv_conj_to_meta: \"(P \\<and> Q \\<Longrightarrow> PROP X) \\<equiv> (\\<lbrakk>P;Q\\<rbrakk> \\<Longrightarrow> PROP X)\"", "lemma remove_subset: \"x\\<in>S \\<Longrightarrow> S-{x} \\<subset> S\"", "lemma subset_minus_empty: \"A\\<subseteq>B \\<Longrightarrow> A-B = {}\"", "lemma insert_minus_eq: \"x\\<noteq>y \\<Longrightarrow> insert x A - {y} = insert x (A - {y})\"", "lemma set_notEmptyE: \"\\<lbrakk>S\\<noteq>{}; !!x. x\\<in>S \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma subset_Collect_conv: \"S \\<subseteq> Collect P \\<longleftrightarrow> (\\<forall>x\\<in>S. P x)\"", "lemma memb_imp_not_empty: \"x\\<in>S \\<Longrightarrow> S\\<noteq>{}\"", "lemma disjoint_mono: \"\\<lbrakk> a\\<subseteq>a'; b\\<subseteq>b'; a'\\<inter>b'={} \\<rbrakk> \\<Longrightarrow> a\\<inter>b={}\"", "lemma disjoint_alt_simp1: \"A-B = A \\<longleftrightarrow> A\\<inter>B = {}\"", "lemma disjoint_alt_simp2: \"A-B \\<noteq> A \\<longleftrightarrow> A\\<inter>B \\<noteq> {}\"", "lemma disjoint_alt_simp3: \"A-B \\<subset> A \\<longleftrightarrow> A\\<inter>B \\<noteq> {}\"", "lemma disjointI[intro?]: \"\\<lbrakk> \\<And>x. \\<lbrakk>x\\<in>a; x\\<in>b\\<rbrakk> \\<Longrightarrow> False \\<rbrakk> \\<Longrightarrow> a\\<inter>b={}\"", "lemmas set_simps = subset_minus_empty disjoint_alt_simp1 disjoint_alt_simp2 disjoint_alt_simp3 Un_absorb1 Un_absorb2", "lemma set_minus_singleton_eq: \"x\\<notin>X \\<Longrightarrow> X-{x} = X\"", "lemma set_diff_diff_left: \"A-B-C = A-(B\\<union>C)\"", "lemma image_update[simp]: \"x\\<notin>A \\<Longrightarrow> f(x:=n)`A = f`A\"", "lemma eq_or_mem_image_simp[simp]: \"{f l |l. l = a \\<or> l\\<in>B} = insert (f a) {f l|l. l\\<in>B}\"", "lemma set_union_code [code_unfold]:\n    \"set xs \\<union> set ys = set (xs @ ys)\"", "lemma in_fst_imageE:\n    assumes \"x \\<in> fst`S\"\n    obtains y where \"(x,y)\\<in>S\"", "lemma in_snd_imageE:\n    assumes \"y \\<in> snd`S\"\n    obtains x where \"(x,y)\\<in>S\"", "lemma fst_image_mp: \"\\<lbrakk>fst`A \\<subseteq> B; (x,y)\\<in>A \\<rbrakk> \\<Longrightarrow> x\\<in>B\"", "lemma snd_image_mp: \"\\<lbrakk>snd`A \\<subseteq> B; (x,y)\\<in>A \\<rbrakk> \\<Longrightarrow> y\\<in>B\"", "lemma inter_eq_subsetI: \"\\<lbrakk> S\\<subseteq>S'; A\\<inter>S' = B\\<inter>S' \\<rbrakk> \\<Longrightarrow> A\\<inter>S = B\\<inter>S\"", "lemma Union_plus:\n  \"(\\<Union> x \\<in> A <+> B. f x) = (\\<Union> a \\<in> A. f (Inl a)) \\<union> (\\<Union>b \\<in> B. f (Inr b))\"", "lemma Union_sum:\n  \"(\\<Union>x. f (x::'a+'b)) = (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))\"\n  (is \"?lhs = ?rhs\")", "lemma card_1_singletonI: \"\\<lbrakk>finite S; card S = 1; x\\<in>S\\<rbrakk> \\<Longrightarrow> S={x}\"", "lemma card_insert_disjoint': \"\\<lbrakk>finite A; x \\<notin> A\\<rbrakk> \\<Longrightarrow> card (insert x A) - Suc 0 = card A\"", "lemma card_eq_UNIV[simp]: \"card (S::'a::finite set) = card (UNIV::'a set) \\<longleftrightarrow> S=UNIV\"", "lemma card_eq_UNIV2[simp]: \"card (UNIV::'a set) = card (S::'a::finite set) \\<longleftrightarrow> S=UNIV\"", "lemma card_ge_UNIV[simp]: \"card (UNIV::'a::finite set) \\<le> card (S::'a set) \\<longleftrightarrow> S=UNIV\"", "lemmas length_remdups_card = length_remdups_concat[of \"[l]\", simplified] for l", "lemma fs_contract: \"fst ` { p | p. f (fst p) (snd p) \\<in> S } = { a . \\<exists>b. f a b \\<in> S }\"", "lemma finite_Collect: \"finite S \\<Longrightarrow> inj f \\<Longrightarrow> finite {a. f a : S}\"", "lemma finite_imp_inj_to_nat_seg':\n    fixes A :: \"'a set\"\n    assumes A: \"finite A\"\n    obtains f::\"'a \\<Rightarrow> nat\" and n::\"nat\" where\n      \"f`A = {i. i<n}\"\n      \"inj_on f A\"", "lemma lists_of_len_fin1: \"finite P \\<Longrightarrow> finite (lists P \\<inter> { l. length l = n })\"", "lemma lists_of_len_fin2: \"finite P \\<Longrightarrow> finite (lists P \\<inter> { l. n = length l })\"", "lemmas lists_of_len_fin = lists_of_len_fin1 lists_of_len_fin2", "lemmas cset_fin_simps = Ex_prod_contract fs_contract[symmetric] image_Collect[symmetric]", "lemmas cset_fin_intros = finite_imageI finite_Collect inj_onI", "lemma Un_interval:\n  fixes b1 :: \"'a::linorder\"\n  assumes \"b1\\<le>b2\" and \"b2\\<le>b3\"\n  shows \"{ f i | i. b1\\<le>i \\<and> i<b2 } \\<union> { f i | i. b2\\<le>i \\<and> i<b3 }\n    = {f i | i. b1\\<le>i \\<and> i<b3}\"", "lemma finite_UNION_then_finite:\n  \"finite (\\<Union>(B ` A)) \\<Longrightarrow> a \\<in> A \\<Longrightarrow> finite (B a)\"", "lemma finite_if_eq_beyond_finite: \"finite S \\<Longrightarrow> finite {s. s - S = s' - S}\"", "lemma distinct_finite_subset:\n  assumes \"finite x\"\n  shows \"finite {ys. set ys \\<subseteq> x \\<and> distinct ys}\" (is \"finite ?S\")", "lemma distinct_finite_set:\n  shows \"finite {ys. set ys = x \\<and> distinct ys}\" (is \"finite ?S\")", "lemma finite_set_image:\n  assumes f: \"finite (set ` A)\"\n  and dist: \"\\<And>xs. xs \\<in> A \\<Longrightarrow> distinct xs\"\n  shows \"finite A\"", "lemma INFM_nat_inductI:\n  assumes P0: \"P (0::nat)\"\n  assumes PS: \"\\<And>i. P i \\<Longrightarrow> \\<exists>j>i. P j \\<and> Q j\"\n  shows \"\\<exists>\\<^sub>\\<infinity>i. Q i\"", "lemma fun_neq_ext_iff: \"m\\<noteq>m' \\<longleftrightarrow> (\\<exists>x. m x \\<noteq> m' x)\"", "lemma inv_on_f_f[simp]: \"\\<lbrakk>inj_on f A; x\\<in>A\\<rbrakk> \\<Longrightarrow> inv_on f A (f x) = x\"", "lemma f_inv_on_f: \"\\<lbrakk> y\\<in>f`A \\<rbrakk> \\<Longrightarrow> f (inv_on f A y) = y\"", "lemma inv_on_f_range: \"\\<lbrakk> y \\<in> f`A \\<rbrakk> \\<Longrightarrow> inv_on f A y \\<in> A\"", "lemma inj_on_map_inv_f [simp]: \"\\<lbrakk>set l \\<subseteq> A; inj_on f A\\<rbrakk> \\<Longrightarrow> map (inv_on f A) (map f l) = l\"", "lemma comp_cong_right: \"x = y \\<Longrightarrow> f o x = f o y\"", "lemma comp_cong_left: \"x = y \\<Longrightarrow> x o f = y o f\"", "lemma fun_comp_eq_conv: \"f o g = fg \\<longleftrightarrow> (\\<forall>x. f (g x) = fg x)\"", "lemma count_mset_set_finite_iff:\n  \"finite S \\<Longrightarrow> count (mset_set S) a = (if a \\<in> S then 1 else 0)\"", "lemma ex_Melem_conv: \"(\\<exists>x. x \\<in># A) = (A \\<noteq> {#})\"", "lemma count_ne_remove: \"\\<lbrakk> x ~= t\\<rbrakk> \\<Longrightarrow> count S x = count (S-{#t#}) x\"", "lemma mset_empty_count[simp]: \"(\\<forall>p. count M p = 0) = (M={#})\"", "lemma size_diff_se: \"t \\<in># S \\<Longrightarrow> size S = size (S - {#t#}) + 1\"", "lemma mset_union_diff_comm: \"t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = (T + S) - {#t#}\"", "lemma mset_right_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># B)\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemma mset_left_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># A)\\<rbrakk> \\<Longrightarrow> a\\<in>#B\"", "lemmas mset_cancel_union = mset_right_cancel_union mset_left_cancel_union", "lemma mset_right_cancel_elem: \"\\<lbrakk>a \\<in># A+{#b#}; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemma mset_left_cancel_elem: \"\\<lbrakk>a \\<in># {#b#}+A; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemmas mset_cancel_elem = mset_right_cancel_elem mset_left_cancel_elem", "lemma mset_diff_cancel1elem[simp]: \"~(a \\<in># B) \\<Longrightarrow> {#a#}-B = {#a#}\"", "lemma union_diff_assoc: \"C-B={#} \\<Longrightarrow> (A+B)-C = A + (B-C)\"", "lemmas mset_neutral_cancel1 = union_left_cancel[where N=\"{#}\", simplified] union_right_cancel[where N=\"{#}\", simplified]", "lemma mset_union_2_elem: \"{#a, b#} = add_mset c M \\<Longrightarrow> {#a#}=M & b=c | a=c & {#b#}=M\"", "lemma mset_un_cases[cases set, case_names left right]:\n    \"\\<lbrakk>a \\<in># A + B; a \\<in># A \\<Longrightarrow> P; a \\<in># B \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_unplusm_dist_cases[cases set, case_names left right]:\n    assumes A: \"{#s#}+A = B+C\"\n    assumes L: \"\\<lbrakk>B={#s#}+(B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C={#s#}+(C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\"\n    shows P", "lemma mset_unplusm_dist_cases2[cases set, case_names left right]:\n    assumes A: \"B+C = {#s#}+A\"\n    assumes L: \"\\<lbrakk>B={#s#}+(B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C={#s#}+(C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\"\n    shows P", "lemma mset_single_cases[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'={#s#}+(c'-{#s#}); c={#r'#}+(c-{#r'#}); c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_single_cases'[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'={#s#}+cc; c={#r'#}+cc; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_single_cases2[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'=(c'-{#s#})+{#s#}; c=(c-{#r'#})+{#r'#}; c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_single_cases2'[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'=cc+{#s#}; c=cc+{#r'#}; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_un_single_un_cases [consumes 1, case_names left right]:\n    assumes A: \"add_mset a A = B + C\"\n      and CASES: \"a \\<in># B \\<Longrightarrow> A = (B - {#a#}) + C \\<Longrightarrow> P\"\n        \"a \\<in># C \\<Longrightarrow> A = B + (C - {#a#}) \\<Longrightarrow> P\" shows \"P\"", "lemma mset_distrib[consumes 1, case_names dist]: assumes A: \"(A::'a multiset)+B = M+N\" \"!!Am An Bm Bn. \\<lbrakk>A=Am+An; B=Bm+Bn; M=Am+Bm; N=An+Bn\\<rbrakk> \\<Longrightarrow> P\" shows \"P\"", "lemma mset_size_le1_cases[case_names empty singleton,consumes 1]: \"\\<lbrakk> size M \\<le> Suc 0; M={#} \\<Longrightarrow> P; !!m. M={#m#} \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma diff_union_single_conv2: \"a \\<in># J \\<Longrightarrow> J + I - {#a#} = (J - {#a#}) + I\"", "lemmas diff_union_single_convs = diff_union_single_conv diff_union_single_conv2", "lemma mset_contains_eq: \"(m \\<in># M) = ({#m#}+(M-{#m#})=M)\"", "lemma mset_le_incr_right1: \"a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b+c\"", "lemma mset_le_incr_right2: \"a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#c+b\"", "lemmas mset_le_incr_right = mset_le_incr_right1 mset_le_incr_right2", "lemma mset_le_decr_left1: \"a+c\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_decr_left2: \"c+a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_add_mset_decr_left1: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_add_mset_decr_left2: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> {#c#}\\<subseteq>#b\"", "lemmas mset_le_decr_left = mset_le_decr_left1 mset_le_decr_left2 mset_le_add_mset_decr_left1\n    mset_le_add_mset_decr_left2", "lemma mset_le_subtract: \"A\\<subseteq>#B \\<Longrightarrow> A-C \\<subseteq># B-(C::'a multiset)\"", "lemma mset_union_subset: \"A+B \\<subseteq># C \\<Longrightarrow> A\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\"", "lemma mset_le_add_mset: \"add_mset x B \\<subseteq># C \\<Longrightarrow> {#x#}\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\"", "lemma mset_le_subtract_left: \"A+B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-A \\<and> A\\<subseteq>#X\"", "lemma mset_le_subtract_right: \"A+B \\<subseteq># (X::'a multiset) \\<Longrightarrow> A \\<subseteq># X-B \\<and> B\\<subseteq>#X\"", "lemma mset_le_subtract_add_mset_left: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-{#x#} \\<and> {#x#}\\<subseteq>#X\"", "lemma mset_le_subtract_add_mset_right: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> {#x#} \\<subseteq># X-B \\<and> B\\<subseteq>#X\"", "lemma mset_le_addE: \"\\<lbrakk> xs \\<subseteq># (ys::'a multiset); !!zs. ys=xs+zs \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_2dist2_cases:\n    assumes A: \"{#a#}+{#b#} \\<subseteq># A+B\"\n    assumes CASES: \"{#a#}+{#b#} \\<subseteq># A \\<Longrightarrow> P\" \"{#a#}+{#b#} \\<subseteq># B \\<Longrightarrow> P\" \"\\<lbrakk>a \\<in># A; b \\<in># B\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>a \\<in># B; b \\<in># A\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_union_subset_s: \"{#a#}+B \\<subseteq># C \\<Longrightarrow> a \\<in># C \\<and> B \\<subseteq># C\"", "lemma mset_le_single_cases[consumes 1, case_names empty singleton]: \"\\<lbrakk>M\\<subseteq>#{#a#}; M={#} \\<Longrightarrow> P; M={#a#} \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_le_distrib[consumes 1, case_names dist]: \"\\<lbrakk>(X::'a multiset)\\<subseteq>#A+B; !!Xa Xb. \\<lbrakk>X=Xa+Xb; Xa\\<subseteq>#A; Xb\\<subseteq>#B\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_le_mono_add_single: \"\\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk> \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># ys + ws\"", "lemma mset_size1elem: \"\\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P={#q#}\"", "lemma mset_size2elem: \"\\<lbrakk>size P \\<le> 2; {#q#}+{#q'#} \\<subseteq># P\\<rbrakk> \\<Longrightarrow> P={#q#}+{#q'#}\"", "lemma mset_map_split_orig: \"!!M1 M2. \\<lbrakk>f `# P = M1+M2; !!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma mset_map_id: \"\\<lbrakk>!!x. f (g x) = x\\<rbrakk> \\<Longrightarrow> f `# g `# X = X\"", "lemma mset_map_split_orig_le: assumes A: \"f `# P \\<subseteq># M1+M2\" and EX: \"!!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 \\<subseteq># M1; f `# P2 \\<subseteq># M2\\<rbrakk> \\<Longrightarrow> Q\" shows \"Q\"", "lemma len_greater_imp_nonempty[simp]: \"length l > x \\<Longrightarrow> l\\<noteq>[]\"", "lemma list_take_induct_tl2:\n  \"\\<lbrakk>length xs = length ys; \\<forall>n<length xs. P (ys ! n) (xs ! n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n < length (tl xs). P ((tl ys) ! n) ((tl xs) ! n)\"", "lemma not_distinct_split_distinct:\n  assumes \"\\<not> distinct xs\"\n  obtains y ys zs where \"distinct ys\" \"y \\<in> set ys\" \"xs = ys@[y]@zs\"", "lemma distinct_length_le:\n  assumes d: \"distinct ys\"\n  and eq: \"set ys = set xs\"\n  shows \"length ys \\<le> length xs\"", "lemma find_SomeD:\n  \"List.find P xs = Some x \\<Longrightarrow> P x\"\n  \"List.find P xs = Some x \\<Longrightarrow> x\\<in>set xs\"", "lemma in_hd_or_tl_conv[simp]: \"l\\<noteq>[] \\<Longrightarrow> x=hd l \\<or> x\\<in>set (tl l) \\<longleftrightarrow> x\\<in>set l\"", "lemma length_dropWhile_takeWhile:\n  assumes \"x < length (dropWhile P xs)\"\n  shows \"x + length (takeWhile P xs) < length xs\"", "lemma neq_NilE: \n  assumes \"l\\<noteq>[]\"\n  obtains x xs where \"l=x#xs\"", "lemma length_Suc_rev_conv: \"length xs = Suc n \\<longleftrightarrow> (\\<exists>ys y. xs=ys@[y] \\<and> length ys = n)\"", "lemma not_hd_in_tl:\n  \"x \\<noteq> hd xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> x \\<in> set (tl xs)\"", "lemma distinct_hd_tl:\n  \"distinct xs \\<Longrightarrow> x = hd xs \\<Longrightarrow> x \\<notin> set (tl (xs))\"", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma nth_tl: \"xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! Suc n\"", "lemma tl_subset:\n  \"xs \\<noteq> [] \\<Longrightarrow> set xs \\<subseteq> A \\<Longrightarrow> set (tl xs) \\<subseteq> A\"", "lemma tl_last:\n  \"tl xs \\<noteq> [] \\<Longrightarrow> last xs = last (tl xs)\"", "lemma tl_obtain_elem:\n  assumes \"xs \\<noteq> []\" \"tl xs = []\"\n  obtains e where \"xs = [e]\"", "lemma butlast_subset:\n  \"xs \\<noteq> [] \\<Longrightarrow> set xs \\<subseteq> A \\<Longrightarrow> set (butlast xs) \\<subseteq> A\"", "lemma butlast_rev_tl:\n  \"xs \\<noteq> [] \\<Longrightarrow> butlast (rev xs) = rev (tl xs)\"", "lemma hd_butlast:\n  \"length xs > 1 \\<Longrightarrow> hd (butlast xs) = hd xs\"", "lemma butlast_upd_last_eq[simp]: \"length l \\<ge> 2 \\<Longrightarrow>\n  (butlast l) [ length l - 2 := x ] = take (length l - 2) l @ [x]\"", "lemma distinct_butlast_swap[simp]: \n  \"distinct pq \\<Longrightarrow> distinct (butlast (pq[i := last pq]))\"", "lemma SPLIT_ACCORDINGE: \n  assumes \"length m = length l\"\n  obtains \"SPLIT_ACCORDING m l\"", "lemma SPLIT_ACCORDING_simp:\n  \"SPLIT_ACCORDING m (l1@l2) \\<longleftrightarrow> (\\<exists>m1 m2. m=m1@m2 \\<and> SPLIT_ACCORDING m1 l1 \\<and> SPLIT_ACCORDING m2 l2)\"\n  \"SPLIT_ACCORDING m (x#l') \\<longleftrightarrow> (\\<exists>y m'. m=y#m' \\<and> SPLIT_ACCORDING m' l')\"", "lemma list_all2_induct[consumes 1, case_names Nil Cons]:\n  assumes \"list_all2 P l l'\"\n  assumes \"Q [] []\"\n  assumes \"\\<And>x x' ls ls'. \\<lbrakk> P x x'; list_all2 P ls ls'; Q ls ls' \\<rbrakk>\n    \\<Longrightarrow> Q (x#ls) (x'#ls')\"\n  shows \"Q l l'\"", "lemma ran_nth_set_encoding_conv[simp]: \n  \"ran (\\<lambda>i. if i<length l then Some (l!i) else None) = set l\"", "lemma nth_image_indices[simp]: \"(!) l ` {0..<length l} = set l\"", "lemma nth_update_invalid[simp]:\"\\<not>i<length l \\<Longrightarrow> l[j:=x]!i = l!i\"", "lemma nth_list_update': \"l[i:=x]!j = (if i=j \\<and> i<length l then x else l!j)\"", "lemma last_take_nth_conv: \"n \\<le> length l \\<Longrightarrow> n\\<noteq>0 \\<Longrightarrow> last (take n l) = l!(n - 1)\"", "lemma nth_append_first[simp]: \"i<length l \\<Longrightarrow> (l@l')!i = l!i\"", "lemma in_set_image_conv_nth: \"f x \\<in> f`set l \\<longleftrightarrow> (\\<exists>i<length l. f (l!i) = f x)\"", "lemma set_image_eq_pointwiseI: \n  assumes \"length l = length l'\"\n  assumes \"\\<And>i. i<length l \\<Longrightarrow> f (l!i) = f (l'!i)\"  \n  shows \"f`set l = f`set l'\"", "lemma insert_swap_set_eq: \"i<length l \\<Longrightarrow> insert (l!i) (set (l[i:=x])) = insert x (set l)\"", "lemma neq_Nil_revE: \n    assumes \"l\\<noteq>[]\" \n    obtains ll e  where \"l = ll@[e]\"", "lemma neq_Nil_rev_conv: \"l\\<noteq>[] \\<longleftrightarrow> (\\<exists>xs x. l = xs@[x])\"", "lemma length_compl_rev_induct[case_names Nil snoc]: \"\\<lbrakk>P []; !! l e . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (l@[e])\\<rbrakk> \\<Longrightarrow> P l\"", "lemma list_append_eq_Cons_cases[consumes 1]: \"\\<lbrakk>ys@zs = x#xs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma list_Cons_eq_append_cases[consumes 1]: \"\\<lbrakk>x#xs = ys@zs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma map_of_rev_distinct[simp]:\n  \"distinct (map fst m) \\<Longrightarrow> map_of (rev m) = map_of m\"", "lemma revg_fun[simp]: \"revg a b = rev a @ b\"", "lemma rev_split_conv[simp]:\n  \"l \\<noteq> [] \\<Longrightarrow> rev (tl l) @ [hd l] = rev l\"", "lemma rev_butlast_is_tl_rev: \"rev (butlast l) = tl (rev l)\"", "lemma hd_last_singletonI:\n  \"\\<lbrakk>xs \\<noteq> []; hd xs = last xs; distinct xs\\<rbrakk> \\<Longrightarrow> xs = [hd xs]\"", "lemma last_filter:\n  \"\\<lbrakk>xs \\<noteq> []; P (last xs)\\<rbrakk> \\<Longrightarrow> last (filter P xs) = last xs\"", "lemma rev_induct2' [case_names empty snocl snocr snoclr]:\n  assumes empty: \"P [] []\"\n  and snocl: \"\\<And>x xs. P (xs@[x]) []\"\n  and snocr: \"\\<And>y ys. P [] (ys@[y])\"\n  and snoclr: \"\\<And>x xs y ys.  P xs ys  \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows \"P xs ys\"", "lemma rev_nonempty_induct2' [case_names single snocl snocr snoclr, consumes 2]:\n  assumes \"xs \\<noteq> []\" \"ys \\<noteq> []\"\n  assumes single': \"\\<And>x y. P [x] [y]\"\n  and snocl: \"\\<And>x xs y. xs \\<noteq> [] \\<Longrightarrow> P (xs@[x]) [y]\"\n  and snocr: \"\\<And>x y ys. ys \\<noteq> [] \\<Longrightarrow> P [x] (ys@[y])\"\n  and snoclr: \"\\<And>x xs y ys. \\<lbrakk>P xs ys; xs \\<noteq> []; ys\\<noteq>[]\\<rbrakk>  \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows \"P xs ys\"", "lemma foldl_A1_eq: \"!!i. \\<lbrakk> !! e. f n e = e; !! e. f e n = e; !!a b c. f a (f b c) = f (f a b) c \\<rbrakk> \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)\"", "lemmas foldl_conc_empty_eq = foldl_A1_eq[of \"(@)\" \"[]\", simplified]", "lemmas foldl_un_empty_eq = foldl_A1_eq[of \"(\\<union>)\" \"{}\", simplified, OF Un_assoc[symmetric]]", "lemma foldl_set: \"foldl (\\<union>) {} l = \\<Union>{x. x\\<in>set l}\"", "lemma (in monoid_mult) foldl_absorb1: \"x*foldl (*) 1 zs = foldl (*) x zs\"", "lemma foldl_rule_aux:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) l2\"\n  shows \"I (foldl f \\<sigma>0 l0) []\"", "lemma foldl_rule_aux_P:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) l2\"\n  assumes final: \"!!\\<sigma>. I \\<sigma> [] \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (foldl f \\<sigma>0 l0)\"", "lemma foldl_rule:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 [] l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> l1 (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) (l1@[x]) l2\"\n  shows \"I (foldl f \\<sigma>0 l0) l0 []\"", "lemma foldl_rule_P:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  \\<comment> \\<open>The invariant holds for the initial state, no items processed yet and all items to be processed:\\<close>\n  assumes initial: \"I \\<sigma>0 [] l0\"\n  \\<comment> \\<open>The invariant remains valid if one item from the list is processed\\<close>\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> l1 (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) (l1@[x]) l2\"\n  \\<comment> \\<open>The proposition follows from the invariant in the final state, i.e. all items processed and nothing to be processed\\<close>\n  assumes final: \"!!\\<sigma>. I \\<sigma> l0 [] \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (foldl f \\<sigma>0 l0)\"", "lemma distinct_foldl_invar:\n  \"\\<lbrakk> distinct S; I (set S) \\<sigma>0;\n     \\<And>x it \\<sigma>. \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk> \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\n   \\<rbrakk> \\<Longrightarrow> I {} (foldl f \\<sigma>0 S)\"", "lemma foldl_length_aux: \"foldl (\\<lambda>i x. Suc i) a l = a + length l\"", "lemmas foldl_length[simp] = foldl_length_aux[where a=0, simplified]", "lemma foldr_length_aux: \"foldr (\\<lambda>x i. Suc i) l a = a + length l\"", "lemmas foldr_length[simp] = foldr_length_aux[where a=0, simplified]", "lemma foldl_f_commute: \"f a (foldl (\\<lambda>a b. f b a) b xs) = foldl (\\<lambda>a b. f b a) (f a b) xs\"", "lemma foldr_conv_foldl: \"foldr f xs a = foldl (\\<lambda>a b. f b a) a xs\"", "lemma filter_conv_foldr:\n  \"filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []\"", "lemma foldr_Cons: \"foldr Cons xs [] = xs\"", "lemma foldr_snd_zip:\n  \"length xs \\<ge> length ys \\<Longrightarrow> foldr (\\<lambda>(x, y). f y) (zip xs ys) b = foldr f ys b\"", "lemma foldl_snd_zip:\n  \"length xs \\<ge> length ys \\<Longrightarrow> foldl (\\<lambda>b (x, y). f b y) b (zip xs ys) = foldl f b ys\"", "lemma fst_foldl: \"fst (foldl (\\<lambda>(a, b) x. (f a x, g a b x)) (a, b) xs) = foldl f a xs\"", "lemma foldl_foldl_conv_concat: \"foldl (foldl f) a xs = foldl f a (concat xs)\"", "lemma foldl_list_update:\n  \"n < length xs \\<Longrightarrow> foldl f a (xs[n := x]) = foldl f (f (foldl f a (take n xs)) x) (drop (Suc n) xs)\"", "lemma map_by_foldl:\n  fixes l :: \"'a list\" and f :: \"'a \\<Rightarrow> 'b\"\n  shows \"foldl (\\<lambda>l x. l@[f x]) [] l = map f l\"", "lemma sorted_in_between:\n  assumes A: \"0\\<le>i\" \"i<j\" \"j<length l\"\n  assumes S: \"sorted l\"\n  assumes E: \"l!i \\<le> x\" \"x<l!j\"\n  obtains k where \"i\\<le>k\" and \"k<j\" and \"l!k\\<le>x\" and \"x<l!(k+1)\"", "lemma sorted_hd_last:\n  \"\\<lbrakk>sorted l; l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> hd l \\<le> last l\"", "lemma (in linorder) sorted_hd_min:\n  \"\\<lbrakk>xs \\<noteq> []; sorted xs\\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set xs. hd xs \\<le> x\"", "lemma sorted_append_bigger:\n  \"\\<lbrakk>sorted xs; \\<forall>x \\<in> set xs. x \\<le> y\\<rbrakk> \\<Longrightarrow> sorted (xs @ [y])\"", "lemma sorted_filter':\n  \"sorted l \\<Longrightarrow> sorted (filter P l)\"", "lemma map_eq_consE: \"\\<lbrakk>map f ls = fa#fl; !!a l. \\<lbrakk> ls=a#l; f a=fa; map f l = fl \\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma map_fst_mk_snd[simp]: \"map fst (map (\\<lambda>x. (x,k)) l) = l\"", "lemma map_snd_mk_fst[simp]: \"map snd (map (\\<lambda>x. (k,x)) l) = l\"", "lemma map_fst_mk_fst[simp]: \"map fst (map (\\<lambda>x. (k,x)) l) = replicate (length l) k\"", "lemma map_snd_mk_snd[simp]: \"map snd (map (\\<lambda>x. (x,k)) l) = replicate (length l) k\"", "lemma map_zip1: \"map (\\<lambda>x. (x,k)) l = zip l (replicate (length l) k)\"", "lemma map_zip2: \"map (\\<lambda>x. (k,x)) l = zip (replicate (length l) k) l\"", "lemmas map_zip=map_zip1 map_zip2", "lemma map_eq_nth_eq:\n  assumes A: \"map f l = map f l'\"\n  shows \"f (l!i) = f (l'!i)\"", "lemma map_upd_eq:\n  \"\\<lbrakk>i<length l \\<Longrightarrow> f (l!i) = f x\\<rbrakk> \\<Longrightarrow> map f (l[i:=x]) = map f l\"", "lemma inj_map_inv_f [simp]: \"inj f \\<Longrightarrow> map (inv f) (map f l) = l\"", "lemma inj_on_map_the: \"\\<lbrakk>D \\<subseteq> dom m; inj_on m D\\<rbrakk> \\<Longrightarrow> inj_on (the\\<circ>m) D\"", "lemma map_consI:\n  \"w=map f ww \\<Longrightarrow> f a#w = map f (a#ww)\"\n  \"w@l=map f ww@l \\<Longrightarrow> f a#w@l = map f (a#ww)@l\"", "lemma restrict_map_subset_eq:\n  fixes R\n  shows \"\\<lbrakk>m |` R = m'; R'\\<subseteq>R\\<rbrakk> \\<Longrightarrow> m|` R' = m' |` R'\"", "lemma restrict_map_self[simp]: \"m |` dom m = m\"", "lemma restrict_map_UNIV[simp]: \"f |` UNIV = f\"", "lemma restrict_map_inv[simp]: \"f |` (- dom f) = Map.empty\"", "lemma restrict_map_upd: \"(f |` S)(k \\<mapsto> v) = f(k\\<mapsto>v) |` (insert k S)\"", "lemma map_upd_eq_restrict: \"m (x:=None) = m |` (-{x})\"", "lemma dom_const'[simp]: \"dom (\\<lambda>x. Some (f x)) = UNIV\"", "lemma restrict_map_eq :\n  \"((m |` A) k = None) \\<longleftrightarrow> (k \\<notin> dom m \\<inter> A)\"\n  \"((m |` A) k = Some v) \\<longleftrightarrow> (m k = Some v \\<and> k \\<in> A)\"", "lemma rel_of_empty[simp]: \"rel_of Map.empty P = {}\"", "lemma remove1_tl: \"xs \\<noteq> [] \\<Longrightarrow> remove1 (hd xs) xs = tl xs\"", "lemma set_oo_map_alt: \"(set \\<circ>\\<circ> map) f = (\\<lambda>l. f ` set l)\"", "lemma filter_rev_aux_alt: \"filter_rev_aux a P l = filter P (rev l) @ a\"", "lemma filter_rev_alt: \"filter_rev P l = filter P (rev l)\"", "lemma remove_rev_alt_def :\n  \"remove_rev x xs = (filter (\\<lambda>y. y \\<noteq> x) (rev xs))\"", "lemma pair_list_split: \"\\<lbrakk> !!l1 l2. \\<lbrakk> l = zip l1 l2; length l1=length l2; length l=length l2 \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma set_zip_cart: \"x\\<in>set (zip l l') \\<Longrightarrow> x\\<in>set l \\<times> set l'\"", "lemma map_prod_fun_zip: \"map (\\<lambda>(x, y). (f x, g y)) (zip xs ys) = zip (map f xs) (map g ys)\"", "lemma zipf_zip: \"\\<lbrakk>length l1 = length l2\\<rbrakk> \\<Longrightarrow> zipf Pair l1 l2 = zip l1 l2\"", "lemma list_all_zip_alt: \"list_all_zip P as bs \\<longleftrightarrow> length as = length bs \\<and> (\\<forall>i<length as. P (as!i) (bs!i))\"", "lemma list_all_zip_map1: \"list_all_zip P (List.map f as) bs \\<longleftrightarrow> list_all_zip (\\<lambda>a b. P (f a) b) as bs\"", "lemma list_all_zip_map2: \"list_all_zip P as (List.map f bs) \\<longleftrightarrow> list_all_zip (\\<lambda>a b. P a (f b)) as bs\"", "lemma lazI[intro?]: \"\\<lbrakk> length a = length b; !!i. i<length b \\<Longrightarrow> P (a!i) (b!i) \\<rbrakk>\n  \\<Longrightarrow> list_all_zip P a b\"", "lemma laz_conj[simp]: \"list_all_zip (\\<lambda>x y. P x y \\<and> Q x y) a b\n                       \\<longleftrightarrow> list_all_zip P a b \\<and> list_all_zip Q a b\"", "lemma laz_len: \"list_all_zip P a b \\<Longrightarrow> length a = length b\"", "lemma laz_eq: \"list_all_zip (=) a b \\<longleftrightarrow> a=b\"", "lemma laz_swap_ex:\n  assumes A: \"list_all_zip (\\<lambda>a b. \\<exists>c. P a b c) A B\"\n  obtains C where\n    \"list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C\"\n    \"list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\"", "lemma laz_weak_Pa[simp]:\n  \"list_all_zip (\\<lambda>a b. P a) A B \\<longleftrightarrow> (length A = length B) \\<and> (\\<forall>a\\<in>set A. P a)\"", "lemma laz_weak_Pb[simp]:\n  \"list_all_zip (\\<lambda>a b. P b) A B \\<longleftrightarrow> (length A = length B) \\<and> (\\<forall>b\\<in>set B. P b)\"", "lemma list_collect_set_simps[simp]:\n  \"list_collect_set f [] = {}\"\n  \"list_collect_set f [a] = f a\"\n  \"list_collect_set f (a#l) = f a \\<union> list_collect_set f l\"\n  \"list_collect_set f (l@l') = list_collect_set f l \\<union> list_collect_set f l'\"", "lemma list_collect_set_map_simps[simp]:\n  \"list_collect_set f (map x []) = {}\"\n  \"list_collect_set f (map x [a]) = f (x a)\"\n  \"list_collect_set f (map x (a#l)) = f (x a) \\<union> list_collect_set f (map x l)\"\n  \"list_collect_set f (map x (l@l')) = list_collect_set f (map x l) \\<union> list_collect_set f (map x l')\"", "lemma list_collect_set_alt: \"list_collect_set f l = \\<Union>{ f (l!i) | i. i<length l }\"", "lemma list_collect_set_as_map: \"list_collect_set f l = \\<Union>(set (map f l))\"", "lemma (in linorder) sorted_wrt_rev_linord [simp] :\n  \"sorted_wrt (\\<ge>) l \\<longleftrightarrow> sorted (rev l)\"", "lemma (in linorder) sorted_wrt_map_linord [simp] :\n  \"sorted_wrt (\\<lambda>(x::'a \\<times> 'b) y. fst x \\<le> fst y) l\n  \\<longleftrightarrow> sorted (map fst l)\"", "lemma (in linorder) sorted_wrt_map_rev_linord [simp] :\n  \"sorted_wrt (\\<lambda>(x::'a \\<times> 'b) y. fst x \\<ge> fst y) l\n  \\<longleftrightarrow> sorted (rev (map fst l))\"", "lemma take_update[simp]: \"take n (l[i:=x]) = (take n l)[i:=x]\"", "lemma take_update_last: \"length list>n \\<Longrightarrow> (take (Suc n) list) [n:=x] = take n list @ [x]\"", "lemma drop_upd_irrelevant: \"m < n \\<Longrightarrow> drop n (l[m:=x]) = drop n l\"", "lemma set_drop_conv:\n  \"set (drop n l) =  { l!i | i. n\\<le>i \\<and> i < length l }\" (is \"?L=?R\")", "lemma filter_upt_take_conv:\n  \"[i\\<leftarrow>[n..<m]. P (take m l ! i) ] = [i\\<leftarrow>[n..<m]. P (l ! i) ]\"", "lemma in_set_drop_conv_nth: \"x\\<in>set (drop n l) \\<longleftrightarrow> (\\<exists>i. n\\<le>i \\<and> i<length l \\<and> x = l!i)\"", "lemma Union_take_drop_id: \"\\<Union>(set (drop n l)) \\<union> \\<Union>(set (take n l)) = \\<Union>(set l)\"", "lemma Un_set_drop_extend: \"\\<lbrakk>j\\<ge>Suc 0; j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! (j - Suc 0) \\<union> \\<Union>(set (drop j l)) = \\<Union>(set (drop (j - Suc 0) l))\"", "lemma drop_take_drop_unsplit:\n  \"i\\<le>j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l\"", "lemma drop_last_conv[simp]: \"l\\<noteq>[] \\<Longrightarrow> drop (length l - Suc 0) l = [last l]\"", "lemma take_butlast_conv[simp]: \"take (length l - Suc 0) l = butlast l\"", "lemma drop_takeWhile:\n    assumes \"i\\<le>length (takeWhile P l)\"\n    shows \"drop i (takeWhile P l) = takeWhile P (drop i l)\"", "lemma less_length_takeWhile_conv: \"i < length (takeWhile P l) \\<longleftrightarrow> (i<length l \\<and> (\\<forall>j\\<le>i. P (l!j)))\"", "lemma eq_len_takeWhile_conv: \"i=length (takeWhile P l) \n  \\<longleftrightarrow> i\\<le>length l \\<and> (\\<forall>j<i. P (l!j)) \\<and> (i<length l \\<longrightarrow> \\<not>P (l!i))\"", "lemma upt_eq_append_conv: \"i\\<le>j \\<Longrightarrow> [i..<j] = xs@ys \\<longleftrightarrow> (\\<exists>k. i\\<le>k \\<and> k\\<le>j \\<and> [i..<k] = xs \\<and> [k..<j] = ys)\"", "lemma map_nth_upt_drop_take_conv: \"N \\<le> length l \\<Longrightarrow> map (nth l) [M..<N] = drop M (take N l)\"", "lemma upt_eq_lel_conv:\n  \"[l..<h] = is1@i#is2 \\<longleftrightarrow> is1 = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l\\<le>i \\<and> i<h\"", "lemma map_add_upt': \"map (\\<lambda>i. i + ofs) [a..<b] = [a+ofs..<b + ofs]\"", "lemma butlast_upt: \"butlast [m..<n] = [m..<n - 1]\"", "lemma butlast_update': \"(butlast l) [i:=x] = butlast (l[i:=x])\"", "lemma take_minus_one_conv_butlast:\n  \"n\\<le>length l \\<Longrightarrow> take (n - Suc 0) l = butlast (take n l)\"", "lemma butlast_eq_cons_conv: \"butlast l = x#xs \\<longleftrightarrow> (\\<exists>xl. l=x#xs@[xl])\"", "lemma butlast_eq_consE:\n  assumes \"butlast l = x#xs\"\n  obtains xl where \"l=x#xs@[xl]\"", "lemma drop_eq_ConsD: \"drop n xs = x # xs' \\<Longrightarrow> drop (Suc n) xs = xs'\"", "lemma slice_len[simp]: \"\\<lbrakk> from \\<le> to; to \\<le> length xs \\<rbrakk> \\<Longrightarrow> length (slice from to xs) = to - from\"", "lemma slice_head: \"\\<lbrakk> from < to; to \\<le> length xs \\<rbrakk> \\<Longrightarrow> hd (slice from to xs) = xs ! from\"", "lemma slice_eq_bounds_empty[simp]: \"slice i i xs = []\"", "lemma slice_nth: \"\\<lbrakk> from < to; to \\<le> length xs; i < to - from \\<rbrakk> \\<Longrightarrow> slice from to xs ! i = xs ! (from + i)\"", "lemma slice_prepend: \"\\<lbrakk> i \\<le> k; k \\<le> length xs \\<rbrakk> \\<Longrightarrow> let p = length ys in slice i k xs = slice (i + p) (k + p) (ys @ xs)\"", "lemma slice_Nil[simp]: \"slice begin end [] = []\"", "lemma slice_Cons: \"slice begin end (x#xs) \n  = (if begin=0 \\<and> end>0 then x#slice begin (end-1) xs else slice (begin - 1) (end - 1) xs)\"", "lemma slice_complete[simp]: \"slice 0 (length xs) xs = xs\"", "lemma length_compl_induct[case_names Nil Cons]: \"\\<lbrakk>P []; !! e l . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (e#l)\\<rbrakk> \\<Longrightarrow> P l\"", "lemma in_set_list_format: \"\\<lbrakk> e\\<in>set l; !!l1 l2. l=l1@e#l2 \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma in_set_upd_cases:\n  assumes \"x\\<in>set (l[i:=y])\"\n  obtains \"i<length l\" and \"x=y\" | \"x\\<in>set l\"", "lemma in_set_upd_eq_aux:\n  assumes \"i<length l\"\n  shows \"x\\<in>set (l[i:=y]) \\<longleftrightarrow> x=y \\<or> (\\<forall>y. x\\<in>set (l[i:=y]))\"", "lemma in_set_upd_eq:\n  assumes \"i<length l\"\n  shows \"x\\<in>set (l[i:=y]) \\<longleftrightarrow> x=y \\<or> (x\\<in>set l \\<and> (\\<forall>y. x\\<in>set (l[i:=y])))\"", "lemma list_2pre_induct[case_names base left right]: assumes BASE: \"P [] []\" and LEFT: \"!!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2\" and RIGHT: \"!!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2')\" shows \"P w1 w2\"", "lemma list_decomp_1: \"length l=1 \\<Longrightarrow> \\<exists>a. l=[a]\"", "lemma list_decomp_2: \"length l=2 \\<Longrightarrow> \\<exists>a b. l=[a,b]\"", "lemma list_rest_coinc: \"\\<lbrakk>length s2 \\<le> length s1; s1@r1 = s2@r2\\<rbrakk> \\<Longrightarrow> \\<exists>r1p. r2=r1p@r1\"", "lemma list_tail_coinc: \"n1#r1 = n2#r2 \\<Longrightarrow> n1=n2 & r1=r2\"", "lemma last_in_set[intro]: \"\\<lbrakk>l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> last l \\<in> set l\"", "lemma empty_append_eq_id[simp]: \"(@) [] = (\\<lambda>x. x)\"", "lemma op_conc_empty_img_id[simp]: \"((@) [] ` L) = L\"", "lemma distinct_match: \"\\<lbrakk> distinct (al@e#bl) \\<rbrakk> \\<Longrightarrow> (al@e#bl = al'@e#bl') \\<longleftrightarrow> (al=al' \\<and> bl=bl')\"", "lemma prop_match: \"\\<lbrakk> list_all P al; \\<not>P e; \\<not>P e'; list_all P bl \\<rbrakk> \\<Longrightarrow> (al@e#bl = al'@e'#bl') \\<longleftrightarrow> (al=al' \\<and> e=e' \\<and> bl=bl')\"", "lemmas prop_matchD = rev_iffD1[OF _ prop_match[where P=P]] for P", "lemma list_se_match[simp]:\n  \"l1 \\<noteq> [] \\<Longrightarrow> l1@l2 = [a] \\<longleftrightarrow> l1 = [a] \\<and> l2 = []\"\n  \"l2 \\<noteq> [] \\<Longrightarrow> l1@l2 = [a] \\<longleftrightarrow> l1 = [] \\<and> l2 = [a]\"\n  \"l1 \\<noteq> [] \\<Longrightarrow> [a] = l1@l2 \\<longleftrightarrow> l1 = [a] \\<and> l2 = []\"\n  \"l2 \\<noteq> [] \\<Longrightarrow> [a] = l1@l2 \\<longleftrightarrow> l1 = [] \\<and> l2 = [a]\"", "lemma distinct_map_eq: \"\\<lbrakk> distinct (List.map f l); f x = f y; x\\<in>set l; y\\<in>set l \\<rbrakk> \\<Longrightarrow> x=y\"", "lemma upt_append:\n  assumes \"i<j\"\n  shows \"[0..<i]@[i..<j] = [0..<j]\"", "lemma upt_filter_extend:\n  assumes LE: \"u\\<le>u'\"\n  assumes NP: \"\\<forall>i. u\\<le>i \\<and> i<u' \\<longrightarrow> \\<not>P i\"\n  shows \"[i\\<leftarrow>[0..<u]. P i] = [i\\<leftarrow>[0..<u']. P i]\"", "lemma filter_upt_last:\n  assumes E: \"[k\\<leftarrow>[0..<length l] . P (l!k)] = js @ [j]\"\n  assumes \"j<i\" and \"i<length l\"\n  shows \"\\<not> P (l!i)\"", "lemma all_set_conv_nth: \"(\\<forall>x\\<in>set l. P x) \\<longleftrightarrow> (\\<forall>i<length l. P (l!i))\"", "lemma upt_0_eq_Nil_conv[simp]: \"[0..<j] = [] \\<longleftrightarrow> j=0\"", "lemma filter_eq_snocD: \"filter P l = l'@[x] \\<Longrightarrow> x\\<in>set l \\<and> P x\"", "lemma lists_image_witness:\n  assumes A: \"x\\<in>lists (f`Q)\"\n  obtains xo where \"xo\\<in>lists Q\" \"x=map f xo\"", "lemma map_of_None_filterD:\n  \"map_of xs x = None \\<Longrightarrow> map_of (filter P xs) x = None\"", "lemma map_of_concat: \"map_of (concat xss) = foldr (\\<lambda>xs f. f ++ map_of xs) xss Map.empty\"", "lemma map_of_Some_split:\n  \"map_of xs k = Some v \\<Longrightarrow> \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None\"", "lemma map_add_find_left:\n  \"g k = None \\<Longrightarrow> (f ++ g) k = f k\"", "lemma map_add_left_None:\n  \"f k = None \\<Longrightarrow> (f ++ g) k = g k\"", "lemma map_of_Some_filter_not_in:\n  \"\\<lbrakk> map_of xs k = Some v; \\<not> P (k, v); distinct (map fst xs) \\<rbrakk> \\<Longrightarrow> map_of (filter P xs) k = None\"", "lemma distinct_map_fst_filterI: \"distinct (map fst xs) \\<Longrightarrow> distinct (map fst (filter P xs))\"", "lemma distinct_map_fstD: \"\\<lbrakk> distinct (map fst xs); (x, y) \\<in> set xs; (x, z) \\<in> set xs \\<rbrakk> \\<Longrightarrow> y = z\"", "lemma concat_filter_neq_Nil:\n  \"concat [ys\\<leftarrow>xs. ys \\<noteq> Nil] = concat xs\"", "lemma distinct_concat':\n  \"\\<lbrakk>distinct [ys\\<leftarrow>xs. ys \\<noteq> Nil]; \\<And>ys. ys \\<in> set xs \\<Longrightarrow> distinct ys;\n   \\<And>ys zs. \\<lbrakk>ys \\<in> set xs; zs \\<in> set xs; ys \\<noteq> zs\\<rbrakk> \\<Longrightarrow> set ys \\<inter> set zs = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (concat xs)\"", "lemma distinct_idx:\n  assumes \"distinct (map f l)\"\n  assumes \"i<length l\"\n  assumes \"j<length l\"\n  assumes \"f (l!i) = f (l!j)\"\n  shows \"i=j\"", "lemma replicate_Suc_conv_snoc:\n  \"replicate (Suc n) x = replicate n x @ [x]\"", "lemma filter_nth_ex_nth:\n  assumes \"n < length (filter P xs)\"\n  shows \"\\<exists>m. n \\<le> m \\<and> m < length xs \\<and> filter P xs ! n = xs ! m \\<and> filter P (take m xs) = take n (filter P xs)\"", "lemma set_map_filter:\n  \"set (List.map_filter g xs) = {y. \\<exists>x. x \\<in> set xs \\<and> g x = Some y}\"", "lemma partition_rev_filter_conv :\n  \"partition_rev P (yes, no) xs = (rev (filter P xs) @ yes,  rev (filter (Not \\<circ> P) xs) @ no)\"", "lemma quicksort_by_rel_remove_acc :\n  \"quicksort_by_rel R sl xs = (quicksort_by_rel R [] xs @ sl)\"", "lemma quicksort_by_rel_remove_acc_guared :\n  \"sl \\<noteq> [] \\<Longrightarrow> quicksort_by_rel R sl xs = (quicksort_by_rel R [] xs @ sl)\"", "lemma quicksort_by_rel_permutes [simp]:\n  \"mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\"", "lemma set_quicksort_by_rel [simp]: \"set (quicksort_by_rel R sl xs) = set (xs @ sl)\"", "lemma sorted_wrt_quicksort_by_rel:\n  fixes R:: \"'x \\<Rightarrow> 'x \\<Rightarrow> bool\"\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows \"sorted_wrt R (quicksort_by_rel R [] xs)\"", "lemma sorted_quicksort_by_rel:\n  \"sorted (quicksort_by_rel (\\<le>) [] xs)\"", "lemma sort_quicksort_by_rel:\n  \"sort = quicksort_by_rel (\\<le>) []\"", "lemma [code]: \"quicksort = quicksort_by_rel (\\<le>) []\"", "lemma list_induct_first2 [consumes 0, case_names Nil Sing Cons2]:\nassumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>x1 x2 xs. P xs \\<Longrightarrow> P (x1 # x2 #xs)\"\nshows \"P xs\"", "lemma mergesort_by_rel_split_length :\n  \"length (fst (mergesort_by_rel_split (xs1, xs2) xs)) = length xs1 + (length xs div 2) + (length xs mod 2) \\<and>\n   length (snd (mergesort_by_rel_split (xs1, xs2) xs)) = length xs2 + (length xs div 2)\"", "lemma mset_mergesort_by_rel_split [simp]:\n  \"mset (fst (mergesort_by_rel_split (xs1, xs2) xs)) +\n   mset (snd (mergesort_by_rel_split (xs1, xs2) xs)) =\n   mset xs + mset xs1 + mset xs2\"", "lemma mergesort_by_rel_merge_simps[simp] :\n  \"mergesort_by_rel_merge R (x#xs) (y#ys) =\n     (if R x y then x # mergesort_by_rel_merge R xs (y#ys) else y # mergesort_by_rel_merge R (x#xs) ys)\"\n  \"mergesort_by_rel_merge R xs [] = xs\"\n  \"mergesort_by_rel_merge R [] ys = ys\"", "lemma mergesort_by_rel_merge_induct [consumes 0, case_names Nil1 Nil2 Cons1 Cons2]:\nassumes \"\\<And>xs::'a list. P xs []\" \"\\<And>ys::'b list. P [] ys\"\n        \"\\<And>x xs y ys. R x y \\<Longrightarrow> P xs (y # ys) \\<Longrightarrow> P (x # xs) (y # ys)\"\n        \"\\<And>x xs y ys. \\<not>(R x y) \\<Longrightarrow> P (x # xs) ys \\<Longrightarrow> P (x # xs) (y # ys)\"\nshows \"P xs ys\"", "lemma mset_mergesort_by_rel_merge [simp]:\n  \"mset (mergesort_by_rel_merge R xs ys) = mset xs + mset ys\"", "lemma set_mergesort_by_rel_merge [simp]:\n  \"set (mergesort_by_rel_merge R xs ys) = set xs \\<union> set ys\"", "lemma sorted_wrt_mergesort_by_rel_merge [simp]:\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows  \"sorted_wrt R (mergesort_by_rel_merge R xs ys) \\<longleftrightarrow>\n          sorted_wrt R xs \\<and> sorted_wrt R ys\"", "lemma mergesort_by_rel_simps [simp, code] :\n  \"mergesort_by_rel R [] = []\"\n  \"mergesort_by_rel R [x] = [x]\"\n  \"mergesort_by_rel R (x1 # x2 # xs) =\n   (let (xs1, xs2) = (mergesort_by_rel_split ([x1], [x2]) xs) in\n   mergesort_by_rel_merge R (mergesort_by_rel R xs1) (mergesort_by_rel R xs2))\"", "lemma mergesort_by_rel_permutes [simp]:\n  \"mset (mergesort_by_rel R xs) = mset xs\"", "lemma set_mergesort_by_rel [simp]: \"set (mergesort_by_rel R xs) = set xs\"", "lemma sorted_wrt_mergesort_by_rel:\n  fixes R:: \"'x \\<Rightarrow> 'x \\<Rightarrow> bool\"\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows \"sorted_wrt R (mergesort_by_rel R xs)\"", "lemma sorted_mergesort_by_rel:\n  \"sorted (mergesort_by_rel (\\<le>) xs)\"", "lemma sort_mergesort_by_rel:\n  \"sort = mergesort_by_rel (\\<le>)\"", "lemma sort_mergesort: \"sort = mergesort\"", "lemma merge_correct :\nassumes l1_OK: \"distinct l1 \\<and> sorted l1\"\nassumes l2_OK: \"distinct l2 \\<and> sorted l2\"\nshows \"distinct (merge l1 l2) \\<and> sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2\"", "lemma merge_list_correct :\nassumes ls_OK: \"\\<And>l. l \\<in> set ls \\<Longrightarrow> distinct l \\<and> sorted l\"\nassumes as_OK: \"\\<And>l. l \\<in> set as \\<Longrightarrow> distinct l \\<and> sorted l\"\nshows \"distinct (merge_list as ls) \\<and> sorted (merge_list as ls) \\<and>\n       set (merge_list as ls) = set (concat (as @ ls))\"", "lemma mergesort_remdups_correct :\n  \"distinct (mergesort_remdups l)\n  \\<and> sorted (mergesort_remdups l)\n  \\<and> (set (mergesort_remdups l) = set l)\"", "lemma ex1_eqI: \"\\<lbrakk>\\<exists>!x. P x; P a; P b\\<rbrakk> \\<Longrightarrow> a=b\"", "lemma remdup_sort_mergesort_remdups:\n  \"remdups o sort = mergesort_remdups\" (is \"?lhs=?rhs\")", "lemma int_of_integer_less_iff: \"int_of_integer x < int_of_integer y \\<longleftrightarrow> x<y\"", "lemma nat_of_integer_less_iff: \"x\\<ge>0 \\<Longrightarrow> y\\<ge>0 \\<Longrightarrow> nat_of_integer x < nat_of_integer y \\<longleftrightarrow> x<y\"", "lemma exists_leI:\n  assumes hyp: \"(\\<forall>n' < n. \\<not> P n') \\<Longrightarrow> P (n::nat)\"\n  shows \"\\<exists>n' \\<le> n. P n'\"", "lemma nat_compl_induct[case_names 0 Suc]: \"\\<lbrakk>P 0; \\<And>n . \\<forall>nn. nn \\<le> n \\<longrightarrow> P nn \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\"", "lemma nat_compl_induct'[case_names 0 Suc]: \"\\<lbrakk>P 0; !! n . \\<lbrakk>!! nn . nn \\<le> n \\<Longrightarrow> P nn\\<rbrakk> \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\"", "lemma nz_le_conv_less: \"0<k \\<Longrightarrow> k \\<le> m \\<Longrightarrow> k - Suc 0 < m\"", "lemma min_Suc_gt[simp]: \n    \"a<b \\<Longrightarrow> min (Suc a) b = Suc a\"  \n    \"a<b \\<Longrightarrow> min b (Suc a) = Suc a\"", "lemma atLeastLessThanPlusOne_atLeastAtMost_integer: \"{l..<u+1} = {l..(u::integer)}\"", "lemma atLeastPlusOneAtMost_greaterThanAtMost_integer: \"{l+1..u} = {l<..(u::integer)}\"", "lemma atLeastPlusOneLessThan_greaterThanLessThan_integer:\n    \"{l+1..<u} = {l<..<u::integer}\"", "lemma image_atLeastZeroLessThan_integer: \"0 \\<le> u \\<Longrightarrow>\n    {(0::integer)..<u} = of_nat ` {..<nat_of_integer u}\"", "lemma image_add_integer_atLeastLessThan:\n    \"(%x. x + (l::integer)) ` {0..<u-l} = {l..<u}\"", "lemma finite_atLeastZeroLessThan_integer: \"finite {(0::integer)..<u}\"", "lemma finite_atLeastLessThan_integer [iff]: \"finite {l..<u::integer}\"", "lemma finite_atLeastAtMost_integer [iff]: \"finite {l..(u::integer)}\"", "lemma finite_greaterThanAtMost_integer [iff]: \"finite {l<..(u::integer)}\"", "lemma finite_greaterThanLessThan_integer [iff]: \"finite {l<..<u::integer}\"", "lemma boolfun_cases_helper: \"g=(\\<lambda>x. False) | g=(\\<lambda>x. x) | g=(\\<lambda>x. True) | g= (\\<lambda>x. \\<not>x)\"", "lemma boolfun_cases[case_names False Id True Neg]: \"\\<lbrakk>g=(\\<lambda>x. False) \\<Longrightarrow> P; g=(\\<lambda>x. x) \\<Longrightarrow> P; g=(\\<lambda>x. True) \\<Longrightarrow> P; g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma some_theI: assumes EX: \"\\<exists>a b . P a b\" and BUN: \"!! b1 b2 . \\<lbrakk>\\<exists>a . P a b1; \\<exists>a . P a b2\\<rbrakk> \\<Longrightarrow> b1=b2\"\n    shows \"P (SOME a . \\<exists>b . P a b) (THE b . \\<exists>a . P a b)\"", "lemma some_insert_self[simp]: \"S\\<noteq>{} \\<Longrightarrow> insert (SOME x. x\\<in>S) S = S\"", "lemma some_elem[simp]: \"S\\<noteq>{} \\<Longrightarrow> (SOME x. x\\<in>S) \\<in> S\"", "lemma some_opt_eq_trivial[simp] :\n  \"Eps_Opt (\\<lambda>y. y = x) = Some x\"", "lemma some_opt_sym_eq_trivial[simp] :\n  \"Eps_Opt ((=) x) = Some x\"", "lemma some_opt_false_trivial[simp] :\n  \"Eps_Opt (\\<lambda>_. False) = None\"", "lemma Eps_Opt_eq_None[simp] :\n  \"Eps_Opt P = None \\<longleftrightarrow> \\<not>(Ex P)\"", "lemma Eps_Opt_eq_Some_implies :\n  \"Eps_Opt P = Some x \\<Longrightarrow> P x\"", "lemma Eps_Opt_eq_Some :\nassumes P_prop: \"\\<And>x'. P x \\<Longrightarrow> P x' \\<Longrightarrow> x' = x\"\nshows \"Eps_Opt P = Some x \\<longleftrightarrow> P x\"", "lemma nested_case_prod_simp: \"(\\<lambda>(a,b) c. f a b c) x y =\n  (case_prod (\\<lambda>a b. f a b y) x)\"", "lemma fn_fst_conv: \"(\\<lambda>x. (f (fst x))) = (\\<lambda>(a,_). f a)\"", "lemma fn_snd_conv: \"(\\<lambda>x. (f (snd x))) = (\\<lambda>(_,b). f b)\"", "lemma pairself_image_eq[simp]:\n  \"pairself f ` {(a,b). P a b} = {(f a, f b)| a b. P a b}\"", "lemma pairself_image_cart[simp]: \"pairself f ` (A\\<times>B) = f`A \\<times> f`B\"", "lemma in_prod_fst_sndI: \"fst x \\<in> A \\<Longrightarrow> snd x \\<in> B \\<Longrightarrow> x\\<in>A\\<times>B\"", "lemma inj_Pair[simp]:\n  \"inj_on (\\<lambda>x. (x,c x)) S\"\n  \"inj_on (\\<lambda>x. (c x,x)) S\"", "lemma img_fst [intro]:\n  assumes \"(a,b) \\<in> S\"\n  shows \"a \\<in> fst ` S\"", "lemma img_snd [intro]:\n  assumes \"(a,b) \\<in> S\"\n  shows \"b \\<in> snd ` S\"", "lemma range_prod:\n  \"range f \\<subseteq> (range (fst \\<circ> f)) \\<times> (range (snd \\<circ> f))\"", "lemma finite_range_prod:\n  assumes fst: \"finite (range (fst \\<circ> f))\"\n  and     snd: \"finite (range (snd \\<circ> f))\"\n  shows \"finite (range f)\"", "lemma fstE:\n  \"x = (a,b) \\<Longrightarrow> P (fst x) \\<Longrightarrow> P a\"", "lemma sndE:\n  \"x = (a,b) \\<Longrightarrow> P (snd x) \\<Longrightarrow> P b\"", "lemma uncurry_apply[simp]: \"uncurry f (a,b) = f a b\"", "lemma curry_uncurry_id[simp]: \"curry (uncurry f) = f\"", "lemma uncurry_curry_id[simp]: \"uncurry (curry f) = f\"", "lemma do_curry: \"f (a,b) = curry f a b\"", "lemma do_uncurry: \"f a b = uncurry f (a,b)\"", "lemma map_sum_Inr_conv: \"map_sum fl fr s = Inr y \\<longleftrightarrow> (\\<exists>x. s=Inr x \\<and> y = fr x)\"", "lemma map_sum_Inl_conv: \"map_sum fl fr s = Inl y \\<longleftrightarrow> (\\<exists>x. s=Inl x \\<and> y = fl x)\"", "lemma r_le_rtrancl[simp]: \"S\\<subseteq>S\\<^sup>*\"", "lemma rtrancl_mono_rightI: \"S\\<subseteq>S' \\<Longrightarrow> S\\<subseteq>S'\\<^sup>*\"", "lemma trancl_sub:\n    \"R \\<subseteq> R\\<^sup>+\"", "lemma trancl_single[simp]:\n    \"{(a,b)}\\<^sup>+ = {(a,b)}\"", "lemma converse_rtranclE'[consumes 1, case_names base step]:\n    assumes \"(u,v)\\<in>R\\<^sup>*\"\n    obtains \"u=v\"\n    | vh where \"u\\<noteq>vh\" and \"(u,vh)\\<in>R\" and \"(vh,v)\\<in>R\\<^sup>*\"", "lemma in_rtrancl_insert: \"x\\<in>R\\<^sup>* \\<Longrightarrow> x\\<in>(insert r R)\\<^sup>*\"", "lemma rtrancl_apply_insert: \"R\\<^sup>*``(insert x S) = insert x (R\\<^sup>*``(S\\<union>R``{x}))\"", "lemma rtrancl_last_visit[cases set, case_names no_visit last_visit_point]:\n    shows\n    \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*;\n       (q,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<Longrightarrow> P;\n       !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>+; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P\n     \\<rbrakk> \\<Longrightarrow> P\"", "lemma rtrancl_last_visit': \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*; (q,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<Longrightarrow> P; !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>*; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma rtrancl_last_visit_node:\n    assumes \"(s,s')\\<in>R\\<^sup>*\"\n    shows \"s\\<noteq>sh \\<and> (s,s')\\<in>(R \\<inter> (UNIV \\<times> (-{sh})))\\<^sup>* \\<or>\n            (s,sh)\\<in>R\\<^sup>* \\<and> (sh,s')\\<in>(R \\<inter> (UNIV \\<times> (-{sh})))\\<^sup>*\"", "lemma rtrancl_last_touch: \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*; q\\<in>S; !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>*; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma trancl_over_edgeE:\n    assumes \"(u,w)\\<in>(insert (v1,v2) E)\\<^sup>+\"\n    obtains \"(u,w)\\<in>E\\<^sup>+\"\n    | \"(u,v1)\\<in>E\\<^sup>*\" and \"(v2,w)\\<in>E\\<^sup>*\"", "lemma rtrancl_image_advance: \"\\<lbrakk>q\\<in>R\\<^sup>* `` Q0; (q,x)\\<in>R\\<rbrakk> \\<Longrightarrow> x\\<in>R\\<^sup>* `` Q0\"", "lemma trancl_image_by_rtrancl: \"(E\\<^sup>+)``Vi \\<union> Vi = (E\\<^sup>*)``Vi\"", "lemma reachable_mono: \"\\<lbrakk>R\\<subseteq>R'; X\\<subseteq>X'\\<rbrakk> \\<Longrightarrow> R\\<^sup>*``X \\<subseteq> R'\\<^sup>*``X'\"", "lemma finite_reachable_advance:\n    \"\\<lbrakk> finite (E\\<^sup>*``{v0}); (v0,v)\\<in>E\\<^sup>* \\<rbrakk> \\<Longrightarrow> finite (E\\<^sup>*``{v})\"", "lemma rtrancl_mono_mp: \"U\\<subseteq>V \\<Longrightarrow> x\\<in>U\\<^sup>* \\<Longrightarrow> x\\<in>V\\<^sup>*\"", "lemma trancl_mono_mp: \"U\\<subseteq>V \\<Longrightarrow> x\\<in>U\\<^sup>+ \\<Longrightarrow> x\\<in>V\\<^sup>+\"", "lemma rtrancl_mapI: \"(a,b)\\<in>E\\<^sup>* \\<Longrightarrow> (f a, f b)\\<in>(pairself f `E)\\<^sup>*\"", "lemma rtrancl_image_advance_rtrancl:\n  assumes \"q \\<in> R\\<^sup>*``Q0\"\n  assumes \"(q,x) \\<in> R\\<^sup>*\"\n  shows \"x \\<in> R\\<^sup>*``Q0\"", "lemma nth_step_trancl:\n  \"\\<And>n m. \\<lbrakk> \\<And> n. n < length xs - 1 \\<Longrightarrow> (xs ! Suc n, xs ! n) \\<in> R \\<rbrakk> \\<Longrightarrow> n < length xs \\<Longrightarrow> m < n \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+\"", "lemma Image_empty_trancl_Image_empty:\n  \"R `` {v} = {} \\<Longrightarrow> R\\<^sup>+ `` {v} = {}\"", "lemma Image_empty_rtrancl_Image_id:\n  \"R `` {v} = {} \\<Longrightarrow> R\\<^sup>* `` {v} = {v}\"", "lemma trans_rtrancl_eq_reflcl:\n  \"trans A \\<Longrightarrow> A^* = A^=\"", "lemma refl_on_reflcl_Image:\n  \"refl_on B A \\<Longrightarrow> C \\<subseteq> B \\<Longrightarrow> A^= `` C = A `` C\"", "lemma Image_absorb_rtrancl:\n  \"\\<lbrakk> trans A; refl_on B A; C \\<subseteq> B \\<rbrakk> \\<Longrightarrow> A^* `` C = A `` C\"", "lemma trancl_Image_unfold_left: \"E\\<^sup>+``S = E\\<^sup>*``E``S\"", "lemma trancl_Image_unfold_right: \"E\\<^sup>+``S = E``E\\<^sup>*``S\"", "lemma trancl_Image_advance_ss: \"(u,v)\\<in>E \\<Longrightarrow> E\\<^sup>+``{v} \\<subseteq> E\\<^sup>+``{u}\"", "lemma rtrancl_Image_advance_ss: \"(u,v)\\<in>E \\<Longrightarrow> E\\<^sup>*``{v} \\<subseteq> E\\<^sup>*``{u}\"", "lemma trancl_union_outside:\n  assumes \"(v,w) \\<in> (E\\<union>U)\\<^sup>+\"\n  and \"(v,w) \\<notin> E\\<^sup>+\"\n  shows \"\\<exists>x y. (v,x) \\<in> (E\\<union>U)\\<^sup>* \\<and> (x,y) \\<in> U \\<and> (y,w) \\<in> (E\\<union>U)\\<^sup>*\"", "lemma trancl_restrict_reachable:\n  assumes \"(u,v) \\<in> E\\<^sup>+\"\n  assumes \"E``S \\<subseteq> S\"\n  assumes \"u\\<in>S\"\n  shows \"(u,v) \\<in> (E\\<inter>S\\<times>S)\\<^sup>+\"", "lemma rtrancl_image_unfold_right: \"E``E\\<^sup>*``V \\<subseteq> E\\<^sup>*``V\"", "lemma trancl_Image_in_Range:\n  \"R\\<^sup>+ `` V \\<subseteq> Range R\"", "lemma rtrancl_Image_in_Field:\n  \"R\\<^sup>* `` V \\<subseteq> Field R \\<union> V\"", "lemma rtrancl_sub_insert_rtrancl:\n  \"R\\<^sup>* \\<subseteq> (insert x R)\\<^sup>*\"", "lemma trancl_sub_insert_trancl:\n  \"R\\<^sup>+ \\<subseteq> (insert x R)\\<^sup>+\"", "lemma Restr_rtrancl_mono:\n  \"(v,w) \\<in> (Restr E U)\\<^sup>* \\<Longrightarrow> (v,w) \\<in> E\\<^sup>*\"", "lemma Restr_trancl_mono:\n  \"(v,w) \\<in> (Restr E U)\\<^sup>+ \\<Longrightarrow> (v,w) \\<in> E\\<^sup>+\"", "lemmas converse_add_simps = converse_Times trancl_converse[symmetric] converse_Un converse_Int", "lemma dom_ran_disj_comp[simp]: \"Domain R \\<inter> Range R = {} \\<Longrightarrow> R O R = {}\"", "lemma below_Id_inv[simp]: \"R\\<inverse>\\<subseteq>Id \\<longleftrightarrow> R\\<subseteq>Id\"", "lemma cyclicE: \"\\<lbrakk>\\<not>acyclic g; !!x. (x,x)\\<in>g\\<^sup>+ \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma acyclic_insert_cyclic: \"\\<lbrakk>acyclic g; \\<not>acyclic (insert (x,y) g)\\<rbrakk> \\<Longrightarrow> (y,x)\\<in>g\\<^sup>*\"", "lemma trancl_multi_insert[cases set, case_names orig via]:\n    \"\\<lbrakk> (a,b)\\<in>(r\\<union>X\\<times>{m})\\<^sup>+;\n      (a,b)\\<in>r\\<^sup>+ \\<Longrightarrow> P;\n       !!x. \\<lbrakk> x\\<in>X; (a,x)\\<in>r\\<^sup>*; (m,b)\\<in>r\\<^sup>* \\<rbrakk> \\<Longrightarrow> P\n    \\<rbrakk> \\<Longrightarrow> P\"", "lemma trancl_multi_insert2[cases set, case_names orig via]:\n    \"\\<lbrakk>(a,b)\\<in>(r\\<union>{m}\\<times>X)\\<^sup>+; (a,b)\\<in>r\\<^sup>+ \\<Longrightarrow> P; !!x. \\<lbrakk> x\\<in>X; (a,m)\\<in>r\\<^sup>*; (x,b)\\<in>r\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma cyclic_subset:\n  \"\\<lbrakk> \\<not> acyclic R; R \\<subseteq> S \\<rbrakk> \\<Longrightarrow> \\<not> acyclic S\"", "lemma wf_min: assumes A: \"wf R\" \"R\\<noteq>{}\" \"!!m. m\\<in>Domain R - Range R \\<Longrightarrow> P\" shows P", "lemma finite_wf_eq_wf_converse: \"finite R \\<Longrightarrow> wf (R\\<inverse>) \\<longleftrightarrow> wf R\"", "lemma wf_max: assumes A: \"wf (R\\<inverse>)\" \"R\\<noteq>{}\" and C: \"!!m. m\\<in>Range R - Domain R \\<Longrightarrow> P\" shows \"P\"", "lemma wf_bounded_supset: \"finite S \\<Longrightarrow> wf {(Q',Q). Q'\\<supset>Q \\<and> Q'\\<subseteq> S}\"", "lemma wf_no_path: \"Domain R \\<inter> Range R = {} \\<Longrightarrow> wf R\"", "lemma brk_rel_wf[simp,intro!]:\n  assumes WF[simp]: \"wf R\"\n  shows \"wf (brk_rel R)\"", "lemma rel_restrict_alt_def:\n  \"rel_restrict R A = R \\<inter> (-A) \\<times> (-A)\"", "lemma rel_restrict_empty[simp]:\n  \"rel_restrict R {} = R\"", "lemma rel_restrict_notR:\n  assumes \"(x,y) \\<in> rel_restrict A R\"\n  shows \"x \\<notin> R\" and \"y \\<notin> R\"", "lemma rel_restrict_sub:\n  \"rel_restrict R A \\<subseteq> R\"", "lemma rel_restrict_Int_empty:\n  \"A \\<inter> Field R = {} \\<Longrightarrow> rel_restrict R A = R\"", "lemma Domain_rel_restrict:\n  \"Domain (rel_restrict R A) \\<subseteq> Domain R - A\"", "lemma Range_rel_restrict:\n  \"Range (rel_restrict R A) \\<subseteq> Range R - A\"", "lemma Field_rel_restrict:\n  \"Field (rel_restrict R A) \\<subseteq> Field R - A\"", "lemma rel_restrict_compl:\n  \"rel_restrict R A \\<inter> rel_restrict R (-A) = {}\"", "lemma finite_rel_restrict:\n  \"finite R \\<Longrightarrow> finite (rel_restrict R A)\"", "lemma R_subset_Field: \"R \\<subseteq> Field R \\<times> Field R\"", "lemma homo_rel_restrict_mono:\n  \"R \\<subseteq> B \\<times> B \\<Longrightarrow> rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)\"", "lemma rel_restrict_union:\n  \"rel_restrict R (A \\<union> B) = rel_restrict (rel_restrict R A) B\"", "lemma rel_restrictI:\n  \"x \\<notin> R \\<Longrightarrow> y \\<notin> R \\<Longrightarrow> (x,y) \\<in> E \\<Longrightarrow> (x,y) \\<in> rel_restrict E R\"", "lemma rel_restrict_lift:\n  \"(x,y) \\<in> rel_restrict E R \\<Longrightarrow> (x,y) \\<in> E\"", "lemma rel_restrict_trancl_mem:\n  \"(a,b) \\<in> (rel_restrict A R)\\<^sup>+ \\<Longrightarrow> (a,b) \\<in> rel_restrict (A\\<^sup>+) R\"", "lemma rel_restrict_trancl_sub:\n  \"(rel_restrict A R)\\<^sup>+ \\<subseteq> rel_restrict (A\\<^sup>+) R\"", "lemma rel_restrict_mono:\n  \"A \\<subseteq> B \\<Longrightarrow> rel_restrict A R \\<subseteq> rel_restrict B R\"", "lemma rel_restrict_mono2:\n  \"R \\<subseteq> S \\<Longrightarrow> rel_restrict A S \\<subseteq> rel_restrict A R\"", "lemma rel_restrict_Sigma_sub:\n  \"rel_restrict ((A\\<times>A)\\<^sup>+) R \\<subseteq> ((A - R) \\<times> (A - R))\\<^sup>+\"", "lemma finite_reachable_restrictedI:\n  assumes F: \"finite Q\"\n  assumes I: \"I\\<subseteq>Q\"\n  assumes R: \"Range E \\<subseteq> Q\"\n  shows \"finite (E\\<^sup>*``I)\"", "lemma rtrancl_restrictI_aux:\n    assumes \"(u,v)\\<in>(E-UNIV\\<times>R)\\<^sup>*\"\n    assumes \"u\\<notin>R\"\n    shows \"(u,v)\\<in>(rel_restrict E R)\\<^sup>* \\<and> v\\<notin>R\"", "lemma E_closed_restr_reach_cases:\n  assumes P: \"(u,v)\\<in>E\\<^sup>*\"\n  assumes CL: \"E``R \\<subseteq> R\"\n  obtains \"v\\<in>R\" | \"u\\<notin>R\" \"(u,v)\\<in>(rel_restrict E R)\\<^sup>*\"", "lemma rel_restrict_trancl_notR:\n  assumes \"(v,w) \\<in> (rel_restrict E R)\\<^sup>+\"\n  shows \"v \\<notin> R\" and \"w \\<notin> R\"", "lemma rel_restrict_tranclI:\n  assumes \"(x,y) \\<in> E\\<^sup>+\"\n  and \"x \\<notin> R\" \"y \\<notin> R\"\n  and \"E `` R \\<subseteq> R\"\n  shows \"(x,y) \\<in> (rel_restrict E R)\\<^sup>+\"", "lemma single_valued_inter1: \"single_valued R \\<Longrightarrow> single_valued (R\\<inter>S)\"", "lemma single_valued_inter2: \"single_valued R \\<Longrightarrow> single_valued (S\\<inter>R)\"", "lemma single_valued_below_Id: \"R\\<subseteq>Id \\<Longrightarrow> single_valued R\"", "lemma bijective_alt: \"bijective R \\<longleftrightarrow> single_valued R \\<and> single_valued (R\\<inverse>)\"", "lemma bijective_Id[simp, intro!]: \"bijective Id\"", "lemma bijective_Empty[simp, intro!]: \"bijective {}\"", "lemma pair_vimage_is_Image[simp]: \"(Pair u -` E) = E``{u}\"", "lemma fst_in_Field: \"fst ` R \\<subseteq> Field R\"", "lemma snd_in_Field: \"snd ` R \\<subseteq> Field R\"", "lemma ran_map_of:\n  \"ran (map_of xs) \\<subseteq> snd ` set (xs)\"", "lemma Image_subset_snd_image:\n  \"A `` B \\<subseteq> snd ` A\"", "lemma finite_Image_subset:\n  \"finite (A `` B) \\<Longrightarrow> C \\<subseteq> A \\<Longrightarrow> finite (C `` B)\"", "lemma finite_Field_eq_finite[simp]: \"finite (Field R) \\<longleftrightarrow> finite R\"", "lemma for_in_RI(*[intro]*): \"x\\<in>Domain R \\<Longrightarrow> (x,fun_of_rel R x)\\<in>R\"", "lemma Field_not_elem:\n  \"v \\<notin> Field R \\<Longrightarrow> \\<forall>(x,y) \\<in> R. x \\<noteq> v \\<and> y \\<noteq> v\"", "lemma Sigma_UNIV_cancel[simp]: \"(A \\<times> X - A \\<times> UNIV) = {}\"", "lemma same_fst_trancl[simp]: \"(same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)\"", "lemma le_some_optE: \"\\<lbrakk>Some m\\<le>x; !!m'. \\<lbrakk>x=Some m'; m\\<le>m'\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma not_Some_eq2[simp]: \"(\\<forall>x y. v \\<noteq> Some (x,y)) = (v = None)\"", "lemma ran_add[simp]: \"dom f \\<inter> dom g = {} \\<Longrightarrow> ran (f++g) = ran f \\<union> ran g\"", "lemma nempty_dom: \"\\<lbrakk>e\\<noteq>Map.empty; !!m. m\\<in>dom e \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma le_map_dom_mono: \"m\\<le>m' \\<Longrightarrow> dom m \\<subseteq> dom m'\"", "lemma map_add_first_le: fixes m::\"'a\\<rightharpoonup>('b::order)\" shows \"\\<lbrakk> m\\<le>m' \\<rbrakk> \\<Longrightarrow> m++n \\<le> m'++n\"", "lemma map_add_distinct_le: shows \"\\<lbrakk> m\\<le>m'; n\\<le>n'; dom m' \\<inter> dom n' = {} \\<rbrakk> \\<Longrightarrow> m++n \\<le> m'++n'\"", "lemma map_add_left_comm: assumes A: \"dom A \\<inter> dom B = {}\" shows \"A ++ (B ++ C) = B ++ (A ++ C)\"", "lemmas map_add_ac = map_add_assoc map_add_comm map_add_left_comm", "lemma le_map_restrict[simp]: fixes m :: \"'a \\<rightharpoonup> ('b::order)\" shows \"m |` X \\<le> m\"", "lemma map_of_distinct_upd:\n  \"x \\<notin> set (map fst xs) \\<Longrightarrow> [x \\<mapsto> y] ++ map_of xs = (map_of xs) (x \\<mapsto> y)\"", "lemma map_of_distinct_upd2:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys))(x \\<mapsto> y)\"", "lemma map_of_distinct_upd3:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ (x,y') # ys))(x \\<mapsto> y)\"", "lemma map_of_distinct_upd4:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ ys) = (map_of (xs @ (x,y) # ys))(x := None)\"", "lemma map_of_distinct_lookup:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) x = Some y\"", "lemma ran_distinct:\n  assumes dist: \"distinct (map fst al)\"\n  shows \"ran (map_of al) = snd ` set al\"", "lemma ran_is_image:\n  \"ran M = (the \\<circ> M) ` (dom M)\"", "lemma map_card_eq_iff:\n  assumes finite: \"finite (dom M)\"\n  and card_eq: \"card (dom M) = card (ran M)\"\n  and indom: \"x \\<in> dom M\"\n  shows \"(M x = M y) \\<longleftrightarrow> (x = y)\"", "lemma map_dom_ran_finite:\n  \"finite (dom M) \\<Longrightarrow> finite (ran M)\"", "lemma map_update_eta_repair[simp]:\n  (* An update operation may get simplified, if it happens to be eta-expanded.\n    This lemma tries to repair some common expressions *)\n  \"dom (\\<lambda>x. if x=k then Some v else m x) = insert k (dom m)\"\n  \"m k = None \\<Longrightarrow> ran (\\<lambda>x. if x=k then Some v else m x) = insert v (ran m)\"", "lemma map_leI[intro?]: \"\\<lbrakk>\\<And>x v. m1 x = Some v \\<Longrightarrow> m2 x = Some v\\<rbrakk> \\<Longrightarrow> m1\\<subseteq>\\<^sub>mm2\"", "lemma map_leD: \"m1\\<subseteq>\\<^sub>mm2 \\<Longrightarrow> m1 k = Some v \\<Longrightarrow> m2 k = Some v\"", "lemma map_restrict_insert_none_simp: \"m x = None \\<Longrightarrow> m|`(-insert x s) = m|`(-s)\"", "lemma eq_f_restr_conv: \"s\\<subseteq>dom (f A) \\<and> A = f A |` (-s) \\<longleftrightarrow> A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A\"", "lemma map_mmupd_empty[simp]: \"map_mmupd m {} v = m\"", "lemma mmupd_in_upd[simp]: \"k\\<in>K \\<Longrightarrow> map_mmupd m K v k = Some v\"", "lemma mmupd_notin_upd[simp]: \"k\\<notin>K \\<Longrightarrow> map_mmupd m K v k = m k\"", "lemma map_mmupdE:\n    assumes \"map_mmupd m K v k = Some x\"\n    obtains \"k\\<notin>K\" \"m k = Some x\"\n          | \"k\\<in>K\" \"x=v\"", "lemma dom_mmupd[simp]: \"dom (map_mmupd m K v) = dom m \\<union> K\"", "lemma le_map_mmupd_not_dom[simp, intro!]: \"m \\<subseteq>\\<^sub>m map_mmupd m (K-dom m) v\"", "lemma map_mmupd_update_less: \"K\\<subseteq>K' \\<Longrightarrow> map_mmupd m (K - dom m) v \\<subseteq>\\<^sub>m map_mmupd m (K'-dom m) v\"", "lemma set_to_map_simp :\nassumes inj_on_fst: \"inj_on fst S\"\nshows \"(set_to_map S k = Some v) \\<longleftrightarrow> (k, v) \\<in> S\"", "lemma inj_on_fst_map_to_set :\n  \"inj_on fst (map_to_set m)\"", "lemma map_to_set_inverse :\n   \"set_to_map (map_to_set m) = m\"", "lemma set_to_map_inverse :\nassumes inj_on_fst_S: \"inj_on fst S\"\nshows \"map_to_set (set_to_map S) = S\"", "lemma map_to_set_empty[simp]: \"map_to_set Map.empty = {}\"", "lemma set_to_map_empty[simp]: \"set_to_map {} = Map.empty\"", "lemma map_to_set_empty_iff: \"map_to_set m = {} \\<longleftrightarrow> m = Map.empty\"\n                            \"{} = map_to_set m \\<longleftrightarrow> m = Map.empty\"", "lemma set_to_map_empty_iff: \"set_to_map S = Map.empty \\<longleftrightarrow> S = {}\" (is ?T1)\n                            \"Map.empty = set_to_map S \\<longleftrightarrow> S = {}\" (is ?T2)", "lemma map_to_set_upd[simp]: \"map_to_set (m (k \\<mapsto> v)) = insert (k, v) (map_to_set m - {(k, v') |v'. True})\"", "lemma set_to_map_insert:\nassumes k_nin: \"fst kv \\<notin> fst ` S\"\nshows \"set_to_map (insert kv S) = (set_to_map S) (fst kv \\<mapsto> snd kv)\"", "lemma map_to_set_dom :\n  \"dom m = fst ` (map_to_set m)\"", "lemma map_to_set_ran :\n  \"ran m = snd ` (map_to_set m)\"", "lemma set_to_map_dom :\n  \"dom (set_to_map S) = fst ` S\"", "lemma set_to_map_ran :\n  \"ran (set_to_map S) \\<subseteq> snd ` S\"", "lemma finite_map_to_set:\n\"finite (map_to_set m) = finite (dom m)\"", "lemma card_map_to_set :\n  \"card (map_to_set m) = card (dom m)\"", "lemma map_of_map_to_set :\n\"distinct (map fst l) \\<Longrightarrow>\n map_of l = m \\<longleftrightarrow> set l = map_to_set m\"", "lemma map_to_set_map_of :\n\"distinct (map fst l) \\<Longrightarrow> map_to_set (map_of l) = set l\"", "lemma the_dflt_None_empty[simp]: \"dflt_None_set {} = None\"", "lemma the_dflt_None_nonempty[simp]: \"S\\<noteq>{} \\<Longrightarrow> dflt_None_set S = Some S\"", "lemma the_dflt_None_set[simp]: \"the_default {} (dflt_None_set x) = x\"", "lemma (in order) min_arg_le[simp]:\n  \"n \\<le> min m n \\<longleftrightarrow> min m n = n\"\n  \"m \\<le> min m n \\<longleftrightarrow> min m n = m\"", "lemma (in linorder) min_arg_not_ge[simp]:\n  \"\\<not> min m n < m \\<longleftrightarrow> min m n = m\"\n  \"\\<not> min m n < n \\<longleftrightarrow> min m n = n\"", "lemma (in linorder) min_eq_arg[simp]:\n  \"min m n = m \\<longleftrightarrow> m\\<le>n\"\n  \"min m n = n \\<longleftrightarrow> n\\<le>m\"", "lemma min_simps[simp]:\n  \"a<(b::'a::order) \\<Longrightarrow> min a b = a\"\n  \"b<(a::'a::order) \\<Longrightarrow> min a b = b\"", "lemma (in -) min_less_self_conv[simp]: \n  \"min a b < a \\<longleftrightarrow> b < (a::_::linorder)\" \n  \"min a b < b \\<longleftrightarrow> a < (b::_::linorder)\"", "lemma ord_eq_le_eq_trans: \"\\<lbrakk> a=b; b\\<le>c; c=d \\<rbrakk> \\<Longrightarrow> a\\<le>d\"", "lemma zero_comp_diff_simps[simp]: \n  \"(0::'a::linordered_idom) \\<le> a - b \\<longleftrightarrow> b \\<le> a\" \n  \"(0::'a::linordered_idom) < a - b \\<longleftrightarrow> b < a\"", "lemma mlex_fst_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a<a'\"\n  assumes \"b<N\" \"b'<N\"\n  shows \"a*N + b < a'*N + b'\"", "lemma mlex_leI:\n  fixes a a' b b' N :: nat\n  assumes \"a\\<le>a'\"\n  assumes \"b\\<le>b'\"\n  shows \"a*N + b \\<le> a'*N + b'\"", "lemma mlex_snd_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a=a'\"\n  assumes \"b<b'\"\n  shows \"a*N + b < a'*N + b'\"", "lemma mlex_bound:  \n  fixes a b :: nat\n  assumes \"a<A\"\n  assumes \"b<N\"\n  shows \"a*N + b < A*N\"", "lemma ccpo_Sup_mono:\n  assumes C: \"Complete_Partial_Order.chain (\\<le>) A\"\n    \"Complete_Partial_Order.chain (\\<le>) B\"\n  assumes B: \"\\<forall>x\\<in>A. \\<exists>y\\<in>B. x\\<le>y\"\n  shows \"Sup A \\<le> Sup B\"", "lemma fixp_mono:\n  assumes M: \"monotone (\\<le>) (\\<le>) f\" \"monotone (\\<le>) (\\<le>) g\"\n  assumes LE: \"\\<And>Z. f Z \\<le> g Z\"\n  shows \"ccpo_class.fixp f \\<le> ccpo_class.fixp g\""], "translations": [["", "lemma TERMI: \"TERM x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM x", "unfolding Pure.term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. PROP A \\<Longrightarrow> PROP A", "."], ["", "subsubsection \\<open>HOL\\<close>"], ["", "(* Stronger disjunction elimination rules. *)"], ["", "lemma disjE1: \"\\<lbrakk> P \\<or> Q; P \\<Longrightarrow> R; \\<lbrakk>\\<not>P;Q\\<rbrakk> \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<or> Q; P \\<Longrightarrow> R;\n     \\<lbrakk>\\<not> P; Q\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by metis"], ["", "lemma disjE2: \"\\<lbrakk> P \\<or> Q; \\<lbrakk>P; \\<not>Q\\<rbrakk> \\<Longrightarrow> R; Q \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<or> Q; \\<lbrakk>P; \\<not> Q\\<rbrakk> \\<Longrightarrow> R;\n     Q \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by blast"], ["", "lemma imp_mp_iff[simp]: \n  \"a \\<and> (a \\<longrightarrow> b) \\<longleftrightarrow> a \\<and> b\" \n  \"(a \\<longrightarrow> b) \\<and> a \\<longleftrightarrow> a \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> (a \\<longrightarrow> b)) = (a \\<and> b) &&&\n    ((a \\<longrightarrow> b) \\<and> a) = (a \\<and> b)", "(* is Inductive.imp_conj_iff, but not in simpset by default *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> (a \\<longrightarrow> b)) = (a \\<and> b) &&&\n    ((a \\<longrightarrow> b) \\<and> a) = (a \\<and> b)", "by blast+"], ["", "lemma atomize_Trueprop_eq[atomize]: \"(Trueprop x \\<equiv> Trueprop y) \\<equiv> Trueprop (x=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<equiv> y) \\<equiv> x = y", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<equiv> y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> x \\<equiv> y", "apply (rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<equiv> y; x\\<rbrakk> \\<Longrightarrow> y\n 2. \\<lbrakk>x \\<equiv> y; y\\<rbrakk> \\<Longrightarrow> x\n 3. x = y \\<Longrightarrow> x \\<equiv> y", "apply (erule equal_elim_rule1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<Longrightarrow> x\n 2. \\<lbrakk>x \\<equiv> y; y\\<rbrakk> \\<Longrightarrow> x\n 3. x = y \\<Longrightarrow> x \\<equiv> y", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<equiv> y; y\\<rbrakk> \\<Longrightarrow> x\n 2. x = y \\<Longrightarrow> x \\<equiv> y", "apply (erule equal_elim_rule2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<Longrightarrow> y\n 2. x = y \\<Longrightarrow> x \\<equiv> y", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> x \\<equiv> y", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Set\\<close>"], ["", "lemma inter_compl_diff_conv[simp]: \"A \\<inter> -B = A - B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> - B = A - B", "by auto"], ["", "lemma pair_set_inverse[simp]: \"{(a,b). P a b}\\<inverse> = {(b,a). P a b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). P a b}\\<inverse> = {(b, a). P a b}", "by auto"], ["", "lemma card_doubleton_eq_2_iff[simp]: \"card {a,b} = 2 \\<longleftrightarrow> a\\<noteq>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card {a, b} = 2) = (a \\<noteq> b)", "by auto"], ["", "subsubsection \\<open>List\\<close>"], ["", "(* TODO: Move, analogous to List.length_greater_0_conv *)"], ["", "thm List.length_greater_0_conv"], ["", "lemma length_ge_1_conv[iff]: \"Suc 0 \\<le> length l \\<longleftrightarrow> l\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc 0 \\<le> length l) = (l \\<noteq> [])", "by (cases l) auto\n  \n\\<comment> \\<open>Obtains a list from the pointwise characterization of its elements\\<close>"], ["", "lemma obtain_list_from_elements:\n  assumes A: \"\\<forall>i<n. (\\<exists>li. P li i)\"\n  obtains l where\n    \"length l = n\"\n    \"\\<forall>i<n. P (l!i) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>length l = n; \\<forall>i<n. P (l ! i) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>length l = n; \\<forall>i<n. P (l ! i) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<exists>li. P li i", "have \"\\<exists>l. length l=n \\<and> (\\<forall>i<n. P (l!i) i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<exists>li. P li i\n\ngoal (1 subgoal):\n 1. \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>li. P li i \\<Longrightarrow>\n    \\<exists>l. length l = 0 \\<and> (\\<forall>i<0. P (l ! i) i)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i<0. \\<exists>li. P li i\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>li. P li i \\<Longrightarrow>\n    \\<exists>l. length l = 0 \\<and> (\\<forall>i<0. P (l ! i) i)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<0. \\<exists>li. P li i\n\ngoal (1 subgoal):\n 1. \\<exists>l. length l = 0 \\<and> (\\<forall>i<0. P (l ! i) i)", "by simp"], ["proof (state)\nthis:\n  \\<exists>l. length l = 0 \\<and> (\\<forall>i<0. P (l ! i) i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n  \\<forall>i<Suc n. \\<exists>li. P li i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n  \\<forall>i<Suc n. \\<exists>li. P li i", "obtain l where IH: \"length l = n\" \"(\\<forall>i<n. P(l!i) i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n  \\<forall>i<Suc n. \\<exists>li. P li i\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>length l = n; \\<forall>i<n. P (l ! i) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length l = n\n  \\<forall>i<n. P (l ! i) i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "moreover"], ["proof (state)\nthis:\n  length l = n\n  \\<forall>i<n. P (l ! i) i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n. \\<exists>li. P li i", "obtain ln where \"P ln n\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n. \\<exists>li. P li i\n\ngoal (1 subgoal):\n 1. (\\<And>ln. P ln n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P ln n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "ultimately"], ["proof (chain)\npicking this:\n  length l = n\n  \\<forall>i<n. P (l ! i) i\n  P ln n", "have \"length (l@[ln]) = Suc n\" \"(\\<forall>i<Suc n. P((l@[ln])!i) i)\""], ["proof (prove)\nusing this:\n  length l = n\n  \\<forall>i<n. P (l ! i) i\n  P ln n\n\ngoal (1 subgoal):\n 1. length (l @ [ln]) = Suc n &&& \\<forall>i<Suc n. P ((l @ [ln]) ! i) i", "by (auto simp add: nth_append dest: less_antisym)"], ["proof (state)\nthis:\n  length (l @ [ln]) = Suc n\n  \\<forall>i<Suc n. P ((l @ [ln]) ! i) i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i<n. \\<exists>li. P li i \\<Longrightarrow>\n                \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i);\n        \\<forall>i<Suc n. \\<exists>li. P li i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc n \\<and>\n                            (\\<forall>i<Suc n. P (l ! i) i)", "thus ?case"], ["proof (prove)\nusing this:\n  length (l @ [ln]) = Suc n\n  \\<forall>i<Suc n. P ((l @ [ln]) ! i) i\n\ngoal (1 subgoal):\n 1. \\<exists>l. length l = Suc n \\<and> (\\<forall>i<Suc n. P (l ! i) i)", "by blast"], ["proof (state)\nthis:\n  \\<exists>l. length l = Suc n \\<and> (\\<forall>i<Suc n. P (l ! i) i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>length l = n; \\<forall>i<n. P (l ! i) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>l. length l = n \\<and> (\\<forall>i<n. P (l ! i) i)\n  \\<lbrakk>length ?l = n; \\<forall>i<n. P (?l ! i) i\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (blast)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sorted_mono:\n  assumes S: \"sorted l\"\n  assumes D: \"distinct l\"\n  assumes B: \"i<j\" \"j<length l\"\n  shows \"l!i < l!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! i < l ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l ! i < l ! j", "from S B"], ["proof (chain)\npicking this:\n  sorted l\n  i < j\n  j < length l", "have \"l!i \\<le> l!j\""], ["proof (prove)\nusing this:\n  sorted l\n  i < j\n  j < length l\n\ngoal (1 subgoal):\n 1. l ! i \\<le> l ! j", "by (simp add: sorted_iff_nth_mono)"], ["proof (state)\nthis:\n  l ! i \\<le> l ! j\n\ngoal (1 subgoal):\n 1. l ! i < l ! j", "also"], ["proof (state)\nthis:\n  l ! i \\<le> l ! j\n\ngoal (1 subgoal):\n 1. l ! i < l ! j", "from nth_eq_iff_index_eq[OF D] B"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length l; ?j < length l\\<rbrakk>\n  \\<Longrightarrow> (l ! ?i = l ! ?j) = (?i = ?j)\n  i < j\n  j < length l", "have \"l!i \\<noteq> l!j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length l; ?j < length l\\<rbrakk>\n  \\<Longrightarrow> (l ! ?i = l ! ?j) = (?i = ?j)\n  i < j\n  j < length l\n\ngoal (1 subgoal):\n 1. l ! i \\<noteq> l ! j", "by auto"], ["proof (state)\nthis:\n  l ! i \\<noteq> l ! j\n\ngoal (1 subgoal):\n 1. l ! i < l ! j", "finally"], ["proof (chain)\npicking this:\n  l ! i < l ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  l ! i < l ! j\n\ngoal (1 subgoal):\n 1. l ! i < l ! j", "."], ["proof (state)\nthis:\n  l ! i < l ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sorted_strict_mono_iff:\n  assumes \"distinct l\" \"sorted l\"\n  assumes \"i<length l\" \"j<length l\"\n  shows \"l!i<l!j \\<longleftrightarrow> i<j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i < l ! j) = (i < j)", "using assms"], ["proof (prove)\nusing this:\n  distinct l\n  sorted l\n  i < length l\n  j < length l\n\ngoal (1 subgoal):\n 1. (l ! i < l ! j) = (i < j)", "by (metis distinct_sorted_mono leI less_le_not_le\n    order.strict_iff_order)"], ["", "lemma distinct_sorted_mono_iff:\n  assumes \"distinct l\" \"sorted l\"\n  assumes \"i<length l\" \"j<length l\"\n  shows \"l!i\\<le>l!j \\<longleftrightarrow> i\\<le>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i \\<le> l ! j) = (i \\<le> j)", "by (metis assms distinct_sorted_strict_mono_iff leD le_less_linear)"], ["", "(* List.thy has:\n declare map_eq_Cons_D [dest!]  Cons_eq_map_D [dest!] \n\n  We could, analogously, declare rules for \"map _ _ = _@_\" as dest!,\n  or use elim!, or declare the _conv-rule as simp\n*)"], ["", "lemma map_eq_appendE: \n  assumes \"map f ls = fl@fl'\"\n  obtains l l' where \"ls=l@l'\" and \"map f l=fl\" and  \"map f l' = fl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>ls = l @ l'; map f l = fl; map f l' = fl'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  map f ls = fl @ fl'\n\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>ls = l @ l'; map f l = fl; map f l' = fl'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction fl arbitrary: ls thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a fl ls thesis.\n       \\<lbrakk>\\<And>ls thesis.\n                   \\<lbrakk>\\<And>l l'.\n                               \\<lbrakk>ls = l @ l'; map f l = fl;\n                                map f l' = fl'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f ls = fl @ fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>l l'.\n           \\<lbrakk>ls = l @ l'; map f l = a # fl; map f l' = fl'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f ls = (a # fl) @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>l l'.\n              \\<lbrakk>?ls = l @ l'; map f l = xs; map f l' = fl'\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   map f ?ls = xs @ fl'\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>ls = ?l @ ?l'; map f ?l = x # xs; map f ?l' = fl'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f ls = (x # xs) @ fl'\n\ngoal (2 subgoals):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a fl ls thesis.\n       \\<lbrakk>\\<And>ls thesis.\n                   \\<lbrakk>\\<And>l l'.\n                               \\<lbrakk>ls = l @ l'; map f l = fl;\n                                map f l' = fl'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f ls = fl @ fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>l l'.\n           \\<lbrakk>ls = l @ l'; map f l = a # fl; map f l' = fl'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f ls = (a # fl) @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>l l'.\n              \\<lbrakk>?ls = l @ l'; map f l = xs; map f l' = fl'\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   map f ?ls = xs @ fl'\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>ls = ?l @ ?l'; map f ?l = x # xs; map f ?l' = fl'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f ls = (x # xs) @ fl'", "obtain l ls' where [simp]: \"ls = l#ls'\" \"f l = x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l l'.\n              \\<lbrakk>?ls = l @ l'; map f l = xs; map f l' = fl'\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   map f ?ls = xs @ fl'\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>ls = ?l @ ?l'; map f ?l = x # xs; map f ?l' = fl'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  map f ls = (x # xs) @ fl'\n\ngoal (1 subgoal):\n 1. (\\<And>l ls'.\n        \\<lbrakk>ls = l # ls'; f l = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ls = l # ls'\n  f l = x\n\ngoal (2 subgoals):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a fl ls thesis.\n       \\<lbrakk>\\<And>ls thesis.\n                   \\<lbrakk>\\<And>l l'.\n                               \\<lbrakk>ls = l @ l'; map f l = fl;\n                                map f l' = fl'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f ls = fl @ fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>l l'.\n           \\<lbrakk>ls = l @ l'; map f l = a # fl; map f l' = fl'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f ls = (a # fl) @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Cons.prems(2)"], ["proof (chain)\npicking this:\n  map f ls = (x # xs) @ fl'\n  ls = l # ls'\n  f l = x", "have \"map f ls' = xs @ fl'\""], ["proof (prove)\nusing this:\n  map f ls = (x # xs) @ fl'\n  ls = l # ls'\n  f l = x\n\ngoal (1 subgoal):\n 1. map f ls' = xs @ fl'", "by simp"], ["proof (state)\nthis:\n  map f ls' = xs @ fl'\n\ngoal (2 subgoals):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a fl ls thesis.\n       \\<lbrakk>\\<And>ls thesis.\n                   \\<lbrakk>\\<And>l l'.\n                               \\<lbrakk>ls = l @ l'; map f l = fl;\n                                map f l' = fl'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f ls = fl @ fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>l l'.\n           \\<lbrakk>ls = l @ l'; map f l = a # fl; map f l' = fl'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f ls = (a # fl) @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Cons.IH[OF _ this]"], ["proof (chain)\npicking this:\n  (\\<And>l l'.\n      \\<lbrakk>ls' = l @ l'; map f l = xs; map f l' = fl'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess ll ll'"], ["proof (prove)\nusing this:\n  (\\<And>l l'.\n      \\<lbrakk>ls' = l @ l'; map f l = xs; map f l' = fl'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  ls' = ll @ ll'\n  map f ll = xs\n  map f ll' = fl'\n\ngoal (2 subgoals):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a fl ls thesis.\n       \\<lbrakk>\\<And>ls thesis.\n                   \\<lbrakk>\\<And>l l'.\n                               \\<lbrakk>ls = l @ l'; map f l = fl;\n                                map f l' = fl'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f ls = fl @ fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>l l'.\n           \\<lbrakk>ls = l @ l'; map f l = a # fl; map f l' = fl'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f ls = (a # fl) @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Cons.prems(1)[of \"l#ll\" ll']"], ["proof (chain)\npicking this:\n  \\<lbrakk>ls = (l # ll) @ ll'; map f (l # ll) = x # xs;\n   map f ll' = fl'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  ls' = ll @ ll'\n  map f ll = xs\n  map f ll' = fl'", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ls = (l # ll) @ ll'; map f (l # ll) = x # xs;\n   map f ll' = fl'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  ls' = ll @ ll'\n  map f ll = xs\n  map f ll' = fl'\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>ls thesis.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>ls = l @ l'; map f l = [];\n                    map f l' = fl'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f ls = [] @ fl'\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed simp"], ["", "lemma map_eq_append_conv: \"map f ls = fl@fl' \\<longleftrightarrow> (\\<exists>l l'. ls = l@l' \\<and> map f l = fl \\<and> map f l' = fl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f ls = fl @ fl') =\n    (\\<exists>l l'. ls = l @ l' \\<and> map f l = fl \\<and> map f l' = fl')", "by (auto elim!: map_eq_appendE)"], ["", "lemmas append_eq_mapE = map_eq_appendE[OF sym]"], ["", "lemma append_eq_map_conv: \"fl@fl' = map f ls \\<longleftrightarrow> (\\<exists>l l'. ls = l@l' \\<and> map f l = fl \\<and> map f l' = fl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fl @ fl' = map f ls) =\n    (\\<exists>l l'. ls = l @ l' \\<and> map f l = fl \\<and> map f l' = fl')", "by (auto elim!: append_eq_mapE)"], ["", "lemma distinct_mapI: \"distinct (map f l) \\<Longrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f l) \\<Longrightarrow> distinct l", "by (induct l) auto"], ["", "lemma map_distinct_upd_conv: \n  \"\\<lbrakk>i<length l; distinct l\\<rbrakk> \\<Longrightarrow> (map f l)[i := x] = map (f(l!i := x)) l\"\n  \\<comment> \\<open>Updating a mapped distinct list is equal to updating the \n    mapping function\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; distinct l\\<rbrakk>\n    \\<Longrightarrow> (map f l)[i := x] = map (f(l ! i := x)) l", "by (auto simp: nth_eq_iff_index_eq intro: nth_equalityI)"], ["", "lemma zip_inj: \"\\<lbrakk>length a = length b; length a' = length b'; zip a b = zip a' b'\\<rbrakk> \\<Longrightarrow> a=a' \\<and> b=b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; length a' = length b';\n     zip a b = zip a' b'\\<rbrakk>\n    \\<Longrightarrow> a = a' \\<and> b = b'", "proof (induct a b arbitrary: a' b' rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a' b'.\n       \\<lbrakk>length a' = length b'; zip [] [] = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> [] = a' \\<and> [] = b'\n 2. \\<And>x xs y ys a' b'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>a' b'.\n           \\<lbrakk>length a' = length b'; zip xs ys = zip a' b'\\<rbrakk>\n           \\<Longrightarrow> xs = a' \\<and> ys = b';\n        length a' = length b'; zip (x # xs) (y # ys) = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> x # xs = a' \\<and> y # ys = b'", "case Nil"], ["proof (state)\nthis:\n  length a' = length b'\n  zip [] [] = zip a' b'\n\ngoal (2 subgoals):\n 1. \\<And>a' b'.\n       \\<lbrakk>length a' = length b'; zip [] [] = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> [] = a' \\<and> [] = b'\n 2. \\<And>x xs y ys a' b'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>a' b'.\n           \\<lbrakk>length a' = length b'; zip xs ys = zip a' b'\\<rbrakk>\n           \\<Longrightarrow> xs = a' \\<and> ys = b';\n        length a' = length b'; zip (x # xs) (y # ys) = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> x # xs = a' \\<and> y # ys = b'", "then"], ["proof (chain)\npicking this:\n  length a' = length b'\n  zip [] [] = zip a' b'", "show ?case"], ["proof (prove)\nusing this:\n  length a' = length b'\n  zip [] [] = zip a' b'\n\ngoal (1 subgoal):\n 1. [] = a' \\<and> [] = b'", "by (cases a'; cases b'; auto)"], ["proof (state)\nthis:\n  [] = a' \\<and> [] = b'\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a' b'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>a' b'.\n           \\<lbrakk>length a' = length b'; zip xs ys = zip a' b'\\<rbrakk>\n           \\<Longrightarrow> xs = a' \\<and> ys = b';\n        length a' = length b'; zip (x # xs) (y # ys) = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> x # xs = a' \\<and> y # ys = b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a' b'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>a' b'.\n           \\<lbrakk>length a' = length b'; zip xs ys = zip a' b'\\<rbrakk>\n           \\<Longrightarrow> xs = a' \\<and> ys = b';\n        length a' = length b'; zip (x # xs) (y # ys) = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> x # xs = a' \\<and> y # ys = b'", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>length ?a' = length ?b'; zip xs ys = zip ?a' ?b'\\<rbrakk>\n  \\<Longrightarrow> xs = ?a' \\<and> ys = ?b'\n  length a' = length b'\n  zip (x # xs) (y # ys) = zip a' b'\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a' b'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>a' b'.\n           \\<lbrakk>length a' = length b'; zip xs ys = zip a' b'\\<rbrakk>\n           \\<Longrightarrow> xs = a' \\<and> ys = b';\n        length a' = length b'; zip (x # xs) (y # ys) = zip a' b'\\<rbrakk>\n       \\<Longrightarrow> x # xs = a' \\<and> y # ys = b'", "then"], ["proof (chain)\npicking this:\n  length xs = length ys\n  \\<lbrakk>length ?a' = length ?b'; zip xs ys = zip ?a' ?b'\\<rbrakk>\n  \\<Longrightarrow> xs = ?a' \\<and> ys = ?b'\n  length a' = length b'\n  zip (x # xs) (y # ys) = zip a' b'", "show ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<lbrakk>length ?a' = length ?b'; zip xs ys = zip ?a' ?b'\\<rbrakk>\n  \\<Longrightarrow> xs = ?a' \\<and> ys = ?b'\n  length a' = length b'\n  zip (x # xs) (y # ys) = zip a' b'\n\ngoal (1 subgoal):\n 1. x # xs = a' \\<and> y # ys = b'", "by (cases a'; cases b'; auto)"], ["proof (state)\nthis:\n  x # xs = a' \\<and> y # ys = b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_eq_zip_same_len[simp]:\n  \"\\<lbrakk> length a = length b; length a' = length b' \\<rbrakk> \\<Longrightarrow>\n  zip a b = zip a' b' \\<longleftrightarrow> a=a' \\<and> b=b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; length a' = length b'\\<rbrakk>\n    \\<Longrightarrow> (zip a b = zip a' b') = (a = a' \\<and> b = b')", "by (auto dest: zip_inj)"], ["", "lemma upt_merge[simp]: \"i\\<le>j \\<and> j\\<le>k \\<Longrightarrow> [i..<j]@[j..<k] = [i..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<and> j \\<le> k \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k]", "by (metis le_Suc_ex upt_add_eq_append)"], ["", "(* Maybe this should go into List.thy, next to snoc_eq_iff_butlast *)"], ["", "lemma snoc_eq_iff_butlast':\n  \"(ys = xs @ [x]) \\<longleftrightarrow> (ys \\<noteq> [] \\<and> butlast ys = xs \\<and> last ys = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys = xs @ [x]) =\n    (ys \\<noteq> [] \\<and> butlast ys = xs \\<and> last ys = x)", "by auto"], ["", "(* Case distinction how two elements of a list can be related to each other *)"], ["", "lemma list_match_lel_lel:\n  assumes \"c1 @ qs # c2 = c1' @ qs' # c2'\"\n  obtains\n    (left) c21' where \"c1 = c1' @ qs' # c21'\" \"c2' = c21' @ qs # c2\"\n  | (center) \"c1' = c1\" \"qs' = qs\" \"c2' = c2\"\n  | (right) c21 where \"c1' = c1 @ qs # c21\" \"c2 = c21 @ qs' # c2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c21'.\n                \\<lbrakk>c1 = c1' @ qs' # c21';\n                 c2' = c21' @ qs # c2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c1' = c1; qs' = qs; c2' = c2\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>c21.\n        \\<lbrakk>c1' = c1 @ qs # c21; c2 = c21 @ qs' # c2'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  c1 @ qs # c2 = c1' @ qs' # c2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c21'.\n                \\<lbrakk>c1 = c1' @ qs' # c21';\n                 c2' = c21' @ qs # c2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c1' = c1; qs' = qs; c2' = c2\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>c21.\n        \\<lbrakk>c1' = c1 @ qs # c21; c2 = c21 @ qs' # c2'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (clarsimp simp: append_eq_append_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>\\<And>c21'.\n                   \\<lbrakk>c1 = c1' @ qs' # c21';\n                    c2' = c21' @ qs # c2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<lbrakk>c1' = c1; qs' = qs; c2' = c2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        \\<And>c21.\n           \\<lbrakk>c1' = c1 @ qs # c21; c2 = c21 @ qs' # c2'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        c1 = c1' @ us \\<and> us @ qs # c2 = qs' # c2' \\<or>\n        c1 @ us = c1' \\<and> qs # c2 = us @ qs' # c2'\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for us"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c21'.\n                \\<lbrakk>c1 = c1' @ qs' # c21';\n                 c2' = c21' @ qs # c2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c1' = c1; qs' = qs; c2' = c2\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>c21.\n        \\<lbrakk>c1' = c1 @ qs # c21; c2 = c21 @ qs' # c2'\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     c1 = c1' @ us \\<and> us @ qs # c2 = qs' # c2' \\<or>\n     c1 @ us = c1' \\<and> qs # c2 = us @ qs' # c2'\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases us) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma xy_in_set_cases[consumes 2, case_names EQ XY YX]:\n  assumes A: \"x\\<in>set l\" \"y\\<in>set l\"\n  and C:\n  \"!!l1 l2. \\<lbrakk> x=y; l=l1@y#l2 \\<rbrakk> \\<Longrightarrow> P\"\n  \"!!l1 l2 l3. \\<lbrakk> x\\<noteq>y; l=l1@x#l2@y#l3 \\<rbrakk> \\<Longrightarrow> P\"\n  \"!!l1 l2 l3. \\<lbrakk> x\\<noteq>y; l=l1@y#l2@x#l3 \\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> P\n 2. x \\<noteq> y \\<Longrightarrow> P", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> P\n 2. x \\<noteq> y \\<Longrightarrow> P", "with A(1)"], ["proof (chain)\npicking this:\n  x \\<in> set l\n  x = y", "obtain l1 l2 where \"l=l1@y#l2\""], ["proof (prove)\nusing this:\n  x \\<in> set l\n  x = y\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ y # l2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list)"], ["proof (state)\nthis:\n  l = l1 @ y # l2\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> P\n 2. x \\<noteq> y \\<Longrightarrow> P", "with C(1) True"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = y; l = ?l1.0 @ y # ?l2.0\\<rbrakk> \\<Longrightarrow> P\n  x = y\n  l = l1 @ y # l2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = y; l = ?l1.0 @ y # ?l2.0\\<rbrakk> \\<Longrightarrow> P\n  x = y\n  l = l1 @ y # l2\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "from A(1)"], ["proof (chain)\npicking this:\n  x \\<in> set l", "obtain l1 l2 where S1: \"l=l1@x#l2\""], ["proof (prove)\nusing this:\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ x # l2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list)"], ["proof (state)\nthis:\n  l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "from A(2)"], ["proof (chain)\npicking this:\n  y \\<in> set l", "obtain l1' l2' where S2: \"l=l1'@y#l2'\""], ["proof (prove)\nusing this:\n  y \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>l1' l2'.\n        l = l1' @ y # l2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list)"], ["proof (state)\nthis:\n  l = l1' @ y # l2'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "from S1 S2"], ["proof (chain)\npicking this:\n  l = l1 @ x # l2\n  l = l1' @ y # l2'", "have M: \"l1@x#l2 = l1'@y#l2'\""], ["proof (prove)\nusing this:\n  l = l1 @ x # l2\n  l = l1' @ y # l2'\n\ngoal (1 subgoal):\n 1. l1 @ x # l2 = l1' @ y # l2'", "by simp"], ["proof (state)\nthis:\n  l1 @ x # l2 = l1' @ y # l2'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> P", "thus P"], ["proof (prove)\nusing this:\n  l1 @ x # l2 = l1' @ y # l2'\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: list_match_lel_lel[consumes 1, case_names 1 2 3])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c21'.\n       \\<lbrakk>l1 = l1' @ y # c21'; l2' = c21' @ x # l2\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "case (1 c)"], ["proof (state)\nthis:\n  l1 = l1' @ y # c\n  l2' = c @ x # l2\n\ngoal (3 subgoals):\n 1. \\<And>c21'.\n       \\<lbrakk>l1 = l1' @ y # c21'; l2' = c21' @ x # l2\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "with S1"], ["proof (chain)\npicking this:\n  l = l1 @ x # l2\n  l1 = l1' @ y # c\n  l2' = c @ x # l2", "have \"l=l1'@y#c@x#l2\""], ["proof (prove)\nusing this:\n  l = l1 @ x # l2\n  l1 = l1' @ y # c\n  l2' = c @ x # l2\n\ngoal (1 subgoal):\n 1. l = l1' @ y # c @ x # l2", "by simp"], ["proof (state)\nthis:\n  l = l1' @ y # c @ x # l2\n\ngoal (3 subgoals):\n 1. \\<And>c21'.\n       \\<lbrakk>l1 = l1' @ y # c21'; l2' = c21' @ x # l2\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "with C(3) False"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<noteq> y; l = ?l1.0 @ y # ?l2.0 @ x # ?l3.0\\<rbrakk>\n  \\<Longrightarrow> P\n  x \\<noteq> y\n  l = l1' @ y # c @ x # l2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; l = ?l1.0 @ y # ?l2.0 @ x # ?l3.0\\<rbrakk>\n  \\<Longrightarrow> P\n  x \\<noteq> y\n  l = l1' @ y # c @ x # l2\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "case 2"], ["proof (state)\nthis:\n  l1' = l1\n  y = x\n  l2' = l2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  l1' = l1\n  y = x\n  l2' = l2", "have False"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  l1' = l1\n  y = x\n  l2' = l2\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l1' = l1; y = x; l2' = l2\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P", ".."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "case (3 c)"], ["proof (state)\nthis:\n  l1' = l1 @ x # c\n  l2 = c @ y # l2'\n\ngoal (1 subgoal):\n 1. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "with S1"], ["proof (chain)\npicking this:\n  l = l1 @ x # l2\n  l1' = l1 @ x # c\n  l2 = c @ y # l2'", "have \"l=l1@x#c@y#l2'\""], ["proof (prove)\nusing this:\n  l = l1 @ x # l2\n  l1' = l1 @ x # c\n  l2 = c @ y # l2'\n\ngoal (1 subgoal):\n 1. l = l1 @ x # c @ y # l2'", "by simp"], ["proof (state)\nthis:\n  l = l1 @ x # c @ y # l2'\n\ngoal (1 subgoal):\n 1. \\<And>c21.\n       \\<lbrakk>l1' = l1 @ x # c21; l2 = c21 @ y # l2'\\<rbrakk>\n       \\<Longrightarrow> P", "with C(2) False"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<noteq> y; l = ?l1.0 @ x # ?l2.0 @ y # ?l3.0\\<rbrakk>\n  \\<Longrightarrow> P\n  x \\<noteq> y\n  l = l1 @ x # c @ y # l2'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; l = ?l1.0 @ x # ?l2.0 @ y # ?l3.0\\<rbrakk>\n  \\<Longrightarrow> P\n  x \\<noteq> y\n  l = l1 @ x # c @ y # l2'\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_e_eq_lel[simp]:\n  \"[e] = l1@e'#l2 \\<longleftrightarrow> l1=[] \\<and> e'=e \\<and> l2=[]\"\n  \"l1@e'#l2 = [e] \\<longleftrightarrow> l1=[] \\<and> e'=e \\<and> l2=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([e] = l1 @ e' # l2) = (l1 = [] \\<and> e' = e \\<and> l2 = []) &&&\n    (l1 @ e' # l2 = [e]) = (l1 = [] \\<and> e' = e \\<and> l2 = [])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l1 @ e' # l2 = [e]) = (l1 = [] \\<and> e' = e \\<and> l2 = [])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_ee_eq_leel[simp]:\n  \"([e1,e2] = l1@e1'#e2'#l2) \\<longleftrightarrow> (l1=[] \\<and> e1=e1' \\<and> e2=e2' \\<and> l2=[])\"\n  \"(l1@e1'#e2'#l2 = [e1,e2]) \\<longleftrightarrow> (l1=[] \\<and> e1=e1' \\<and> e2=e2' \\<and> l2=[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([e1, e2] = l1 @ e1' # e2' # l2) =\n    (l1 = [] \\<and> e1 = e1' \\<and> e2 = e2' \\<and> l2 = []) &&&\n    (l1 @ e1' # e2' # l2 = [e1, e2]) =\n    (l1 = [] \\<and> e1 = e1' \\<and> e2 = e2' \\<and> l2 = [])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l1 @ e1' # e2' # l2 = [e1, e2]) =\n    (l1 = [] \\<and> e1 = e1' \\<and> e2 = e2' \\<and> l2 = [])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Transitive Closure\\<close>"], ["", "text \\<open>A point-free induction rule for elements reachable from an initial set\\<close>"], ["", "lemma rtrancl_reachable_induct[consumes 0, case_names base step]:\n  assumes I0: \"I \\<subseteq> INV\"\n  assumes IS: \"E``INV \\<subseteq> INV\"\n  shows \"E\\<^sup>*``I \\<subseteq> INV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` I \\<subseteq> INV", "by (metis I0 IS Image_closed_trancl Image_mono subset_refl)"], ["", "lemma acyclic_empty[simp, intro!]: \"acyclic {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic {}", "by (unfold acyclic_def) auto"], ["", "lemma acyclic_union:\n  \"acyclic (A\\<union>B) \\<Longrightarrow> acyclic A\"\n  \"acyclic (A\\<union>B) \\<Longrightarrow> acyclic B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (acyclic (A \\<union> B) \\<Longrightarrow> acyclic A) &&&\n    (acyclic (A \\<union> B) \\<Longrightarrow> acyclic B)", "by (metis Un_upper1 Un_upper2 acyclic_subset)+"], ["", "subsubsection \\<open>Lattice Syntax\\<close>"], ["", "(* Providing the syntax in a locale makes it more usable, without polluting the global namespace*)"], ["", "locale Lattice_Syntax begin"], ["", "notation\n    bot (\"\\<bottom>\") and\n    top (\"\\<top>\") and\n    inf  (infixl \"\\<sqinter>\" 70) and\n    sup  (infixl \"\\<squnion>\" 65) and\n    Inf  (\"\\<Sqinter>_\" [900] 900) and\n    Sup  (\"\\<Squnion>_\" [900] 900)"], ["", "end"], ["", "text \\<open>Here we provide a collection of miscellaneous definitions and helper lemmas\\<close>"], ["", "subsection \"Miscellaneous (1)\""], ["", "text \\<open>This stuff is used in this theory itself, and thus occurs in first place or is simply not sorted into any other section of this theory.\\<close>"], ["", "lemma IdD: \"(a,b)\\<in>Id \\<Longrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> Id \\<Longrightarrow> a = b", "by simp"], ["", "text \\<open>Conversion Tag\\<close>"], ["", "definition [simp]: \"CNV x y \\<equiv> x=y\""], ["", "lemma CNV_I: \"CNV x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV x x", "by simp"], ["", "lemma CNV_eqD: \"CNV x y \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV x y \\<Longrightarrow> x = y", "by simp"], ["", "lemma CNV_meqD: \"CNV x y \\<Longrightarrow> x\\<equiv>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV x y \\<Longrightarrow> x \\<equiv> y", "by simp"], ["", "(* TODO: Move. Shouldn't this be detected by simproc? *)"], ["", "lemma ex_b_b_and_simp[simp]: \"(\\<exists>b. b \\<and> Q b) \\<longleftrightarrow> Q True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. b \\<and> Q b) = Q True", "by auto"], ["", "lemma ex_b_not_b_and_simp[simp]: \"(\\<exists>b. \\<not>b \\<and> Q b) \\<longleftrightarrow> Q False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. \\<not> b \\<and> Q b) = Q False", "by auto"], ["", "method repeat_all_new methods m = m;(repeat_all_new \\<open>m\\<close>)?"], ["", "subsubsection \"AC-operators\""], ["", "text \\<open>Locale to declare AC-laws as simplification rules\\<close>"], ["", "locale Assoc =\n  fixes f\n  assumes assoc[simp]: \"f (f x y) z = f x (f y z)\""], ["", "locale AC = Assoc +\n  assumes commute[simp]: \"f x y = f y x\""], ["", "lemma (in AC) left_commute[simp]: \"f x (f y z) = f y (f x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x (f y z) = f y (f x z)", "by (simp only: assoc[symmetric]) simp"], ["", "lemmas (in AC) AC_simps = commute assoc left_commute"], ["", "text \\<open>Locale to define functions from surjective, unique relations\\<close>"], ["", "locale su_rel_fun =\n  fixes F and f\n  assumes unique: \"\\<lbrakk>(A,B)\\<in>F; (A,B')\\<in>F\\<rbrakk> \\<Longrightarrow> B=B'\"\n  assumes surjective: \"\\<lbrakk>!!B. (A,B)\\<in>F \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"\n  assumes f_def: \"f A == THE B. (A,B)\\<in>F\""], ["", "lemma (in su_rel_fun) repr1: \"(A,f A)\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, f A) \\<in> F", "proof (unfold f_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, THE B. (A, B) \\<in> F) \\<in> F", "obtain B where \"(A,B)\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. (A, B) \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule surjective)"], ["proof (state)\nthis:\n  (A, B) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, THE B. (A, B) \\<in> F) \\<in> F", "with theI[where P=\"\\<lambda>B. (A,B)\\<in>F\", OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x. (A, x) \\<in> F \\<Longrightarrow> x = B) \\<Longrightarrow>\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n  (A, B) \\<in> F", "show \"(A, THE x. (A, x) \\<in> F) \\<in> F\""], ["proof (prove)\nusing this:\n  (\\<And>x. (A, x) \\<in> F \\<Longrightarrow> x = B) \\<Longrightarrow>\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n  (A, B) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, THE x. (A, x) \\<in> F) \\<in> F", "by (blast intro: unique)"], ["proof (state)\nthis:\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in su_rel_fun) repr2: \"(A,B)\\<in>F \\<Longrightarrow> B=f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, B) \\<in> F \\<Longrightarrow> B = f A", "using repr1"], ["proof (prove)\nusing this:\n  (?A, f ?A) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, B) \\<in> F \\<Longrightarrow> B = f A", "by (blast intro: unique)"], ["", "lemma (in su_rel_fun) repr: \"(f A = B) = ((A,B)\\<in>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f A = B) = ((A, B) \\<in> F)", "using repr1 repr2"], ["proof (prove)\nusing this:\n  (?A, f ?A) \\<in> F\n  (?A, ?B) \\<in> F \\<Longrightarrow> ?B = f ?A\n\ngoal (1 subgoal):\n 1. (f A = B) = ((A, B) \\<in> F)", "by (blast)\n\n    \\<comment> \\<open>Contract quantification over two variables to pair\\<close>"], ["", "lemma Ex_prod_contract: \"(\\<exists>a b. P a b) \\<longleftrightarrow> (\\<exists>z. P (fst z) (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. P a b) = (\\<exists>z. P (fst z) (snd z))", "by auto"], ["", "lemma All_prod_contract: \"(\\<forall>a b. P a b) \\<longleftrightarrow> (\\<forall>z. P (fst z) (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P a b) = (\\<forall>z. P (fst z) (snd z))", "by auto"], ["", "lemma nat_geq_1_eq_neqz: \"x\\<ge>1 \\<longleftrightarrow> x\\<noteq>(0::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> x) = (x \\<noteq> 0)", "by auto"], ["", "lemma nat_in_between_eq:\n  \"(a<b \\<and> b\\<le>Suc a) \\<longleftrightarrow> b = Suc a\"\n  \"(a\\<le>b \\<and> b<Suc a) \\<longleftrightarrow> b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b \\<and> b \\<le> Suc a) = (b = Suc a) &&&\n    (a \\<le> b \\<and> b < Suc a) = (b = a)", "by auto"], ["", "lemma Suc_n_minus_m_eq: \"\\<lbrakk> n\\<ge>m; m>1 \\<rbrakk> \\<Longrightarrow> Suc (n - m) = n - (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; 1 < m\\<rbrakk>\n    \\<Longrightarrow> Suc (n - m) = n - (m - 1)", "by simp"], ["", "lemma Suc_to_right: \"Suc n = m \\<Longrightarrow> n = m - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n = m \\<Longrightarrow> n = m - Suc 0", "by simp"], ["", "lemma Suc_diff[simp]: \"\\<And>n m. n\\<ge>m \\<Longrightarrow> m\\<ge>1 \\<Longrightarrow> Suc (n - m) = n - (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>m \\<le> n; 1 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> Suc (n - m) = n - (m - 1)", "by simp"], ["", "lemma if_not_swap[simp]: \"(if \\<not>c then a else b) = (if c then b else a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<not> c then a else b) = (if c then b else a)", "by auto"], ["", "lemma all_to_meta: \"Trueprop (\\<forall>a. P a) \\<equiv> (\\<And>a. P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. P a \\<equiv> (\\<And>a. P a)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. \\<forall>a. P a \\<Longrightarrow> P a\n 2. (\\<And>a. P a) \\<Longrightarrow> \\<forall>a. P a", "by auto"], ["", "lemma imp_to_meta: \"Trueprop (P\\<longrightarrow>Q) \\<equiv> (P\\<Longrightarrow>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<longrightarrow> Q \\<equiv> (P \\<Longrightarrow> Q)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<longrightarrow> Q; P\\<rbrakk> \\<Longrightarrow> Q\n 2. (P \\<Longrightarrow> Q) \\<Longrightarrow> P \\<longrightarrow> Q", "by auto"], ["", "(* for some reason, there is no such rule in HOL *)"], ["", "lemma iffI2: \"\\<lbrakk>P \\<Longrightarrow> Q; \\<not> P \\<Longrightarrow> \\<not> Q\\<rbrakk> \\<Longrightarrow> P \\<longleftrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow> Q;\n     \\<not> P \\<Longrightarrow> \\<not> Q\\<rbrakk>\n    \\<Longrightarrow> P = Q", "by metis"], ["", "lemma iffExI:\n  \"\\<lbrakk> \\<And>x. P x \\<Longrightarrow> Q x; \\<And>x. Q x \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> (\\<exists>x. P x) \\<longleftrightarrow> (\\<exists>x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P x \\<Longrightarrow> Q x;\n     \\<And>x. Q x \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x. P x) = (\\<exists>x. Q x)", "by metis"], ["", "lemma bex2I[intro?]: \"\\<lbrakk> (a,b)\\<in>S; (a,b)\\<in>S \\<Longrightarrow> P a b \\<rbrakk> \\<Longrightarrow> \\<exists>a b. (a,b)\\<in>S \\<and> P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> S; (a, b) \\<in> S \\<Longrightarrow> P a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> S \\<and> P a b", "by blast"], ["", "(* TODO: Move lemma to HOL! *)"], ["", "lemma cnv_conj_to_meta: \"(P \\<and> Q \\<Longrightarrow> PROP X) \\<equiv> (\\<lbrakk>P;Q\\<rbrakk> \\<Longrightarrow> PROP X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q \\<Longrightarrow> PROP X) \\<equiv>\n    (\\<lbrakk>P; Q\\<rbrakk> \\<Longrightarrow> PROP X)", "by (rule BNF_Fixpoint_Base.conj_imp_eq_imp_imp)"], ["", "subsection \\<open>Sets\\<close>"], ["", "lemma remove_subset: \"x\\<in>S \\<Longrightarrow> S-{x} \\<subset> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> S - {x} \\<subset> S", "by auto"], ["", "lemma subset_minus_empty: \"A\\<subseteq>B \\<Longrightarrow> A-B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> A - B = {}", "by auto"], ["", "lemma insert_minus_eq: \"x\\<noteq>y \\<Longrightarrow> insert x A - {y} = insert x (A - {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> insert x A - {y} = insert x (A - {y})", "by auto"], ["", "lemma set_notEmptyE: \"\\<lbrakk>S\\<noteq>{}; !!x. x\\<in>S \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {}; \\<And>x. x \\<in> S \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (metis equals0I)"], ["", "lemma subset_Collect_conv: \"S \\<subseteq> Collect P \\<longleftrightarrow> (\\<forall>x\\<in>S. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<subseteq> Collect P) = (\\<forall>x\\<in>S. P x)", "by auto"], ["", "lemma memb_imp_not_empty: \"x\\<in>S \\<Longrightarrow> S\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> S \\<noteq> {}", "by auto"], ["", "lemma disjoint_mono: \"\\<lbrakk> a\\<subseteq>a'; b\\<subseteq>b'; a'\\<inter>b'={} \\<rbrakk> \\<Longrightarrow> a\\<inter>b={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<subseteq> a'; b \\<subseteq> b';\n     a' \\<inter> b' = {}\\<rbrakk>\n    \\<Longrightarrow> a \\<inter> b = {}", "by auto"], ["", "lemma disjoint_alt_simp1: \"A-B = A \\<longleftrightarrow> A\\<inter>B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B = A) = (A \\<inter> B = {})", "by auto"], ["", "lemma disjoint_alt_simp2: \"A-B \\<noteq> A \\<longleftrightarrow> A\\<inter>B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B \\<noteq> A) = (A \\<inter> B \\<noteq> {})", "by auto"], ["", "lemma disjoint_alt_simp3: \"A-B \\<subset> A \\<longleftrightarrow> A\\<inter>B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B \\<subset> A) = (A \\<inter> B \\<noteq> {})", "by auto"], ["", "lemma disjointI[intro?]: \"\\<lbrakk> \\<And>x. \\<lbrakk>x\\<in>a; x\\<in>b\\<rbrakk> \\<Longrightarrow> False \\<rbrakk> \\<Longrightarrow> a\\<inter>b={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> a; x \\<in> b\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    a \\<inter> b = {}", "by auto"], ["", "lemmas set_simps = subset_minus_empty disjoint_alt_simp1 disjoint_alt_simp2 disjoint_alt_simp3 Un_absorb1 Un_absorb2"], ["", "lemma set_minus_singleton_eq: \"x\\<notin>X \\<Longrightarrow> X-{x} = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> X \\<Longrightarrow> X - {x} = X", "by auto"], ["", "lemma set_diff_diff_left: \"A-B-C = A-(B\\<union>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B - C = A - (B \\<union> C)", "by auto"], ["", "lemma image_update[simp]: \"x\\<notin>A \\<Longrightarrow> f(x:=n)`A = f`A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Longrightarrow> f(x := n) ` A = f ` A", "by auto"], ["", "lemma eq_or_mem_image_simp[simp]: \"{f l |l. l = a \\<or> l\\<in>B} = insert (f a) {f l|l. l\\<in>B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f l |l. l = a \\<or> l \\<in> B} = insert (f a) {f l |l. l \\<in> B}", "by blast"], ["", "lemma set_union_code [code_unfold]:\n    \"set xs \\<union> set ys = set (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<union> set ys = set (xs @ ys)", "by auto"], ["", "lemma in_fst_imageE:\n    assumes \"x \\<in> fst`S\"\n    obtains y where \"(x,y)\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. (x, y) \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> fst ` S\n\ngoal (1 subgoal):\n 1. (\\<And>y. (x, y) \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma in_snd_imageE:\n    assumes \"y \\<in> snd`S\"\n    obtains x where \"(x,y)\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (x, y) \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> snd ` S\n\ngoal (1 subgoal):\n 1. (\\<And>x. (x, y) \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma fst_image_mp: \"\\<lbrakk>fst`A \\<subseteq> B; (x,y)\\<in>A \\<rbrakk> \\<Longrightarrow> x\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ` A \\<subseteq> B; (x, y) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> x \\<in> B", "by (metis Domain.DomainI fst_eq_Domain in_mono)"], ["", "lemma snd_image_mp: \"\\<lbrakk>snd`A \\<subseteq> B; (x,y)\\<in>A \\<rbrakk> \\<Longrightarrow> y\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd ` A \\<subseteq> B; (x, y) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> y \\<in> B", "by (metis Range.intros rev_subsetD snd_eq_Range)"], ["", "lemma inter_eq_subsetI: \"\\<lbrakk> S\\<subseteq>S'; A\\<inter>S' = B\\<inter>S' \\<rbrakk> \\<Longrightarrow> A\\<inter>S = B\\<inter>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> S'; A \\<inter> S' = B \\<inter> S'\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> S = B \\<inter> S", "by auto"], ["", "text \\<open>\n  Decompose general union over sum types.\n\\<close>"], ["", "lemma Union_plus:\n  \"(\\<Union> x \\<in> A <+> B. f x) = (\\<Union> a \\<in> A. f (Inl a)) \\<union> (\\<Union>b \\<in> B. f (Inr b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (f ` (A <+> B)) =\n    (\\<Union>a\\<in>A. f (Inl a)) \\<union> (\\<Union>b\\<in>B. f (Inr b))", "by auto"], ["", "lemma Union_sum:\n  \"(\\<Union>x. f (x::'a+'b)) = (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range f) =\n    (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (range f) =\n    (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))", "have \"?lhs = (\\<Union>x \\<in> UNIV <+> UNIV. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range f) = \\<Union> (f ` (UNIV <+> UNIV))", "by simp"], ["proof (state)\nthis:\n  \\<Union> (range f) = \\<Union> (f ` (UNIV <+> UNIV))\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) =\n    (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (range f) = \\<Union> (f ` (UNIV <+> UNIV))\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) =\n    (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))", "by (simp only: Union_plus)"], ["proof (state)\nthis:\n  \\<Union> (range f) =\n  (\\<Union>l. f (Inl l)) \\<union> (\\<Union>r. f (Inr r))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Finite Sets\\<close>"], ["", "lemma card_1_singletonI: \"\\<lbrakk>finite S; card S = 1; x\\<in>S\\<rbrakk> \\<Longrightarrow> S={x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; card S = 1; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> S = {x}", "proof (safe, rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: (1 x')"], ["proof (state)\nthis:\n  finite S\n  card S = 1\n  x \\<in> S\n  x' \\<in> S\n  x' \\<notin> {}\n  x' \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"finite (S-{x})\" \"S-{x} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite S\n  card S = 1\n  x \\<in> S\n  x' \\<in> S\n  x' \\<notin> {}\n  x' \\<noteq> x\n\ngoal (1 subgoal):\n 1. finite (S - {x}) &&& S - {x} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  finite (S - {x})\n  S - {x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"card (S-{x}) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite (S - {x})\n  S - {x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (S - {x}) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (S - {x}) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card (S - {x}) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "from prems(1-3)"], ["proof (chain)\npicking this:\n  finite S\n  card S = 1\n  x \\<in> S", "have \"card (S-{x}) = 0\""], ["proof (prove)\nusing this:\n  finite S\n  card S = 1\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. card (S - {x}) = 0", "by auto"], ["proof (state)\nthis:\n  card (S - {x}) = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  card (S - {x}) \\<noteq> 0\n  card (S - {x}) = 0", "have False"], ["proof (prove)\nusing this:\n  card (S - {x}) \\<noteq> 0\n  card (S - {x}) = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite S; card S = 1; x \\<in> S; xa \\<in> S; xa \\<notin> {};\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_insert_disjoint': \"\\<lbrakk>finite A; x \\<notin> A\\<rbrakk> \\<Longrightarrow> card (insert x A) - Suc 0 = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> card (insert x A) - Suc 0 = card A", "by (drule (1) card_insert_disjoint) auto"], ["", "lemma card_eq_UNIV[simp]: \"card (S::'a::finite set) = card (UNIV::'a set) \\<longleftrightarrow> S=UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card S = card UNIV) = (S = UNIV)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. card S = card UNIV \\<Longrightarrow> x \\<in> S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. card S = card UNIV \\<Longrightarrow> x \\<in> S", "assume A: \"card S = card (UNIV::'a set)\""], ["proof (state)\nthis:\n  card S = card UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. card S = card UNIV \\<Longrightarrow> x \\<in> S", "show \"x\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "assume \"x\\<notin>S\""], ["proof (state)\nthis:\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "hence \"S\\<subset>UNIV\""], ["proof (prove)\nusing this:\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. S \\<subset> UNIV", "by auto"], ["proof (state)\nthis:\n  S \\<subset> UNIV\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "with psubset_card_mono[of UNIV S]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite UNIV; S \\<subset> UNIV\\<rbrakk>\n  \\<Longrightarrow> card S < card UNIV\n  S \\<subset> UNIV", "have \"card S < card (UNIV::'a set)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite UNIV; S \\<subset> UNIV\\<rbrakk>\n  \\<Longrightarrow> card S < card UNIV\n  S \\<subset> UNIV\n\ngoal (1 subgoal):\n 1. card S < card UNIV", "by auto"], ["proof (state)\nthis:\n  card S < card UNIV\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  card S = card UNIV\n  card S < card UNIV", "show False"], ["proof (prove)\nusing this:\n  card S = card UNIV\n  card S < card UNIV\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_eq_UNIV2[simp]: \"card (UNIV::'a set) = card (S::'a::finite set) \\<longleftrightarrow> S=UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card UNIV = card S) = (S = UNIV)", "using card_eq_UNIV[of S]"], ["proof (prove)\nusing this:\n  (card S = card UNIV) = (S = UNIV)\n\ngoal (1 subgoal):\n 1. (card UNIV = card S) = (S = UNIV)", "by metis"], ["", "lemma card_ge_UNIV[simp]: \"card (UNIV::'a::finite set) \\<le> card (S::'a set) \\<longleftrightarrow> S=UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card UNIV \\<le> card S) = (S = UNIV)", "using card_mono[of \"UNIV::'a::finite set\" S, simplified]"], ["proof (prove)\nusing this:\n  card S \\<le> card UNIV\n\ngoal (1 subgoal):\n 1. (card UNIV \\<le> card S) = (S = UNIV)", "by auto"], ["", "lemmas length_remdups_card = length_remdups_concat[of \"[l]\", simplified] for l"], ["", "lemma fs_contract: \"fst ` { p | p. f (fst p) (snd p) \\<in> S } = { a . \\<exists>b. f a b \\<in> S }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {p |p. f (fst p) (snd p) \\<in> S} = {a. \\<exists>b. f a b \\<in> S}", "by (simp add: image_Collect)"], ["", "lemma finite_Collect: \"finite S \\<Longrightarrow> inj f \\<Longrightarrow> finite {a. f a : S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; inj f\\<rbrakk>\n    \\<Longrightarrow> finite {a. f a \\<in> S}", "by(simp add: finite_vimageI vimage_def[symmetric])\n\n  \\<comment> \\<open>Finite sets have an injective mapping to an initial segments of the\n      natural numbers\\<close>"], ["", "(* This lemma is also in the standard library (from Isabelle2009-1 on)\n      as @{thm [source] Finite_Set.finite_imp_inj_to_nat_seg}. However, it is formulated with HOL's\n      \\<exists> there rather then with the meta-logic obtain *)"], ["", "lemma finite_imp_inj_to_nat_seg':\n    fixes A :: \"'a set\"\n    assumes A: \"finite A\"\n    obtains f::\"'a \\<Rightarrow> nat\" and n::\"nat\" where\n      \"f`A = {i. i<n}\"\n      \"inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f n.\n        \\<lbrakk>f ` A = {i. i < n}; inj_on f A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis A finite_imp_inj_to_nat_seg)"], ["", "lemma lists_of_len_fin1: \"finite P \\<Longrightarrow> finite (lists P \\<inter> { l. length l = n })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = n})", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = 0})\n 2. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "case 0"], ["proof (state)\nthis:\n  finite P\n\ngoal (2 subgoals):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = 0})\n 2. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "thus ?case"], ["proof (prove)\nusing this:\n  finite P\n\ngoal (1 subgoal):\n 1. finite (lists P \\<inter> {l. length l = 0})", "by auto"], ["proof (state)\nthis:\n  finite (lists P \\<inter> {l. length l = 0})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "case (Suc n)"], ["proof (state)\nthis:\n  finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = n})\n  finite P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "have \"lists P \\<inter> { l. length l = Suc n }\n          = (\\<lambda>(a,l). a#l) ` (P \\<times> (lists P \\<inter> {l. length l = n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists P \\<inter> {l. length l = Suc n} =\n    (\\<lambda>(a, l). a # l) `\n    (P \\<times> (lists P \\<inter> {l. length l = n}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set x. x \\<in> P; length x = Suc n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x.\n                                     case x of (a, l) \\<Rightarrow> a # l) `\n                                 (P \\<times>\n                                  (lists P \\<inter> {l. length l = n}))", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set x. x \\<in> P; length x = Suc n;\n        x = []\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x.\n                                     case x of (a, l) \\<Rightarrow> a # l) `\n                                 (P \\<times>\n                                  (lists P \\<inter> {l. length l = n}))\n 2. \\<And>x a list.\n       \\<lbrakk>\\<forall>x\\<in>set x. x \\<in> P; length x = Suc n;\n        x = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x.\n                                     case x of (a, l) \\<Rightarrow> a # l) `\n                                 (P \\<times>\n                                  (lists P \\<inter> {l. length l = n}))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lists P \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (P \\<times> (lists P \\<inter> {l. length l = n}))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "moreover"], ["proof (state)\nthis:\n  lists P \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (P \\<times> (lists P \\<inter> {l. length l = n}))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "from Suc"], ["proof (chain)\npicking this:\n  finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = n})\n  finite P", "have \"finite \\<dots>\""], ["proof (prove)\nusing this:\n  finite P \\<Longrightarrow> finite (lists P \\<inter> {l. length l = n})\n  finite P\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(a, l). a # l) `\n      (P \\<times> (lists P \\<inter> {l. length l = n})))", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (P \\<times> (lists P \\<inter> {l. length l = n})))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite P \\<Longrightarrow>\n                finite (lists P \\<inter> {l. length l = n});\n        finite P\\<rbrakk>\n       \\<Longrightarrow> finite (lists P \\<inter> {l. length l = Suc n})", "ultimately"], ["proof (chain)\npicking this:\n  lists P \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (P \\<times> (lists P \\<inter> {l. length l = n}))\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (P \\<times> (lists P \\<inter> {l. length l = n})))", "show ?case"], ["proof (prove)\nusing this:\n  lists P \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (P \\<times> (lists P \\<inter> {l. length l = n}))\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (P \\<times> (lists P \\<inter> {l. length l = n})))\n\ngoal (1 subgoal):\n 1. finite (lists P \\<inter> {l. length l = Suc n})", "by simp"], ["proof (state)\nthis:\n  finite (lists P \\<inter> {l. length l = Suc n})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_of_len_fin2: \"finite P \\<Longrightarrow> finite (lists P \\<inter> { l. n = length l })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. n = length l})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. n = length l})", "assume A: \"finite P\""], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. n = length l})", "have S: \"{ l. n = length l } = { l. length l = n }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. n = length l} = {l. length l = n}", "by auto"], ["proof (state)\nthis:\n  {l. n = length l} = {l. length l = n}\n\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. n = length l})", "have \"finite (lists P \\<inter> { l. n = length l })\n      \\<longleftrightarrow> finite (lists P \\<inter> { l. length l = n })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lists P \\<inter> {l. n = length l}) =\n    finite (lists P \\<inter> {l. length l = n})", "by (subst S) simp"], ["proof (state)\nthis:\n  finite (lists P \\<inter> {l. n = length l}) =\n  finite (lists P \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow> finite (lists P \\<inter> {l. n = length l})", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (lists P \\<inter> {l. n = length l}) =\n  finite (lists P \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite (lists P \\<inter> {l. n = length l})", "using lists_of_len_fin1[OF A]"], ["proof (prove)\nusing this:\n  finite (lists P \\<inter> {l. n = length l}) =\n  finite (lists P \\<inter> {l. length l = n})\n  finite (lists P \\<inter> {l. length l = ?n})\n\ngoal (1 subgoal):\n 1. finite (lists P \\<inter> {l. n = length l})", "by auto"], ["proof (state)\nthis:\n  finite (lists P \\<inter> {l. n = length l})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas lists_of_len_fin = lists_of_len_fin1 lists_of_len_fin2"], ["", "(* Try (simp only: cset_fin_simps, fastforce intro: cset_fin_intros) when reasoning about finiteness of collected sets *)"], ["", "lemmas cset_fin_simps = Ex_prod_contract fs_contract[symmetric] image_Collect[symmetric]"], ["", "lemmas cset_fin_intros = finite_imageI finite_Collect inj_onI"], ["", "lemma Un_interval:\n  fixes b1 :: \"'a::linorder\"\n  assumes \"b1\\<le>b2\" and \"b2\\<le>b3\"\n  shows \"{ f i | i. b1\\<le>i \\<and> i<b2 } \\<union> { f i | i. b2\\<le>i \\<and> i<b3 }\n    = {f i | i. b1\\<le>i \\<and> i<b3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f i |i. b1 \\<le> i \\<and> i < b2} \\<union>\n    {f i |i. b2 \\<le> i \\<and> i < b3} =\n    {f i |i. b1 \\<le> i \\<and> i < b3}", "using assms"], ["proof (prove)\nusing this:\n  b1 \\<le> b2\n  b2 \\<le> b3\n\ngoal (1 subgoal):\n 1. {f i |i. b1 \\<le> i \\<and> i < b2} \\<union>\n    {f i |i. b2 \\<le> i \\<and> i < b3} =\n    {f i |i. b1 \\<le> i \\<and> i < b3}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b2} \\<union>\n                      {f i |i. b2 \\<le> i \\<and> i < b3} =\n                      {f i |i. b1 \\<le> i \\<and> i < b3}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b2} \\<union>\n                      {f i |i. b2 \\<le> i \\<and> i < b3}\n                      \\<subseteq> {f i |i. b1 \\<le> i \\<and> i < b3}\n 2. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b3}\n                      \\<subseteq> {f i |i.\n                                   b1 \\<le> i \\<and> i < b2} \\<union>\n                                  {f i |i. b2 \\<le> i \\<and> i < b3}", "apply safe []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i; i < b2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f i = f ia \\<and> b1 \\<le> ia \\<and> ia < b3\n 2. \\<And>x i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b2 \\<le> i; i < b3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f i = f ia \\<and> b1 \\<le> ia \\<and> ia < b3\n 3. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b3}\n                      \\<subseteq> {f i |i.\n                                   b1 \\<le> i \\<and> i < b2} \\<union>\n                                  {f i |i. b2 \\<le> i \\<and> i < b3}", "apply (rule_tac x=i in exI, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b2 \\<le> i; i < b3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f i = f ia \\<and> b1 \\<le> ia \\<and> ia < b3\n 2. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b3}\n                      \\<subseteq> {f i |i.\n                                   b1 \\<le> i \\<and> i < b2} \\<union>\n                                  {f i |i. b2 \\<le> i \\<and> i < b3}", "apply (rule_tac x=i in exI, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3\\<rbrakk>\n    \\<Longrightarrow> {f i |i. b1 \\<le> i \\<and> i < b3}\n                      \\<subseteq> {f i |i.\n                                   b1 \\<le> i \\<and> i < b2} \\<union>\n                                  {f i |i. b2 \\<le> i \\<and> i < b3}", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3;\n        x \\<in> {f i |i. b1 \\<le> i \\<and> i < b3}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f i |i. b1 \\<le> i \\<and> i < b2} \\<union>\n                                 {f i |i. b2 \\<le> i \\<and> i < b3}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3;\n        \\<exists>i. x = f i \\<and> b1 \\<le> i \\<and> i < b3\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             x = f i \\<and> b1 \\<le> i \\<and> i < b2) \\<or>\n                         (\\<exists>i.\n                             x = f i \\<and> b2 \\<le> i \\<and> i < b3)", "apply (elim exE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f i = f ia \\<and>\n                             b1 \\<le> ia \\<and> ia < b2) \\<or>\n                         (\\<exists>ia.\n                             f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3)", "apply (case_tac \"i<b2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        i < b2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f i = f ia \\<and>\n                             b1 \\<le> ia \\<and> ia < b2) \\<or>\n                         (\\<exists>ia.\n                             f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3)\n 2. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        \\<not> i < b2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f i = f ia \\<and>\n                             b1 \\<le> ia \\<and> ia < b2) \\<or>\n                         (\\<exists>ia.\n                             f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3)", "apply (rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        i < b2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f i = f ia \\<and> b1 \\<le> ia \\<and> ia < b2\n 2. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        \\<not> i < b2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f i = f ia \\<and>\n                             b1 \\<le> ia \\<and> ia < b2) \\<or>\n                         (\\<exists>ia.\n                             f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3)", "apply (rule_tac x=i in exI, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        \\<not> i < b2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f i = f ia \\<and>\n                             b1 \\<le> ia \\<and> ia < b2) \\<or>\n                         (\\<exists>ia.\n                             f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3)", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>b1 \\<le> b2; b2 \\<le> b3; b1 \\<le> i \\<and> i < b3;\n        \\<not> i < b2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f i = f ia \\<and> b2 \\<le> ia \\<and> ia < b3", "apply (rule_tac x=i in exI, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The standard library proves that a generalized union is finite\n  if the index set is finite and if for every index the component\n  set is itself finite. Conversely, we show that every component\n  set must be finite when the union is finite.\n\\<close>"], ["", "lemma finite_UNION_then_finite:\n  \"finite (\\<Union>(B ` A)) \\<Longrightarrow> a \\<in> A \\<Longrightarrow> finite (B a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (\\<Union> (B ` A)); a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> finite (B a)", "by (metis Set.set_insert UN_insert Un_infinite)"], ["", "lemma finite_if_eq_beyond_finite: \"finite S \\<Longrightarrow> finite {s. s - S = s' - S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> finite {s. s - S = s' - S}", "proof (rule finite_subset[where B=\"(\\<lambda>s. s \\<union> (s' - S)) ` Pow S\"], clarsimp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; x - S = s' - S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n 2. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; x - S = s' - S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n 2. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "have \"s = (s \\<inter> S) \\<union> (s - S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = s \\<inter> S \\<union> (s - S)", "by auto"], ["proof (state)\nthis:\n  s = s \\<inter> S \\<union> (s - S)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; x - S = s' - S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n 2. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "also"], ["proof (state)\nthis:\n  s = s \\<inter> S \\<union> (s - S)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; x - S = s' - S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n 2. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "assume \"s - S = s' - S\""], ["proof (state)\nthis:\n  s - S = s' - S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; x - S = s' - S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n 2. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "finally"], ["proof (chain)\npicking this:\n  s = s \\<inter> S \\<union> (s' - S)", "show \"s \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\""], ["proof (prove)\nusing this:\n  s = s \\<inter> S \\<union> (s' - S)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S", "by blast"], ["proof (state)\nthis:\n  s \\<in> (\\<lambda>s. s \\<union> (s' - S)) ` Pow S\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    finite ((\\<lambda>s. s \\<union> (s' - S)) ` Pow S)", "qed blast"], ["", "lemma distinct_finite_subset:\n  assumes \"finite x\"\n  shows \"finite {ys. set ys \\<subseteq> x \\<and> distinct ys}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ys. set ys \\<subseteq> x \\<and> distinct ys}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {ys. set ys \\<subseteq> x \\<and> distinct ys} \\<subseteq> ?B\n 2. finite ?B", "from assms"], ["proof (chain)\npicking this:\n  finite x", "show \"?S \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\""], ["proof (prove)\nusing this:\n  finite x\n\ngoal (1 subgoal):\n 1. {ys. set ys \\<subseteq> x \\<and> distinct ys}\n    \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "by clarsimp (metis distinct_card card_mono)"], ["proof (state)\nthis:\n  {ys. set ys \\<subseteq> x \\<and> distinct ys}\n  \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\n\ngoal (1 subgoal):\n 1. finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "from assms"], ["proof (chain)\npicking this:\n  finite x", "show \"finite ...\""], ["proof (prove)\nusing this:\n  finite x\n\ngoal (1 subgoal):\n 1. finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "by (rule finite_lists_length_le)"], ["proof (state)\nthis:\n  finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_finite_set:\n  shows \"finite {ys. set ys = x \\<and> distinct ys}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ys. set ys = x \\<and> distinct ys}", "proof (cases \"finite x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}\n 2. infinite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "case False"], ["proof (state)\nthis:\n  infinite x\n\ngoal (2 subgoals):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}\n 2. infinite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "hence \"{ys. set ys = x} = {}\""], ["proof (prove)\nusing this:\n  infinite x\n\ngoal (1 subgoal):\n 1. {ys. set ys = x} = {}", "by auto"], ["proof (state)\nthis:\n  {ys. set ys = x} = {}\n\ngoal (2 subgoals):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}\n 2. infinite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {ys. set ys = x} = {}\n\ngoal (1 subgoal):\n 1. finite {ys. set ys = x \\<and> distinct ys}", "by simp"], ["proof (state)\nthis:\n  finite {ys. set ys = x \\<and> distinct ys}\n\ngoal (1 subgoal):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "case True"], ["proof (state)\nthis:\n  finite x\n\ngoal (1 subgoal):\n 1. finite x \\<Longrightarrow> finite {ys. set ys = x \\<and> distinct ys}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ys. set ys = x \\<and> distinct ys}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {ys. set ys = x \\<and> distinct ys} \\<subseteq> ?B\n 2. finite ?B", "show \"?S \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys. set ys = x \\<and> distinct ys}\n    \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "using distinct_card"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. {ys. set ys = x \\<and> distinct ys}\n    \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "by force"], ["proof (state)\nthis:\n  {ys. set ys = x \\<and> distinct ys}\n  \\<subseteq> {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\n\ngoal (1 subgoal):\n 1. finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "from True"], ["proof (chain)\npicking this:\n  finite x", "show \"finite ...\""], ["proof (prove)\nusing this:\n  finite x\n\ngoal (1 subgoal):\n 1. finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}", "by (rule finite_lists_length_le)"], ["proof (state)\nthis:\n  finite {ys. set ys \\<subseteq> x \\<and> length ys \\<le> card x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {ys. set ys = x \\<and> distinct ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_set_image:\n  assumes f: \"finite (set ` A)\"\n  and dist: \"\\<And>xs. xs \\<in> A \\<Longrightarrow> distinct xs\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> ?B\n 2. finite ?B", "from f"], ["proof (chain)\npicking this:\n  finite (set ` A)", "show \"finite (set -` (set ` A) \\<inter> {xs. distinct xs})\""], ["proof (prove)\nusing this:\n  finite (set ` A)\n\ngoal (1 subgoal):\n 1. finite (set -` set ` A \\<inter> {xs. distinct xs})", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (set -` {} \\<inter> {xs. distinct xs})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite (set -` F \\<inter> {xs. distinct xs})\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set -` insert x F \\<inter> {xs. distinct xs})", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  finite (set -` F \\<inter> {xs. distinct xs})\n\ngoal (2 subgoals):\n 1. finite (set -` {} \\<inter> {xs. distinct xs})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite (set -` F \\<inter> {xs. distinct xs})\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set -` insert x F \\<inter> {xs. distinct xs})", "have \"finite (set -` {x} \\<inter> {xs. distinct xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set -` {x} \\<inter> {xs. distinct xs})", "apply (simp add: vimage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({xa. set xa = x} \\<inter> {xs. distinct xs})", "by (metis Collect_conj_eq distinct_finite_set)"], ["proof (state)\nthis:\n  finite (set -` {x} \\<inter> {xs. distinct xs})\n\ngoal (2 subgoals):\n 1. finite (set -` {} \\<inter> {xs. distinct xs})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite (set -` F \\<inter> {xs. distinct xs})\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (set -` insert x F \\<inter> {xs. distinct xs})", "with insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  finite (set -` F \\<inter> {xs. distinct xs})\n  finite (set -` {x} \\<inter> {xs. distinct xs})", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  finite (set -` F \\<inter> {xs. distinct xs})\n  finite (set -` {x} \\<inter> {xs. distinct xs})\n\ngoal (1 subgoal):\n 1. finite (set -` insert x F \\<inter> {xs. distinct xs})", "apply (subst vimage_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     finite (set -` F \\<inter> {xs. distinct xs});\n     finite (set -` {x} \\<inter> {xs. distinct xs})\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((set -` {x} \\<union> set -` F) \\<inter>\n                        Collect distinct)", "apply (subst Int_Un_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     finite (set -` F \\<inter> {xs. distinct xs});\n     finite (set -` {x} \\<inter> {xs. distinct xs})\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (set -` {x} \\<inter> Collect distinct \\<union>\n                        set -` F \\<inter> Collect distinct)", "apply (rule finite_UnI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     finite (set -` F \\<inter> {xs. distinct xs});\n     finite (set -` {x} \\<inter> {xs. distinct xs})\\<rbrakk>\n    \\<Longrightarrow> finite (set -` {x} \\<inter> Collect distinct)\n 2. \\<lbrakk>finite F; x \\<notin> F;\n     finite (set -` F \\<inter> {xs. distinct xs});\n     finite (set -` {x} \\<inter> {xs. distinct xs})\\<rbrakk>\n    \\<Longrightarrow> finite (set -` F \\<inter> Collect distinct)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite (set -` insert x F \\<inter> {xs. distinct xs})\n\ngoal (1 subgoal):\n 1. finite (set -` {} \\<inter> {xs. distinct xs})", "qed simp"], ["proof (state)\nthis:\n  finite (set -` set ` A \\<inter> {xs. distinct xs})\n\ngoal (1 subgoal):\n 1. A \\<subseteq> set -` set ` A \\<inter> {xs. distinct xs}", "moreover"], ["proof (state)\nthis:\n  finite (set -` set ` A \\<inter> {xs. distinct xs})\n\ngoal (1 subgoal):\n 1. A \\<subseteq> set -` set ` A \\<inter> {xs. distinct xs}", "from dist"], ["proof (chain)\npicking this:\n  ?xs \\<in> A \\<Longrightarrow> distinct ?xs", "show \"A \\<subseteq> ...\""], ["proof (prove)\nusing this:\n  ?xs \\<in> A \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. A \\<subseteq> set -` set ` A \\<inter> {xs. distinct xs}", "by (auto simp add: vimage_image_eq)"], ["proof (state)\nthis:\n  A \\<subseteq> set -` set ` A \\<inter> {xs. distinct xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Infinite Set\\<close>"], ["", "lemma INFM_nat_inductI:\n  assumes P0: \"P (0::nat)\"\n  assumes PS: \"\\<And>i. P i \\<Longrightarrow> \\<exists>j>i. P j \\<and> Q j\"\n  shows \"\\<exists>\\<^sub>\\<infinity>i. Q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. Q i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. Q i", "have \"\\<forall>i. \\<exists>j>i. P j \\<and> Q j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j>i. P j \\<and> Q j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. P j \\<and> Q j", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. P j \\<and> Q j", "show \"\\<exists>j>i. P j \\<and> Q j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. P j \\<and> Q j", "apply (induction i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>j>0. P j \\<and> Q j\n 2. \\<And>i.\n       \\<exists>j>i. P j \\<and> Q j \\<Longrightarrow>\n       \\<exists>j>Suc i. P j \\<and> Q j", "using PS[OF P0]"], ["proof (prove)\nusing this:\n  \\<exists>j>0. P j \\<and> Q j\n\ngoal (2 subgoals):\n 1. \\<exists>j>0. P j \\<and> Q j\n 2. \\<And>i.\n       \\<exists>j>i. P j \\<and> Q j \\<Longrightarrow>\n       \\<exists>j>Suc i. P j \\<and> Q j", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j>i. P j \\<and> Q j \\<Longrightarrow>\n       \\<exists>j>Suc i. P j \\<and> Q j", "by (metis PS Suc_lessI)"], ["proof (state)\nthis:\n  \\<exists>j>i. P j \\<and> Q j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>j>i. P j \\<and> Q j\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. Q i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j>i. P j \\<and> Q j\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. Q i", "unfolding INFM_nat"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j>i. P j \\<and> Q j\n\ngoal (1 subgoal):\n 1. \\<forall>m. \\<exists>n>m. Q n", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>i. Q i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Functions\\<close>"], ["", "lemma fun_neq_ext_iff: \"m\\<noteq>m' \\<longleftrightarrow> (\\<exists>x. m x \\<noteq> m' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<noteq> m') = (\\<exists>x. m x \\<noteq> m' x)", "by auto"], ["", "definition \"inv_on f A x == SOME y. y\\<in>A \\<and> f y = x\""], ["", "lemma inv_on_f_f[simp]: \"\\<lbrakk>inj_on f A; x\\<in>A\\<rbrakk> \\<Longrightarrow> inv_on f A (f x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> inv_on f A (f x) = x", "by (auto simp add: inv_on_def inj_on_def)"], ["", "lemma f_inv_on_f: \"\\<lbrakk> y\\<in>f`A \\<rbrakk> \\<Longrightarrow> f (inv_on f A y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f ` A \\<Longrightarrow> f (inv_on f A y) = y", "by (auto simp add: inv_on_def intro: someI2)"], ["", "lemma inv_on_f_range: \"\\<lbrakk> y \\<in> f`A \\<rbrakk> \\<Longrightarrow> inv_on f A y \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f ` A \\<Longrightarrow> inv_on f A y \\<in> A", "by (auto simp add: inv_on_def intro: someI2)"], ["", "lemma inj_on_map_inv_f [simp]: \"\\<lbrakk>set l \\<subseteq> A; inj_on f A\\<rbrakk> \\<Longrightarrow> map (inv_on f A) (map f l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subseteq> A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> map (inv_on f A) (map f l) = l", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subseteq> A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> map (inv_on f A \\<circ> f) l = l", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> map (inv_on f A \\<circ> f) [] = []\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>set l \\<subseteq> A; inj_on f A\\<rbrakk>\n                \\<Longrightarrow> map (inv_on f A \\<circ> f) l = l;\n        set (a # l) \\<subseteq> A; inj_on f A\\<rbrakk>\n       \\<Longrightarrow> map (inv_on f A \\<circ> f) (a # l) = a # l", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma comp_cong_right: \"x = y \\<Longrightarrow> f o x = f o y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> f \\<circ> x = f \\<circ> y", "by (simp)"], ["", "lemma comp_cong_left: \"x = y \\<Longrightarrow> x o f = y o f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> x \\<circ> f = y \\<circ> f", "by (simp)"], ["", "lemma fun_comp_eq_conv: \"f o g = fg \\<longleftrightarrow> (\\<forall>x. f (g x) = fg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> g = fg) = (\\<forall>x. f (g x) = fg x)", "by auto"], ["", "abbreviation comp2 (infixl \"oo\" 55) where \"f oo g \\<equiv> \\<lambda>x. f o (g x)\""], ["", "abbreviation comp3 (infixl \"ooo\" 55) where \"f ooo g \\<equiv> \\<lambda>x. f oo (g x)\""], ["", "notation\n  comp2  (infixl \"\\<circ>\\<circ>\" 55) and\n  comp3  (infixl \"\\<circ>\\<circ>\\<circ>\" 55)"], ["", "definition [code_unfold, simp]: \"swap_args2 f x y \\<equiv> f y x\""], ["", "subsection \\<open>Multisets\\<close>"], ["", "(*\n  The following is a syntax extension for multisets. Unfortunately, it depends on a change in the Library/Multiset.thy, so it is commented out here, until it will be incorporated\n  into Library/Multiset.thy by its maintainers.\n\n  The required change in Library/Multiset.thy is removing the syntax for single:\n     - single :: \"'a => 'a multiset\"    (\"{#_#}\")\n     + single :: \"'a => 'a multiset\"\n\n  And adding the following translations instead:\n\n     + syntax\n     + \"_multiset\" :: \"args \\<Rightarrow> 'a multiset\" (\"{#(_)#}\")\n\n     + translations\n     +   \"{#x, xs#}\" == \"{#x#} + {#xs#}\"\n     +   \"{# x #}\" == \"single x\"\n\n  This translates \"{# \\<dots> #}\" into a sum of singletons, that is parenthesized to the right. ?? Can we also achieve left-parenthesizing ??\n\n*)\n\n\n  (* Let's try what happens if declaring AC-rules for multiset union as simp-rules *)\n(*declare union_ac[simp] -- don't do it !*)"], ["", "lemma count_mset_set_finite_iff:\n  \"finite S \\<Longrightarrow> count (mset_set S) a = (if a \\<in> S then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    count (mset_set S) a = (if a \\<in> S then 1 else 0)", "by simp"], ["", "lemma ex_Melem_conv: \"(\\<exists>x. x \\<in># A) = (A \\<noteq> {#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in># A) = (A \\<noteq> {#})", "by (simp add: ex_in_conv)"], ["", "subsubsection \\<open>Count\\<close>"], ["", "lemma count_ne_remove: \"\\<lbrakk> x ~= t\\<rbrakk> \\<Longrightarrow> count S x = count (S-{#t#}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> t \\<Longrightarrow> count S x = count (S - {#t#}) x", "by (auto)"], ["", "lemma mset_empty_count[simp]: \"(\\<forall>p. count M p = 0) = (M={#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. count M p = 0) = (M = {#})", "by (auto simp add: multiset_eq_iff)"], ["", "subsubsection \\<open>Union, difference and intersection\\<close>"], ["", "lemma size_diff_se: \"t \\<in># S \\<Longrightarrow> size S = size (S - {#t#}) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> size S = size (S - {#t#}) + 1", "proof (unfold size_multiset_overloaded_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "let ?SIZE = \"sum (count S) (set_mset S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume A: \"t \\<in># S\""], ["proof (state)\nthis:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from A"], ["proof (chain)\npicking this:\n  t \\<in># S", "have SPLITPRE: \"finite (set_mset S) & {t}\\<subseteq>(set_mset S)\""], ["proof (prove)\nusing this:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S", "by auto"], ["proof (state)\nthis:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "hence \"?SIZE = sum (count S) (set_mset S - {t}) + sum (count S) {t}\""], ["proof (prove)\nusing this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + sum (count S) {t}", "by (blast dest: sum.subset_diff)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + sum (count S) {t}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "hence \"?SIZE = sum (count S) (set_mset S - {t}) + count (S) t\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + sum (count S) {t}\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + count S t", "by auto"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "with A"], ["proof (chain)\npicking this:\n  t \\<in># S\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t", "have \"count S t = count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  t \\<in># S\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. count S t = count (S - {#t#}) t + 1", "by auto"], ["proof (state)\nthis:\n  count S t = count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n  count S t = count (S - {#t#}) t + 1", "have D: \"?SIZE = sum (count S) (set_mset S - {t}) + count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n  count S t = count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1", "by (arith)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "have \"sum (count S) (set_mset S - {t}) = sum (count (S-{#t#})) (set_mset S - {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "have \"\\<forall>x\\<in>(set_mset S - {t}). count S x = count (S-{#t#}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x", "by (auto iff add: count_ne_remove)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})", "have D: \"?SIZE = sum (count (S-{#t#})) (set_mset S - {t}) + count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1", "by (simp)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "{"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume CASE: \"t \\<notin># S - {#t#}\""], ["proof (state)\nthis:\n  t \\<notin># S - {#t#}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from CASE"], ["proof (chain)\npicking this:\n  t \\<notin># S - {#t#}", "have \"set_mset S - {t} = set_mset (S - {#t#})\""], ["proof (prove)\nusing this:\n  t \\<notin># S - {#t#}\n\ngoal (1 subgoal):\n 1. set_mset S - {t} = set_mset (S - {#t#})", "by (auto simp add: in_diff_count split: if_splits)"], ["proof (state)\nthis:\n  set_mset S - {t} = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "with CASE D"], ["proof (chain)\npicking this:\n  t \\<notin># S - {#t#}\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  set_mset S - {t} = set_mset (S - {#t#})", "have \"?SIZE = sum (count (S-{#t#})) (set_mset (S - {#t#})) + 1\""], ["proof (prove)\nusing this:\n  t \\<notin># S - {#t#}\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  set_mset S - {t} = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by (simp add: not_in_iff)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "}"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "{"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume CASE: \"t \\<in># S - {#t#}\""], ["proof (state)\nthis:\n  t \\<in># S - {#t#}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from CASE"], ["proof (chain)\npicking this:\n  t \\<in># S - {#t#}", "have \"t \\<in># S\""], ["proof (prove)\nusing this:\n  t \\<in># S - {#t#}\n\ngoal (1 subgoal):\n 1. t \\<in># S", "by (rule in_diffD)"], ["proof (state)\nthis:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "with CASE"], ["proof (chain)\npicking this:\n  t \\<in># S - {#t#}\n  t \\<in># S", "have 1: \"set_mset S = set_mset (S-{#t#})\""], ["proof (prove)\nusing this:\n  t \\<in># S - {#t#}\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. set_mset S = set_mset (S - {#t#})", "by (auto simp add: in_diff_count split: if_splits)"], ["proof (state)\nthis:\n  set_mset S = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  set_mset S = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from D"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1", "have \"?SIZE = sum (count (S-{#t#})) (set_mset S - {t}) + sum (count (S-{#t#})) {t} + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) +\n    sum (count (S - {#t#})) {t} +\n    1", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from SPLITPRE sum.subset_diff"], ["proof (chain)\npicking this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n  \\<lbrakk>?B \\<subseteq> ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?g (?A - ?B) + sum ?g ?B", "have \"sum (count (S-{#t#})) (set_mset S) = sum (count (S-{#t#})) (set_mset S - {t}) + sum (count (S-{#t#})) {t}\""], ["proof (prove)\nusing this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n  \\<lbrakk>?B \\<subseteq> ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?g (?A - ?B) + sum ?g ?B\n\ngoal (1 subgoal):\n 1. sum (count (S - {#t#})) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}", "by (blast)"], ["proof (state)\nthis:\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  set_mset S = set_mset (S - {#t#})\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}", "have \"?SIZE = sum (count (S-{#t#})) (set_mset (S-{#t#})) + 1\""], ["proof (prove)\nusing this:\n  set_mset S = set_mset (S - {#t#})\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "}"], ["proof (state)\nthis:\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "show \"?SIZE = sum (count (S-{#t#})) (set_mset (S - {#t#})) + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by blast"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Check whether this proof can be done simpler *)"], ["", "lemma mset_union_diff_comm: \"t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = (T + S) - {#t#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "assume \"t \\<in># S\""], ["proof (state)\nthis:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "then"], ["proof (chain)\npicking this:\n  t \\<in># S", "obtain S' where S: \"S = add_mset t S'\""], ["proof (prove)\nusing this:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. (\\<And>S'. S = add_mset t S' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis insert_DiffM)"], ["proof (state)\nthis:\n  S = add_mset t S'\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "then"], ["proof (chain)\npicking this:\n  S = add_mset t S'", "show ?thesis"], ["proof (prove)\nusing this:\n  S = add_mset t S'\n\ngoal (1 subgoal):\n 1. T + (S - {#t#}) = T + S - {#t#}", "by auto"], ["proof (state)\nthis:\n  T + (S - {#t#}) = T + S - {#t#}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*  lemma mset_diff_diff_left: \"A-B-C = A-((B::'a multiset)+C)\" proof -\n    have \"\\<forall>e . count (A-B-C) e = count (A-(B+C)) e\" by auto\n    thus ?thesis by (simp add: multiset_eq_conv_count_eq)\n  qed\n\n  lemma mset_diff_commute: \"A-B-C = A-C-(B::'a multiset)\" proof -\n    have \"A-B-C = A-(B+C)\" by (simp add: mset_diff_diff_left)\n    also have \"\\<dots> = A-(C+B)\" by (simp add: union_commute)\n    thus ?thesis by (simp add: mset_diff_diff_left)\n  qed\n\n  lemma mset_diff_same_empty[simp]: \"(S::'a multiset) - S = {#}\"\n  proof -\n    have \"\\<forall>e . count (S-S) e = 0\" by auto\n    hence \"\\<forall>e . ~ (e : set_mset (S-S))\" by auto\n    hence \"set_mset (S-S) = {}\" by blast\n    thus ?thesis by (auto)\n  qed\n*)"], ["", "lemma mset_right_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># B)\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<notin># B\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "by (simp)"], ["", "lemma mset_left_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># A)\\<rbrakk> \\<Longrightarrow> a\\<in>#B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> a \\<in># B", "by (simp)"], ["", "lemmas mset_cancel_union = mset_right_cancel_union mset_left_cancel_union"], ["", "lemma mset_right_cancel_elem: \"\\<lbrakk>a \\<in># A+{#b#}; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + {#b#}; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "by simp"], ["", "lemma mset_left_cancel_elem: \"\\<lbrakk>a \\<in># {#b#}+A; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># {#b#} + A; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "by simp"], ["", "lemmas mset_cancel_elem = mset_right_cancel_elem mset_left_cancel_elem"], ["", "lemma mset_diff_cancel1elem[simp]: \"~(a \\<in># B) \\<Longrightarrow> {#a#}-B = {#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "by (auto simp add: not_in_iff intro!: multiset_eqI)"], ["", "(*  lemma diff_union_inverse[simp]: \"A + B - B = (A::'a multiset)\"\n    by (auto iff add: multiset_eq_conv_count_eq)\n\n  lemma diff_union_inverse2[simp]: \"B + A - B = (A::'a multiset)\"\n    by (auto iff add: multiset_eq_conv_count_eq)\n*)\n  (*lemma union_diff_assoc_se2: \"t \\<in># A \\<Longrightarrow> (A+B)-{#t#} = (A-{#t#}) + B\"\n    by (auto iff add: multiset_eq_conv_count_eq)\n  lemmas union_diff_assoc_se = union_diff_assoc_se1 union_diff_assoc_se2*)"], ["", "lemma union_diff_assoc: \"C-B={#} \\<Longrightarrow> (A+B)-C = A + (B-C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C - B = {#} \\<Longrightarrow> A + B - C = A + (B - C)", "by (simp add: multiset_eq_iff)"], ["", "lemmas mset_neutral_cancel1 = union_left_cancel[where N=\"{#}\", simplified] union_right_cancel[where N=\"{#}\", simplified]"], ["", "declare mset_neutral_cancel1[simp]"], ["", "lemma mset_union_2_elem: \"{#a, b#} = add_mset c M \\<Longrightarrow> {#a#}=M & b=c | a=c & {#b#}=M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a, b#} = add_mset c M \\<Longrightarrow>\n    {#a#} = M \\<and> b = c \\<or> a = c \\<and> {#b#} = M", "by (auto simp: add_eq_conv_diff)"], ["", "lemma mset_un_cases[cases set, case_names left right]:\n    \"\\<lbrakk>a \\<in># A + B; a \\<in># A \\<Longrightarrow> P; a \\<in># B \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<in># A \\<Longrightarrow> P;\n     a \\<in># B \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto)"], ["", "lemma mset_unplusm_dist_cases[cases set, case_names left right]:\n    assumes A: \"{#s#}+A = B+C\"\n    assumes L: \"\\<lbrakk>B={#s#}+(B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C={#s#}+(C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\"\n    shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A[symmetric]"], ["proof (chain)\npicking this:\n  B + C = {#s#} + A", "have \"s \\<in># B+C\""], ["proof (prove)\nusing this:\n  B + C = {#s#} + A\n\ngoal (1 subgoal):\n 1. s \\<in># B + C", "by simp"], ["proof (state)\nthis:\n  s \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  s \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_un_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "case left"], ["proof (state)\nthis:\n  s \\<in># B\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "hence 1: \"B={#s#}+(B-{#s#})\""], ["proof (prove)\nusing this:\n  s \\<in># B\n\ngoal (1 subgoal):\n 1. B = {#s#} + (B - {#s#})", "by simp"], ["proof (state)\nthis:\n  B = {#s#} + (B - {#s#})\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  {#s#} + A = B + C\n  B = {#s#} + (B - {#s#})", "have \"{#s#}+A = {#s#}+((B-{#s#})+C)\""], ["proof (prove)\nusing this:\n  {#s#} + A = B + C\n  B = {#s#} + (B - {#s#})\n\ngoal (1 subgoal):\n 1. {#s#} + A = {#s#} + (B - {#s#} + C)", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + A = {#s#} + (B - {#s#} + C)\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "hence 2: \"A = (B-{#s#})+C\""], ["proof (prove)\nusing this:\n  {#s#} + A = {#s#} + (B - {#s#} + C)\n\ngoal (1 subgoal):\n 1. A = B - {#s#} + C", "by (simp)"], ["proof (state)\nthis:\n  A = B - {#s#} + C\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "from L[OF 1 2]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "case right"], ["proof (state)\nthis:\n  s \\<in># C\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "hence 1: \"C={#s#}+(C-{#s#})\""], ["proof (prove)\nusing this:\n  s \\<in># C\n\ngoal (1 subgoal):\n 1. C = {#s#} + (C - {#s#})", "by simp"], ["proof (state)\nthis:\n  C = {#s#} + (C - {#s#})\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  {#s#} + A = B + C\n  C = {#s#} + (C - {#s#})", "have \"{#s#}+A = {#s#}+(B+(C-{#s#}))\""], ["proof (prove)\nusing this:\n  {#s#} + A = B + C\n  C = {#s#} + (C - {#s#})\n\ngoal (1 subgoal):\n 1. {#s#} + A = {#s#} + (B + (C - {#s#}))", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + A = {#s#} + (B + (C - {#s#}))\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "hence 2: \"A = B+(C-{#s#})\""], ["proof (prove)\nusing this:\n  {#s#} + A = {#s#} + (B + (C - {#s#}))\n\ngoal (1 subgoal):\n 1. A = B + (C - {#s#})", "by (simp)"], ["proof (state)\nthis:\n  A = B + (C - {#s#})\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "from R[OF 1 2]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_unplusm_dist_cases2[cases set, case_names left right]:\n    assumes A: \"B+C = {#s#}+A\"\n    assumes L: \"\\<lbrakk>B={#s#}+(B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C={#s#}+(C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\"\n    shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using mset_unplusm_dist_cases[OF A[symmetric]] L R"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>B = {#s#} + (B - {#s#}); A = B - {#s#} + C\\<rbrakk>\n           \\<Longrightarrow> ?P;\n   \\<lbrakk>C = {#s#} + (C - {#s#}); A = B + (C - {#s#})\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>B = {#s#} + (B - {#s#}); A = B - {#s#} + C\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>C = {#s#} + (C - {#s#}); A = B + (C - {#s#})\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["", "lemma mset_single_cases[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'={#s#}+(c'-{#s#}); c={#r'#}+(c-{#r'#}); c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "assume CASE: \"s=r'\""], ["proof (state)\nthis:\n  s = r'\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  s = r'", "have \"c=c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  s = r'\n\ngoal (1 subgoal):\n 1. c = c'", "by simp"], ["proof (state)\nthis:\n  c = c'\n\ngoal (1 subgoal):\n 1. P", "with CASE CASES"], ["proof (chain)\npicking this:\n  s = r'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c = c'", "have ?thesis"], ["proof (prove)\nusing this:\n  s = r'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c = c'\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "assume CASE: \"s\\<noteq>r'\""], ["proof (state)\nthis:\n  s \\<noteq> r'\n\ngoal (1 subgoal):\n 1. P", "have \"s \\<in># {#s#}+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in># {#s#} + c", "by simp"], ["proof (state)\nthis:\n  s \\<in># {#s#} + c\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  s \\<in># {#s#} + c", "have \"s \\<in># {#r'#}+c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  s \\<in># {#s#} + c\n\ngoal (1 subgoal):\n 1. s \\<in># {#r'#} + c'", "by simp"], ["proof (state)\nthis:\n  s \\<in># {#r'#} + c'\n\ngoal (1 subgoal):\n 1. P", "with CASE"], ["proof (chain)\npicking this:\n  s \\<noteq> r'\n  s \\<in># {#r'#} + c'", "have \"s \\<in># c'\""], ["proof (prove)\nusing this:\n  s \\<noteq> r'\n  s \\<in># {#r'#} + c'\n\ngoal (1 subgoal):\n 1. s \\<in># c'", "by simp"], ["proof (state)\nthis:\n  s \\<in># c'\n\ngoal (1 subgoal):\n 1. P", "hence 1: \"c' = {#s#} + (c' - {#s#})\""], ["proof (prove)\nusing this:\n  s \\<in># c'\n\ngoal (1 subgoal):\n 1. c' = {#s#} + (c' - {#s#})", "by simp"], ["proof (state)\nthis:\n  c' = {#s#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  c' = {#s#} + (c' - {#s#})", "have \"{#s#}+c = {#s#}+({#r'#}+(c' - {#s#}))\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  c' = {#s#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))\n\ngoal (1 subgoal):\n 1. P", "hence 2: \"c={#r'#}+(c' - {#s#})\""], ["proof (prove)\nusing this:\n  {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))\n\ngoal (1 subgoal):\n 1. c = {#r'#} + (c' - {#s#})", "by (auto)"], ["proof (state)\nthis:\n  c = {#r'#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. P", "hence 3: \"c-{#r'#} = (c' - {#s#})\""], ["proof (prove)\nusing this:\n  c = {#r'#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. c - {#r'#} = c' - {#s#}", "by auto"], ["proof (state)\nthis:\n  c - {#r'#} = c' - {#s#}\n\ngoal (1 subgoal):\n 1. P", "from 1 2 3 CASES"], ["proof (chain)\npicking this:\n  c' = {#s#} + (c' - {#s#})\n  c = {#r'#} + (c' - {#s#})\n  c - {#r'#} = c' - {#s#}\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P", "have ?thesis"], ["proof (prove)\nusing this:\n  c' = {#s#} + (c' - {#s#})\n  c = {#r'#} + (c' - {#s#})\n  c - {#r'#} = c' - {#s#}\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  s \\<noteq> r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  s = r' \\<Longrightarrow> P\n  s \\<noteq> r' \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  s = r' \\<Longrightarrow> P\n  s \\<noteq> r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_single_cases'[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'={#s#}+cc; c={#r'#}+cc; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A  CASES"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + ?cc; c = {#r'#} + ?cc; c' - {#s#} = ?cc;\n   c - {#r'#} = ?cc\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: mset_single_cases)"], ["", "lemma mset_single_cases2[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'=(c'-{#s#})+{#s#}; c=(c-{#r'#})+{#r'#}; c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'", "have \"add_mset s c = add_mset r' c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. add_mset s c = add_mset r' c'", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. P", "using CASES"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = c' - {#s#} + {#s#}; c = c - {#r'#} + {#r'#};\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases rule: mset_single_cases) simp_all"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_single_cases2'[cases set, case_names loc env]:\n    assumes A: \"add_mset s c = add_mset r' c'\"\n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'=cc+{#s#}; c=cc+{#r'#}; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A  CASES"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = ?cc + {#s#}; c = ?cc + {#r'#}; c' - {#s#} = ?cc;\n   c - {#r'#} = ?cc\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: mset_single_cases2)"], ["", "lemma mset_un_single_un_cases [consumes 1, case_names left right]:\n    assumes A: \"add_mset a A = B + C\"\n      and CASES: \"a \\<in># B \\<Longrightarrow> A = (B - {#a#}) + C \\<Longrightarrow> P\"\n        \"a \\<in># C \\<Longrightarrow> A = B + (C - {#a#}) \\<Longrightarrow> P\" shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"a \\<in># A+{#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in># A + {#a#}", "by simp"], ["proof (state)\nthis:\n  a \\<in># A + {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  a \\<in># A + {#a#}", "have \"a \\<in># B+C\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  a \\<in># A + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B + C", "by auto"], ["proof (state)\nthis:\n  a \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_un_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "case left"], ["proof (state)\nthis:\n  a \\<in># B\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "hence \"B=B-{#a#}+{#a#}\""], ["proof (prove)\nusing this:\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. B = B - {#a#} + {#a#}", "by auto"], ["proof (state)\nthis:\n  B = B - {#a#} + {#a#}\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  B = B - {#a#} + {#a#}", "have \"A+{#a#} = (B-{#a#})+C+{#a#}\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  B = B - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. A + {#a#} = B - {#a#} + C + {#a#}", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  A + {#a#} = B - {#a#} + C + {#a#}\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "hence \"A=(B-{#a#})+C\""], ["proof (prove)\nusing this:\n  A + {#a#} = B - {#a#} + C + {#a#}\n\ngoal (1 subgoal):\n 1. A = B - {#a#} + C", "by simp"], ["proof (state)\nthis:\n  A = B - {#a#} + C\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "with CASES(1)[OF left]"], ["proof (chain)\npicking this:\n  A = B - {#a#} + C \\<Longrightarrow> P\n  A = B - {#a#} + C", "show ?thesis"], ["proof (prove)\nusing this:\n  A = B - {#a#} + C \\<Longrightarrow> P\n  A = B - {#a#} + C\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "case right"], ["proof (state)\nthis:\n  a \\<in># C\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "hence \"C=C-{#a#}+{#a#}\""], ["proof (prove)\nusing this:\n  a \\<in># C\n\ngoal (1 subgoal):\n 1. C = C - {#a#} + {#a#}", "by auto"], ["proof (state)\nthis:\n  C = C - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  C = C - {#a#} + {#a#}", "have \"A+{#a#} = B+(C-{#a#})+{#a#}\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  C = C - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. A + {#a#} = B + (C - {#a#}) + {#a#}", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  A + {#a#} = B + (C - {#a#}) + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "hence \"A=B+(C-{#a#})\""], ["proof (prove)\nusing this:\n  A + {#a#} = B + (C - {#a#}) + {#a#}\n\ngoal (1 subgoal):\n 1. A = B + (C - {#a#})", "by simp"], ["proof (state)\nthis:\n  A = B + (C - {#a#})\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "with CASES(2)[OF right]"], ["proof (chain)\npicking this:\n  A = B + (C - {#a#}) \\<Longrightarrow> P\n  A = B + (C - {#a#})", "show ?thesis"], ["proof (prove)\nusing this:\n  A = B + (C - {#a#}) \\<Longrightarrow> P\n  A = B + (C - {#a#})\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Can this proof be done more automatically ? *)"], ["", "lemma mset_distrib[consumes 1, case_names dist]: assumes A: \"(A::'a multiset)+B = M+N\" \"!!Am An Bm Bn. \\<lbrakk>A=Am+An; B=Bm+Bn; M=Am+Bm; N=An+Bn\\<rbrakk> \\<Longrightarrow> P\" shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have BN_MA: \"B - N = M - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - N = M - A", "by (metis (no_types) add_diff_cancel_right assms(1) union_commute)"], ["proof (state)\nthis:\n  B - N = M - A\n\ngoal (1 subgoal):\n 1. P", "have H: \"A = A\\<inter># C + (A - C) \\<inter># D\" if \"A + B = C + D\" for A B C D :: \"'a multiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A \\<inter># C + (A - C) \\<inter># D", "by (metis add.commute diff_intersect_left_idem mset_subset_eq_add_left subset_eq_diff_conv\n          subset_mset.add_diff_inverse subset_mset.inf_absorb1 subset_mset.inf_le1 that)"], ["proof (state)\nthis:\n  ?A + ?B = ?C + ?D \\<Longrightarrow>\n  ?A = ?A \\<inter># ?C + (?A - ?C) \\<inter># ?D\n\ngoal (1 subgoal):\n 1. P", "have A': \"A = A\\<inter># M + (A - M) \\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A \\<inter># M + (A - M) \\<inter># N", "using A(1) H"], ["proof (prove)\nusing this:\n  A + B = M + N\n  ?A + ?B = ?C + ?D \\<Longrightarrow>\n  ?A = ?A \\<inter># ?C + (?A - ?C) \\<inter># ?D\n\ngoal (1 subgoal):\n 1. A = A \\<inter># M + (A - M) \\<inter># N", "by blast"], ["proof (state)\nthis:\n  A = A \\<inter># M + (A - M) \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  A = A \\<inter># M + (A - M) \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "have B': \"B = (B - N) \\<inter># M + B\\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = (B - N) \\<inter># M + B \\<inter># N", "using A(1) H[of B A N M]"], ["proof (prove)\nusing this:\n  A + B = M + N\n  B + A = N + M \\<Longrightarrow> B = B \\<inter># N + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. B = (B - N) \\<inter># M + B \\<inter># N", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  B = (B - N) \\<inter># M + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  B = (B - N) \\<inter># M + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "have \"M = A \\<inter># M + (B - N) \\<inter># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = A \\<inter># M + (B - N) \\<inter># M", "using H[of M N A B] BN_MA[symmetric] A(1)"], ["proof (prove)\nusing this:\n  M + N = A + B \\<Longrightarrow> M = M \\<inter># A + (M - A) \\<inter># B\n  M - A = B - N\n  A + B = M + N\n\ngoal (1 subgoal):\n 1. M = A \\<inter># M + (B - N) \\<inter># M", "by (metis (no_types) diff_intersect_left_idem\n          diff_union_cancelR multiset_inter_commute subset_mset.diff_add subset_mset.inf.cobounded1\n          union_commute)"], ["proof (state)\nthis:\n  M = A \\<inter># M + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  M = A \\<inter># M + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. P", "have \"N = (A - M) \\<inter># N + B \\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = (A - M) \\<inter># N + B \\<inter># N", "by (metis A' assms(1) diff_union_cancelL inter_union_distrib_left inter_union_distrib_right\n          mset_subset_eq_multiset_union_diff_commute subset_mset.inf.cobounded1 subset_mset.inf.commute)"], ["proof (state)\nthis:\n  N = (A - M) \\<inter># N + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N", "show P"], ["proof (prove)\nusing this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "using A(2)"], ["proof (prove)\nusing this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N\n  \\<lbrakk>A = ?Am + ?An; B = ?Bm + ?Bn; M = ?Am + ?Bm;\n   N = ?An + ?Bn\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Singleton multisets\\<close>"], ["", "lemma mset_size_le1_cases[case_names empty singleton,consumes 1]: \"\\<lbrakk> size M \\<le> Suc 0; M={#} \\<Longrightarrow> P; !!m. M={#m#} \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size M \\<le> Suc 0; M = {#} \\<Longrightarrow> P;\n     \\<And>m. M = {#m#} \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases M) auto"], ["", "lemma diff_union_single_conv2: \"a \\<in># J \\<Longrightarrow> J + I - {#a#} = (J - {#a#}) + I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in># J \\<Longrightarrow> J + I - {#a#} = J - {#a#} + I", "by simp"], ["", "lemmas diff_union_single_convs = diff_union_single_conv diff_union_single_conv2"], ["", "lemma mset_contains_eq: \"(m \\<in># M) = ({#m#}+(M-{#m#})=M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<in># M) = ({#m#} + (M - {#m#}) = M)", "using diff_single_trivial"], ["proof (prove)\nusing this:\n  ?x \\<notin># ?M \\<Longrightarrow> ?M - {#?x#} = ?M\n\ngoal (1 subgoal):\n 1. (m \\<in># M) = ({#m#} + (M - {#m#}) = M)", "by fastforce"], ["", "subsubsection \\<open>Pointwise ordering\\<close>"], ["", "(*declare mset_le_trans[trans] Seems to be in there now. Why is this not done in Multiset.thy or order-class ? *)"], ["", "lemma mset_le_incr_right1: \"a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c", "using mset_subset_eq_mono_add[of a b \"{#}\" c, simplified]"], ["proof (prove)\nusing this:\n  a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c\n\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c", "."], ["", "lemma mset_le_incr_right2: \"a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#c+b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># c + b", "using mset_le_incr_right1"], ["proof (prove)\nusing this:\n  ?a \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b + ?c\n\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># c + b", "by (auto simp add: union_commute)"], ["", "lemmas mset_le_incr_right = mset_le_incr_right1 mset_le_incr_right2"], ["", "lemma mset_le_decr_left1: \"a+c\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + c \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "using mset_le_incr_right1 mset_subset_eq_mono_add_right_cancel"], ["proof (prove)\nusing this:\n  ?a \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b + ?c\n  (?A + ?C \\<subseteq># ?B + ?C) = (?A \\<subseteq># ?B)\n\ngoal (1 subgoal):\n 1. a + c \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by blast"], ["", "lemma mset_le_decr_left2: \"c+a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "using mset_le_decr_left1"], ["proof (prove)\nusing this:\n  ?a + ?c \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b\n\ngoal (1 subgoal):\n 1. c + a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by (auto simp add: union_ac)"], ["", "lemma mset_le_add_mset_decr_left1: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset c a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by (simp add: mset_subset_eq_insertD subset_mset.dual_order.strict_implies_order)"], ["", "lemma mset_le_add_mset_decr_left2: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> {#c#}\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset c a \\<subseteq># b \\<Longrightarrow> {#c#} \\<subseteq># b", "by (simp add: mset_subset_eq_insertD subset_mset.dual_order.strict_implies_order)"], ["", "lemmas mset_le_decr_left = mset_le_decr_left1 mset_le_decr_left2 mset_le_add_mset_decr_left1\n    mset_le_add_mset_decr_left2"], ["", "lemma mset_le_subtract: \"A\\<subseteq>#B \\<Longrightarrow> A-C \\<subseteq># B-(C::'a multiset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq># B \\<Longrightarrow> A - C \\<subseteq># B - C", "apply (unfold subseteq_mset_def count_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n    \\<forall>a. count A a - count C a \\<le> count B a - count C a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a - count C a \\<le> count B a - count C a", "apply (subgoal_tac \"count A a \\<le> count B a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a. count A a \\<le> count B a;\n        count A a \\<le> count B a\\<rbrakk>\n       \\<Longrightarrow> count A a - count C a \\<le> count B a - count C a\n 2. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a \\<le> count B a", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a \\<le> count B a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_union_subset: \"A+B \\<subseteq># C \\<Longrightarrow> A\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># C \\<Longrightarrow>\n    A \\<subseteq># C \\<and> B \\<subseteq># C", "by (auto dest: mset_le_decr_left)"], ["", "lemma mset_le_add_mset: \"add_mset x B \\<subseteq># C \\<Longrightarrow> {#x#}\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># C \\<Longrightarrow>\n    {#x#} \\<subseteq># C \\<and> B \\<subseteq># C", "by (auto dest: mset_le_decr_left)"], ["", "lemma mset_le_subtract_left: \"A+B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-A \\<and> A\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># X \\<Longrightarrow>\n    B \\<subseteq># X - A \\<and> A \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"A+B\" \"X\" \"A\"] mset_union_subset)"], ["", "lemma mset_le_subtract_right: \"A+B \\<subseteq># (X::'a multiset) \\<Longrightarrow> A \\<subseteq># X-B \\<and> B\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># X \\<Longrightarrow>\n    A \\<subseteq># X - B \\<and> B \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"A+B\" \"X\" \"B\"] mset_union_subset)"], ["", "lemma mset_le_subtract_add_mset_left: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-{#x#} \\<and> {#x#}\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># X \\<Longrightarrow>\n    B \\<subseteq># X - {#x#} \\<and> {#x#} \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"add_mset x B\" \"X\" \"{#x#}\"] mset_le_add_mset)"], ["", "lemma mset_le_subtract_add_mset_right: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> {#x#} \\<subseteq># X-B \\<and> B\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># X \\<Longrightarrow>\n    {#x#} \\<subseteq># X - B \\<and> B \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"add_mset x B\" \"X\" \"B\"] mset_le_add_mset)"], ["", "lemma mset_le_addE: \"\\<lbrakk> xs \\<subseteq># (ys::'a multiset); !!zs. ys=xs+zs \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<subseteq># ys;\n     \\<And>zs. ys = xs + zs \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "using mset_subset_eq_exists_conv"], ["proof (prove)\nusing this:\n  (?A \\<subseteq># ?B) = (\\<exists>C. ?B = ?A + C)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<subseteq># ys;\n     \\<And>zs. ys = xs + zs \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "declare subset_mset.diff_add[simp, intro]"], ["", "lemma mset_2dist2_cases:\n    assumes A: \"{#a#}+{#b#} \\<subseteq># A+B\"\n    assumes CASES: \"{#a#}+{#b#} \\<subseteq># A \\<Longrightarrow> P\" \"{#a#}+{#b#} \\<subseteq># B \\<Longrightarrow> P\" \"\\<lbrakk>a \\<in># A; b \\<in># B\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>a \\<in># B; b \\<in># A\\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<in># A\" \"b \\<in># A-{#a#}\""], ["proof (state)\nthis:\n  a \\<in># A\n  b \\<in># A - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with mset_subset_eq_mono_add[of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"A-{#a#}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (A - {#a#})\n  a \\<in># A\n  b \\<in># A - {#a#}", "have \"{#a#}+{#b#} \\<subseteq># A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (A - {#a#})\n  a \\<in># A\n  b \\<in># A - {#a#}\n\ngoal (1 subgoal):\n 1. {#a#} + {#b#} \\<subseteq># A", "by auto"], ["proof (state)\nthis:\n  {#a#} + {#b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<in># A\" \"\\<not> (b \\<in># A-{#a#})\""], ["proof (state)\nthis:\n  a \\<in># A\n  b \\<notin># A - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<in># A\n  b \\<notin># A - {#a#}", "have \"b \\<in># B\""], ["proof (prove)\nusing this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<in># A\n  b \\<notin># A - {#a#}\n\ngoal (1 subgoal):\n 1. b \\<in># B", "by (metis diff_union_single_conv2 mset_le_subtract_left mset_subset_eq_insertD mset_un_cases)"], ["proof (state)\nthis:\n  b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "assume C: \"\\<not> (a \\<in># A)\" \"b \\<in># B-{#a#}\""], ["proof (state)\nthis:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<in># B - {#a#}", "have \"a \\<in># B\""], ["proof (prove)\nusing this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<in># B - {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B", "by (auto dest: mset_subset_eqD)"], ["proof (state)\nthis:\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. P", "with C mset_subset_eq_mono_add[of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"B-{#a#}\"]"], ["proof (chain)\npicking this:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (B - {#a#})\n  a \\<in># B", "have \"{#a#}+{#b#} \\<subseteq># B\""], ["proof (prove)\nusing this:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (B - {#a#})\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. {#a#} + {#b#} \\<subseteq># B", "by auto"], ["proof (state)\nthis:\n  {#a#} + {#b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "assume C: \"\\<not> (a \\<in># A)\" \"\\<not> (b \\<in># B-{#a#})\""], ["proof (state)\nthis:\n  a \\<notin># A\n  b \\<notin># B - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<notin># B - {#a#}", "have \"a \\<in># B \\<and> b \\<in># A\""], ["proof (prove)\nusing this:\n  {#a#} + {#b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<notin># B - {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B \\<and> b \\<in># A", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{#a#} + {#b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> a \\<in># B\n 2. \\<lbrakk>{#a#} + {#b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> b \\<in># A", "apply (auto dest!: mset_subset_eq_insertD simp: insert_union_subset_iff; fail)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{#a#} + {#b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> b \\<in># A", "by (metis mset_diff_cancel1elem mset_le_subtract_left multiset_diff_union_assoc\n            single_subset_iff subset_eq_diff_conv)"], ["proof (state)\nthis:\n  a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "using CASES"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n  {#a#} + {#b#} \\<subseteq># A \\<Longrightarrow> P\n  {#a#} + {#b#} \\<subseteq># B \\<Longrightarrow> P\n  \\<lbrakk>a \\<in># A; b \\<in># B\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>a \\<in># B; b \\<in># A\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_union_subset_s: \"{#a#}+B \\<subseteq># C \\<Longrightarrow> a \\<in># C \\<and> B \\<subseteq># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} + B \\<subseteq># C \\<Longrightarrow>\n    a \\<in># C \\<and> B \\<subseteq># C", "by (drule mset_union_subset) simp"], ["", "(* TODO: Check which of these lemmas are already introduced by order-classes ! *)"], ["", "lemma mset_le_single_cases[consumes 1, case_names empty singleton]: \"\\<lbrakk>M\\<subseteq>#{#a#}; M={#} \\<Longrightarrow> P; M={#a#} \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<subseteq># {#a#}; M = {#} \\<Longrightarrow> P;\n     M = {#a#} \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct M) auto"], ["", "lemma mset_le_distrib[consumes 1, case_names dist]: \"\\<lbrakk>(X::'a multiset)\\<subseteq>#A+B; !!Xa Xb. \\<lbrakk>X=Xa+Xb; Xa\\<subseteq>#A; Xb\\<subseteq>#B\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq># A + B;\n     \\<And>Xa Xb.\n        \\<lbrakk>X = Xa + Xb; Xa \\<subseteq># A; Xb \\<subseteq># B\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto elim!: mset_le_addE mset_distrib)"], ["", "lemma mset_le_mono_add_single: \"\\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk> \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># ys + ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk>\n    \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># ys + ws", "by (meson mset_subset_eq_mono_add single_subset_iff)"], ["", "lemma mset_size1elem: \"\\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P={#q#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P = {#q#}", "by (auto elim: mset_size_le1_cases)"], ["", "lemma mset_size2elem: \"\\<lbrakk>size P \\<le> 2; {#q#}+{#q'#} \\<subseteq># P\\<rbrakk> \\<Longrightarrow> P={#q#}+{#q'#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size P \\<le> 2; {#q#} + {#q'#} \\<subseteq># P\\<rbrakk>\n    \\<Longrightarrow> P = {#q#} + {#q'#}", "by (auto elim: mset_le_addE)"], ["", "subsubsection \\<open>Image under function\\<close>"], ["", "notation image_mset (infixr \"`#\" 90)"], ["", "lemma mset_map_split_orig: \"!!M1 M2. \\<lbrakk>f `# P = M1+M2; !!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>f `# P = M1 + M2;\n        \\<And>P1 P2.\n           \\<lbrakk>P = P1 + P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "by (induct P) (force elim!: mset_un_single_un_cases)+"], ["", "lemma mset_map_id: \"\\<lbrakk>!!x. f (g x) = x\\<rbrakk> \\<Longrightarrow> f `# g `# X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f (g x) = x) \\<Longrightarrow> f `# g `# X = X", "by (induct X) auto"], ["", "text \\<open>The following is a very specialized lemma. Intuitively, it splits the original multiset\n  by a splitting of some pointwise supermultiset of its image.\n\n  Application:\n  This lemma came in handy when proving the correctness of a constraint system that collects at most k sized submultisets of the sets of spawned threads.\n\\<close>"], ["", "lemma mset_map_split_orig_le: assumes A: \"f `# P \\<subseteq># M1+M2\" and EX: \"!!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 \\<subseteq># M1; f `# P2 \\<subseteq># M2\\<rbrakk> \\<Longrightarrow> Q\" shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "using A EX"], ["proof (prove)\nusing this:\n  f `# P \\<subseteq># M1 + M2\n  \\<lbrakk>P = ?P1.0 + ?P2.0; f `# ?P1.0 \\<subseteq># M1;\n   f `# ?P2.0 \\<subseteq># M2\\<rbrakk>\n  \\<Longrightarrow> Q\n\ngoal (1 subgoal):\n 1. Q", "by (auto elim: mset_le_distrib mset_map_split_orig)"], ["", "subsection \\<open>Lists\\<close>"], ["", "lemma len_greater_imp_nonempty[simp]: \"length l > x \\<Longrightarrow> l\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length l \\<Longrightarrow> l \\<noteq> []", "by auto"], ["", "lemma list_take_induct_tl2:\n  \"\\<lbrakk>length xs = length ys; \\<forall>n<length xs. P (ys ! n) (xs ! n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n < length (tl xs). P ((tl ys) ! n) ((tl xs) ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys;\n     \\<forall>n<length xs. P (ys ! n) (xs ! n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n<length (tl xs). P (tl ys ! n) (tl xs ! n)", "by (induct xs ys rule: list_induct2) auto"], ["", "lemma not_distinct_split_distinct:\n  assumes \"\\<not> distinct xs\"\n  obtains y ys zs where \"distinct ys\" \"y \\<in> set ys\" \"xs = ys@[y]@zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys y zs.\n        \\<lbrakk>distinct ys; y \\<in> set ys; xs = ys @ [y] @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys y zs.\n        \\<lbrakk>distinct ys; y \\<in> set ys; xs = ys @ [y] @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys y zs.\n                \\<lbrakk>distinct ys; y \\<in> set ys;\n                 [] = ys @ [y] @ zs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> distinct []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<And>ys y zs.\n                            \\<lbrakk>distinct ys; y \\<in> set ys;\n                             xs = ys @ [y] @ zs\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<not> distinct xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>ys y zs.\n           \\<lbrakk>distinct ys; y \\<in> set ys;\n            xs @ [x] = ys @ [y] @ zs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> distinct (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>distinct ?ys; ?y \\<in> set ?ys; [] = ?ys @ [?y] @ ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys y zs.\n                \\<lbrakk>distinct ys; y \\<in> set ys;\n                 [] = ys @ [y] @ zs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> distinct []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<And>ys y zs.\n                            \\<lbrakk>distinct ys; y \\<in> set ys;\n                             xs = ys @ [y] @ zs\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<not> distinct xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>ys y zs.\n           \\<lbrakk>distinct ys; y \\<in> set ys;\n            xs @ [x] = ys @ [y] @ zs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> distinct (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?ys; ?y \\<in> set ?ys; [] = ?ys @ [?y] @ ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> distinct []\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<And>ys y zs.\n                            \\<lbrakk>distinct ys; y \\<in> set ys;\n                             xs = ys @ [y] @ zs\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<not> distinct xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>ys y zs.\n           \\<lbrakk>distinct ys; y \\<in> set ys;\n            xs @ [x] = ys @ [y] @ zs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> distinct (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<And>ys y zs.\n                            \\<lbrakk>distinct ys; y \\<in> set ys;\n                             xs = ys @ [y] @ zs\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<not> distinct xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>ys y zs.\n           \\<lbrakk>distinct ys; y \\<in> set ys;\n            xs @ [x] = ys @ [y] @ zs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> distinct (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ys y zs.\n              \\<lbrakk>distinct ys; y \\<in> set ys;\n               xs = ys @ [y] @ zs\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<not> distinct xs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>distinct ?ys; ?y \\<in> set ?ys;\n   xs @ [x] = ?ys @ [?y] @ ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> distinct (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<And>ys y zs.\n                            \\<lbrakk>distinct ys; y \\<in> set ys;\n                             xs = ys @ [y] @ zs\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<not> distinct xs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>ys y zs.\n           \\<lbrakk>distinct ys; y \\<in> set ys;\n            xs @ [x] = ys @ [y] @ zs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> distinct (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ys y zs.\n              \\<lbrakk>distinct ys; y \\<in> set ys;\n               xs = ys @ [y] @ zs\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<not> distinct xs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>distinct ?ys; ?y \\<in> set ?ys;\n   xs @ [x] = ?ys @ [?y] @ ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> distinct (xs @ [x])\n\ngoal (1 subgoal):\n 1. thesis", "by (cases \"distinct xs\") auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_length_le:\n  assumes d: \"distinct ys\"\n  and eq: \"set ys = set xs\"\n  shows \"length ys \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "from d"], ["proof (chain)\npicking this:\n  distinct ys", "have \"length ys = card (set ys)\""], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. length ys = card (set ys)", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  length ys = card (set ys)\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "also"], ["proof (state)\nthis:\n  length ys = card (set ys)\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "from eq List.card_set"], ["proof (chain)\npicking this:\n  set ys = set xs\n  card (set ?xs) = length (remdups ?xs)", "have \"card (set ys) = length (remdups xs)\""], ["proof (prove)\nusing this:\n  set ys = set xs\n  card (set ?xs) = length (remdups ?xs)\n\ngoal (1 subgoal):\n 1. card (set ys) = length (remdups xs)", "by simp"], ["proof (state)\nthis:\n  card (set ys) = length (remdups xs)\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "also"], ["proof (state)\nthis:\n  card (set ys) = length (remdups xs)\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "have \"... \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remdups xs) \\<le> length xs", "by simp"], ["proof (state)\nthis:\n  length (remdups xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "finally"], ["proof (chain)\npicking this:\n  length ys \\<le> length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  length ys \\<le> length xs\n\ngoal (1 subgoal):\n 1. length ys \\<le> length xs", "."], ["proof (state)\nthis:\n  length ys \\<le> length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_SomeD:\n  \"List.find P xs = Some x \\<Longrightarrow> P x\"\n  \"List.find P xs = Some x \\<Longrightarrow> x\\<in>set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find P xs = Some x \\<Longrightarrow> P x) &&&\n    (find P xs = Some x \\<Longrightarrow> x \\<in> set xs)", "by (auto simp add: find_Some_iff)"], ["", "lemma in_hd_or_tl_conv[simp]: \"l\\<noteq>[] \\<Longrightarrow> x=hd l \\<or> x\\<in>set (tl l) \\<longleftrightarrow> x\\<in>set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    (x = hd l \\<or> x \\<in> set (tl l)) = (x \\<in> set l)", "by (cases l) auto"], ["", "lemma length_dropWhile_takeWhile:\n  assumes \"x < length (dropWhile P xs)\"\n  shows \"x + length (takeWhile P xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + length (takeWhile P xs) < length xs", "using assms"], ["proof (prove)\nusing this:\n  x < length (dropWhile P xs)\n\ngoal (1 subgoal):\n 1. x + length (takeWhile P xs) < length xs", "by (induct xs) auto"], ["", "text \\<open>Elim-version of @{thm neq_Nil_conv}.\\<close>"], ["", "lemma neq_NilE: \n  assumes \"l\\<noteq>[]\"\n  obtains x xs where \"l=x#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xs. l = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. l = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust)"], ["", "lemma length_Suc_rev_conv: \"length xs = Suc n \\<longleftrightarrow> (\\<exists>ys y. xs=ys@[y] \\<and> length ys = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = Suc n) =\n    (\\<exists>ys y. xs = ys @ [y] \\<and> length ys = n)", "by (cases xs rule: rev_cases) auto"], ["", "subsubsection \\<open>List Destructors\\<close>"], ["", "lemma not_hd_in_tl:\n  \"x \\<noteq> hd xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> x \\<in> set (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> hd xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (tl xs)", "by (induct xs) simp_all"], ["", "lemma distinct_hd_tl:\n  \"distinct xs \\<Longrightarrow> x = hd xs \\<Longrightarrow> x \\<notin> set (tl (xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (tl xs)", "by (induct xs) simp_all"], ["", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by (induct xs) simp_all"], ["", "lemma nth_tl: \"xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> tl xs ! n = xs ! Suc n", "by (induct xs) simp_all"], ["", "lemma tl_subset:\n  \"xs \\<noteq> [] \\<Longrightarrow> set xs \\<subseteq> A \\<Longrightarrow> set (tl xs) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; set xs \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> set (tl xs) \\<subseteq> A", "by (metis in_set_tlD rev_subsetD subsetI)"], ["", "lemma tl_last:\n  \"tl xs \\<noteq> [] \\<Longrightarrow> last xs = last (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl xs \\<noteq> [] \\<Longrightarrow> last xs = last (tl xs)", "by (induct xs) simp_all"], ["", "lemma tl_obtain_elem:\n  assumes \"xs \\<noteq> []\" \"tl xs = []\"\n  obtains e where \"xs = [e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e. xs = [e] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  tl xs = []\n\ngoal (1 subgoal):\n 1. (\\<And>e. xs = [e] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct xs rule: list_nonempty_induct) simp_all"], ["", "lemma butlast_subset:\n  \"xs \\<noteq> [] \\<Longrightarrow> set xs \\<subseteq> A \\<Longrightarrow> set (butlast xs) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; set xs \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> set (butlast xs) \\<subseteq> A", "by (metis in_set_butlastD rev_subsetD subsetI)"], ["", "lemma butlast_rev_tl:\n  \"xs \\<noteq> [] \\<Longrightarrow> butlast (rev xs) = rev (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> butlast (rev xs) = rev (tl xs)", "by (induct xs rule: rev_induct) simp_all"], ["", "lemma hd_butlast:\n  \"length xs > 1 \\<Longrightarrow> hd (butlast xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow> hd (butlast xs) = hd xs", "by (induct xs) simp_all"], ["", "lemma butlast_upd_last_eq[simp]: \"length l \\<ge> 2 \\<Longrightarrow>\n  (butlast l) [ length l - 2 := x ] = take (length l - 2) l @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length l \\<Longrightarrow>\n    (butlast l)[length l - 2 := x] = take (length l - 2) l @ [x]", "apply (case_tac l rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 \\<le> length l; l = []\\<rbrakk>\n    \\<Longrightarrow> (butlast l)[length l - 2 := x] =\n                      take (length l - 2) l @ [x]\n 2. \\<And>ys y.\n       \\<lbrakk>2 \\<le> length l; l = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> (butlast l)[length l - 2 := x] =\n                         take (length l - 2) l @ [x]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>2 \\<le> length l; l = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> (butlast l)[length l - 2 := x] =\n                         take (length l - 2) l @ [x]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ys \\<noteq> []; l = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> ys[length ys - Suc 0 := x] =\n                         take (length ys - Suc 0) ys @ [x]", "apply (case_tac ys rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>ys \\<noteq> []; l = ys @ [y]; ys = []\\<rbrakk>\n       \\<Longrightarrow> ys[length ys - Suc 0 := x] =\n                         take (length ys - Suc 0) ys @ [x]\n 2. \\<And>ys y ysa ya.\n       \\<lbrakk>ys \\<noteq> []; l = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> ys[length ys - Suc 0 := x] =\n                         take (length ys - Suc 0) ys @ [x]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y ysa ya.\n       \\<lbrakk>ys \\<noteq> []; l = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> ys[length ys - Suc 0 := x] =\n                         take (length ys - Suc 0) ys @ [x]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_butlast_swap[simp]: \n  \"distinct pq \\<Longrightarrow> distinct (butlast (pq[i := last pq]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct pq \\<Longrightarrow> distinct (butlast (pq[i := last pq]))", "apply (cases pq rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct pq; pq = []\\<rbrakk>\n    \\<Longrightarrow> distinct (butlast (pq[i := last pq]))\n 2. \\<And>ys y.\n       \\<lbrakk>distinct pq; pq = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> distinct (butlast (pq[i := last pq]))", "apply (auto simp: list_update_append distinct_list_update split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Splitting list according to structure of other list\\<close>"], ["", "context begin"], ["", "private"], ["", "definition \"SPLIT_ACCORDING m l \\<equiv> length l = length m\""], ["", "private"], ["", "lemma SPLIT_ACCORDINGE: \n  assumes \"length m = length l\"\n  obtains \"SPLIT_ACCORDING m l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPLIT_ACCORDING m l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding SPLIT_ACCORDING_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = length m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  length m = length l\n\ngoal (1 subgoal):\n 1. (length l = length m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["", "private"], ["", "lemma SPLIT_ACCORDING_simp:\n  \"SPLIT_ACCORDING m (l1@l2) \\<longleftrightarrow> (\\<exists>m1 m2. m=m1@m2 \\<and> SPLIT_ACCORDING m1 l1 \\<and> SPLIT_ACCORDING m2 l2)\"\n  \"SPLIT_ACCORDING m (x#l') \\<longleftrightarrow> (\\<exists>y m'. m=y#m' \\<and> SPLIT_ACCORDING m' l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPLIT_ACCORDING m (l1 @ l2) =\n    (\\<exists>m1 m2.\n        m = m1 @ m2 \\<and>\n        SPLIT_ACCORDING m1 l1 \\<and> SPLIT_ACCORDING m2 l2) &&&\n    SPLIT_ACCORDING m (x # l') =\n    (\\<exists>y m'. m = y # m' \\<and> SPLIT_ACCORDING m' l')", "apply (fastforce simp: SPLIT_ACCORDING_def intro: exI[where x = \"take (length l1) m\"] exI[where x = \"drop (length l1) m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPLIT_ACCORDING m (x # l') =\n    (\\<exists>y m'. m = y # m' \\<and> SPLIT_ACCORDING m' l')", "apply (cases m;auto simp: SPLIT_ACCORDING_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Split structure of list @{term m} according to structure of list @{term l}.\\<close>"], ["", "method split_list_according for m :: \"'a list\" and l :: \"'b list\" =\n  (rule SPLIT_ACCORDINGE[of m l],\n    (simp; fail),\n    ( simp only: SPLIT_ACCORDING_simp,\n      elim exE conjE, \n      simp only: SPLIT_ACCORDING_def\n    )\n  )"], ["", "end"], ["", "subsubsection \\<open>\\<open>list_all2\\<close>\\<close>"], ["", "lemma list_all2_induct[consumes 1, case_names Nil Cons]:\n  assumes \"list_all2 P l l'\"\n  assumes \"Q [] []\"\n  assumes \"\\<And>x x' ls ls'. \\<lbrakk> P x x'; list_all2 P ls ls'; Q ls ls' \\<rbrakk>\n    \\<Longrightarrow> Q (x#ls) (x'#ls')\"\n  shows \"Q l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q l l'", "using list_all2_lengthD[OF assms(1)] assms"], ["proof (prove)\nusing this:\n  length l = length l'\n  list_all2 P l l'\n  Q [] []\n  \\<lbrakk>P ?x ?x'; list_all2 P ?ls ?ls'; Q ?ls ?ls'\\<rbrakk>\n  \\<Longrightarrow> Q (?x # ?ls) (?x' # ?ls')\n\ngoal (1 subgoal):\n 1. Q l l'", "apply (induct rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all2 P [] []; Q [] [];\n     \\<And>x x' ls ls'.\n        \\<lbrakk>P x x'; list_all2 P ls ls'; Q ls ls'\\<rbrakk>\n        \\<Longrightarrow> Q (x # ls) (x' # ls')\\<rbrakk>\n    \\<Longrightarrow> Q [] []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>list_all2 P xs ys; Q [] [];\n         \\<And>x x' ls ls'.\n            \\<lbrakk>P x x'; list_all2 P ls ls'; Q ls ls'\\<rbrakk>\n            \\<Longrightarrow> Q (x # ls) (x' # ls')\\<rbrakk>\n        \\<Longrightarrow> Q xs ys;\n        list_all2 P (x # xs) (y # ys); Q [] [];\n        \\<And>x x' ls ls'.\n           \\<lbrakk>P x x'; list_all2 P ls ls'; Q ls ls'\\<rbrakk>\n           \\<Longrightarrow> Q (x # ls) (x' # ls')\\<rbrakk>\n       \\<Longrightarrow> Q (x # xs) (y # ys)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Indexing\\<close>"], ["", "lemma ran_nth_set_encoding_conv[simp]: \n  \"ran (\\<lambda>i. if i<length l then Some (l!i) else None) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (\\<lambda>i. if i < length l then Some (l ! i) else None) = set l", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ran (\\<lambda>i.\n                       if i < length l then Some (l ! i)\n                       else None) \\<Longrightarrow>\n       x \\<in> set l\n 2. \\<And>x.\n       x \\<in> set l \\<Longrightarrow>\n       x \\<in> ran (\\<lambda>i. if i < length l then Some (l ! i) else None)", "apply (auto simp: ran_def split: if_split_asm) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set l \\<Longrightarrow>\n       x \\<in> ran (\\<lambda>i. if i < length l then Some (l ! i) else None)", "apply (auto simp: in_set_conv_nth intro: ranI) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_image_indices[simp]: \"(!) l ` {0..<length l} = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) l ` {0..<length l} = set l", "by (auto simp: in_set_conv_nth)"], ["", "lemma nth_update_invalid[simp]:\"\\<not>i<length l \\<Longrightarrow> l[j:=x]!i = l!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> l[j := x] ! i = l ! i", "apply (induction l arbitrary: i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<not> i < length [] \\<Longrightarrow> [][j := x] ! i = [] ! i\n 2. \\<And>a l i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<not> i < length l \\<Longrightarrow>\n                   l[j := x] ! i = l ! i;\n        \\<not> i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> (a # l)[j := x] ! i = (a # l) ! i", "apply (auto split: nat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_list_update': \"l[i:=x]!j = (if i=j \\<and> i<length l then x else l!j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l[i := x] ! j = (if i = j \\<and> i < length l then x else l ! j)", "by auto"], ["", "lemma last_take_nth_conv: \"n \\<le> length l \\<Longrightarrow> n\\<noteq>0 \\<Longrightarrow> last (take n l) = l!(n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length l; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> last (take n l) = l ! (n - 1)", "apply (induction l arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length []; n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (take n []) = [] ! (n - 1)\n 2. \\<And>a l n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n \\<le> length l; n \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> last (take n l) = l ! (n - 1);\n        n \\<le> length (a # l); n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (take n (a # l)) = (a # l) ! (n - 1)", "apply (auto simp: take_Cons split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_append_first[simp]: \"i<length l \\<Longrightarrow> (l@l')!i = l!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow> (l @ l') ! i = l ! i", "by (simp add: nth_append)"], ["", "lemma in_set_image_conv_nth: \"f x \\<in> f`set l \\<longleftrightarrow> (\\<exists>i<length l. f (l!i) = f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x \\<in> f ` set l) = (\\<exists>i<length l. f (l ! i) = f x)", "by (auto simp: in_set_conv_nth) (metis image_eqI nth_mem)"], ["", "lemma set_image_eq_pointwiseI: \n  assumes \"length l = length l'\"\n  assumes \"\\<And>i. i<length l \\<Longrightarrow> f (l!i) = f (l'!i)\"  \n  shows \"f`set l = f`set l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set l = f ` set l'", "using assms"], ["proof (prove)\nusing this:\n  length l = length l'\n  ?i < length l \\<Longrightarrow> f (l ! ?i) = f (l' ! ?i)\n\ngoal (1 subgoal):\n 1. f ` set l = f ` set l'", "by (fastforce simp: in_set_conv_nth in_set_image_conv_nth)"], ["", "lemma insert_swap_set_eq: \"i<length l \\<Longrightarrow> insert (l!i) (set (l[i:=x])) = insert x (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    insert (l ! i) (set (l[i := x])) = insert x (set l)", "by (auto simp: in_set_conv_nth nth_list_update split: if_split_asm)"], ["", "subsubsection \\<open>Reverse lists\\<close>"], ["", "lemma neq_Nil_revE: \n    assumes \"l\\<noteq>[]\" \n    obtains ll e  where \"l = ll@[e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ll e. l = ll @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ll e. l = ll @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l rule: rev_cases) auto"], ["", "lemma neq_Nil_rev_conv: \"l\\<noteq>[] \\<longleftrightarrow> (\\<exists>xs x. l = xs@[x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<noteq> []) = (\\<exists>xs x. l = xs @ [x])", "by (cases l rule: rev_cases) auto"], ["", "text \\<open>Caution: Same order of case variables in snoc-case as @{thm [source] rev_exhaust}, the other way round than @{thm [source] rev_induct} !\\<close>"], ["", "lemma length_compl_rev_induct[case_names Nil snoc]: \"\\<lbrakk>P []; !! l e . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (l@[e])\\<rbrakk> \\<Longrightarrow> P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P [];\n     \\<And>l e.\n        (\\<And>ll.\n            length ll \\<le> length l \\<Longrightarrow>\n            P ll) \\<Longrightarrow>\n        P (l @ [e])\\<rbrakk>\n    \\<Longrightarrow> P l", "apply(induct_tac l rule: length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(case_tac \"xs\" rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> P xs\n 2. \\<And>xs ys y.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_append_eq_Cons_cases[consumes 1]: \"\\<lbrakk>ys@zs = x#xs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys @ zs = x # xs;\n     \\<lbrakk>ys = []; zs = x # xs\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; ys' @ zs = xs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto iff add: append_eq_Cons_conv)"], ["", "lemma list_Cons_eq_append_cases[consumes 1]: \"\\<lbrakk>x#xs = ys@zs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x # xs = ys @ zs;\n     \\<lbrakk>ys = []; zs = x # xs\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; ys' @ zs = xs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto iff add: Cons_eq_append_conv)"], ["", "lemma map_of_rev_distinct[simp]:\n  \"distinct (map fst m) \\<Longrightarrow> map_of (rev m) = map_of m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst m) \\<Longrightarrow> map_of (rev m) = map_of m", "apply (induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> map_of (rev []) = map_of []\n 2. \\<And>a m.\n       \\<lbrakk>distinct (map fst m) \\<Longrightarrow>\n                map_of (rev m) = map_of m;\n        distinct (map fst (a # m))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (a # m)) = map_of (a # m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       \\<lbrakk>distinct (map fst m) \\<Longrightarrow>\n                map_of (rev m) = map_of m;\n        distinct (map fst (a # m))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (a # m)) = map_of (a # m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       \\<lbrakk>map_of (rev m) = map_of m;\n        fst a \\<notin> fst ` set m \\<and> distinct (map fst m)\\<rbrakk>\n       \\<Longrightarrow> [fst a \\<mapsto> snd a] ++ map_of m = map_of m\n                         (fst a \\<mapsto> snd a)", "apply (subst map_add_comm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a m.\n       \\<lbrakk>map_of (rev m) = map_of m;\n        fst a \\<notin> fst ` set m \\<and> distinct (map fst m)\\<rbrakk>\n       \\<Longrightarrow> dom [fst a \\<mapsto> snd a] \\<inter>\n                         dom (map_of m) =\n                         {}\n 2. \\<And>a m.\n       \\<lbrakk>map_of (rev m) = map_of m;\n        fst a \\<notin> fst ` set m \\<and> distinct (map fst m)\\<rbrakk>\n       \\<Longrightarrow> map_of m ++ [fst a \\<mapsto> snd a] = map_of m\n                         (fst a \\<mapsto> snd a)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       \\<lbrakk>map_of (rev m) = map_of m;\n        fst a \\<notin> fst ` set m \\<and> distinct (map fst m)\\<rbrakk>\n       \\<Longrightarrow> map_of m ++ [fst a \\<mapsto> snd a] = map_of m\n                         (fst a \\<mapsto> snd a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\n\\<comment> \\<open>Tail-recursive, generalized @{const rev}. May also be used for\n      tail-recursively getting a list with all elements of the two\n      operands, if the order does not matter, e.g. when implementing\n      sets by lists.\\<close>"], ["", "fun revg where\n  \"revg [] b = b\" |\n  \"revg (a#as) b = revg as (a#b)\""], ["", "lemma revg_fun[simp]: \"revg a b = rev a @ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revg a b = rev a @ b", "by (induct a arbitrary: b)\n      auto"], ["", "lemma rev_split_conv[simp]:\n  \"l \\<noteq> [] \\<Longrightarrow> rev (tl l) @ [hd l] = rev l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> rev (tl l) @ [hd l] = rev l", "by (induct l) simp_all"], ["", "lemma rev_butlast_is_tl_rev: \"rev (butlast l) = tl (rev l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (butlast l) = tl (rev l)", "by (induct l) auto"], ["", "lemma hd_last_singletonI:\n  \"\\<lbrakk>xs \\<noteq> []; hd xs = last xs; distinct xs\\<rbrakk> \\<Longrightarrow> xs = [hd xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; hd xs = last xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> xs = [hd xs]", "by (induct xs rule: list_nonempty_induct) auto"], ["", "lemma last_filter:\n  \"\\<lbrakk>xs \\<noteq> []; P (last xs)\\<rbrakk> \\<Longrightarrow> last (filter P xs) = last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; P (last xs)\\<rbrakk>\n    \\<Longrightarrow> last (filter P xs) = last xs", "by (induct xs rule: rev_nonempty_induct) simp_all"], ["", "(* As the following two rules are similar in nature to list_induct2',\n   they are named accordingly. *)"], ["", "lemma rev_induct2' [case_names empty snocl snocr snoclr]:\n  assumes empty: \"P [] []\"\n  and snocl: \"\\<And>x xs. P (xs@[x]) []\"\n  and snocr: \"\\<And>y ys. P [] (ys@[y])\"\n  and snoclr: \"\\<And>x xs y ys.  P xs ys  \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct xs arbitrary: ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. P [] x\n 2. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. P [] x\n 2. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P [] ys", "using empty snocr"], ["proof (prove)\nusing this:\n  P [] []\n  P [] (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P [] ys", "by (cases ys rule: rev_exhaust) simp_all"], ["proof (state)\nthis:\n  P [] ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "case snoc"], ["proof (state)\nthis:\n  P xs_ ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "thus ?case"], ["proof (prove)\nusing this:\n  P xs_ ?ys\n\ngoal (1 subgoal):\n 1. P (xs_ @ [x_]) ys", "using snocl snoclr"], ["proof (prove)\nusing this:\n  P xs_ ?ys\n  P (?xs @ [?x]) []\n  P ?xs ?ys \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P (xs_ @ [x_]) ys", "by (cases ys rule: rev_exhaust) simp_all"], ["proof (state)\nthis:\n  P (xs_ @ [x_]) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_nonempty_induct2' [case_names single snocl snocr snoclr, consumes 2]:\n  assumes \"xs \\<noteq> []\" \"ys \\<noteq> []\"\n  assumes single': \"\\<And>x y. P [x] [y]\"\n  and snocl: \"\\<And>x xs y. xs \\<noteq> [] \\<Longrightarrow> P (xs@[x]) [y]\"\n  and snocr: \"\\<And>x y ys. ys \\<noteq> [] \\<Longrightarrow> P [x] (ys@[y])\"\n  and snoclr: \"\\<And>x xs y ys. \\<lbrakk>P xs ys; xs \\<noteq> []; ys\\<noteq>[]\\<rbrakk>  \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using assms(1,2)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct xs arbitrary: ys rule: rev_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ys. ys \\<noteq> [] \\<Longrightarrow> P [x] ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "case single"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x ys. ys \\<noteq> [] \\<Longrightarrow> P [x] ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "then"], ["proof (chain)\npicking this:\n  ys \\<noteq> []", "obtain z zs where \"ys = zs@[z]\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>zs z. ys = zs @ [z] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis rev_exhaust)"], ["proof (state)\nthis:\n  ys = zs @ [z]\n\ngoal (2 subgoals):\n 1. \\<And>x ys. ys \\<noteq> [] \\<Longrightarrow> P [x] ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "thus ?case"], ["proof (prove)\nusing this:\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. P [x_] ys", "using single' snocr"], ["proof (prove)\nusing this:\n  ys = zs @ [z]\n  P [?x] [?y]\n  ?ys \\<noteq> [] \\<Longrightarrow> P [?x] (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P [x_] ys", "by (cases \"zs = []\") simp_all"], ["proof (state)\nthis:\n  P [x_] ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "case (snoc x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ?ys \\<noteq> [] \\<Longrightarrow> P xs ?ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ?ys \\<noteq> [] \\<Longrightarrow> P xs ?ys\n  ys \\<noteq> []", "obtain z zs where zs: \"ys = zs@[z]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ?ys \\<noteq> [] \\<Longrightarrow> P xs ?ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>zs z. ys = zs @ [z] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis rev_exhaust)"], ["proof (state)\nthis:\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>ys. ys \\<noteq> [] \\<Longrightarrow> P xs ys;\n        ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x]) ys", "thus ?case"], ["proof (prove)\nusing this:\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. P (xs @ [x]) ys", "using snocl snoclr snoc"], ["proof (prove)\nusing this:\n  ys = zs @ [z]\n  ?xs \\<noteq> [] \\<Longrightarrow> P (?xs @ [?x]) [?y]\n  \\<lbrakk>P ?xs ?ys; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n  xs \\<noteq> []\n  ?ys \\<noteq> [] \\<Longrightarrow> P xs ?ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. P (xs @ [x]) ys", "by (cases \"zs = []\") simp_all"], ["proof (state)\nthis:\n  P (xs @ [x]) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Folding\""], ["", "text \"Ugly lemma about foldl over associative operator with left and right neutral element\""], ["", "lemma foldl_A1_eq: \"!!i. \\<lbrakk> !! e. f n e = e; !! e. f e n = e; !!a b c. f a (f b c) = f (f a b) c \\<rbrakk> \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)", "proof (induct ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i [] = f i (foldl f n [])\n 2. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "case Nil"], ["proof (state)\nthis:\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i [] = f i (foldl f n [])\n 2. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "thus ?case"], ["proof (prove)\nusing this:\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. foldl f i [] = f i (foldl f n [])", "by simp"], ["proof (state)\nthis:\n  foldl f i [] = f i (foldl f n [])\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "case (Cons a ww i)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "note IHP[simplified]=this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "have \"foldl f i (a # ww) = foldl f (f i a) ww\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f i (a # ww) = foldl f (f i a) ww", "by simp"], ["proof (state)\nthis:\n  foldl f i (a # ww) = foldl f (f i a) ww\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  foldl f i (a # ww) = foldl f (f i a) ww\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c", "have \"\\<dots> = f (f i a) (foldl f n ww)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. foldl f (f i a) ww = f (f i a) (foldl f n ww)", "by blast"], ["proof (state)\nthis:\n  foldl f (f i a) ww = f (f i a) (foldl f n ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  foldl f (f i a) ww = f (f i a) (foldl f n ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(4)"], ["proof (chain)\npicking this:\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c", "have \"\\<dots> = f i (f a (foldl f n ww))\""], ["proof (prove)\nusing this:\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))", "by simp"], ["proof (state)\nthis:\n  f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(1)[OF IHP(2,3,4), where i=a]"], ["proof (chain)\npicking this:\n  foldl f a ww = f a (foldl f n ww)", "have \"\\<dots> = f i (foldl f a ww)\""], ["proof (prove)\nusing this:\n  foldl f a ww = f a (foldl f n ww)\n\ngoal (1 subgoal):\n 1. f i (f a (foldl f n ww)) = f i (foldl f a ww)", "by simp"], ["proof (state)\nthis:\n  f i (f a (foldl f n ww)) = f i (foldl f a ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f i (f a (foldl f n ww)) = f i (foldl f a ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(2)[of a]"], ["proof (chain)\npicking this:\n  f n a = a", "have \"\\<dots> = f i (foldl f (f n a) ww)\""], ["proof (prove)\nusing this:\n  f n a = a\n\ngoal (1 subgoal):\n 1. f i (foldl f a ww) = f i (foldl f (f n a) ww)", "by simp"], ["proof (state)\nthis:\n  f i (foldl f a ww) = f i (foldl f (f n a) ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f i (foldl f a ww) = f i (foldl f (f n a) ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "have \"\\<dots> = f i (foldl f n (a#ww))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i (foldl f (f n a) ww) = f i (foldl f n (a # ww))", "by simp"], ["proof (state)\nthis:\n  f i (foldl f (f n a) ww) = f i (foldl f n (a # ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "finally"], ["proof (chain)\npicking this:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))", "show ?case"], ["proof (prove)\nusing this:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))\n\ngoal (1 subgoal):\n 1. foldl f i (a # ww) = f i (foldl f n (a # ww))", "."], ["proof (state)\nthis:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas foldl_conc_empty_eq = foldl_A1_eq[of \"(@)\" \"[]\", simplified]"], ["", "lemmas foldl_un_empty_eq = foldl_A1_eq[of \"(\\<union>)\" \"{}\", simplified, OF Un_assoc[symmetric]]"], ["", "lemma foldl_set: \"foldl (\\<union>) {} l = \\<Union>{x. x\\<in>set l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<union>) {} l = \\<Union> {x. x \\<in> set l}", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foldl (\\<union>) {} [] = \\<Union> {x. x \\<in> set []}\n 2. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> {x. x \\<in> set l} \\<Longrightarrow>\n       foldl (\\<union>) {} (a # l) = \\<Union> {x. x \\<in> set (a # l)}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> (set l) \\<Longrightarrow>\n       foldl (\\<union>) a l = \\<Union> {x. x = a \\<or> x \\<in> set l}", "apply (subst foldl_un_empty_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> (set l) \\<Longrightarrow>\n       a \\<union> foldl (\\<union>) {} l =\n       \\<Union> {x. x = a \\<or> x \\<in> set l}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in monoid_mult) foldl_absorb1: \"x*foldl (*) 1 zs = foldl (*) x zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * foldl (*) (1::'a) zs = foldl (*) x zs", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (*) x zs = x * foldl (*) (1::'a) zs", "apply (rule foldl_A1_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e. (1::'a) * e = e\n 2. \\<And>e. e * (1::'a) = e\n 3. \\<And>a b c. a * (b * c) = a * b * c", "apply (auto simp add: mult.assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Towards an invariant rule for foldl\\<close>"], ["", "lemma foldl_rule_aux:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) l2\"\n  shows \"I (foldl f \\<sigma>0 l0) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (foldl f \\<sigma>0 l0) []", "using initial step"], ["proof (prove)\nusing this:\n  I \\<sigma>0 l0\n  \\<lbrakk>l0 = ?l1.0 @ ?x # ?l2.0; I ?\\<sigma> (?x # ?l2.0)\\<rbrakk>\n  \\<Longrightarrow> I (f ?\\<sigma> ?x) ?l2.0\n\ngoal (1 subgoal):\n 1. I (foldl f \\<sigma>0 l0) []", "apply (induct l0 arbitrary: \\<sigma>0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>0.\n       \\<lbrakk>I \\<sigma>0 [];\n        \\<And>l1 x l2 \\<sigma>.\n           \\<lbrakk>[] = l1 @ x # l2; I \\<sigma> (x # l2)\\<rbrakk>\n           \\<Longrightarrow> I (f \\<sigma> x) l2\\<rbrakk>\n       \\<Longrightarrow> I (foldl f \\<sigma>0 []) []\n 2. \\<And>a l0 \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>I \\<sigma>0 l0;\n                    \\<And>l1 x l2 \\<sigma>.\n                       \\<lbrakk>l0 = l1 @ x # l2;\n                        I \\<sigma> (x # l2)\\<rbrakk>\n                       \\<Longrightarrow> I (f \\<sigma> x) l2\\<rbrakk>\n                   \\<Longrightarrow> I (foldl f \\<sigma>0 l0) [];\n        I \\<sigma>0 (a # l0);\n        \\<And>l1 x l2 \\<sigma>.\n           \\<lbrakk>a # l0 = l1 @ x # l2; I \\<sigma> (x # l2)\\<rbrakk>\n           \\<Longrightarrow> I (f \\<sigma> x) l2\\<rbrakk>\n       \\<Longrightarrow> I (foldl f \\<sigma>0 (a # l0)) []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldl_rule_aux_P:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) l2\"\n  assumes final: \"!!\\<sigma>. I \\<sigma> [] \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (foldl f \\<sigma>0 l0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (foldl f \\<sigma>0 l0)", "using foldl_rule_aux[of I \\<sigma>0 l0, OF initial, OF step] final"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l1 l2 x \\<sigma>.\n              \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> (x # l2)\\<rbrakk>\n              \\<Longrightarrow> l0 =\n                                ?l1.1 l1 l2 x \\<sigma> @\n                                ?x3 x \\<sigma> # l2;\n   \\<And>l1 l2 x \\<sigma>.\n      \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> (x # l2)\\<rbrakk>\n      \\<Longrightarrow> I (?\\<sigma>2 x \\<sigma>)\n                         (?x3 x \\<sigma> # l2)\\<rbrakk>\n  \\<Longrightarrow> I (foldl\n                        (\\<lambda>\\<sigma> x.\n                            f (?\\<sigma>2 x \\<sigma>) (?x3 x \\<sigma>))\n                        \\<sigma>0 l0)\n                     []\n  I ?\\<sigma> [] \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. P (foldl f \\<sigma>0 l0)", "by simp"], ["", "lemma foldl_rule:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes initial: \"I \\<sigma>0 [] l0\"\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> l1 (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) (l1@[x]) l2\"\n  shows \"I (foldl f \\<sigma>0 l0) l0 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (foldl f \\<sigma>0 l0) l0 []", "using initial step"], ["proof (prove)\nusing this:\n  I \\<sigma>0 [] l0\n  \\<lbrakk>l0 = ?l1.0 @ ?x # ?l2.0; I ?\\<sigma> ?l1.0 (?x # ?l2.0)\\<rbrakk>\n  \\<Longrightarrow> I (f ?\\<sigma> ?x) (?l1.0 @ [?x]) ?l2.0\n\ngoal (1 subgoal):\n 1. I (foldl f \\<sigma>0 l0) l0 []", "apply (rule_tac I=\"\\<lambda>\\<sigma> lr. \\<exists>ll. l0=ll@lr \\<and> I \\<sigma> ll lr\" in foldl_rule_aux_P)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<sigma>0 [] l0;\n     \\<And>l1 x l2 \\<sigma>.\n        \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> l1 (x # l2)\\<rbrakk>\n        \\<Longrightarrow> I (f \\<sigma> x) (l1 @ [x]) l2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ll. l0 = ll @ l0 \\<and> I \\<sigma>0 ll l0\n 2. \\<And>l1 l2 x \\<sigma>.\n       \\<lbrakk>I \\<sigma>0 [] l0;\n        \\<And>l1 x l2 \\<sigma>.\n           \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> l1 (x # l2)\\<rbrakk>\n           \\<Longrightarrow> I (f \\<sigma> x) (l1 @ [x]) l2;\n        l0 = l1 @ x # l2;\n        \\<exists>ll. l0 = ll @ x # l2 \\<and> I \\<sigma> ll (x # l2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll.\n                            l0 = ll @ l2 \\<and> I (f \\<sigma> x) ll l2\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>I \\<sigma>0 [] l0;\n        \\<And>l1 x l2 \\<sigma>.\n           \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> l1 (x # l2)\\<rbrakk>\n           \\<Longrightarrow> I (f \\<sigma> x) (l1 @ [x]) l2;\n        \\<exists>ll. l0 = ll @ [] \\<and> I \\<sigma> ll []\\<rbrakk>\n       \\<Longrightarrow> I \\<sigma> l0 []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Invariant rule for foldl. The invariant is parameterized with\n  the state, the list of items that have already been processed and\n  the list of items that still have to be processed.\n\\<close>"], ["", "lemma foldl_rule_P:\n  fixes I :: \"'\\<sigma> \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  \\<comment> \\<open>The invariant holds for the initial state, no items processed yet and all items to be processed:\\<close>\n  assumes initial: \"I \\<sigma>0 [] l0\"\n  \\<comment> \\<open>The invariant remains valid if one item from the list is processed\\<close>\n  assumes step: \"!!l1 l2 x \\<sigma>. \\<lbrakk> l0=l1@x#l2; I \\<sigma> l1 (x#l2) \\<rbrakk> \\<Longrightarrow> I (f \\<sigma> x) (l1@[x]) l2\"\n  \\<comment> \\<open>The proposition follows from the invariant in the final state, i.e. all items processed and nothing to be processed\\<close>\n  assumes final: \"!!\\<sigma>. I \\<sigma> l0 [] \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (foldl f \\<sigma>0 l0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (foldl f \\<sigma>0 l0)", "using foldl_rule[of I, OF initial step]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l1 l2 x \\<sigma>.\n              \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> l1 (x # l2)\\<rbrakk>\n              \\<Longrightarrow> l0 = l1 @ x # l2;\n   \\<And>l1 l2 x \\<sigma>.\n      \\<lbrakk>l0 = l1 @ x # l2; I \\<sigma> l1 (x # l2)\\<rbrakk>\n      \\<Longrightarrow> I (?\\<sigma>2 x \\<sigma>) l1 (x # l2)\\<rbrakk>\n  \\<Longrightarrow> I (foldl\n                        (\\<lambda>\\<sigma> x. f (?\\<sigma>2 x \\<sigma>) x)\n                        \\<sigma>0 l0)\n                     l0 []\n\ngoal (1 subgoal):\n 1. P (foldl f \\<sigma>0 l0)", "by (simp add: final)"], ["", "text \\<open>Invariant reasoning over @{const foldl} for distinct lists. Invariant rule makes no\n  assumptions about ordering.\\<close>"], ["", "lemma distinct_foldl_invar:\n  \"\\<lbrakk> distinct S; I (set S) \\<sigma>0;\n     \\<And>x it \\<sigma>. \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk> \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\n   \\<rbrakk> \\<Longrightarrow> I {} (foldl f \\<sigma>0 S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n    \\<Longrightarrow> I {} (foldl f \\<sigma>0 S)", "proof (induct S arbitrary: \\<sigma>0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>0.\n       \\<lbrakk>distinct []; I (set []) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set [];\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 [])\n 2. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  I (set []) \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> set []; I ?it ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I (?it - {?x}) (f ?\\<sigma> ?x)\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>0.\n       \\<lbrakk>distinct []; I (set []) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set [];\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 [])\n 2. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct []\n  I (set []) \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> set []; I ?it ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I (?it - {?x}) (f ?\\<sigma> ?x)\n\ngoal (1 subgoal):\n 1. I {} (foldl f \\<sigma>0 [])", "by auto"], ["proof (state)\nthis:\n  I {} (foldl f \\<sigma>0 [])\n\ngoal (1 subgoal):\n 1. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "case (Cons x S)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct S; I (set S) ?\\<sigma>0.0;\n   \\<And>x it \\<sigma>.\n      \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n  \\<Longrightarrow> I {} (foldl f ?\\<sigma>0.0 S)\n  distinct (x # S)\n  I (set (x # S)) \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> set (x # S);\n   I ?it ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I (?it - {?x}) (f ?\\<sigma> ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "note [simp] = Cons.prems(1)[simplified]"], ["proof (state)\nthis:\n  x \\<notin> set S \\<and> distinct S\n\ngoal (1 subgoal):\n 1. \\<And>a S \\<sigma>0.\n       \\<lbrakk>\\<And>\\<sigma>0.\n                   \\<lbrakk>distinct S; I (set S) \\<sigma>0;\n                    \\<And>x it \\<sigma>.\n                       \\<lbrakk>x \\<in> it; it \\<subseteq> set S;\n                        I it \\<sigma>\\<rbrakk>\n                       \\<Longrightarrow> I (it - {x})\n    (f \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> I {} (foldl f \\<sigma>0 S);\n        distinct (a # S); I (set (a # S)) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> set (a # S);\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> I {} (foldl f \\<sigma>0 (a # S))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I {} (foldl f \\<sigma>0 (x # S))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. I {} (foldl f (f \\<sigma>0 x) S)", "apply (rule Cons.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct S\n 2. I (set S) (f \\<sigma>0 x)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct S\n 2. I (set S) (f \\<sigma>0 x)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  distinct (x # S)", "show \"distinct S\""], ["proof (prove)\nusing this:\n  distinct (x # S)\n\ngoal (1 subgoal):\n 1. distinct S", "by simp"], ["proof (state)\nthis:\n  distinct S\n\ngoal (2 subgoals):\n 1. I (set S) (f \\<sigma>0 x)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "from Cons.prems(3)[of x \"set (x#S)\", simplified,\n                       OF Cons.prems(2)[simplified]]"], ["proof (chain)\npicking this:\n  I (set S) (f \\<sigma>0 x)", "show \"I (set S) (f \\<sigma>0 x)\""], ["proof (prove)\nusing this:\n  I (set S) (f \\<sigma>0 x)\n\ngoal (1 subgoal):\n 1. I (set S) (f \\<sigma>0 x)", "."], ["proof (state)\nthis:\n  I (set S) (f \\<sigma>0 x)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "fix xx it \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "assume A: \"xx\\<in>it\" \"it \\<subseteq> set S\" \"I it \\<sigma>\""], ["proof (state)\nthis:\n  xx \\<in> it\n  it \\<subseteq> set S\n  I it \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> set S; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {x}) (f \\<sigma> x)", "show \"I (it - {xx}) (f \\<sigma> xx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (it - {xx}) (f \\<sigma> xx)", "using A(2)"], ["proof (prove)\nusing this:\n  it \\<subseteq> set S\n\ngoal (1 subgoal):\n 1. I (it - {xx}) (f \\<sigma> xx)", "apply (rule_tac Cons.prems(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. it \\<subseteq> set S \\<Longrightarrow> xx \\<in> it\n 2. it \\<subseteq> set S \\<Longrightarrow> it \\<subseteq> set (x # S)\n 3. it \\<subseteq> set S \\<Longrightarrow> I it \\<sigma>", "apply (simp_all add: A(1,3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. it \\<subseteq> set S \\<Longrightarrow> it \\<subseteq> insert x (set S)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  I (it - {xx}) (f \\<sigma> xx)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I {} (foldl f \\<sigma>0 (x # S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_length_aux: \"foldl (\\<lambda>i x. Suc i) a l = a + length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>i x. Suc i) a l = a + length l", "by (induct l arbitrary: a) auto"], ["", "lemmas foldl_length[simp] = foldl_length_aux[where a=0, simplified]"], ["", "lemma foldr_length_aux: \"foldr (\\<lambda>x i. Suc i) l a = a + length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. Suc) l a = a + length l", "by (induct l arbitrary: a rule: rev_induct) auto"], ["", "lemmas foldr_length[simp] = foldr_length_aux[where a=0, simplified]"], ["", "context comp_fun_commute begin"], ["", "lemma foldl_f_commute: \"f a (foldl (\\<lambda>a b. f b a) b xs) = foldl (\\<lambda>a b. f b a) (f a b) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a (foldl (\\<lambda>a b. f b a) b xs) =\n    foldl (\\<lambda>a b. f b a) (f a b) xs", "by(induct xs arbitrary: b)(simp_all add: fun_left_comm)"], ["", "lemma foldr_conv_foldl: \"foldr f xs a = foldl (\\<lambda>a b. f b a) a xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr f xs a = foldl (\\<lambda>a b. f b a) a xs", "by(induct xs arbitrary: a)(simp_all add: foldl_f_commute)"], ["", "end"], ["", "lemma filter_conv_foldr:\n  \"filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []", "by(induct xs) simp_all"], ["", "lemma foldr_Cons: \"foldr Cons xs [] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (#) xs [] = xs", "by(induct xs) simp_all"], ["", "lemma foldr_snd_zip:\n  \"length xs \\<ge> length ys \\<Longrightarrow> foldr (\\<lambda>(x, y). f y) (zip xs ys) b = foldr f ys b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys \\<le> length xs \\<Longrightarrow>\n    foldr (\\<lambda>(x, y). f y) (zip xs ys) b = foldr f ys b", "proof(induct ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). f y) (zip xs []) b = foldr f [] b\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   length ys \\<le> length xs \\<Longrightarrow>\n                   foldr (\\<lambda>(x, y). f y) (zip xs ys) b =\n                   foldr f ys b;\n        length (a # ys) \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). f y) (zip xs (a # ys)) b =\n                         foldr f (a # ys) b", "case (Cons y ys)"], ["proof (state)\nthis:\n  length ys \\<le> length ?xs \\<Longrightarrow>\n  foldr (\\<lambda>a. case a of (x, a) \\<Rightarrow> f a) (zip ?xs ys) b =\n  foldr f ys b\n  length (y # ys) \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). f y) (zip xs []) b = foldr f [] b\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   length ys \\<le> length xs \\<Longrightarrow>\n                   foldr (\\<lambda>(x, y). f y) (zip xs ys) b =\n                   foldr f ys b;\n        length (a # ys) \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). f y) (zip xs (a # ys)) b =\n                         foldr f (a # ys) b", "thus ?case"], ["proof (prove)\nusing this:\n  length ys \\<le> length ?xs \\<Longrightarrow>\n  foldr (\\<lambda>a. case a of (x, a) \\<Rightarrow> f a) (zip ?xs ys) b =\n  foldr f ys b\n  length (y # ys) \\<le> length xs\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, a) \\<Rightarrow> f a) (zip xs (y # ys))\n     b =\n    foldr f (y # ys) b", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, a) \\<Rightarrow> f a) (zip xs (y # ys))\n   b =\n  foldr f (y # ys) b\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). f y) (zip xs []) b = foldr f [] b", "qed simp"], ["", "lemma foldl_snd_zip:\n  \"length xs \\<ge> length ys \\<Longrightarrow> foldl (\\<lambda>b (x, y). f b y) b (zip xs ys) = foldl f b ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys \\<le> length xs \\<Longrightarrow>\n    foldl (\\<lambda>b (x, y). f b y) b (zip xs ys) = foldl f b ys", "proof(induct ys arbitrary: xs b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs b.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldl (\\<lambda>b (x, y). f b y) b (zip xs []) = foldl f b []\n 2. \\<And>a ys xs b.\n       \\<lbrakk>\\<And>xs b.\n                   length ys \\<le> length xs \\<Longrightarrow>\n                   foldl (\\<lambda>b (x, y). f b y) b (zip xs ys) =\n                   foldl f b ys;\n        length (a # ys) \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>b (x, y). f b y) b\n                          (zip xs (a # ys)) =\n                         foldl f b (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  length ys \\<le> length ?xs \\<Longrightarrow>\n  foldl (\\<lambda>b a. case a of (x, a) \\<Rightarrow> f b a) ?b\n   (zip ?xs ys) =\n  foldl f ?b ys\n  length (y # ys) \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs b.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldl (\\<lambda>b (x, y). f b y) b (zip xs []) = foldl f b []\n 2. \\<And>a ys xs b.\n       \\<lbrakk>\\<And>xs b.\n                   length ys \\<le> length xs \\<Longrightarrow>\n                   foldl (\\<lambda>b (x, y). f b y) b (zip xs ys) =\n                   foldl f b ys;\n        length (a # ys) \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>b (x, y). f b y) b\n                          (zip xs (a # ys)) =\n                         foldl f b (a # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  length ys \\<le> length ?xs \\<Longrightarrow>\n  foldl (\\<lambda>b a. case a of (x, a) \\<Rightarrow> f b a) ?b\n   (zip ?xs ys) =\n  foldl f ?b ys\n  length (y # ys) \\<le> length xs\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>b a. case a of (x, a) \\<Rightarrow> f b a) b\n     (zip xs (y # ys)) =\n    foldl f b (y # ys)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>b a. case a of (x, a) \\<Rightarrow> f b a) b\n   (zip xs (y # ys)) =\n  foldl f b (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs b.\n       length [] \\<le> length xs \\<Longrightarrow>\n       foldl (\\<lambda>b (x, y). f b y) b (zip xs []) = foldl f b []", "qed simp"], ["", "lemma fst_foldl: \"fst (foldl (\\<lambda>(a, b) x. (f a x, g a b x)) (a, b) xs) = foldl f a xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl (\\<lambda>(a, b) x. (f a x, g a b x)) (a, b) xs) =\n    foldl f a xs", "by(induct xs arbitrary: a b) simp_all"], ["", "lemma foldl_foldl_conv_concat: \"foldl (foldl f) a xs = foldl f a (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (foldl f) a xs = foldl f a (concat xs)", "by(induct xs arbitrary: a) simp_all"], ["", "lemma foldl_list_update:\n  \"n < length xs \\<Longrightarrow> foldl f a (xs[n := x]) = foldl f (f (foldl f a (take n xs)) x) (drop (Suc n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    foldl f a (xs[n := x]) =\n    foldl f (f (foldl f a (take n xs)) x) (drop (Suc n) xs)", "by(simp add: upd_conv_take_nth_drop)"], ["", "lemma map_by_foldl:\n  fixes l :: \"'a list\" and f :: \"'a \\<Rightarrow> 'b\"\n  shows \"foldl (\\<lambda>l x. l@[f x]) [] l = map f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "fix l'"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "have \"foldl (\\<lambda>l x. l@[f x]) l' l = l'@map f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) l' l = l' @ map f l", "by (induct l arbitrary: l') auto"], ["proof (state)\nthis:\n  foldl (\\<lambda>l x. l @ [f x]) l' l = l' @ map f l\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>l x. l @ [f x]) ?l'2 l = ?l'2 @ map f l\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>l x. l @ [f x]) ?l'2 l = ?l'2 @ map f l\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>l x. l @ [f x]) [] l = map f l", "by simp"], ["proof (state)\nthis:\n  foldl (\\<lambda>l x. l @ [f x]) [] l = map f l\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Sorting\\<close>"], ["", "lemma sorted_in_between:\n  assumes A: \"0\\<le>i\" \"i<j\" \"j<length l\"\n  assumes S: \"sorted l\"\n  assumes E: \"l!i \\<le> x\" \"x<l!j\"\n  obtains k where \"i\\<le>k\" and \"k<j\" and \"l!k\\<le>x\" and \"x<l!(k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; k < j; l ! k \\<le> x; x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; k < j; l ! k \\<le> x; x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A E"], ["proof (chain)\npicking this:\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j", "have \"\\<exists>k. i\\<le>k \\<and> k<j \\<and> l!k\\<le>x \\<and> x<l!(k+1)\""], ["proof (prove)\nusing this:\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "proof (induct \"j-i\" arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; 0 \\<le> i; i < j; j < length l; l ! i \\<le> x;\n        x < l ! j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k < j \\<and>\n                            l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<And>xa i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>xa = j - i; 0 \\<le> i; i < j; j < length l;\n                    l ! i \\<le> x; x < l ! j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k\\<ge>i.\n  k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1);\n        Suc xa = j - i; 0 \\<le> i; i < j; j < length l; l ! i \\<le> x;\n        x < l ! j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k < j \\<and>\n                            l ! k \\<le> x \\<and> x < l ! (k + 1)", "case (Suc d)"], ["proof (state)\nthis:\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; 0 \\<le> i; i < j; j < length l; l ! i \\<le> x;\n        x < l ! j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k < j \\<and>\n                            l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<And>xa i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>xa = j - i; 0 \\<le> i; i < j; j < length l;\n                    l ! i \\<le> x; x < l ! j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k\\<ge>i.\n  k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1);\n        Suc xa = j - i; 0 \\<le> i; i < j; j < length l; l ! i \\<le> x;\n        x < l ! j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k < j \\<and>\n                            l ! k \\<le> x \\<and> x < l ! (k + 1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "proof (cases \"l!(i+1) \\<le> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "case True"], ["proof (state)\nthis:\n  l ! (i + 1) \\<le> x\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True Suc.hyps"], ["proof (chain)\npicking this:\n  l ! (i + 1) \\<le> x\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i", "have \"d = j - (i + 1)\""], ["proof (prove)\nusing this:\n  l ! (i + 1) \\<le> x\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i\n\ngoal (1 subgoal):\n 1. d = j - (i + 1)", "by simp"], ["proof (state)\nthis:\n  d = j - (i + 1)\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "moreover"], ["proof (state)\nthis:\n  d = j - (i + 1)\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True"], ["proof (chain)\npicking this:\n  l ! (i + 1) \\<le> x", "have \"i+1 < j\""], ["proof (prove)\nusing this:\n  l ! (i + 1) \\<le> x\n\ngoal (1 subgoal):\n 1. i + 1 < j", "by (metis Suc.prems Suc_eq_plus1 Suc_lessI not_less)"], ["proof (state)\nthis:\n  i + 1 < j\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "moreover"], ["proof (state)\nthis:\n  i + 1 < j\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True"], ["proof (chain)\npicking this:\n  l ! (i + 1) \\<le> x", "have \"0\\<le>i+1\""], ["proof (prove)\nusing this:\n  l ! (i + 1) \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> i + 1", "by simp"], ["proof (state)\nthis:\n  0 \\<le> i + 1\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "ultimately"], ["proof (chain)\npicking this:\n  d = j - (i + 1)\n  i + 1 < j\n  0 \\<le> i + 1", "obtain k where\n        \"i+1\\<le>k\" \"k<j\" \"l!k \\<le> x\" \"x<l!(k+1)\""], ["proof (prove)\nusing this:\n  d = j - (i + 1)\n  i + 1 < j\n  0 \\<le> i + 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i + 1 \\<le> k; k < j; l ! k \\<le> x;\n         x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps(1)[of j \"i+1\"] Suc.prems True"], ["proof (prove)\nusing this:\n  d = j - (i + 1)\n  i + 1 < j\n  0 \\<le> i + 1\n  \\<lbrakk>d = j - (i + 1); 0 \\<le> i + 1; i + 1 < j; j < length l;\n   l ! (i + 1) \\<le> x; x < l ! j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>i + 1.\n                       k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n  l ! (i + 1) \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i + 1 \\<le> k; k < j; l ! k \\<le> x;\n         x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i + 1 \\<le> k\n  k < j\n  l ! k \\<le> x\n  x < l ! (k + 1)\n\ngoal (2 subgoals):\n 1. l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i + 1 \\<le> k\n  k < j\n  l ! k \\<le> x\n  x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "by (auto dest: Suc_leD)"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "case False"], ["proof (state)\nthis:\n  \\<not> l ! (i + 1) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> l ! (i + 1) \\<le> x \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "proof (cases \"x<(l!(j - 1))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "case True"], ["proof (state)\nthis:\n  x < l ! (j - 1)\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True Suc.hyps"], ["proof (chain)\npicking this:\n  x < l ! (j - 1)\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i", "have \"d = j - (i + 1)\""], ["proof (prove)\nusing this:\n  x < l ! (j - 1)\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i\n\ngoal (1 subgoal):\n 1. d = j - (i + 1)", "by simp"], ["proof (state)\nthis:\n  d = j - (i + 1)\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "moreover"], ["proof (state)\nthis:\n  d = j - (i + 1)\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True Suc.prems"], ["proof (chain)\npicking this:\n  x < l ! (j - 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j", "have \"i < j - 1\""], ["proof (prove)\nusing this:\n  x < l ! (j - 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n\ngoal (1 subgoal):\n 1. i < j - 1", "by (metis Suc_eq_plus1 Suc_lessI diff_Suc_1 less_diff_conv not_le)"], ["proof (state)\nthis:\n  i < j - 1\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "moreover"], ["proof (state)\nthis:\n  i < j - 1\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "from True Suc.prems"], ["proof (chain)\npicking this:\n  x < l ! (j - 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j", "have \"j - 1 < length l\""], ["proof (prove)\nusing this:\n  x < l ! (j - 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n\ngoal (1 subgoal):\n 1. j - 1 < length l", "by simp"], ["proof (state)\nthis:\n  j - 1 < length l\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "ultimately"], ["proof (chain)\npicking this:\n  d = j - (i + 1)\n  i < j - 1\n  j - 1 < length l", "obtain k where\n          \"i\\<le>k\" \"k<j - 1\" \"l!k \\<le> x\" \"x<l!(k+1)\""], ["proof (prove)\nusing this:\n  d = j - (i + 1)\n  i < j - 1\n  j - 1 < length l\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; k < j - 1; l ! k \\<le> x;\n         x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps(1)[of \"j - 1\" i] Suc.prems True"], ["proof (prove)\nusing this:\n  d = j - (i + 1)\n  i < j - 1\n  j - 1 < length l\n  \\<lbrakk>d = j - 1 - i; 0 \\<le> i; i < j - 1; j - 1 < length l;\n   l ! i \\<le> x; x < l ! (j - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>i.\n                       k < j - 1 \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n  x < l ! (j - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; k < j - 1; l ! k \\<le> x;\n         x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> k\n  k < j - 1\n  l ! k \\<le> x\n  x < l ! (k + 1)\n\ngoal (2 subgoals):\n 1. x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n 2. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k < j - 1\n  l ! k \\<le> x\n  x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "by (auto dest: Suc_leD)"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "case False"], ["proof (state)\nthis:\n  \\<not> x < l ! (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x < l ! (j - 1) \\<Longrightarrow>\n    \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x < l ! (j - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "using Suc"], ["proof (prove)\nusing this:\n  \\<not> x < l ! (j - 1)\n  \\<lbrakk>d = ?j - ?i; 0 \\<le> ?i; ?i < ?j; ?j < length l; l ! ?i \\<le> x;\n   x < l ! ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>?i.\n                       k < ?j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n  Suc d = j - i\n  0 \\<le> i\n  i < j\n  j < length l\n  l ! i \\<le> x\n  x < l ! j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> x < l ! (j - Suc 0);\n     \\<And>j i.\n        \\<lbrakk>d = j - i; i < j; j < length l; l ! i \\<le> x;\n         x < l ! j\\<rbrakk>\n        \\<Longrightarrow> \\<exists>k\\<ge>i.\n                             k < j \\<and>\n                             l ! k \\<le> x \\<and> x < l ! Suc k;\n     Suc d = j - i; i < j; j < length l; l ! i \\<le> x; x < l ! j\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k\\<ge>i.\n                         k < j \\<and> l ! k \\<le> x \\<and> x < l ! Suc k", "by (metis Suc_leI add_0_iff add_diff_inverse diff_Suc_1 le_add2 lessI\n              not0_implies_Suc not_less)"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; 0 \\<le> i; i < j; j < length l; l ! i \\<le> x;\n        x < l ! j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k < j \\<and>\n                            l ! k \\<le> x \\<and> x < l ! (k + 1)", "qed simp"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; k < j; l ! k \\<le> x; x < l ! (k + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>k\\<ge>i. k < j \\<and> l ! k \\<le> x \\<and> x < l ! (k + 1)\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_hd_last:\n  \"\\<lbrakk>sorted l; l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> hd l \\<le> last l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted l; l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd l \\<le> last l", "by (metis eq_iff hd_Cons_tl last_in_set not_hd_in_tl sorted.simps(2))"], ["", "lemma (in linorder) sorted_hd_min:\n  \"\\<lbrakk>xs \\<noteq> []; sorted xs\\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set xs. hd xs \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; sorted xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set xs. hd xs \\<le> x", "by (induct xs, auto)"], ["", "lemma sorted_append_bigger:\n  \"\\<lbrakk>sorted xs; \\<forall>x \\<in> set xs. x \\<le> y\\<rbrakk> \\<Longrightarrow> sorted (xs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> sorted (xs @ [y])", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; \\<forall>x\\<in>set []. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> sorted ([] @ [y])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "case Nil"], ["proof (state)\nthis:\n  sorted []\n  \\<forall>x\\<in>set []. x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; \\<forall>x\\<in>set []. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> sorted ([] @ [y])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "then"], ["proof (chain)\npicking this:\n  sorted []\n  \\<forall>x\\<in>set []. x \\<le> y", "show ?case"], ["proof (prove)\nusing this:\n  sorted []\n  \\<forall>x\\<in>set []. x \\<le> y\n\ngoal (1 subgoal):\n 1. sorted ([] @ [y])", "by simp"], ["proof (state)\nthis:\n  sorted ([] @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y", "have s: \"sorted xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y\n\ngoal (1 subgoal):\n 1. sorted xs", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y", "have a: \"\\<forall>x\\<in>set xs. x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 \\<forall>x\\<in>set xs. x \\<le> y\\<rbrakk>\n                \\<Longrightarrow> sorted (xs @ [y]);\n        sorted (a # xs); \\<forall>x\\<in>set (a # xs). x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted ((a # xs) @ [y])", "from Cons(1)[OF s a] Cons(2-)"], ["proof (chain)\npicking this:\n  sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y", "show ?case"], ["proof (prove)\nusing this:\n  sorted (xs @ [y])\n  sorted (x # xs)\n  \\<forall>x\\<in>set (x # xs). x \\<le> y\n\ngoal (1 subgoal):\n 1. sorted ((x # xs) @ [y])", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  sorted ((x # xs) @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_filter':\n  \"sorted l \\<Longrightarrow> sorted (filter P l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted l \\<Longrightarrow> sorted (filter P l)", "using sorted_filter[where f=id, simplified]"], ["proof (prove)\nusing this:\n  sorted ?xs \\<Longrightarrow> sorted (filter ?P ?xs)\n\ngoal (1 subgoal):\n 1. sorted l \\<Longrightarrow> sorted (filter P l)", "."], ["", "subsubsection \\<open>Map\\<close>"], ["", "(* List.thy has:\n declare map_eq_Cons_D [dest!]  Cons_eq_map_D [dest!] *)"], ["", "lemma map_eq_consE: \"\\<lbrakk>map f ls = fa#fl; !!a l. \\<lbrakk> ls=a#l; f a=fa; map f l = fl \\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map f ls = fa # fl;\n     \\<And>a l.\n        \\<lbrakk>ls = a # l; f a = fa; map f l = fl\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "lemma map_fst_mk_snd[simp]: \"map fst (map (\\<lambda>x. (x,k)) l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>x. (x, k)) l) = l", "by (induct l) auto"], ["", "lemma map_snd_mk_fst[simp]: \"map snd (map (\\<lambda>x. (k,x)) l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (map (Pair k) l) = l", "by (induct l) auto"], ["", "lemma map_fst_mk_fst[simp]: \"map fst (map (\\<lambda>x. (k,x)) l) = replicate (length l) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (Pair k) l) = replicate (length l) k", "by (induct l) auto"], ["", "lemma map_snd_mk_snd[simp]: \"map snd (map (\\<lambda>x. (x,k)) l) = replicate (length l) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (map (\\<lambda>x. (x, k)) l) = replicate (length l) k", "by (induct l) auto"], ["", "lemma map_zip1: \"map (\\<lambda>x. (x,k)) l = zip l (replicate (length l) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (x, k)) l = zip l (replicate (length l) k)", "by (induct l) auto"], ["", "lemma map_zip2: \"map (\\<lambda>x. (k,x)) l = zip (replicate (length l) k) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Pair k) l = zip (replicate (length l) k) l", "by (induct l) auto"], ["", "lemmas map_zip=map_zip1 map_zip2"], ["", "(* TODO/FIXME: hope nobody changes nth to be underdefined! *)"], ["", "lemma map_eq_nth_eq:\n  assumes A: \"map f l = map f l'\"\n  shows \"f (l!i) = f (l'!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (l ! i) = f (l' ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (l ! i) = f (l' ! i)", "from A"], ["proof (chain)\npicking this:\n  map f l = map f l'", "have \"length l = length l'\""], ["proof (prove)\nusing this:\n  map f l = map f l'\n\ngoal (1 subgoal):\n 1. length l = length l'", "by (metis length_map)"], ["proof (state)\nthis:\n  length l = length l'\n\ngoal (1 subgoal):\n 1. f (l ! i) = f (l' ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length l = length l'\n\ngoal (1 subgoal):\n 1. f (l ! i) = f (l' ! i)", "using A"], ["proof (prove)\nusing this:\n  length l = length l'\n  map f l = map f l'\n\ngoal (1 subgoal):\n 1. f (l ! i) = f (l' ! i)", "apply (induct arbitrary: i rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. map f [] = map f [] \\<Longrightarrow> f ([] ! i) = f ([] ! i)\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           map f xs = map f ys \\<Longrightarrow> f (xs ! i) = f (ys ! i);\n        map f (x # xs) = map f (y # ys)\\<rbrakk>\n       \\<Longrightarrow> f ((x # xs) ! i) = f ((y # ys) ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           map f xs = map f ys \\<Longrightarrow> f (xs ! i) = f (ys ! i);\n        map f (x # xs) = map f (y # ys)\\<rbrakk>\n       \\<Longrightarrow> f ((x # xs) ! i) = f ((y # ys) ! i)", "apply (simp add: nth_def split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f (l ! i) = f (l' ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_upd_eq:\n  \"\\<lbrakk>i<length l \\<Longrightarrow> f (l!i) = f x\\<rbrakk> \\<Longrightarrow> map f (l[i:=x]) = map f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < length l \\<Longrightarrow> f (l ! i) = f x) \\<Longrightarrow>\n    map f (l[i := x]) = map f l", "by (metis list_update_beyond list_update_id map_update not_le_imp_less)"], ["", "lemma inj_map_inv_f [simp]: \"inj f \\<Longrightarrow> map (inv f) (map f l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> map (inv f) (map f l) = l", "by (simp)"], ["", "lemma inj_on_map_the: \"\\<lbrakk>D \\<subseteq> dom m; inj_on m D\\<rbrakk> \\<Longrightarrow> inj_on (the\\<circ>m) D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<subseteq> dom m; inj_on m D\\<rbrakk>\n    \\<Longrightarrow> inj_on (the \\<circ> m) D", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        (the \\<circ> m) x = (the \\<circ> m) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"m x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = None\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"m y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = None; m y = None\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = None; m y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto intro: inj_onD) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = None; m y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto intro: inj_onD) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"m y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y a.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a; m y = None\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto intro: inj_onD) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        the (m x) = the (m y); m x = Some a; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rule inj_onD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> inj_on (?f43 x y a aa) (?A43 x y a aa)\n 2. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> ?f43 x y a aa x = ?f43 x y a aa y\n 3. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ?A43 x y a aa\n 4. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ?A43 x y a aa", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> m x = m y\n 2. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D\n 3. \\<And>x y a aa.\n       \\<lbrakk>D \\<subseteq> dom m; inj_on m D; x \\<in> D; y \\<in> D;\n        a = aa; m x = Some aa; m y = Some aa\\<rbrakk>\n       \\<Longrightarrow> y \\<in> D", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_consI:\n  \"w=map f ww \\<Longrightarrow> f a#w = map f (a#ww)\"\n  \"w@l=map f ww@l \\<Longrightarrow> f a#w@l = map f (a#ww)@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = map f ww \\<Longrightarrow> f a # w = map f (a # ww)) &&&\n    (w @ l = map f ww @ l \\<Longrightarrow>\n     f a # w @ l = map f (a # ww) @ l)", "by auto"], ["", "lemma restrict_map_subset_eq:\n  fixes R\n  shows \"\\<lbrakk>m |` R = m'; R'\\<subseteq>R\\<rbrakk> \\<Longrightarrow> m|` R' = m' |` R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m |` R = m'; R' \\<subseteq> R\\<rbrakk>\n    \\<Longrightarrow> m |` R' = m' |` R'", "by (auto simp add: Int_absorb1)"], ["", "lemma restrict_map_self[simp]: \"m |` dom m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` dom m = m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (m |` dom m) x = m x", "apply (case_tac \"m x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. m x = None \\<Longrightarrow> (m |` dom m) x = m x\n 2. \\<And>x a. m x = Some a \\<Longrightarrow> (m |` dom m) x = m x", "apply (auto simp add: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_map_UNIV[simp]: \"f |` UNIV = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |` UNIV = f", "by (auto simp add: restrict_map_def)"], ["", "lemma restrict_map_inv[simp]: \"f |` (- dom f) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |` (- dom f) = Map.empty", "by (auto simp add: restrict_map_def intro: ext)"], ["", "lemma restrict_map_upd: \"(f |` S)(k \\<mapsto> v) = f(k\\<mapsto>v) |` (insert k S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f |` S)(k \\<mapsto> v) = f(k \\<mapsto> v) |` insert k S", "by (auto simp add: restrict_map_def intro: ext)"], ["", "lemma map_upd_eq_restrict: \"m (x:=None) = m |` (-{x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m(x := None) = m |` (- {x})", "by (auto intro: ext)"], ["", "declare Map.finite_dom_map_of [simp, intro!]"], ["", "lemma dom_const'[simp]: \"dom (\\<lambda>x. Some (f x)) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. Some (f x)) = UNIV", "by auto"], ["", "lemma restrict_map_eq :\n  \"((m |` A) k = None) \\<longleftrightarrow> (k \\<notin> dom m \\<inter> A)\"\n  \"((m |` A) k = Some v) \\<longleftrightarrow> (m k = Some v \\<and> k \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((m |` A) k = None) = (k \\<notin> dom m \\<inter> A) &&&\n    ((m |` A) k = Some v) = (m k = Some v \\<and> k \\<in> A)", "unfolding restrict_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if k \\<in> A then m k else None) = None) =\n    (k \\<notin> dom m \\<inter> A) &&&\n    ((if k \\<in> A then m k else None) = Some v) =\n    (m k = Some v \\<and> k \\<in> A)", "by (simp_all add: dom_def)"], ["", "definition \"rel_of m P == {(k,v). m k = Some v \\<and> P (k, v)}\""], ["", "lemma rel_of_empty[simp]: \"rel_of Map.empty P = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_of Map.empty P = {}", "by (auto simp add: rel_of_def)"], ["", "lemma remove1_tl: \"xs \\<noteq> [] \\<Longrightarrow> remove1 (hd xs) xs = tl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> remove1 (hd xs) xs = tl xs", "by (cases xs) auto"], ["", "lemma set_oo_map_alt: \"(set \\<circ>\\<circ> map) f = (\\<lambda>l. f ` set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set \\<circ>\\<circ> map) f = (\\<lambda>l. f ` set l)", "by auto"], ["", "subsubsection \"Filter and Revert\""], ["", "primrec filter_rev_aux where\n  \"filter_rev_aux a P [] = a\"\n| \"filter_rev_aux a P (x#xs) = (\n     if P x then filter_rev_aux (x#a) P xs else filter_rev_aux a P xs)\""], ["", "lemma filter_rev_aux_alt: \"filter_rev_aux a P l = filter P (rev l) @ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_rev_aux a P l = filter P (rev l) @ a", "by (induct l arbitrary: a) auto"], ["", "definition \"filter_rev == filter_rev_aux []\""], ["", "lemma filter_rev_alt: \"filter_rev P l = filter P (rev l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_rev P l = filter P (rev l)", "unfolding filter_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_rev_aux [] P l = filter P (rev l)", "by (simp add: filter_rev_aux_alt)"], ["", "definition \"remove_rev x == filter_rev (Not o (=) x)\""], ["", "lemma remove_rev_alt_def :\n  \"remove_rev x xs = (filter (\\<lambda>y. y \\<noteq> x) (rev xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_rev x xs = filter (\\<lambda>y. y \\<noteq> x) (rev xs)", "unfolding remove_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_rev ((Not \\<circ>\\<circ> (=)) x) xs =\n    filter (\\<lambda>y. y \\<noteq> x) (rev xs)", "apply (simp add: filter_rev_alt comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) x) (rev xs) =\n    filter (\\<lambda>y. y \\<noteq> x) (rev xs)", "by metis"], ["", "subsubsection \"zip\""], ["", "declare zip_map_fst_snd[simp]"], ["", "lemma pair_list_split: \"\\<lbrakk> !!l1 l2. \\<lbrakk> l = zip l1 l2; length l1=length l2; length l=length l2 \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n         length l = length l2\\<rbrakk>\n        \\<Longrightarrow> P) \\<Longrightarrow>\n    P", "proof (induct l arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       (\\<And>l1 l2.\n           \\<lbrakk>[] = zip l1 l2; length l1 = length l2;\n            length [] = length l2\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>[] = zip ?l1.0 ?l2.0; length ?l1.0 = length ?l2.0;\n   length [] = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       (\\<And>l1 l2.\n           \\<lbrakk>[] = zip l1 l2; length l1 = length l2;\n            length [] = length l2\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] = zip ?l1.0 ?l2.0; length ?l1.0 = length ?l2.0;\n   length [] = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons a l)"], ["proof (state)\nthis:\n  (\\<And>l1 l2.\n      \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n       length l = length l2\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n  \\<lbrakk>a # l = zip ?l1.0 ?l2.0; length ?l1.0 = length ?l2.0;\n   length (a # l) = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from Cons.hyps"], ["proof (chain)\npicking this:\n  (\\<And>l1 l2.\n      \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n       length l = length l2\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain l1 l2 where IHAPP: \"l=zip l1 l2\" \"length l1 = length l2\" \"length l=length l2\""], ["proof (prove)\nusing this:\n  (\\<And>l1 l2.\n      \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n       length l = length l2\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n         length l = length l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  l = zip l1 l2\n  length l1 = length l2\n  length l = length l2\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "obtain a1 a2 where [simp]: \"a=(a1,a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 a2. a = (a1, a2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  a = (a1, a2)\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from IHAPP"], ["proof (chain)\npicking this:\n  l = zip l1 l2\n  length l1 = length l2\n  length l = length l2", "have \"a#l = zip (a1#l1) (a2#l2)\" \"length (a1#l1) = length (a2#l2)\" \"length (a#l) = length (a2#l2)\""], ["proof (prove)\nusing this:\n  l = zip l1 l2\n  length l1 = length l2\n  length l = length l2\n\ngoal (1 subgoal):\n 1. a # l = zip (a1 # l1) (a2 # l2) &&&\n    length (a1 # l1) = length (a2 # l2) &&&\n    length (a # l) = length (a2 # l2)", "by (simp_all only:) (simp_all (no_asm_use))"], ["proof (state)\nthis:\n  a # l = zip (a1 # l1) (a2 # l2)\n  length (a1 # l1) = length (a2 # l2)\n  length (a # l) = length (a2 # l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   (\\<And>l1 l2.\n                       \\<lbrakk>l = zip l1 l2; length l1 = length l2;\n                        length l = length l2\\<rbrakk>\n                       \\<Longrightarrow> P) \\<Longrightarrow>\n                   P;\n        \\<And>l1 l2.\n           \\<lbrakk>a # l = zip l1 l2; length l1 = length l2;\n            length (a # l) = length l2\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with Cons.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>a # l = zip ?l1.0 ?l2.0; length ?l1.0 = length ?l2.0;\n   length (a # l) = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> P\n  a # l = zip (a1 # l1) (a2 # l2)\n  length (a1 # l1) = length (a2 # l2)\n  length (a # l) = length (a2 # l2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a # l = zip ?l1.0 ?l2.0; length ?l1.0 = length ?l2.0;\n   length (a # l) = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> P\n  a # l = zip (a1 # l1) (a2 # l2)\n  length (a1 # l1) = length (a2 # l2)\n  length (a # l) = length (a2 # l2)\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_zip_cart: \"x\\<in>set (zip l l') \\<Longrightarrow> x\\<in>set l \\<times> set l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (zip l l') \\<Longrightarrow> x \\<in> set l \\<times> set l'", "by (auto simp add: set_zip)"], ["", "lemma map_prod_fun_zip: \"map (\\<lambda>(x, y). (f x, g y)) (zip xs ys) = zip (map f xs) (map g ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<lambda>x y. (f x, g y)) xs ys = zip (map f xs) (map g ys)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map2 (\\<lambda>x y. (f x, g y)) [] ys = zip (map f []) (map g ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           map2 (\\<lambda>x y. (f x, g y)) xs ys =\n           zip (map f xs) (map g ys)) \\<Longrightarrow>\n       map2 (\\<lambda>x y. (f x, g y)) (a # xs) ys =\n       zip (map f (a # xs)) (map g ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map2 (\\<lambda>x y. (f x, g y)) [] ys = zip (map f []) (map g ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           map2 (\\<lambda>x y. (f x, g y)) xs ys =\n           zip (map f xs) (map g ys)) \\<Longrightarrow>\n       map2 (\\<lambda>x y. (f x, g y)) (a # xs) ys =\n       zip (map f (a # xs)) (map g ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<lambda>x y. (f x, g y)) [] ys = zip (map f []) (map g ys)", "by simp"], ["proof (state)\nthis:\n  map2 (\\<lambda>x y. (f x, g y)) [] ys = zip (map f []) (map g ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           map2 (\\<lambda>x y. (f x, g y)) xs ys =\n           zip (map f xs) (map g ys)) \\<Longrightarrow>\n       map2 (\\<lambda>x y. (f x, g y)) (a # xs) ys =\n       zip (map f (a # xs)) (map g ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           map2 (\\<lambda>x y. (f x, g y)) xs ys =\n           zip (map f xs) (map g ys)) \\<Longrightarrow>\n       map2 (\\<lambda>x y. (f x, g y)) (a # xs) ys =\n       zip (map f (a # xs)) (map g ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  map2 (\\<lambda>x y. (f x, g y)) xs ?ys = zip (map f xs) (map g ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           map2 (\\<lambda>x y. (f x, g y)) xs ys =\n           zip (map f xs) (map g ys)) \\<Longrightarrow>\n       map2 (\\<lambda>x y. (f x, g y)) (a # xs) ys =\n       zip (map f (a # xs)) (map g ys)", "thus ?case"], ["proof (prove)\nusing this:\n  map2 (\\<lambda>x y. (f x, g y)) xs ?ys = zip (map f xs) (map g ?ys)\n\ngoal (1 subgoal):\n 1. map2 (\\<lambda>x y. (f x, g y)) (x # xs) ys =\n    zip (map f (x # xs)) (map g ys)", "by(cases ys) simp_all"], ["proof (state)\nthis:\n  map2 (\\<lambda>x y. (f x, g y)) (x # xs) ys =\n  zip (map f (x # xs)) (map g ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Generalized Zip\\<close>"], ["", "text \\<open>Zip two lists element-wise, where the combination of two elements is specified by a function. Note that this function is underdefined for lists of different length.\\<close>"], ["", "fun zipf :: \"('a\\<Rightarrow>'b\\<Rightarrow>'c) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> 'c list\" where\n  \"zipf f [] [] = []\" |\n  \"zipf f (a#as) (b#bs) = f a b # zipf f as bs\""], ["", "lemma zipf_zip: \"\\<lbrakk>length l1 = length l2\\<rbrakk> \\<Longrightarrow> zipf Pair l1 l2 = zip l1 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 = length l2 \\<Longrightarrow> zipf Pair l1 l2 = zip l1 l2", "apply (induct l1 arbitrary: l2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l2.\n       length [] = length l2 \\<Longrightarrow> zipf Pair [] l2 = zip [] l2\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   length l1 = length l2 \\<Longrightarrow>\n                   zipf Pair l1 l2 = zip l1 l2;\n        length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> zipf Pair (a # l1) l2 = zip (a # l1) l2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   length l1 = length l2 \\<Longrightarrow>\n                   zipf Pair l1 l2 = zip l1 l2;\n        Suc (length l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> zipf Pair (a # l1) l2 = zip (a # l1) l2", "apply (case_tac l2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   length l1 = length l2 \\<Longrightarrow>\n                   zipf Pair l1 l2 = zip l1 l2;\n        Suc (length l1) = length l2; l2 = []\\<rbrakk>\n       \\<Longrightarrow> zipf Pair (a # l1) l2 = zip (a # l1) l2\n 2. \\<And>a l1 l2 aa list.\n       \\<lbrakk>\\<And>l2.\n                   length l1 = length l2 \\<Longrightarrow>\n                   zipf Pair l1 l2 = zip l1 l2;\n        Suc (length l1) = length l2; l2 = aa # list\\<rbrakk>\n       \\<Longrightarrow> zipf Pair (a # l1) l2 = zip (a # l1) l2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>All quantification over zipped lists\\<close>"], ["", "fun list_all_zip where\n  \"list_all_zip P [] [] \\<longleftrightarrow> True\" |\n  \"list_all_zip P (a#as) (b#bs) \\<longleftrightarrow> P a b \\<and> list_all_zip P as bs\" |\n  \"list_all_zip P _ _ \\<longleftrightarrow> False\""], ["", "lemma list_all_zip_alt: \"list_all_zip P as bs \\<longleftrightarrow> length as = length bs \\<and> (\\<forall>i<length as. P (as!i) (bs!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip P as bs =\n    (length as = length bs \\<and>\n     (\\<forall>i<length as. P (as ! i) (bs ! i)))", "apply (induct P\\<equiv>P as bs rule: list_all_zip.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_all_zip P [] [] =\n    (length [] = length [] \\<and>\n     (\\<forall>i<length []. P ([] ! i) ([] ! i)))\n 2. \\<And>a as b bs.\n       list_all_zip P as bs =\n       (length as = length bs \\<and>\n        (\\<forall>i<length as. P (as ! i) (bs ! i))) \\<Longrightarrow>\n       list_all_zip P (a # as) (b # bs) =\n       (length (a # as) = length (b # bs) \\<and>\n        (\\<forall>i<length (a # as). P ((a # as) ! i) ((b # bs) ! i)))\n 3. \\<And>v va.\n       list_all_zip P (v # va) [] =\n       (length (v # va) = length [] \\<and>\n        (\\<forall>i<length (v # va). P ((v # va) ! i) ([] ! i)))\n 4. \\<And>v va.\n       list_all_zip P [] (v # va) =\n       (length [] = length (v # va) \\<and>\n        (\\<forall>i<length []. P ([] ! i) ((v # va) ! i)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as b bs i.\n       \\<lbrakk>list_all_zip P as bs; P a b; length as = length bs;\n        \\<forall>i<length bs. P (as ! i) (bs ! i);\n        i < Suc (length bs)\\<rbrakk>\n       \\<Longrightarrow> P ((a # as) ! i) ((b # bs) ! i)", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs i.\n       \\<lbrakk>list_all_zip P as bs; P a b; length as = length bs;\n        \\<forall>i<length bs. P (as ! i) (bs ! i); i < Suc (length bs);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> P ((a # as) ! i) ((b # bs) ! i)\n 2. \\<And>a as b bs i nat.\n       \\<lbrakk>list_all_zip P as bs; P a b; length as = length bs;\n        \\<forall>i<length bs. P (as ! i) (bs ! i); i < Suc (length bs);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P ((a # as) ! i) ((b # bs) ! i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_all_zip_map1: \"list_all_zip P (List.map f as) bs \\<longleftrightarrow> list_all_zip (\\<lambda>a b. P (f a) b) as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip P (map f as) bs = list_all_zip (\\<lambda>a. P (f a)) as bs", "apply (induct as arbitrary: bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       list_all_zip P (map f []) bs =\n       list_all_zip (\\<lambda>a. P (f a)) [] bs\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P (map f as) bs =\n           list_all_zip (\\<lambda>a. P (f a)) as bs) \\<Longrightarrow>\n       list_all_zip P (map f (a # as)) bs =\n       list_all_zip (\\<lambda>a. P (f a)) (a # as) bs", "apply (case_tac bs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs.\n       bs = [] \\<Longrightarrow>\n       list_all_zip P (map f []) bs =\n       list_all_zip (\\<lambda>a. P (f a)) [] bs\n 2. \\<And>bs a list.\n       bs = a # list \\<Longrightarrow>\n       list_all_zip P (map f []) bs =\n       list_all_zip (\\<lambda>a. P (f a)) [] bs\n 3. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P (map f as) bs =\n           list_all_zip (\\<lambda>a. P (f a)) as bs) \\<Longrightarrow>\n       list_all_zip P (map f (a # as)) bs =\n       list_all_zip (\\<lambda>a. P (f a)) (a # as) bs", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P (map f as) bs =\n           list_all_zip (\\<lambda>a. P (f a)) as bs) \\<Longrightarrow>\n       list_all_zip P (map f (a # as)) bs =\n       list_all_zip (\\<lambda>a. P (f a)) (a # as) bs", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   list_all_zip P (map f as) bs =\n                   list_all_zip (\\<lambda>a. P (f a)) as bs;\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> list_all_zip P (map f (a # as)) bs =\n                         list_all_zip (\\<lambda>a. P (f a)) (a # as) bs\n 2. \\<And>a as bs aa list.\n       \\<lbrakk>\\<And>bs.\n                   list_all_zip P (map f as) bs =\n                   list_all_zip (\\<lambda>a. P (f a)) as bs;\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip P (map f (a # as)) bs =\n                         list_all_zip (\\<lambda>a. P (f a)) (a # as) bs", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_all_zip_map2: \"list_all_zip P as (List.map f bs) \\<longleftrightarrow> list_all_zip (\\<lambda>a b. P a (f b)) as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip P as (map f bs) =\n    list_all_zip (\\<lambda>a b. P a (f b)) as bs", "apply (induct as arbitrary: bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       list_all_zip P [] (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) [] bs\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P as (map f bs) =\n           list_all_zip (\\<lambda>a b. P a (f b)) as bs) \\<Longrightarrow>\n       list_all_zip P (a # as) (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) (a # as) bs", "apply (case_tac bs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs.\n       bs = [] \\<Longrightarrow>\n       list_all_zip P [] (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) [] bs\n 2. \\<And>bs a list.\n       bs = a # list \\<Longrightarrow>\n       list_all_zip P [] (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) [] bs\n 3. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P as (map f bs) =\n           list_all_zip (\\<lambda>a b. P a (f b)) as bs) \\<Longrightarrow>\n       list_all_zip P (a # as) (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) (a # as) bs", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           list_all_zip P as (map f bs) =\n           list_all_zip (\\<lambda>a b. P a (f b)) as bs) \\<Longrightarrow>\n       list_all_zip P (a # as) (map f bs) =\n       list_all_zip (\\<lambda>a b. P a (f b)) (a # as) bs", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   list_all_zip P as (map f bs) =\n                   list_all_zip (\\<lambda>a b. P a (f b)) as bs;\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> list_all_zip P (a # as) (map f bs) =\n                         list_all_zip (\\<lambda>a b. P a (f b)) (a # as) bs\n 2. \\<And>a as bs aa list.\n       \\<lbrakk>\\<And>bs.\n                   list_all_zip P as (map f bs) =\n                   list_all_zip (\\<lambda>a b. P a (f b)) as bs;\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip P (a # as) (map f bs) =\n                         list_all_zip (\\<lambda>a b. P a (f b)) (a # as) bs", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare list_all_zip_alt[mono]"], ["", "lemma lazI[intro?]: \"\\<lbrakk> length a = length b; !!i. i<length b \\<Longrightarrow> P (a!i) (b!i) \\<rbrakk>\n  \\<Longrightarrow> list_all_zip P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b;\n     \\<And>i. i < length b \\<Longrightarrow> P (a ! i) (b ! i)\\<rbrakk>\n    \\<Longrightarrow> list_all_zip P a b", "by (auto simp add: list_all_zip_alt)"], ["", "lemma laz_conj[simp]: \"list_all_zip (\\<lambda>x y. P x y \\<and> Q x y) a b\n                       \\<longleftrightarrow> list_all_zip P a b \\<and> list_all_zip Q a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip (\\<lambda>x y. P x y \\<and> Q x y) a b =\n    (list_all_zip P a b \\<and> list_all_zip Q a b)", "by (auto simp add: list_all_zip_alt)"], ["", "lemma laz_len: \"list_all_zip P a b \\<Longrightarrow> length a = length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip P a b \\<Longrightarrow> length a = length b", "by (simp add: list_all_zip_alt)"], ["", "lemma laz_eq: \"list_all_zip (=) a b \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip (=) a b = (a = b)", "apply (induct a arbitrary: b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. list_all_zip (=) [] b = ([] = b)\n 2. \\<And>a1 a2 b.\n       (\\<And>b. list_all_zip (=) a2 b = (a2 = b)) \\<Longrightarrow>\n       list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply (case_tac b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b. b = [] \\<Longrightarrow> list_all_zip (=) [] b = ([] = b)\n 2. \\<And>b a list.\n       b = a # list \\<Longrightarrow> list_all_zip (=) [] b = ([] = b)\n 3. \\<And>a1 a2 b.\n       (\\<And>b. list_all_zip (=) a2 b = (a2 = b)) \\<Longrightarrow>\n       list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a list.\n       b = a # list \\<Longrightarrow> list_all_zip (=) [] b = ([] = b)\n 2. \\<And>a1 a2 b.\n       (\\<And>b. list_all_zip (=) a2 b = (a2 = b)) \\<Longrightarrow>\n       list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       (\\<And>b. list_all_zip (=) a2 b = (a2 = b)) \\<Longrightarrow>\n       list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b. list_all_zip (=) a2 b = (a2 = b); b = []\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)\n 2. \\<And>a1 a2 b a list.\n       \\<lbrakk>\\<And>b. list_all_zip (=) a2 b = (a2 = b);\n        b = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b a list.\n       \\<lbrakk>\\<And>b. list_all_zip (=) a2 b = (a2 = b);\n        b = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (=) (a1 # a2) b = (a1 # a2 = b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma laz_swap_ex:\n  assumes A: \"list_all_zip (\\<lambda>a b. \\<exists>c. P a b c) A B\"\n  obtains C where\n    \"list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C\"\n    \"list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C;\n         list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C;\n         list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A"], ["proof (chain)\npicking this:\n  list_all_zip (\\<lambda>a b. \\<exists>c. P a b c) A B", "have\n    [simp]: \"length A = length B\" and\n    IC: \"\\<forall>i<length B. \\<exists>ci. P (A!i) (B!i) ci\""], ["proof (prove)\nusing this:\n  list_all_zip (\\<lambda>a b. \\<exists>c. P a b c) A B\n\ngoal (1 subgoal):\n 1. length A = length B &&&\n    \\<forall>i<length B. \\<exists>ci. P (A ! i) (B ! i) ci", "by (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  length A = length B\n  \\<forall>i<length B. \\<exists>ci. P (A ! i) (B ! i) ci\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C;\n         list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from obtain_list_from_elements[OF IC]"], ["proof (chain)\npicking this:\n  (\\<And>l.\n      \\<lbrakk>length l = length B;\n       \\<forall>i<length B. P (A ! i) (B ! i) (l ! i)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain C where\n    \"length C = length B\"\n    \"\\<forall>i<length B. P (A!i) (B!i) (C!i)\""], ["proof (prove)\nusing this:\n  (\\<And>l.\n      \\<lbrakk>length l = length B;\n       \\<forall>i<length B. P (A ! i) (B ! i) (l ! i)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>length C = length B;\n         \\<forall>i<length B. P (A ! i) (B ! i) (C ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  length C = length B\n  \\<forall>i<length B. P (A ! i) (B ! i) (C ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>list_all_zip (\\<lambda>a c. \\<exists>b. P a b c) A C;\n         list_all_zip (\\<lambda>b c. \\<exists>a. P a b c) B C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  length C = length B\n  \\<forall>i<length B. P (A ! i) (B ! i) (C ! i)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule_tac that) (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma laz_weak_Pa[simp]:\n  \"list_all_zip (\\<lambda>a b. P a) A B \\<longleftrightarrow> (length A = length B) \\<and> (\\<forall>a\\<in>set A. P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip (\\<lambda>a b. P a) A B =\n    (length A = length B \\<and> (\\<forall>a\\<in>set A. P a))", "by (auto simp add: list_all_zip_alt set_conv_nth)"], ["", "lemma laz_weak_Pb[simp]:\n  \"list_all_zip (\\<lambda>a b. P b) A B \\<longleftrightarrow> (length A = length B) \\<and> (\\<forall>b\\<in>set B. P b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_zip (\\<lambda>a. P) A B =\n    (length A = length B \\<and> (\\<forall>b\\<in>set B. P b))", "by (force simp add: list_all_zip_alt set_conv_nth)"], ["", "subsubsection \"Collecting Sets over Lists\""], ["", "definition \"list_collect_set f l == \\<Union>{ f a | a. a\\<in>set l }\""], ["", "lemma list_collect_set_simps[simp]:\n  \"list_collect_set f [] = {}\"\n  \"list_collect_set f [a] = f a\"\n  \"list_collect_set f (a#l) = f a \\<union> list_collect_set f l\"\n  \"list_collect_set f (l@l') = list_collect_set f l \\<union> list_collect_set f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_collect_set f [] = {} &&& list_collect_set f [a] = f a) &&&\n    list_collect_set f (a # l) = f a \\<union> list_collect_set f l &&&\n    list_collect_set f (l @ l') =\n    list_collect_set f l \\<union> list_collect_set f l'", "by (unfold list_collect_set_def) auto"], ["", "lemma list_collect_set_map_simps[simp]:\n  \"list_collect_set f (map x []) = {}\"\n  \"list_collect_set f (map x [a]) = f (x a)\"\n  \"list_collect_set f (map x (a#l)) = f (x a) \\<union> list_collect_set f (map x l)\"\n  \"list_collect_set f (map x (l@l')) = list_collect_set f (map x l) \\<union> list_collect_set f (map x l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_collect_set f (map x []) = {} &&&\n     list_collect_set f (map x [a]) = f (x a)) &&&\n    list_collect_set f (map x (a # l)) =\n    f (x a) \\<union> list_collect_set f (map x l) &&&\n    list_collect_set f (map x (l @ l')) =\n    list_collect_set f (map x l) \\<union> list_collect_set f (map x l')", "by simp_all"], ["", "lemma list_collect_set_alt: \"list_collect_set f l = \\<Union>{ f (l!i) | i. i<length l }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_collect_set f l = \\<Union> {f (l ! i) |i. i < length l}", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_collect_set f [] = \\<Union> {f ([] ! i) |i. i < length []}\n 2. \\<And>a l.\n       list_collect_set f l =\n       \\<Union> {f (l ! i) |i. i < length l} \\<Longrightarrow>\n       list_collect_set f (a # l) =\n       \\<Union> {f ((a # l) ! i) |i. i < length (a # l)}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       list_collect_set f l =\n       \\<Union> {f (l ! i) |i. i < length l} \\<Longrightarrow>\n       list_collect_set f (a # l) =\n       \\<Union> {f ((a # l) ! i) |i. i < length (a # l)}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> list_collect_set f (a # l)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Union>\n                                  {f ((a # l) ! i) |i. i < length (a # l)}\n 2. \\<And>a l x X i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> list_collect_set f (a # l)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f (l ! i); i < length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>i.\n                                xa = f ((a # l) ! i) \\<and>\n                                i < Suc (length l)) \\<and>\n                            x \\<in> xa\n 2. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply (rule_tac x=\"f (l!i)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f (l ! i); i < length l\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ia.\n                             f (l ! i) = f ((a # l) ! ia) \\<and>\n                             ia < Suc (length l)) \\<and>\n                         x \\<in> f (l ! i)\n 2. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f (l ! i); i < length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            f (l ! i) = f ((a # l) ! ia) \\<and>\n                            ia < Suc (length l)\n 2. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply (rule_tac x=\"Suc i\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f (l ! i); i < length l\\<rbrakk>\n       \\<Longrightarrow> f (l ! i) = f ((a # l) ! Suc i) \\<and>\n                         Suc i < Suc (length l)\n 2. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l x i.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa;\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a\n 2. \\<And>a l x i nat.\n       \\<lbrakk>list_collect_set f l =\n                \\<Union> {f (l ! i) |i. i < length l};\n        x \\<in> f ((a # l) ! i); i < Suc (length l);\n        \\<forall>xa.\n           (\\<forall>i.\n               xa = f (l ! i) \\<longrightarrow> \\<not> i < length l) \\<or>\n           x \\<notin> xa;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_collect_set_as_map: \"list_collect_set f l = \\<Union>(set (map f l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_collect_set f l = \\<Union> (set (map f l))", "by (unfold list_collect_set_def) auto"], ["", "subsubsection \\<open>Sorted List with arbitrary Relations\\<close>"], ["", "lemma (in linorder) sorted_wrt_rev_linord [simp] :\n  \"sorted_wrt (\\<ge>) l \\<longleftrightarrow> sorted (rev l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) l = sorted (rev l)", "by (simp add: sorted_sorted_wrt sorted_wrt_rev)"], ["", "lemma (in linorder) sorted_wrt_map_linord [simp] :\n  \"sorted_wrt (\\<lambda>(x::'a \\<times> 'b) y. fst x \\<le> fst y) l\n  \\<longleftrightarrow> sorted (map fst l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst x \\<le> fst y) l = sorted (map fst l)", "by (simp add: sorted_sorted_wrt sorted_wrt_map)"], ["", "lemma (in linorder) sorted_wrt_map_rev_linord [simp] :\n  \"sorted_wrt (\\<lambda>(x::'a \\<times> 'b) y. fst x \\<ge> fst y) l\n  \\<longleftrightarrow> sorted (rev (map fst l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y \\<le> fst x) l =\n    sorted (rev (map fst l))", "by (induct l) (auto simp add: sorted_append)"], ["", "subsubsection \\<open>Take and Drop\\<close>"], ["", "lemma take_update[simp]: \"take n (l[i:=x]) = (take n l)[i:=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n (l[i := x]) = (take n l)[i := x]", "apply (induct l arbitrary: n i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i. take n ([][i := x]) = (take n [])[i := x]\n 2. \\<And>a l n i.\n       (\\<And>n i.\n           take n (l[i := x]) = (take n l)[i := x]) \\<Longrightarrow>\n       take n ((a # l)[i := x]) = (take n (a # l))[i := x]", "apply (auto split: nat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l n.\n       (\\<And>n i.\n           take n (l[i := x]) = (take n l)[i := x]) \\<Longrightarrow>\n       take n (x # l) = (take n (a # l))[0 := x]\n 2. \\<And>a l n x2.\n       (\\<And>n i.\n           take n (l[i := x]) = (take n l)[i := x]) \\<Longrightarrow>\n       take n (a # l[x2 := x]) = (take n (a # l))[Suc x2 := x]", "apply (case_tac n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a l n.\n       \\<lbrakk>\\<And>n i. take n (l[i := x]) = (take n l)[i := x];\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> take n (x # l) = (take n (a # l))[0 := x]\n 2. \\<And>a l n nat.\n       \\<lbrakk>\\<And>n i. take n (l[i := x]) = (take n l)[i := x];\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take n (x # l) = (take n (a # l))[0 := x]\n 3. \\<And>a l n x2.\n       (\\<And>n i.\n           take n (l[i := x]) = (take n l)[i := x]) \\<Longrightarrow>\n       take n (a # l[x2 := x]) = (take n (a # l))[Suc x2 := x]", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l n x2.\n       (\\<And>n i.\n           take n (l[i := x]) = (take n l)[i := x]) \\<Longrightarrow>\n       take n (a # l[x2 := x]) = (take n (a # l))[Suc x2 := x]", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l n x2.\n       \\<lbrakk>\\<And>n i. take n (l[i := x]) = (take n l)[i := x];\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> take n (a # l[x2 := x]) = (take n (a # l))\n                         [Suc x2 := x]\n 2. \\<And>a l n x2 nat.\n       \\<lbrakk>\\<And>n i. take n (l[i := x]) = (take n l)[i := x];\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take n (a # l[x2 := x]) = (take n (a # l))\n                         [Suc x2 := x]", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_update_last: \"length list>n \\<Longrightarrow> (take (Suc n) list) [n:=x] = take n list @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length list \\<Longrightarrow>\n    (take (Suc n) list)[n := x] = take n list @ [x]", "by (induct list arbitrary: n)\n       (auto split: nat.split)"], ["", "lemma drop_upd_irrelevant: \"m < n \\<Longrightarrow> drop n (l[m:=x]) = drop n l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> drop n (l[m := x]) = drop n l", "apply (induct n arbitrary: l m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l m. m < 0 \\<Longrightarrow> drop 0 (l[m := x]) = drop 0 l\n 2. \\<And>n l m.\n       \\<lbrakk>\\<And>l m.\n                   m < n \\<Longrightarrow> drop n (l[m := x]) = drop n l;\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> drop (Suc n) (l[m := x]) = drop (Suc n) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n l m.\n       \\<lbrakk>\\<And>l m.\n                   m < n \\<Longrightarrow> drop n (l[m := x]) = drop n l;\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> drop (Suc n) (l[m := x]) = drop (Suc n) l", "apply (case_tac l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n l m.\n       \\<lbrakk>\\<And>l m.\n                   m < n \\<Longrightarrow> drop n (l[m := x]) = drop n l;\n        m < Suc n; l = []\\<rbrakk>\n       \\<Longrightarrow> drop (Suc n) (l[m := x]) = drop (Suc n) l\n 2. \\<And>n l m a list.\n       \\<lbrakk>\\<And>l m.\n                   m < n \\<Longrightarrow> drop n (l[m := x]) = drop n l;\n        m < Suc n; l = a # list\\<rbrakk>\n       \\<Longrightarrow> drop (Suc n) (l[m := x]) = drop (Suc n) l", "apply (auto split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_drop_conv:\n  \"set (drop n l) =  { l!i | i. n\\<le>i \\<and> i < length l }\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (drop n l) = {l ! i |i. n \\<le> i \\<and> i < length l}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "assume \"x\\<in>?L\""], ["proof (state)\nthis:\n  x \\<in> set (drop n l)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (drop n l)", "obtain i where L: \"i<length l - n\" and X: \"x = drop n l!i\""], ["proof (prove)\nusing this:\n  x \\<in> set (drop n l)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length l - n; x = drop n l ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length l - n\n  x = drop n l ! i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "note X"], ["proof (state)\nthis:\n  x = drop n l ! i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "also"], ["proof (state)\nthis:\n  x = drop n l ! i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "have \"\\<dots> = l!(n+i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n l ! i = l ! (n + i)", "using L"], ["proof (prove)\nusing this:\n  i < length l - n\n\ngoal (1 subgoal):\n 1. drop n l ! i = l ! (n + i)", "by simp"], ["proof (state)\nthis:\n  drop n l ! i = l ! (n + i)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (drop n l) \\<Longrightarrow>\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n 2. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "finally"], ["proof (chain)\npicking this:\n  x = l ! (n + i)", "show \"x\\<in>?R\""], ["proof (prove)\nusing this:\n  x = l ! (n + i)\n\ngoal (1 subgoal):\n 1. x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}", "using L"], ["proof (prove)\nusing this:\n  x = l ! (n + i)\n  i < length l - n\n\ngoal (1 subgoal):\n 1. x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "assume \"x\\<in>?R\""], ["proof (state)\nthis:\n  x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}", "obtain i where L: \"n\\<le>i\" \"i<length l\" and X: \"x=l!i\""], ["proof (prove)\nusing this:\n  x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>n \\<le> i; i < length l; x = l ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n \\<le> i\n  i < length l\n  x = l ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "note X"], ["proof (state)\nthis:\n  x = l ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "moreover"], ["proof (state)\nthis:\n  x = l ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "have \"l!i = drop n l ! (i - n)\" and \"(i-n) < length l - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! i = drop n l ! (i - n) &&& i - n < length l - n", "using L"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < length l\n\ngoal (1 subgoal):\n 1. l ! i = drop n l ! (i - n) &&& i - n < length l - n", "by (auto)"], ["proof (state)\nthis:\n  l ! i = drop n l ! (i - n)\n  i - n < length l - n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {l ! i |i. n \\<le> i \\<and> i < length l} \\<Longrightarrow>\n       x \\<in> set (drop n l)", "ultimately"], ["proof (chain)\npicking this:\n  x = l ! i\n  l ! i = drop n l ! (i - n)\n  i - n < length l - n", "show \"x\\<in>?L\""], ["proof (prove)\nusing this:\n  x = l ! i\n  l ! i = drop n l ! (i - n)\n  i - n < length l - n\n\ngoal (1 subgoal):\n 1. x \\<in> set (drop n l)", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  x \\<in> set (drop n l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_upt_take_conv:\n  \"[i\\<leftarrow>[n..<m]. P (take m l ! i) ] = [i\\<leftarrow>[n..<m]. P (l ! i) ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. P (take m l ! i)) [n..<m] =\n    filter (\\<lambda>i. P (l ! i)) [n..<m]", "by (rule filter_cong) (simp_all)"], ["", "lemma in_set_drop_conv_nth: \"x\\<in>set (drop n l) \\<longleftrightarrow> (\\<exists>i. n\\<le>i \\<and> i<length l \\<and> x = l!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (drop n l)) =\n    (\\<exists>i\\<ge>n. i < length l \\<and> x = l ! i)", "apply (clarsimp simp: in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length l - n. drop n l ! i = x) =\n    (\\<exists>i\\<ge>n. i < length l \\<and> x = l ! i)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length l - n; x = drop n l ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia\\<ge>n.\n                            ia < length l \\<and> drop n l ! i = l ! ia\n 2. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length l; x = l ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length l - n. drop n l ! ia = l ! i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length l - n; x = l ! (n + i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia\\<ge>n.\n                            ia < length l \\<and> l ! (n + i) = l ! ia\n 2. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length l; x = l ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length l - n. drop n l ! ia = l ! i", "apply (metis le_add2 less_diff_conv add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length l; x = l ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length l - n. drop n l ! ia = l ! i", "apply (rule_tac x=\"i-n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length l; x = l ! i\\<rbrakk>\n       \\<Longrightarrow> i - n < length l - n \\<and>\n                         drop n l ! (i - n) = l ! i", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Union_take_drop_id: \"\\<Union>(set (drop n l)) \\<union> \\<Union>(set (take n l)) = \\<Union>(set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (drop n l)) \\<union> \\<Union> (set (take n l)) =\n    \\<Union> (set l)", "by (metis Union_Un_distrib append_take_drop_id set_union_code sup_commute)"], ["", "lemma Un_set_drop_extend: \"\\<lbrakk>j\\<ge>Suc 0; j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! (j - Suc 0) \\<union> \\<Union>(set (drop j l)) = \\<Union>(set (drop (j - Suc 0) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! (j - Suc 0) \\<union> \\<Union> (set (drop j l)) =\n                      \\<Union> (set (drop (j - Suc 0) l))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l;\n        x \\<in> l ! (j - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Union> (set (drop (j - Suc 0) l))\n 2. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop j l)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Union> (set (drop (j - Suc 0) l))\n 3. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop (j - Suc 0) l);\n        x \\<notin> \\<Union> (set (drop j l))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l ! (j - Suc 0)", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l;\n        x \\<in> l ! (j - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>set (drop (j - Suc 0) l). x \\<in> X\n 2. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop j l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>set (drop (j - Suc 0) l). x \\<in> X\n 3. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop (j - Suc 0) l);\n        \\<forall>xa\\<in>set (drop j l). x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l ! (j - Suc 0)", "apply (metis diff_Suc_Suc diff_zero gr0_implies_Suc in_set_drop_conv_nth\n    le_refl less_eq_Suc_le order.strict_iff_order)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop j l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>set (drop (j - Suc 0) l). x \\<in> X\n 2. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop (j - Suc 0) l);\n        \\<forall>xa\\<in>set (drop j l). x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l ! (j - Suc 0)", "apply (metis Nat.diff_le_self set_drop_subset_set_drop subset_code(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>Suc 0 \\<le> j; j < length l; x \\<in> X;\n        X \\<in> set (drop (j - Suc 0) l);\n        \\<forall>xa\\<in>set (drop j l). x \\<notin> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l ! (j - Suc 0)", "by (metis diff_Suc_Suc gr0_implies_Suc in_set_drop_conv_nth\n    less_eq_Suc_le order.strict_iff_order minus_nat.diff_0)"], ["", "lemma drop_take_drop_unsplit:\n  \"i\\<le>j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l", "then"], ["proof (chain)\npicking this:\n  i \\<le> j", "obtain skf where \"i + skf = j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<And>skf. i + skf = j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis le_iff_add)"], ["proof (state)\nthis:\n  i + skf = j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> drop i (take j l) @ drop j l = drop i l", "thus \"drop i (take j l) @ drop j l = drop i l\""], ["proof (prove)\nusing this:\n  i + skf = j\n\ngoal (1 subgoal):\n 1. drop i (take j l) @ drop j l = drop i l", "by (metis append_take_drop_id diff_add_inverse drop_drop drop_take\n      add.commute)"], ["proof (state)\nthis:\n  drop i (take j l) @ drop j l = drop i l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_last_conv[simp]: \"l\\<noteq>[] \\<Longrightarrow> drop (length l - Suc 0) l = [last l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> drop (length l - Suc 0) l = [last l]", "by (cases l rule: rev_cases) auto"], ["", "lemma take_butlast_conv[simp]: \"take (length l - Suc 0) l = butlast l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length l - Suc 0) l = butlast l", "by (cases l rule: rev_cases) auto"], ["", "lemma drop_takeWhile:\n    assumes \"i\\<le>length (takeWhile P l)\"\n    shows \"drop i (takeWhile P l) = takeWhile P (drop i l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i (takeWhile P l) = takeWhile P (drop i l)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length (takeWhile P l)\n\ngoal (1 subgoal):\n 1. drop i (takeWhile P l) = takeWhile P (drop i l)", "proof (induction l arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length (takeWhile P []) \\<Longrightarrow>\n       drop i (takeWhile P []) = takeWhile P (drop i [])\n 2. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length (takeWhile P l) \\<Longrightarrow>\n                   drop i (takeWhile P l) = takeWhile P (drop i l);\n        i \\<le> length (takeWhile P (a # l))\\<rbrakk>\n       \\<Longrightarrow> drop i (takeWhile P (a # l)) =\n                         takeWhile P (drop i (a # l))", "case Nil"], ["proof (state)\nthis:\n  i \\<le> length (takeWhile P [])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length (takeWhile P []) \\<Longrightarrow>\n       drop i (takeWhile P []) = takeWhile P (drop i [])\n 2. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length (takeWhile P l) \\<Longrightarrow>\n                   drop i (takeWhile P l) = takeWhile P (drop i l);\n        i \\<le> length (takeWhile P (a # l))\\<rbrakk>\n       \\<Longrightarrow> drop i (takeWhile P (a # l)) =\n                         takeWhile P (drop i (a # l))", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> length (takeWhile P [])\n\ngoal (1 subgoal):\n 1. drop i (takeWhile P []) = takeWhile P (drop i [])", "by auto"], ["proof (state)\nthis:\n  drop i (takeWhile P []) = takeWhile P (drop i [])\n\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length (takeWhile P l) \\<Longrightarrow>\n                   drop i (takeWhile P l) = takeWhile P (drop i l);\n        i \\<le> length (takeWhile P (a # l))\\<rbrakk>\n       \\<Longrightarrow> drop i (takeWhile P (a # l)) =\n                         takeWhile P (drop i (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length (takeWhile P l) \\<Longrightarrow>\n                   drop i (takeWhile P l) = takeWhile P (drop i l);\n        i \\<le> length (takeWhile P (a # l))\\<rbrakk>\n       \\<Longrightarrow> drop i (takeWhile P (a # l)) =\n                         takeWhile P (drop i (a # l))", "case (Cons x l)"], ["proof (state)\nthis:\n  ?i \\<le> length (takeWhile P l) \\<Longrightarrow>\n  drop ?i (takeWhile P l) = takeWhile P (drop ?i l)\n  i \\<le> length (takeWhile P (x # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length (takeWhile P l) \\<Longrightarrow>\n                   drop i (takeWhile P l) = takeWhile P (drop i l);\n        i \\<le> length (takeWhile P (a # l))\\<rbrakk>\n       \\<Longrightarrow> drop i (takeWhile P (a # l)) =\n                         takeWhile P (drop i (a # l))", "thus ?case"], ["proof (prove)\nusing this:\n  ?i \\<le> length (takeWhile P l) \\<Longrightarrow>\n  drop ?i (takeWhile P l) = takeWhile P (drop ?i l)\n  i \\<le> length (takeWhile P (x # l))\n\ngoal (1 subgoal):\n 1. drop i (takeWhile P (x # l)) = takeWhile P (drop i (x # l))", "by (cases i) auto"], ["proof (state)\nthis:\n  drop i (takeWhile P (x # l)) = takeWhile P (drop i (x # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_length_takeWhile_conv: \"i < length (takeWhile P l) \\<longleftrightarrow> (i<length l \\<and> (\\<forall>j\\<le>i. P (l!j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < length (takeWhile P l)) =\n    (i < length l \\<and> (\\<forall>j\\<le>i. P (l ! j)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < length (takeWhile P l) \\<Longrightarrow> i < length l\n 2. \\<And>j.\n       \\<lbrakk>i < length (takeWhile P l); j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> P (l ! j)\n 3. \\<lbrakk>i < length l; \\<forall>j\\<le>i. P (l ! j)\\<rbrakk>\n    \\<Longrightarrow> i < length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (takeWhile P l) \\<Longrightarrow> i < length l", "using length_takeWhile_le less_le_trans"], ["proof (prove)\nusing this:\n  length (takeWhile ?P ?xs) \\<le> length ?xs\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. i < length (takeWhile P l) \\<Longrightarrow> i < length l", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i < length (takeWhile P l); j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> P (l ! j)\n 2. \\<lbrakk>i < length l; \\<forall>j\\<le>i. P (l ! j)\\<rbrakk>\n    \\<Longrightarrow> i < length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (takeWhile P l); j_ \\<le> i\\<rbrakk>\n    \\<Longrightarrow> P (l ! j_)", "by (metis dual_order.strict_trans2 nth_mem set_takeWhileD takeWhile_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; \\<forall>j\\<le>i. P (l ! j)\\<rbrakk>\n    \\<Longrightarrow> i < length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; \\<forall>j\\<le>i. P (l ! j)\\<rbrakk>\n    \\<Longrightarrow> i < length (takeWhile P l)", "by (meson less_le_trans not_le_imp_less nth_length_takeWhile)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_len_takeWhile_conv: \"i=length (takeWhile P l) \n  \\<longleftrightarrow> i\\<le>length l \\<and> (\\<forall>j<i. P (l!j)) \\<and> (i<length l \\<longrightarrow> \\<not>P (l!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = length (takeWhile P l)) =\n    (i \\<le> length l \\<and>\n     (\\<forall>j<i. P (l ! j)) \\<and>\n     (i < length l \\<longrightarrow> \\<not> P (l ! i)))", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. i = length (takeWhile P l) \\<Longrightarrow>\n    length (takeWhile P l) \\<le> length l\n 2. \\<And>j.\n       \\<lbrakk>i = length (takeWhile P l);\n        j < length (takeWhile P l)\\<rbrakk>\n       \\<Longrightarrow> P (l ! j)\n 3. \\<lbrakk>i = length (takeWhile P l); length (takeWhile P l) < length l;\n     P (l ! length (takeWhile P l))\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)\n 5. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = length (takeWhile P l) \\<Longrightarrow>\n    length (takeWhile P l) \\<le> length l", "using length_takeWhile_le less_le_trans"], ["proof (prove)\nusing this:\n  length (takeWhile ?P ?xs) \\<le> length ?xs\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. i = length (takeWhile P l) \\<Longrightarrow>\n    length (takeWhile P l) \\<le> length l", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i = length (takeWhile P l);\n        j < length (takeWhile P l)\\<rbrakk>\n       \\<Longrightarrow> P (l ! j)\n 2. \\<lbrakk>i = length (takeWhile P l); length (takeWhile P l) < length l;\n     P (l ! length (takeWhile P l))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)\n 4. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = length (takeWhile P l);\n     j_ < length (takeWhile P l)\\<rbrakk>\n    \\<Longrightarrow> P (l ! j_)", "by (auto simp: less_length_takeWhile_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = length (takeWhile P l); length (takeWhile P l) < length l;\n     P (l ! length (takeWhile P l))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)\n 3. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = length (takeWhile P l); length (takeWhile P l) < length l;\n     P (l ! length (takeWhile P l))\\<rbrakk>\n    \\<Longrightarrow> False", "using nth_length_takeWhile"], ["proof (prove)\nusing this:\n  length (takeWhile ?P ?xs) < length ?xs \\<Longrightarrow>\n  \\<not> ?P (?xs ! length (takeWhile ?P ?xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = length (takeWhile P l); length (takeWhile P l) < length l;\n     P (l ! length (takeWhile P l))\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)\n 2. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "by (metis length_takeWhile_le nth_length_takeWhile order.order_iff_strict)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length l; \\<forall>j<i. P (l ! j);\n     \\<not> P (l ! i)\\<rbrakk>\n    \\<Longrightarrow> i = length (takeWhile P l)", "by (metis dual_order.strict_trans2 leI less_length_takeWhile_conv linorder_neqE_nat nth_length_takeWhile)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Up-to\\<close>"], ["", "lemma upt_eq_append_conv: \"i\\<le>j \\<Longrightarrow> [i..<j] = xs@ys \\<longleftrightarrow> (\\<exists>k. i\\<le>k \\<and> k\\<le>j \\<and> [i..<k] = xs \\<and> [k..<j] = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    ([i..<j] = xs @ ys) =\n    (\\<exists>k\\<ge>i. k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; [i..<j] = xs @ ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k\\<ge>i.\n                         k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\n 2. \\<lbrakk>i \\<le> j;\n     \\<exists>k\\<ge>i.\n        k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = xs @ ys", "assume \"[i..<j] = xs @ ys\"  \n  and \"i\\<le>j\""], ["proof (state)\nthis:\n  [i..<j] = xs @ ys\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; [i..<j] = xs @ ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k\\<ge>i.\n                         k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\n 2. \\<lbrakk>i \\<le> j;\n     \\<exists>k\\<ge>i.\n        k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = xs @ ys", "thus \"\\<exists>k\\<ge>i. k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\""], ["proof (prove)\nusing this:\n  [i..<j] = xs @ ys\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys", "apply (induction xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>[i..<j] = [] @ ys; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k \\<le> j \\<and>\n                            [i..<k] = [] \\<and> [k..<j] = ys\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>[i..<j] = xs @ ys; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k\\<ge>i.\n  k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys;\n        [i..<j] = (a # xs) @ ys; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k \\<le> j \\<and>\n                            [i..<k] = a # xs \\<and> [k..<j] = ys", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>[i..<j] = xs @ ys; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k\\<ge>i.\n  k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys;\n        [i..<j] = (a # xs) @ ys; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>i.\n                            k \\<le> j \\<and>\n                            [i..<k] = a # xs \\<and> [k..<j] = ys", "apply (clarsimp simp: upt_eq_Cons_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>[i..<j] = xs @ ys; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k\\<ge>i.\n  k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys;\n        a < j; [Suc a..<j] = xs @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<ge>a.\n                            k \\<le> j \\<and>\n                            a < k \\<and>\n                            [Suc a..<k] = xs \\<and> [k..<j] = ys", "by (meson Suc_le_eq less_imp_le_nat)"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>i. k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j;\n     \\<exists>k\\<ge>i.\n        k \\<le> j \\<and> [i..<k] = xs \\<and> [k..<j] = ys\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = xs @ ys", "qed auto"], ["", "lemma map_nth_upt_drop_take_conv: \"N \\<le> length l \\<Longrightarrow> map (nth l) [M..<N] = drop M (take N l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> length l \\<Longrightarrow>\n    map ((!) l) [M..<N] = drop M (take N l)", "by (induction N) (auto simp: take_Suc_conv_app_nth)"], ["", "lemma upt_eq_lel_conv:\n  \"[l..<h] = is1@i#is2 \\<longleftrightarrow> is1 = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l\\<le>i \\<and> i<h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([l..<h] = is1 @ i # is2) =\n    (is1 = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n    is1 = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h\n 2. is1 = [l..<i] \\<and>\n    is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h \\<Longrightarrow>\n    [l..<h] = is1 @ i # is2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n    is1 = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h", "apply (induction is1 arbitrary: l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       [l..<h] = [] @ i # is2 \\<Longrightarrow>\n       [] = [l..<i] \\<and> is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h\n 2. \\<And>a is1 l.\n       \\<lbrakk>\\<And>l.\n                   [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n                   is1 = [l..<i] \\<and>\n                   is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h;\n        [l..<h] = (a # is1) @ i # is2\\<rbrakk>\n       \\<Longrightarrow> a # is1 = [l..<i] \\<and>\n                         is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h", "apply (auto simp: upt_eq_Cons_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a is1 l.\n       \\<lbrakk>\\<And>l.\n                   [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n                   is1 = [l..<i] \\<and>\n                   is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h;\n        [l..<h] = (a # is1) @ i # is2\\<rbrakk>\n       \\<Longrightarrow> a # is1 = [l..<i] \\<and>\n                         is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h", "apply (clarsimp simp: upt_eq_Cons_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a is1.\n       \\<lbrakk>\\<And>l.\n                   [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n                   is1 = [l..<i] \\<and>\n                   is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h;\n        a < h; [Suc a..<h] = is1 @ i # is2\\<rbrakk>\n       \\<Longrightarrow> a # is1 = [a..<i] \\<and> a \\<le> i", "using Suc_le_eq upt_rec"], ["proof (prove)\nusing this:\n  (Suc ?m \\<le> ?n) = (?m < ?n)\n  [?i..<?j] = (if ?i < ?j then ?i # [Suc ?i..<?j] else [])\n\ngoal (1 subgoal):\n 1. \\<And>a is1.\n       \\<lbrakk>\\<And>l.\n                   [l..<h] = is1 @ i # is2 \\<Longrightarrow>\n                   is1 = [l..<i] \\<and>\n                   is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h;\n        a < h; [Suc a..<h] = is1 @ i # is2\\<rbrakk>\n       \\<Longrightarrow> a # is1 = [a..<i] \\<and> a \\<le> i", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. is1 = [l..<i] \\<and>\n    is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h \\<Longrightarrow>\n    [l..<h] = is1 @ i # is2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is1 = [l..<i] \\<and>\n    is2 = [Suc i..<h] \\<and> l \\<le> i \\<and> i < h \\<Longrightarrow>\n    [l..<h] = is1 @ i # is2", "by (auto simp: upt_conv_Cons[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_add_upt': \"map (\\<lambda>i. i + ofs) [a..<b] = [a+ofs..<b + ofs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. i + ofs) [a..<b] = [a + ofs..<b + ofs]", "by (induct b) simp_all"], ["", "subsubsection \\<open>Last and butlast\\<close>"], ["", "lemma butlast_upt: \"butlast [m..<n] = [m..<n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast [m..<n] = [m..<n - 1]", "apply (cases \"m<n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m < n \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]\n 2. \\<not> m < n \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]", "apply (cases n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>m < n; n = 0\\<rbrakk>\n    \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]\n 2. \\<And>nat.\n       \\<lbrakk>m < n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]\n 3. \\<not> m < n \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>m < n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]\n 2. \\<not> m < n \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> m < n \\<Longrightarrow> butlast [m..<n] = [m..<n - 1]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*lemma butlast_upt: \"n<m \\<Longrightarrow> butlast [n..<m] = [n..<m - 1]\"\n  apply (cases \"[n..<m]\" rule: rev_cases)\n  apply simp\n  apply (cases m)\n  apply simp\n  apply simp\n  done*)"], ["", "lemma butlast_update': \"(butlast l) [i:=x] = butlast (l[i:=x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (butlast l)[i := x] = butlast (l[i := x])", "by (metis butlast_conv_take butlast_list_update length_butlast take_update)"], ["", "lemma take_minus_one_conv_butlast:\n  \"n\\<le>length l \\<Longrightarrow> take (n - Suc 0) l = butlast (take n l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length l \\<Longrightarrow>\n    take (n - Suc 0) l = butlast (take n l)", "by (simp add: butlast_take)"], ["", "lemma butlast_eq_cons_conv: \"butlast l = x#xs \\<longleftrightarrow> (\\<exists>xl. l=x#xs@[xl])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (butlast l = x # xs) = (\\<exists>xl. l = x # xs @ [xl])", "by (metis Cons_eq_appendI append_butlast_last_id butlast.simps\n    butlast_snoc eq_Nil_appendI)"], ["", "lemma butlast_eq_consE:\n  assumes \"butlast l = x#xs\"\n  obtains xl where \"l=x#xs@[xl]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xl. l = x # xs @ [xl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  butlast l = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>xl. l = x # xs @ [xl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: butlast_eq_cons_conv)"], ["", "lemma drop_eq_ConsD: \"drop n xs = x # xs' \\<Longrightarrow> drop (Suc n) xs = xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n xs = x # xs' \\<Longrightarrow> drop (Suc n) xs = xs'", "by(induct xs arbitrary: n)(simp_all add: drop_Cons split: nat.split_asm)"], ["", "subsubsection \\<open>List Slices\\<close>"], ["", "text \\<open>Based on Lars Hupel's code.\\<close>"], ["", "definition slice :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"slice from to list = take (to - from) (drop from list)\""], ["", "lemma slice_len[simp]: \"\\<lbrakk> from \\<le> to; to \\<le> length xs \\<rbrakk> \\<Longrightarrow> length (slice from to xs) = to - from\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from \\<le> to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> length (slice from to xs) = to - from", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from \\<le> to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> length (take (to - from) (drop from xs)) = to - from", "by simp"], ["", "lemma slice_head: \"\\<lbrakk> from < to; to \\<le> length xs \\<rbrakk> \\<Longrightarrow> hd (slice from to xs) = xs ! from\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (slice from to xs) = xs ! from", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (take (to - from) (drop from xs)) = xs ! from", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (take (to - from) (drop from xs)) = xs ! from", "assume a1: \"from < to\""], ["proof (state)\nthis:\n  from < to\n\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (take (to - from) (drop from xs)) = xs ! from", "assume \"to \\<le> length xs\""], ["proof (state)\nthis:\n  to \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (take (to - from) (drop from xs)) = xs ! from", "then"], ["proof (chain)\npicking this:\n  to \\<le> length xs", "have \"\\<And>n. to - (to - n) \\<le> length (take to xs)\""], ["proof (prove)\nusing this:\n  to \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>n. to - (to - n) \\<le> length (take to xs)", "by (metis (no_types) slice_def diff_le_self drop_take length_drop slice_len)"], ["proof (state)\nthis:\n  to - (to - ?n) \\<le> length (take to xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> hd (take (to - from) (drop from xs)) = xs ! from", "then"], ["proof (chain)\npicking this:\n  to - (to - ?n) \\<le> length (take to xs)", "show \"hd (take (to - from) (drop from xs)) = xs ! from\""], ["proof (prove)\nusing this:\n  to - (to - ?n) \\<le> length (take to xs)\n\ngoal (1 subgoal):\n 1. hd (take (to - from) (drop from xs)) = xs ! from", "using a1"], ["proof (prove)\nusing this:\n  to - (to - ?n) \\<le> length (take to xs)\n  from < to\n\ngoal (1 subgoal):\n 1. hd (take (to - from) (drop from xs)) = xs ! from", "by (metis diff_diff_cancel drop_take hd_drop_conv_nth leI le_antisym less_or_eq_imp_le nth_take)"], ["proof (state)\nthis:\n  hd (take (to - from) (drop from xs)) = xs ! from\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_eq_bounds_empty[simp]: \"slice i i xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice i i xs = []", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (i - i) (drop i xs) = []", "by auto"], ["", "lemma slice_nth: \"\\<lbrakk> from < to; to \\<le> length xs; i < to - from \\<rbrakk> \\<Longrightarrow> slice from to xs ! i = xs ! (from + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs; i < to - from\\<rbrakk>\n    \\<Longrightarrow> slice from to xs ! i = xs ! (from + i)", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>from < to; to \\<le> length xs; i < to - from\\<rbrakk>\n    \\<Longrightarrow> take (to - from) (drop from xs) ! i = xs ! (from + i)", "by (induction \"to - from\" arbitrary: \"from\" to i) simp+"], ["", "lemma slice_prepend: \"\\<lbrakk> i \\<le> k; k \\<le> length xs \\<rbrakk> \\<Longrightarrow> let p = length ys in slice i k xs = slice (i + p) (k + p) (ys @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> k; k \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> let p = length ys\n                      in slice i k xs = slice (i + p) (k + p) (ys @ xs)", "unfolding slice_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> k; k \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> take (k - i) (drop i xs) =\n                      take (k + length ys - (i + length ys))\n                       (drop (i + length ys) (ys @ xs))", "by force"], ["", "lemma slice_Nil[simp]: \"slice begin end [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice begin end [] = []", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (end - begin) (drop begin []) = []", "by auto"], ["", "lemma slice_Cons: \"slice begin end (x#xs) \n  = (if begin=0 \\<and> end>0 then x#slice begin (end-1) xs else slice (begin - 1) (end - 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice begin end (x # xs) =\n    (if begin = 0 \\<and> 0 < end then x # slice begin (end - 1) xs\n     else slice (begin - 1) (end - 1) xs)", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (end - begin) (drop begin (x # xs)) =\n    (if begin = 0 \\<and> 0 < end\n     then x # take (end - 1 - begin) (drop begin xs)\n     else take (end - 1 - (begin - 1)) (drop (begin - 1) xs))", "by (auto simp: take_Cons' drop_Cons')"], ["", "lemma slice_complete[simp]: \"slice 0 (length xs) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice 0 (length xs) xs = xs", "unfolding slice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs - 0) (drop 0 xs) = xs", "by simp"], ["", "subsubsection \\<open>Miscellaneous\\<close>"], ["", "lemma length_compl_induct[case_names Nil Cons]: \"\\<lbrakk>P []; !! e l . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (e#l)\\<rbrakk> \\<Longrightarrow> P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P [];\n     \\<And>e l.\n        (\\<And>ll.\n            length ll \\<le> length l \\<Longrightarrow>\n            P ll) \\<Longrightarrow>\n        P (e # l)\\<rbrakk>\n    \\<Longrightarrow> P l", "apply(induct_tac l rule: length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(case_tac \"xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> P xs\n 2. \\<And>xs a list.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_set_list_format: \"\\<lbrakk> e\\<in>set l; !!l1 l2. l=l1@e#l2 \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set l;\n     \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof (induct l arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>e \\<in> set [];\n        \\<And>l1 l2. [] = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>e \\<in> set l;\n                    \\<And>l1 l2.\n                       l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e \\<in> set (a # l);\n        \\<And>l1 l2. a # l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  e \\<in> set []\n  [] = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>e \\<in> set [];\n        \\<And>l1 l2. [] = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>e \\<in> set l;\n                    \\<And>l1 l2.\n                       l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e \\<in> set (a # l);\n        \\<And>l1 l2. a # l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> set []\n  [] = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>e \\<in> set l;\n                    \\<And>l1 l2.\n                       l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e \\<in> set (a # l);\n        \\<And>l1 l2. a # l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>e \\<in> set l;\n                    \\<And>l1 l2.\n                       l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e \\<in> set (a # l);\n        \\<And>l1 l2. a # l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<in> set l;\n   \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  e \\<in> set (a # l)\n  a # l = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a l P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>e \\<in> set l;\n                    \\<And>l1 l2.\n                       l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e \\<in> set (a # l);\n        \\<And>l1 l2. a # l = l1 @ e # l2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases \"a=e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = e \\<Longrightarrow> P\n 2. a \\<noteq> e \\<Longrightarrow> P", "case True"], ["proof (state)\nthis:\n  a = e\n\ngoal (2 subgoals):\n 1. a = e \\<Longrightarrow> P\n 2. a \\<noteq> e \\<Longrightarrow> P", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>e \\<in> set l;\n   \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  e \\<in> set (a # l)\n  a # l = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n  a = e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set l;\n   \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  e \\<in> set (a # l)\n  a # l = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n  a = e\n\ngoal (1 subgoal):\n 1. P", "by force"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "case False"], ["proof (state)\nthis:\n  a \\<noteq> e\n\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "with Cons.prems(1)"], ["proof (chain)\npicking this:\n  e \\<in> set (a # l)\n  a \\<noteq> e", "have \"e\\<in>set l\""], ["proof (prove)\nusing this:\n  e \\<in> set (a # l)\n  a \\<noteq> e\n\ngoal (1 subgoal):\n 1. e \\<in> set l", "by auto"], ["proof (state)\nthis:\n  e \\<in> set l\n\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "with Cons.hyps"], ["proof (chain)\npicking this:\n  \\<lbrakk>e \\<in> set l;\n   \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  e \\<in> set l", "obtain l1 l2 where \"l=l1@e#l2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set l;\n   \\<And>l1 l2. l = l1 @ e # l2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  e \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ e # l2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = l1 @ e # l2\n\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "hence \"a#l = (a#l1)@e#l2\""], ["proof (prove)\nusing this:\n  l = l1 @ e # l2\n\ngoal (1 subgoal):\n 1. a # l = (a # l1) @ e # l2", "by simp"], ["proof (state)\nthis:\n  a # l = (a # l1) @ e # l2\n\ngoal (1 subgoal):\n 1. a \\<noteq> e \\<Longrightarrow> P", "with Cons.prems(2)"], ["proof (chain)\npicking this:\n  a # l = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n  a # l = (a # l1) @ e # l2", "show P"], ["proof (prove)\nusing this:\n  a # l = ?l1.0 @ e # ?l2.0 \\<Longrightarrow> P\n  a # l = (a # l1) @ e # l2\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_upd_cases:\n  assumes \"x\\<in>set (l[i:=y])\"\n  obtains \"i<length l\" and \"x=y\" | \"x\\<in>set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i < length l; x = y\\<rbrakk> \\<Longrightarrow> thesis;\n     x \\<in> set l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis assms in_set_conv_nth length_list_update nth_list_update_eq\n    nth_list_update_neq)"], ["", "lemma in_set_upd_eq_aux:\n  assumes \"i<length l\"\n  shows \"x\\<in>set (l[i:=y]) \\<longleftrightarrow> x=y \\<or> (\\<forall>y. x\\<in>set (l[i:=y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (l[i := y])) =\n    (x = y \\<or> (\\<forall>y. x \\<in> set (l[i := y])))", "by (metis in_set_upd_cases assms list_update_overwrite\n    set_update_memI)"], ["", "lemma in_set_upd_eq:\n  assumes \"i<length l\"\n  shows \"x\\<in>set (l[i:=y]) \\<longleftrightarrow> x=y \\<or> (x\\<in>set l \\<and> (\\<forall>y. x\\<in>set (l[i:=y])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (l[i := y])) =\n    (x = y \\<or> x \\<in> set l \\<and> (\\<forall>y. x \\<in> set (l[i := y])))", "by (metis in_set_upd_cases in_set_upd_eq_aux assms)"], ["", "text \\<open>Simultaneous induction over two lists, prepending an element to one of the lists in each step\\<close>"], ["", "lemma list_2pre_induct[case_names base left right]: assumes BASE: \"P [] []\" and LEFT: \"!!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2\" and RIGHT: \"!!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2')\" shows \"P w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w1 w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "{ \\<comment> \\<open>The proof is done by induction over the sum of the lengths of the lists\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "have \"!!w1 w2. \\<lbrakk>length w1 + length w2 = n; P [] []; !!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2; !!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2') \\<rbrakk> \\<Longrightarrow> P w1 w2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>length w1 + length w2 = n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w1 w2.\n       \\<lbrakk>length w1 + length w2 = 0; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2\n 2. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply (case_tac w1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w1 = []\\<rbrakk>\n       \\<Longrightarrow> P w1 w2\n 2. \\<And>n w1 w2 a list.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P [] w2", "apply (case_tac w2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w2 = []\\<rbrakk>\n       \\<Longrightarrow> P [] w2\n 2. \\<And>n w2 a list.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P [] w2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = n; P [] [];\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3; P [] [];\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "from this[OF _ BASE LEFT RIGHT]"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3;\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P w1' w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 w2'\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3;\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P w1' w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 w2'\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "by blast"], ["proof (state)\nthis:\n  P w1 w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_decomp_1: \"length l=1 \\<Longrightarrow> \\<exists>a. l=[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow> \\<exists>a. l = [a]", "by (case_tac l, auto)"], ["", "lemma list_decomp_2: \"length l=2 \\<Longrightarrow> \\<exists>a b. l=[a,b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = 2 \\<Longrightarrow> \\<exists>a b. l = [a, b]", "by (case_tac l, auto simp add: list_decomp_1)"], ["", "lemma list_rest_coinc: \"\\<lbrakk>length s2 \\<le> length s1; s1@r1 = s2@r2\\<rbrakk> \\<Longrightarrow> \\<exists>r1p. r2=r1p@r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "by (metis append_eq_append_conv_if)"], ["", "lemma list_tail_coinc: \"n1#r1 = n2#r2 \\<Longrightarrow> n1=n2 & r1=r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 # r1 = n2 # r2 \\<Longrightarrow> n1 = n2 \\<and> r1 = r2", "by (auto)"], ["", "lemma last_in_set[intro]: \"\\<lbrakk>l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> last l \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> last l \\<in> set l", "by (induct l) auto"], ["", "lemma empty_append_eq_id[simp]: \"(@) [] = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@) [] = (\\<lambda>x. x)", "by auto"], ["", "lemma op_conc_empty_img_id[simp]: \"((@) [] ` L) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@) [] ` L = L", "by auto"], ["", "lemma distinct_match: \"\\<lbrakk> distinct (al@e#bl) \\<rbrakk> \\<Longrightarrow> (al@e#bl = al'@e#bl') \\<longleftrightarrow> (al=al' \\<and> bl=bl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (al @ e # bl) \\<Longrightarrow>\n    (al @ e # bl = al' @ e # bl') = (al = al' \\<and> bl = bl')", "proof (rule iffI, induct al arbitrary: al')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>al'.\n       \\<lbrakk>distinct ([] @ e # bl); [] @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> [] = al' \\<and> bl = bl'\n 2. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 3. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "case Nil"], ["proof (state)\nthis:\n  distinct ([] @ e # bl)\n  [] @ e # bl = al' @ e # bl'\n\ngoal (3 subgoals):\n 1. \\<And>al'.\n       \\<lbrakk>distinct ([] @ e # bl); [] @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> [] = al' \\<and> bl = bl'\n 2. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 3. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "thus ?case"], ["proof (prove)\nusing this:\n  distinct ([] @ e # bl)\n  [] @ e # bl = al' @ e # bl'\n\ngoal (1 subgoal):\n 1. [] = al' \\<and> bl = bl'", "by (cases al') auto"], ["proof (state)\nthis:\n  [] = al' \\<and> bl = bl'\n\ngoal (2 subgoals):\n 1. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "case (Cons a al)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (al @ e # bl); al @ e # bl = ?al' @ e # bl'\\<rbrakk>\n  \\<Longrightarrow> al = ?al' \\<and> bl = bl'\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n\ngoal (2 subgoals):\n 1. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "note Cprems=Cons.prems"], ["proof (state)\nthis:\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n\ngoal (2 subgoals):\n 1. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "note Chyps=Cons.hyps"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (al @ e # bl); al @ e # bl = ?al' @ e # bl'\\<rbrakk>\n  \\<Longrightarrow> al = ?al' \\<and> bl = bl'\n\ngoal (2 subgoals):\n 1. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>distinct (al @ e # bl);\n                    al @ e # bl = al' @ e # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> bl = bl';\n        distinct ((a # al) @ e # bl);\n        (a # al) @ e # bl = al' @ e # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # al = al' \\<and> bl = bl'", "proof (cases al')"], ["proof (state)\ngoal (2 subgoals):\n 1. al' = [] \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "case Nil"], ["proof (state)\nthis:\n  al' = []\n\ngoal (2 subgoals):\n 1. al' = [] \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "with Cprems"], ["proof (chain)\npicking this:\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n  al' = []", "have False"], ["proof (prove)\nusing this:\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n  al' = []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. al' = [] \\<Longrightarrow> a # al = al' \\<and> bl = bl'\n 2. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # al = al' \\<and> bl = bl'", ".."], ["proof (state)\nthis:\n  a # al = al' \\<and> bl = bl'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "case [simp]: (Cons a' all')"], ["proof (state)\nthis:\n  al' = a' # all'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "with Cprems"], ["proof (chain)\npicking this:\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n  al' = a' # all'", "have [simp]: \"a=a'\" and P: \"al@e#bl = all'@e#bl'\""], ["proof (prove)\nusing this:\n  distinct ((a # al) @ e # bl)\n  (a # al) @ e # bl = al' @ e # bl'\n  al' = a' # all'\n\ngoal (1 subgoal):\n 1. a = a' &&& al @ e # bl = all' @ e # bl'", "by auto"], ["proof (state)\nthis:\n  a = a'\n  al @ e # bl = all' @ e # bl'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "from Cprems(1)"], ["proof (chain)\npicking this:\n  distinct ((a # al) @ e # bl)", "have D: \"distinct (al@e#bl)\""], ["proof (prove)\nusing this:\n  distinct ((a # al) @ e # bl)\n\ngoal (1 subgoal):\n 1. distinct (al @ e # bl)", "by auto"], ["proof (state)\nthis:\n  distinct (al @ e # bl)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "from Chyps[OF D P]"], ["proof (chain)\npicking this:\n  al = all' \\<and> bl = bl'", "have [simp]: \"al=all'\" \"bl=bl'\""], ["proof (prove)\nusing this:\n  al = all' \\<and> bl = bl'\n\ngoal (1 subgoal):\n 1. al = all' &&& bl = bl'", "by auto"], ["proof (state)\nthis:\n  al = all'\n  bl = bl'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       al' = aa # list \\<Longrightarrow> a # al = al' \\<and> bl = bl'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # al = al' \\<and> bl = bl'", "by simp"], ["proof (state)\nthis:\n  a # al = al' \\<and> bl = bl'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # al = al' \\<and> bl = bl'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (al @ e # bl); al = al' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e # bl'", "qed simp"], ["", "lemma prop_match: \"\\<lbrakk> list_all P al; \\<not>P e; \\<not>P e'; list_all P bl \\<rbrakk> \\<Longrightarrow> (al@e#bl = al'@e'#bl') \\<longleftrightarrow> (al=al' \\<and> e=e' \\<and> bl=bl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all P al; \\<not> P e; \\<not> P e'; list_all P bl\\<rbrakk>\n    \\<Longrightarrow> (al @ e # bl = al' @ e' # bl') =\n                      (al = al' \\<and> e = e' \\<and> bl = bl')", "apply (rule iffI, induct al arbitrary: al')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>al'.\n       \\<lbrakk>list_all P []; \\<not> P e; \\<not> P e'; list_all P bl;\n        [] @ e # bl = al' @ e' # bl'\\<rbrakk>\n       \\<Longrightarrow> [] = al' \\<and> e = e' \\<and> bl = bl'\n 2. \\<And>a al al'.\n       \\<lbrakk>\\<And>al'.\n                   \\<lbrakk>list_all P al; \\<not> P e; \\<not> P e';\n                    list_all P bl; al @ e # bl = al' @ e' # bl'\\<rbrakk>\n                   \\<Longrightarrow> al = al' \\<and> e = e' \\<and> bl = bl';\n        list_all P (a # al); \\<not> P e; \\<not> P e'; list_all P bl;\n        (a # al) @ e # bl = al' @ e' # bl'\\<rbrakk>\n       \\<Longrightarrow> a # al = al' \\<and> e = e' \\<and> bl = bl'\n 3. \\<lbrakk>list_all P al; \\<not> P e; \\<not> P e'; list_all P bl;\n     al = al' \\<and> e = e' \\<and> bl = bl'\\<rbrakk>\n    \\<Longrightarrow> al @ e # bl = al' @ e' # bl'", "apply (case_tac al', fastforce, fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas prop_matchD = rev_iffD1[OF _ prop_match[where P=P]] for P"], ["", "declare distinct_tl[simp]"], ["", "lemma list_se_match[simp]:\n  \"l1 \\<noteq> [] \\<Longrightarrow> l1@l2 = [a] \\<longleftrightarrow> l1 = [a] \\<and> l2 = []\"\n  \"l2 \\<noteq> [] \\<Longrightarrow> l1@l2 = [a] \\<longleftrightarrow> l1 = [] \\<and> l2 = [a]\"\n  \"l1 \\<noteq> [] \\<Longrightarrow> [a] = l1@l2 \\<longleftrightarrow> l1 = [a] \\<and> l2 = []\"\n  \"l2 \\<noteq> [] \\<Longrightarrow> [a] = l1@l2 \\<longleftrightarrow> l1 = [] \\<and> l2 = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l1 \\<noteq> [] \\<Longrightarrow>\n      (l1 @ l2 = [a]) = (l1 = [a] \\<and> l2 = [])) &&&\n     (l2 \\<noteq> [] \\<Longrightarrow>\n      (l1 @ l2 = [a]) = (l1 = [] \\<and> l2 = [a]))) &&&\n    (l1 \\<noteq> [] \\<Longrightarrow>\n     ([a] = l1 @ l2) = (l1 = [a] \\<and> l2 = [])) &&&\n    (l2 \\<noteq> [] \\<Longrightarrow>\n     ([a] = l1 @ l2) = (l1 = [] \\<and> l2 = [a]))", "apply (cases l1, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l2 \\<noteq> [] \\<Longrightarrow>\n    (l1 @ l2 = [a]) = (l1 = [] \\<and> l2 = [a])\n 2. l1 \\<noteq> [] \\<Longrightarrow>\n    ([a] = l1 @ l2) = (l1 = [a] \\<and> l2 = [])\n 3. l2 \\<noteq> [] \\<Longrightarrow>\n    ([a] = l1 @ l2) = (l1 = [] \\<and> l2 = [a])", "apply (cases l1, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l1 \\<noteq> [] \\<Longrightarrow>\n    ([a] = l1 @ l2) = (l1 = [a] \\<and> l2 = [])\n 2. l2 \\<noteq> [] \\<Longrightarrow>\n    ([a] = l1 @ l2) = (l1 = [] \\<and> l2 = [a])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 \\<noteq> [] \\<Longrightarrow>\n    ([a] = l1 @ l2) = (l1 = [] \\<and> l2 = [a])", "apply (cases l1, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Placed here because it depends on xy_in_set_cases *)"], ["", "lemma distinct_map_eq: \"\\<lbrakk> distinct (List.map f l); f x = f y; x\\<in>set l; y\\<in>set l \\<rbrakk> \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map f l); f x = f y; x \\<in> set l;\n     y \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (erule (2) xy_in_set_cases) auto"], ["", "lemma upt_append:\n  assumes \"i<j\"\n  shows \"[0..<i]@[i..<j] = [0..<j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<i] @ [i..<j] = [0..<j]", "using assms"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. [0..<i] @ [i..<j] = [0..<j]", "apply (induct j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < 0 \\<Longrightarrow> [0..<i] @ [i..<0] = [0..<0]\n 2. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> [0..<i] @ [i..<j] = [0..<j];\n        i < Suc j\\<rbrakk>\n       \\<Longrightarrow> [0..<i] @ [i..<Suc j] = [0..<Suc j]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> [0..<i] @ [i..<j] = [0..<j];\n        i < Suc j\\<rbrakk>\n       \\<Longrightarrow> [0..<i] @ [i..<Suc j] = [0..<Suc j]", "apply (case_tac \"i=j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> [0..<i] @ [i..<j] = [0..<j];\n        i < Suc j; i = j\\<rbrakk>\n       \\<Longrightarrow> [0..<i] @ [i..<Suc j] = [0..<Suc j]\n 2. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> [0..<i] @ [i..<j] = [0..<j];\n        i < Suc j; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> [0..<i] @ [i..<Suc j] = [0..<Suc j]", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upt_filter_extend:\n  assumes LE: \"u\\<le>u'\"\n  assumes NP: \"\\<forall>i. u\\<le>i \\<and> i<u' \\<longrightarrow> \\<not>P i\"\n  shows \"[i\\<leftarrow>[0..<u]. P i] = [i\\<leftarrow>[0..<u']. P i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P [0..<u] = filter P [0..<u']", "proof (cases \"u=u'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']\n 2. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "case True"], ["proof (state)\nthis:\n  u = u'\n\ngoal (2 subgoals):\n 1. u = u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']\n 2. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = u'\n\ngoal (1 subgoal):\n 1. filter P [0..<u] = filter P [0..<u']", "by simp"], ["proof (state)\nthis:\n  filter P [0..<u] = filter P [0..<u']\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "case False"], ["proof (state)\nthis:\n  u \\<noteq> u'\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "hence \"u<u'\""], ["proof (prove)\nusing this:\n  u \\<noteq> u'\n\ngoal (1 subgoal):\n 1. u < u'", "using LE"], ["proof (prove)\nusing this:\n  u \\<noteq> u'\n  u \\<le> u'\n\ngoal (1 subgoal):\n 1. u < u'", "by simp"], ["proof (state)\nthis:\n  u < u'\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "hence \"[0..<u'] = [0..<u]@[u ..<u']\""], ["proof (prove)\nusing this:\n  u < u'\n\ngoal (1 subgoal):\n 1. [0..<u'] = [0..<u] @ [u..<u']", "by (simp add: upt_append)"], ["proof (state)\nthis:\n  [0..<u'] = [0..<u] @ [u..<u']\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "hence \"[i\\<leftarrow>[0..<u']. P i] = [i\\<leftarrow>[0..<u]. P i] @ [i\\<leftarrow>[u..<u']. P i]\""], ["proof (prove)\nusing this:\n  [0..<u'] = [0..<u] @ [u..<u']\n\ngoal (1 subgoal):\n 1. filter P [0..<u'] = filter P [0..<u] @ filter P [u..<u']", "by simp"], ["proof (state)\nthis:\n  filter P [0..<u'] = filter P [0..<u] @ filter P [u..<u']\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "also"], ["proof (state)\nthis:\n  filter P [0..<u'] = filter P [0..<u] @ filter P [u..<u']\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "have \"[i\\<leftarrow>[u..<u']. P i] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P [u..<u'] = []", "using NP"], ["proof (prove)\nusing this:\n  \\<forall>i. u \\<le> i \\<and> i < u' \\<longrightarrow> \\<not> P i\n\ngoal (1 subgoal):\n 1. filter P [u..<u'] = []", "by (auto simp: filter_empty_conv)"], ["proof (state)\nthis:\n  filter P [u..<u'] = []\n\ngoal (1 subgoal):\n 1. u \\<noteq> u' \\<Longrightarrow> filter P [0..<u] = filter P [0..<u']", "finally"], ["proof (chain)\npicking this:\n  filter P [0..<u'] = filter P [0..<u] @ []", "show ?thesis"], ["proof (prove)\nusing this:\n  filter P [0..<u'] = filter P [0..<u] @ []\n\ngoal (1 subgoal):\n 1. filter P [0..<u] = filter P [0..<u']", "by simp"], ["proof (state)\nthis:\n  filter P [0..<u] = filter P [0..<u']\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_upt_last:\n  assumes E: \"[k\\<leftarrow>[0..<length l] . P (l!k)] = js @ [j]\"\n  assumes \"j<i\" and \"i<length l\"\n  shows \"\\<not> P (l!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (l ! i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "assume A: \"P (l!i)\""], ["proof (state)\nthis:\n  P (l ! i)\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "have \"[0..<length l] = [0..<i]@[i..<length l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<length l] = [0..<i] @ [i..<length l]", "using \\<open>i<length l\\<close>"], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. [0..<length l] = [0..<i] @ [i..<length l]", "by (simp add: upt_append)"], ["proof (state)\nthis:\n  [0..<length l] = [0..<i] @ [i..<length l]\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [0..<length l] = [0..<i] @ [i..<length l]\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "have \"[i..<length l] = i#[Suc i..<length l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..<length l] = i # [Suc i..<length l]", "using \\<open>i<length l\\<close>"], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. [i..<length l] = i # [Suc i..<length l]", "by (auto simp: upt_conv_Cons)"], ["proof (state)\nthis:\n  [i..<length l] = i # [Suc i..<length l]\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  [0..<length l] = [0..<i] @ i # [Suc i..<length l]", "have \"[k\\<leftarrow>[0..<i] . P (l!k)]@i#[k\\<leftarrow>[Suc i..<length l] . P (l!k)] = js@[j]\""], ["proof (prove)\nusing this:\n  [0..<length l] = [0..<i] @ i # [Suc i..<length l]\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>k. P (l ! k)) [0..<i] @\n    i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l] =\n    js @ [j]", "unfolding E[symmetric]"], ["proof (prove)\nusing this:\n  [0..<length l] = [0..<i] @ i # [Suc i..<length l]\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>k. P (l ! k)) [0..<i] @\n    i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l] =\n    filter (\\<lambda>k. P (l ! k)) [0..<length l]", "using \\<open>P (l!i)\\<close>"], ["proof (prove)\nusing this:\n  [0..<length l] = [0..<i] @ i # [Suc i..<length l]\n  P (l ! i)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>k. P (l ! k)) [0..<i] @\n    i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l] =\n    filter (\\<lambda>k. P (l ! k)) [0..<length l]", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>k. P (l ! k)) [0..<i] @\n  i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l] =\n  js @ [j]\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "hence \"j = last (i#[k\\<leftarrow>[Suc i..<length l] . P (l!k)])\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>k. P (l ! k)) [0..<i] @\n  i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l] =\n  js @ [j]\n\ngoal (1 subgoal):\n 1. j = last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "by (metis last_appendR last_snoc list.distinct(1))"], ["proof (state)\nthis:\n  j = last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  j = last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "have \"\\<dots> \\<ge> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "have \"sorted (i#[k\\<leftarrow>[Suc i..<length l] . P (l!k)])\" (is \"sorted ?l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "by (simp add: sorted_filter[where f=id, simplified])"], ["proof (state)\nthis:\n  sorted (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "hence \"hd ?l \\<le> last ?l\""], ["proof (prove)\nusing this:\n  sorted (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. hd (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n    \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "by (rule sorted_hd_last) simp"], ["proof (state)\nthis:\n  hd (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n  \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n  \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])", "by simp"], ["proof (state)\nthis:\n  i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> last (i # filter (\\<lambda>k. P (l ! k)) [Suc i..<length l])\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"i\\<le>j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j", "."], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. P (l ! i) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using \\<open>j<i\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j < i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_set_conv_nth: \"(\\<forall>x\\<in>set l. P x) \\<longleftrightarrow> (\\<forall>i<length l. P (l!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set l. P x) = (\\<forall>i<length l. P (l ! i))", "by (auto intro: all_nth_imp_all_set)"], ["", "(* TODO: Special case of upt_eq_Nil_conv. Find cases where the latter does not work \\<dots>\n*)"], ["", "lemma upt_0_eq_Nil_conv[simp]: \"[0..<j] = [] \\<longleftrightarrow> j=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([0..<j] = []) = (j = 0)", "by auto"], ["", "lemma filter_eq_snocD: \"filter P l = l'@[x] \\<Longrightarrow> x\\<in>set l \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P l = l' @ [x] \\<Longrightarrow> x \\<in> set l \\<and> P x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter P l = l' @ [x] \\<Longrightarrow> x \\<in> set l \\<and> P x", "assume A: \"filter P l = l'@[x]\""], ["proof (state)\nthis:\n  filter P l = l' @ [x]\n\ngoal (1 subgoal):\n 1. filter P l = l' @ [x] \\<Longrightarrow> x \\<in> set l \\<and> P x", "hence \"x\\<in>set (filter P l)\""], ["proof (prove)\nusing this:\n  filter P l = l' @ [x]\n\ngoal (1 subgoal):\n 1. x \\<in> set (filter P l)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (filter P l)\n\ngoal (1 subgoal):\n 1. filter P l = l' @ [x] \\<Longrightarrow> x \\<in> set l \\<and> P x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (filter P l)\n\ngoal (1 subgoal):\n 1. x \\<in> set l \\<and> P x", "by simp"], ["proof (state)\nthis:\n  x \\<in> set l \\<and> P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_image_witness:\n  assumes A: \"x\\<in>lists (f`Q)\"\n  obtains xo where \"xo\\<in>lists Q\" \"x=map f xo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xo.\n        \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xo.\n        \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<lbrakk> x\\<in>lists (f`Q) \\<rbrakk> \\<Longrightarrow> \\<exists>xo\\<in>lists Q. x=map f xo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lists (f ` Q) \\<Longrightarrow>\n    \\<exists>xo\\<in>lists Q. x = map f xo", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists (f ` Q) \\<Longrightarrow>\n    \\<exists>xo\\<in>lists Q. [] = map f xo\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists (f ` Q)\n\ngoal (2 subgoals):\n 1. [] \\<in> lists (f ` Q) \\<Longrightarrow>\n    \\<exists>xo\\<in>lists Q. [] = map f xo\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. \\<exists>xo\\<in>lists Q. [] = map f xo", "by auto"], ["proof (state)\nthis:\n  \\<exists>xo\\<in>lists Q. [] = map f xo\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<in> lists (f ` Q) \\<Longrightarrow>\n  \\<exists>xo\\<in>lists Q. xs = map f xo\n  x # xs \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "then"], ["proof (chain)\npicking this:\n  xs \\<in> lists (f ` Q) \\<Longrightarrow>\n  \\<exists>xo\\<in>lists Q. xs = map f xo\n  x # xs \\<in> lists (f ` Q)", "obtain xos where \"xos\\<in>lists Q\" \"xs=map f xos\""], ["proof (prove)\nusing this:\n  xs \\<in> lists (f ` Q) \\<Longrightarrow>\n  \\<exists>xo\\<in>lists Q. xs = map f xo\n  x # xs \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. (\\<And>xos.\n        \\<lbrakk>xos \\<in> lists Q; xs = map f xos\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xos \\<in> lists Q\n  xs = map f xos\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "moreover"], ["proof (state)\nthis:\n  xos \\<in> lists Q\n  xs = map f xos\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "from Cons.prems"], ["proof (chain)\npicking this:\n  x # xs \\<in> lists (f ` Q)", "have \"x\\<in>f`Q\""], ["proof (prove)\nusing this:\n  x # xs \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. x \\<in> f ` Q", "by auto"], ["proof (state)\nthis:\n  x \\<in> f ` Q\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "then"], ["proof (chain)\npicking this:\n  x \\<in> f ` Q", "obtain xo where \"xo\\<in>Q\" \"x=f xo\""], ["proof (prove)\nusing this:\n  x \\<in> f ` Q\n\ngoal (1 subgoal):\n 1. (\\<And>xo.\n        \\<lbrakk>xo \\<in> Q; x = f xo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xo \\<in> Q\n  x = f xo\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> lists (f ` Q) \\<Longrightarrow>\n                \\<exists>xo\\<in>lists Q. x = map f xo;\n        a # x \\<in> lists (f ` Q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xo\\<in>lists Q. a # x = map f xo", "ultimately"], ["proof (chain)\npicking this:\n  xos \\<in> lists Q\n  xs = map f xos\n  xo \\<in> Q\n  x = f xo", "show ?case"], ["proof (prove)\nusing this:\n  xos \\<in> lists Q\n  xs = map f xos\n  xo \\<in> Q\n  x = f xo\n\ngoal (1 subgoal):\n 1. \\<exists>xo\\<in>lists Q. x # xs = map f xo", "by (rule_tac x=\"xo#xos\" in bexI) auto"], ["proof (state)\nthis:\n  \\<exists>xo\\<in>lists Q. x # xs = map f xo\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lists (f ` Q) \\<Longrightarrow>\n  \\<exists>xo\\<in>lists Q. x = map f xo\n\ngoal (1 subgoal):\n 1. (\\<And>xo.\n        \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> lists (f ` Q) \\<Longrightarrow>\n  \\<exists>xo\\<in>lists Q. x = map f xo\n\ngoal (1 subgoal):\n 1. thesis", "apply (simp_all add: A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xo\\<in>lists Q. x = map f xo \\<Longrightarrow> thesis", "apply (erule_tac bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xo.\n       \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule_tac that)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xo.\n       \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n       \\<Longrightarrow> ?xo5 xo \\<in> lists Q\n 2. \\<And>xo.\n       \\<lbrakk>xo \\<in> lists Q; x = map f xo\\<rbrakk>\n       \\<Longrightarrow> x = map f (?xo5 xo)", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_None_filterD:\n  \"map_of xs x = None \\<Longrightarrow> map_of (filter P xs) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs x = None \\<Longrightarrow> map_of (filter P xs) x = None", "by(induct xs) auto"], ["", "lemma map_of_concat: \"map_of (concat xss) = foldr (\\<lambda>xs f. f ++ map_of xs) xss Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat xss) =\n    foldr (\\<lambda>xs f. f ++ map_of xs) xss Map.empty", "by(induct xss) simp_all"], ["", "lemma map_of_Some_split:\n  \"map_of xs k = Some v \\<Longrightarrow> \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs k = Some v \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of [] k = Some v \\<Longrightarrow>\n    \\<exists>ys zs. [] = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. \\<And>a xs.\n       \\<lbrakk>map_of xs k = Some v \\<Longrightarrow>\n                \\<exists>ys zs.\n                   xs = ys @ (k, v) # zs \\<and> map_of ys k = None;\n        map_of (a # xs) k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ (k, v) # zs \\<and>\n                            map_of ys k = None", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_of xs k = Some v \\<Longrightarrow>\n  \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n  map_of (x # xs) k = Some v\n\ngoal (2 subgoals):\n 1. map_of [] k = Some v \\<Longrightarrow>\n    \\<exists>ys zs. [] = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. \\<And>a xs.\n       \\<lbrakk>map_of xs k = Some v \\<Longrightarrow>\n                \\<exists>ys zs.\n                   xs = ys @ (k, v) # zs \\<and> map_of ys k = None;\n        map_of (a # xs) k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ (k, v) # zs \\<and>\n                            map_of ys k = None", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (2 subgoals):\n 1. map_of [] k = Some v \\<Longrightarrow>\n    \\<exists>ys zs. [] = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. \\<And>a xs.\n       \\<lbrakk>map_of xs k = Some v \\<Longrightarrow>\n                \\<exists>ys zs.\n                   xs = ys @ (k, v) # zs \\<and> map_of ys k = None;\n        map_of (a # xs) k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ (k, v) # zs \\<and>\n                            map_of ys k = None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "proof(cases \"k' = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "case True"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "with \\<open>map_of (x # xs) k = Some v\\<close> x"], ["proof (chain)\npicking this:\n  map_of (x # xs) k = Some v\n  x = (k', v')\n  k' = k", "have \"x # xs = [] @ (k, v) # xs\" \"map_of [] k = None\""], ["proof (prove)\nusing this:\n  map_of (x # xs) k = Some v\n  x = (k', v')\n  k' = k\n\ngoal (1 subgoal):\n 1. x # xs = [] @ (k, v) # xs &&& map_of [] k = None", "by simp_all"], ["proof (state)\nthis:\n  x # xs = [] @ (k, v) # xs\n  map_of [] k = None\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  x # xs = [] @ (k, v) # xs\n  map_of [] k = None\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "case False"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "with \\<open>map_of (x # xs) k = Some v\\<close> x"], ["proof (chain)\npicking this:\n  map_of (x # xs) k = Some v\n  x = (k', v')\n  k' \\<noteq> k", "have \"map_of xs k = Some v\""], ["proof (prove)\nusing this:\n  map_of (x # xs) k = Some v\n  x = (k', v')\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. map_of xs k = Some v", "by simp"], ["proof (state)\nthis:\n  map_of xs k = Some v\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "from \\<open>map_of xs k = Some v \\<Longrightarrow> \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None\\<close>[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "obtain ys zs where \"xs = ys @ (k, v) # zs\" \"map_of ys k = None\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ (k, v) # zs; map_of ys k = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ys @ (k, v) # zs\n  map_of ys k = None\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "with False x"], ["proof (chain)\npicking this:\n  k' \\<noteq> k\n  x = (k', v')\n  xs = ys @ (k, v) # zs\n  map_of ys k = None", "have \"x # xs = (x # ys) @ (k, v) # zs\" \"map_of (x # ys) k = None\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k\n  x = (k', v')\n  xs = ys @ (k, v) # zs\n  map_of ys k = None\n\ngoal (1 subgoal):\n 1. x # xs = (x # ys) @ (k, v) # zs &&& map_of (x # ys) k = None", "by simp_all"], ["proof (state)\nthis:\n  x # xs = (x # ys) @ (k, v) # zs\n  map_of (x # ys) k = None\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  x # xs = (x # ys) @ (k, v) # zs\n  map_of (x # ys) k = None\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys zs. x # xs = ys @ (k, v) # zs \\<and> map_of ys k = None\n\ngoal (1 subgoal):\n 1. map_of [] k = Some v \\<Longrightarrow>\n    \\<exists>ys zs. [] = ys @ (k, v) # zs \\<and> map_of ys k = None", "qed simp"], ["", "lemma map_add_find_left:\n  \"g k = None \\<Longrightarrow> (f ++ g) k = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g k = None \\<Longrightarrow> (f ++ g) k = f k", "by(simp add: map_add_def)"], ["", "lemma map_add_left_None:\n  \"f k = None \\<Longrightarrow> (f ++ g) k = g k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k = None \\<Longrightarrow> (f ++ g) k = g k", "by(simp add: map_add_def split: option.split)"], ["", "lemma map_of_Some_filter_not_in:\n  \"\\<lbrakk> map_of xs k = Some v; \\<not> P (k, v); distinct (map fst xs) \\<rbrakk> \\<Longrightarrow> map_of (filter P xs) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of xs k = Some v; \\<not> P (k, v);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> map_of (filter P xs) k = None", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of [] k = Some v; \\<not> P (k, v);\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> map_of (filter P []) k = None\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>map_of xs k = Some v; \\<not> P (k, v);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> map_of (filter P xs) k = None;\n        map_of (a # xs) k = Some v; \\<not> P (k, v);\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> map_of (filter P (a # xs)) k = None", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>(k, v) \\<in> set xs \\<Longrightarrow>\n                map_of (filter P xs) k = None;\n        \\<not> P (k, v); k \\<notin> fst ` set xs;\n        distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> map_of (filter P xs) k = None", "apply(auto simp add: map_of_eq_None_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_map_fst_filterI: \"distinct (map fst xs) \\<Longrightarrow> distinct (map fst (filter P xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow> distinct (map fst (filter P xs))", "by(induct xs) auto"], ["", "lemma distinct_map_fstD: \"\\<lbrakk> distinct (map fst xs); (x, y) \\<in> set xs; (x, z) \\<in> set xs \\<rbrakk> \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); (x, y) \\<in> set xs;\n     (x, z) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> y = z", "by(induct xs)(fastforce elim: notE rev_image_eqI)+"], ["", "lemma concat_filter_neq_Nil:\n  \"concat [ys\\<leftarrow>xs. ys \\<noteq> Nil] = concat xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (filter (\\<lambda>ys. ys \\<noteq> []) xs) = concat xs", "by(induct xs) simp_all"], ["", "lemma distinct_concat':\n  \"\\<lbrakk>distinct [ys\\<leftarrow>xs. ys \\<noteq> Nil]; \\<And>ys. ys \\<in> set xs \\<Longrightarrow> distinct ys;\n   \\<And>ys zs. \\<lbrakk>ys \\<in> set xs; zs \\<in> set xs; ys \\<noteq> zs\\<rbrakk> \\<Longrightarrow> set ys \\<inter> set zs = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (filter (\\<lambda>ys. ys \\<noteq> []) xs);\n     \\<And>ys. ys \\<in> set xs \\<Longrightarrow> distinct ys;\n     \\<And>ys zs.\n        \\<lbrakk>ys \\<in> set xs; zs \\<in> set xs; ys \\<noteq> zs\\<rbrakk>\n        \\<Longrightarrow> set ys \\<inter> set zs = {}\\<rbrakk>\n    \\<Longrightarrow> distinct (concat xs)", "by(erule distinct_concat[of \"[ys\\<leftarrow>xs. ys \\<noteq> Nil]\", unfolded concat_filter_neq_Nil]) auto"], ["", "lemma distinct_idx:\n  assumes \"distinct (map f l)\"\n  assumes \"i<length l\"\n  assumes \"j<length l\"\n  assumes \"f (l!i) = f (l!j)\"\n  shows \"i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "by (metis assms distinct_conv_nth length_map nth_map)"], ["", "lemma replicate_Suc_conv_snoc:\n  \"replicate (Suc n) x = replicate n x @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (Suc n) x = replicate n x @ [x]", "by (metis replicate_Suc replicate_append_same)"], ["", "lemma filter_nth_ex_nth:\n  assumes \"n < length (filter P xs)\"\n  shows \"\\<exists>m. n \\<le> m \\<and> m < length xs \\<and> filter P xs ! n = xs ! m \\<and> filter P (take m xs) = take n (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length xs \\<and>\n       filter P xs ! n = xs ! m \\<and>\n       filter P (take m xs) = take n (filter P xs)", "using assms"], ["proof (prove)\nusing this:\n  n < length (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length xs \\<and>\n       filter P xs ! n = xs ! m \\<and>\n       filter P (take m xs) = take n (filter P xs)", "proof(induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length (filter P []) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length [] \\<and>\n       filter P [] ! n = [] ! m \\<and>\n       filter P (take m []) = take n (filter P [])\n 2. \\<And>x xs.\n       \\<lbrakk>n < length (filter P xs) \\<Longrightarrow>\n                \\<exists>m\\<ge>n.\n                   m < length xs \\<and>\n                   filter P xs ! n = xs ! m \\<and>\n                   filter P (take m xs) = take n (filter P xs);\n        n < length (filter P (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<ge>n.\n                            m < length (xs @ [x]) \\<and>\n                            filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n                            filter P (take m (xs @ [x])) =\n                            take n (filter P (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  n < length (filter P [])\n\ngoal (2 subgoals):\n 1. n < length (filter P []) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length [] \\<and>\n       filter P [] ! n = [] ! m \\<and>\n       filter P (take m []) = take n (filter P [])\n 2. \\<And>x xs.\n       \\<lbrakk>n < length (filter P xs) \\<Longrightarrow>\n                \\<exists>m\\<ge>n.\n                   m < length xs \\<and>\n                   filter P xs ! n = xs ! m \\<and>\n                   filter P (take m xs) = take n (filter P xs);\n        n < length (filter P (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<ge>n.\n                            m < length (xs @ [x]) \\<and>\n                            filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n                            filter P (take m (xs @ [x])) =\n                            take n (filter P (xs @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  n < length (filter P [])\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length [] \\<and>\n       filter P [] ! n = [] ! m \\<and>\n       filter P (take m []) = take n (filter P [])", "by simp"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length [] \\<and>\n     filter P [] ! n = [] ! m \\<and>\n     filter P (take m []) = take n (filter P [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n < length (filter P xs) \\<Longrightarrow>\n                \\<exists>m\\<ge>n.\n                   m < length xs \\<and>\n                   filter P xs ! n = xs ! m \\<and>\n                   filter P (take m xs) = take n (filter P xs);\n        n < length (filter P (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<ge>n.\n                            m < length (xs @ [x]) \\<and>\n                            filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n                            filter P (take m (xs @ [x])) =\n                            take n (filter P (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n < length (filter P xs) \\<Longrightarrow>\n                \\<exists>m\\<ge>n.\n                   m < length xs \\<and>\n                   filter P xs ! n = xs ! m \\<and>\n                   filter P (take m xs) = take n (filter P xs);\n        n < length (filter P (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<ge>n.\n                            m < length (xs @ [x]) \\<and>\n                            filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n                            filter P (take m (xs @ [x])) =\n                            take n (filter P (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  n < length (filter P xs) \\<Longrightarrow>\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)\n  n < length (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n < length (filter P xs) \\<Longrightarrow>\n                \\<exists>m\\<ge>n.\n                   m < length xs \\<and>\n                   filter P xs ! n = xs ! m \\<and>\n                   filter P (take m xs) = take n (filter P xs);\n        n < length (filter P (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<ge>n.\n                            m < length (xs @ [x]) \\<and>\n                            filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n                            filter P (take m (xs @ [x])) =\n                            take n (filter P (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "proof(cases \"P x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. \\<not> P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. \\<not> P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "from \\<open>n < length (filter P (xs @ [x]))\\<close>"], ["proof (chain)\npicking this:\n  n < length (filter P (xs @ [x]))", "have \"n < length (filter P xs)\""], ["proof (prove)\nusing this:\n  n < length (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. n < length (filter P xs)", "by simp"], ["proof (state)\nthis:\n  n < length (filter P xs)\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. \\<not> P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "hence \"\\<exists>m\\<ge>n. m < length xs \\<and> filter P xs ! n = xs ! m \\<and> filter P (take m xs) = take n (filter P xs)\""], ["proof (prove)\nusing this:\n  n < length (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length xs \\<and>\n       filter P xs ! n = xs ! m \\<and>\n       filter P (take m xs) = take n (filter P xs)", "by(rule snoc)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. \\<not> P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length (xs @ [x]) \\<and>\n     filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n     filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "case [simp]: True"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "proof(cases \"n = length (filter P xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. n \\<noteq> length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  n \\<noteq> length (filter P xs)\n\ngoal (2 subgoals):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. n \\<noteq> length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "with \\<open>n < length (filter P (xs @ [x]))\\<close>"], ["proof (chain)\npicking this:\n  n < length (filter P (xs @ [x]))\n  n \\<noteq> length (filter P xs)", "have \"n < length (filter P xs)\""], ["proof (prove)\nusing this:\n  n < length (filter P (xs @ [x]))\n  n \\<noteq> length (filter P xs)\n\ngoal (1 subgoal):\n 1. n < length (filter P xs)", "by simp"], ["proof (state)\nthis:\n  n < length (filter P xs)\n\ngoal (2 subgoals):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. n \\<noteq> length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  n < length (filter P xs)\n\ngoal (2 subgoals):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. n \\<noteq> length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "hence \"\\<exists>m\\<ge>n. m < length xs \\<and> filter P xs ! n = xs ! m \\<and> filter P (take m xs) = take n (filter P xs)\""], ["proof (prove)\nusing this:\n  n < length (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length xs \\<and>\n       filter P xs ! n = xs ! m \\<and>\n       filter P (take m xs) = take n (filter P xs)", "by(rule snoc)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)\n\ngoal (2 subgoals):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n 2. n \\<noteq> length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  n < length (filter P xs)\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  n < length (filter P xs)\n  \\<exists>m\\<ge>n.\n     m < length xs \\<and>\n     filter P xs ! n = xs ! m \\<and>\n     filter P (take m xs) = take n (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "by(auto simp add: nth_append)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length (xs @ [x]) \\<and>\n     filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n     filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "case [simp]: True"], ["proof (state)\nthis:\n  n = length (filter P xs)\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "hence \"filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs\""], ["proof (prove)\nusing this:\n  n = length (filter P xs)\n\ngoal (1 subgoal):\n 1. filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs", "by simp"], ["proof (state)\nthis:\n  filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "have \"length xs < length (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs < length (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  length xs < length (xs @ [x])\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  length xs < length (xs @ [x])\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "have \"length xs \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs", "by simp"], ["proof (state)\nthis:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "have \"filter P (take (length xs) (xs @ [x])) = take n (filter P (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (take (length xs) (xs @ [x])) = take n (filter P (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  filter P (take (length xs) (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. n = length (filter P xs) \\<Longrightarrow>\n    \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs\n  length xs < length (xs @ [x])\n  n \\<le> length xs\n  filter P (take (length xs) (xs @ [x])) = take n (filter P (xs @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  filter P (xs @ [x]) ! n = (xs @ [x]) ! length xs\n  length xs < length (xs @ [x])\n  n \\<le> length xs\n  filter P (take (length xs) (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>n.\n       m < length (xs @ [x]) \\<and>\n       filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n       filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length (xs @ [x]) \\<and>\n     filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n     filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length (xs @ [x]) \\<and>\n     filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n     filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n.\n     m < length (xs @ [x]) \\<and>\n     filter P (xs @ [x]) ! n = (xs @ [x]) ! m \\<and>\n     filter P (take m (xs @ [x])) = take n (filter P (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_map_filter:\n  \"set (List.map_filter g xs) = {y. \\<exists>x. x \\<in> set xs \\<and> g x = Some y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.map_filter g xs) =\n    {y. \\<exists>x. x \\<in> set xs \\<and> g x = Some y}", "by (induct xs) (auto simp add: List.map_filter_def set_eq_iff)"], ["", "subsection \\<open>Quicksort by Relation\\<close>"], ["", "text \\<open>A functional implementation of quicksort on lists. It it similar to the\none in Isabelle/HOL's example directory. However, it uses tail-recursion for append and arbitrary\nrelations.\\<close>"], ["", "fun partition_rev :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a list \\<times> 'a list) \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> 'a list)\" where\n   \"partition_rev P (yes, no) [] = (yes, no)\"\n | \"partition_rev P (yes, no) (x # xs) =\n      partition_rev P (if P x then (x # yes, no) else (yes, x # no)) xs\""], ["", "lemma partition_rev_filter_conv :\n  \"partition_rev P (yes, no) xs = (rev (filter P xs) @ yes,  rev (filter (Not \\<circ> P) xs) @ no)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_rev P (yes, no) xs =\n    (rev (filter P xs) @ yes, rev (filter (Not \\<circ> P) xs) @ no)", "by (induct xs arbitrary: yes no) (simp_all)"], ["", "function quicksort_by_rel :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"quicksort_by_rel R sl [] = sl\"\n| \"quicksort_by_rel R sl (x#xs) =\n   (let (xs_s, xs_b) = partition_rev (\\<lambda>y. R y x) ([],[]) xs in\n    quicksort_by_rel R (x # (quicksort_by_rel R sl xs_b)) xs_s)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>R sl. x = (R, sl, []) \\<Longrightarrow> P;\n        \\<And>R sl xa xs. x = (R, sl, xa # xs) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>R sl Ra sla.\n       (R, sl, []) = (Ra, sla, []) \\<Longrightarrow> sl = sla\n 3. \\<And>R sl Ra sla x xs.\n       (R, sl, []) = (Ra, sla, x # xs) \\<Longrightarrow>\n       sl =\n       (let (xs_s, xs_b) = partition_rev (\\<lambda>y. Ra y x) ([], []) xs\n        in quicksort_by_rel_sumC\n            (Ra, x # quicksort_by_rel_sumC (Ra, sla, xs_b), xs_s))\n 4. \\<And>R sl x xs Ra sla xa xsa.\n       (R, sl, x # xs) = (Ra, sla, xa # xsa) \\<Longrightarrow>\n       (let (xs_s, xs_b) = partition_rev (\\<lambda>y. R y x) ([], []) xs\n        in quicksort_by_rel_sumC\n            (R, x # quicksort_by_rel_sumC (R, sl, xs_b), xs_s)) =\n       (let (xs_s, xs_b) = partition_rev (\\<lambda>y. Ra y xa) ([], []) xsa\n        in quicksort_by_rel_sumC\n            (Ra, xa # quicksort_by_rel_sumC (Ra, sla, xs_b), xs_s))", "by pat_completeness simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All quicksort_by_rel_dom", "by (relation \"measure (\\<lambda>(_, _, xs). length xs)\")\n   (simp_all add: partition_rev_filter_conv less_Suc_eq_le)"], ["", "lemma quicksort_by_rel_remove_acc :\n  \"quicksort_by_rel R sl xs = (quicksort_by_rel R [] xs @ sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "proof (induct xs arbitrary: sl rule: measure_induct_rule[of \"length\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           quicksort_by_rel R sl y =\n           quicksort_by_rel R [] y @ sl) \\<Longrightarrow>\n       quicksort_by_rel R sl x = quicksort_by_rel R [] x @ sl", "case (less xs)"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  quicksort_by_rel R ?sl ?y = quicksort_by_rel R [] ?y @ ?sl\n\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           quicksort_by_rel R sl y =\n           quicksort_by_rel R [] y @ sl) \\<Longrightarrow>\n       quicksort_by_rel R sl x = quicksort_by_rel R [] x @ sl", "note ind_hyp = this"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  quicksort_by_rel R ?sl ?y = quicksort_by_rel R [] ?y @ ?sl\n\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           quicksort_by_rel R sl y =\n           quicksort_by_rel R [] y @ sl) \\<Longrightarrow>\n       quicksort_by_rel R sl x = quicksort_by_rel R [] x @ sl", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "by simp"], ["proof (state)\nthis:\n  quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "obtain xs1 xs2 where part_rev_eq[simp]: \"partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2.\n        partition_rev (\\<lambda>y. R y x) ([], []) xs' =\n        (xs1, xs2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "from part_rev_eq[symmetric]"], ["proof (chain)\npicking this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'", "have length_le: \"length xs1 < length xs\" \"length xs2 < length xs\""], ["proof (prove)\nusing this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "unfolding partition_rev_filter_conv"], ["proof (prove)\nusing this:\n  (xs1, xs2) =\n  (rev (filter (\\<lambda>y. R y x) xs') @ [],\n   rev (filter (Not \\<circ> (\\<lambda>y. R y x)) xs') @ [])\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "by (simp_all add: less_Suc_eq_le)"], ["proof (state)\nthis:\n  length xs1 < length xs\n  length xs2 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "note ind_hyp1a = ind_hyp[OF length_le(1), of \"x # quicksort_by_rel R [] xs2\"]"], ["proof (state)\nthis:\n  quicksort_by_rel R (x # quicksort_by_rel R [] xs2) xs1 =\n  quicksort_by_rel R [] xs1 @ x # quicksort_by_rel R [] xs2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "note ind_hyp1b = ind_hyp[OF length_le(1), of \"x # quicksort_by_rel R [] xs2 @ sl\"]"], ["proof (state)\nthis:\n  quicksort_by_rel R (x # quicksort_by_rel R [] xs2 @ sl) xs1 =\n  quicksort_by_rel R [] xs1 @ x # quicksort_by_rel R [] xs2 @ sl\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "note ind_hyp2 = ind_hyp[OF length_le(2), of sl]"], ["proof (state)\nthis:\n  quicksort_by_rel R sl xs2 = quicksort_by_rel R [] xs2 @ sl\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "by (simp add: ind_hyp1a ind_hyp1b ind_hyp2)"], ["proof (state)\nthis:\n  quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quicksort_by_rel_remove_acc_guared :\n  \"sl \\<noteq> [] \\<Longrightarrow> quicksort_by_rel R sl xs = (quicksort_by_rel R [] xs @ sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    quicksort_by_rel R sl xs = quicksort_by_rel R [] xs @ sl", "by (metis quicksort_by_rel_remove_acc)"], ["", "lemma quicksort_by_rel_permutes [simp]:\n  \"mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "proof (induct xs arbitrary: sl rule: measure_induct_rule[of \"length\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           mset (quicksort_by_rel R sl y) = mset (y @ sl)) \\<Longrightarrow>\n       mset (quicksort_by_rel R sl x) = mset (x @ sl)", "case (less xs)"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  mset (quicksort_by_rel R ?sl ?y) = mset (?y @ ?sl)\n\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           mset (quicksort_by_rel R sl y) = mset (y @ sl)) \\<Longrightarrow>\n       mset (quicksort_by_rel R sl x) = mset (x @ sl)", "note ind_hyp = this"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  mset (quicksort_by_rel R ?sl ?y) = mset (?y @ ?sl)\n\ngoal (1 subgoal):\n 1. \\<And>x sl.\n       (\\<And>y sl.\n           length y < length x \\<Longrightarrow>\n           mset (quicksort_by_rel R sl y) = mset (y @ sl)) \\<Longrightarrow>\n       mset (quicksort_by_rel R sl x) = mset (x @ sl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "by simp"], ["proof (state)\nthis:\n  mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "obtain xs1 xs2 where part_rev_eq[simp]: \"partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2.\n        partition_rev (\\<lambda>y. R y x) ([], []) xs' =\n        (xs1, xs2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "from part_rev_eq[symmetric]"], ["proof (chain)\npicking this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'", "have xs'_multi_eq : \"mset xs' = mset xs1 + mset xs2\""], ["proof (prove)\nusing this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs1 + mset xs2", "unfolding partition_rev_filter_conv"], ["proof (prove)\nusing this:\n  (xs1, xs2) =\n  (rev (filter (\\<lambda>y. R y x) xs') @ [],\n   rev (filter (Not \\<circ> (\\<lambda>y. R y x)) xs') @ [])\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs1 + mset xs2", "by (simp add: mset_filter)"], ["proof (state)\nthis:\n  mset xs' = mset xs1 + mset xs2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "from part_rev_eq[symmetric]"], ["proof (chain)\npicking this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'", "have length_le: \"length xs1 < length xs\" \"length xs2 < length xs\""], ["proof (prove)\nusing this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "unfolding partition_rev_filter_conv"], ["proof (prove)\nusing this:\n  (xs1, xs2) =\n  (rev (filter (\\<lambda>y. R y x) xs') @ [],\n   rev (filter (Not \\<circ> (\\<lambda>y. R y x)) xs') @ [])\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "by (simp_all add: less_Suc_eq_le)"], ["proof (state)\nthis:\n  length xs1 < length xs\n  length xs2 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "note ind_hyp[OF length_le(1)] ind_hyp[OF length_le(2)]"], ["proof (state)\nthis:\n  mset (quicksort_by_rel R ?sl xs1) = mset (xs1 @ ?sl)\n  mset (quicksort_by_rel R ?sl xs2) = mset (xs2 @ ?sl)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mset (quicksort_by_rel R ?sl xs1) = mset (xs1 @ ?sl)\n  mset (quicksort_by_rel R ?sl xs2) = mset (xs2 @ ?sl)\n\ngoal (1 subgoal):\n 1. mset (quicksort_by_rel R sl xs) = mset (xs @ sl)", "by (simp add: xs'_multi_eq union_assoc)"], ["proof (state)\nthis:\n  mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (quicksort_by_rel R sl xs) = mset (xs @ sl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_quicksort_by_rel [simp]: \"set (quicksort_by_rel R sl xs) = set (xs @ sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (quicksort_by_rel R sl xs) = set (xs @ sl)", "unfolding set_mset_comp_mset [symmetric] o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset (quicksort_by_rel R sl xs)) = set_mset (mset (xs @ sl))", "by simp"], ["", "lemma sorted_wrt_quicksort_by_rel:\n  fixes R:: \"'x \\<Rightarrow> 'x \\<Rightarrow> bool\"\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows \"sorted_wrt R (quicksort_by_rel R [] xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort_by_rel R [] xs)", "proof (induct xs rule: measure_induct_rule[of \"length\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (quicksort_by_rel R [] y)) \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] x)", "case (less xs)"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (quicksort_by_rel R [] ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (quicksort_by_rel R [] y)) \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] x)", "note ind_hyp = this"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (quicksort_by_rel R [] ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (quicksort_by_rel R [] y)) \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort_by_rel R [] xs)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt R (quicksort_by_rel R [] xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt R (quicksort_by_rel R [] xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort_by_rel R [] xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort_by_rel R [] xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "obtain xs1 xs2 where part_rev_eq[simp]: \"partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2.\n        partition_rev (\\<lambda>y. R y x) ([], []) xs' =\n        (xs1, xs2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  partition_rev (\\<lambda>y. R y x) ([], []) xs' = (xs1, xs2)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "from part_rev_eq[symmetric]"], ["proof (chain)\npicking this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'", "have xs1_props: \"\\<And>y. y \\<in> set xs1 \\<Longrightarrow> (R y x)\" and\n                                     xs2_props: \"\\<And>y. y \\<in> set xs2 \\<Longrightarrow> \\<not>(R y x)\""], ["proof (prove)\nusing this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> set xs1 \\<Longrightarrow> R y x) &&&\n    (\\<And>y. y \\<in> set xs2 \\<Longrightarrow> \\<not> R y x)", "unfolding partition_rev_filter_conv"], ["proof (prove)\nusing this:\n  (xs1, xs2) =\n  (rev (filter (\\<lambda>y. R y x) xs') @ [],\n   rev (filter (Not \\<circ> (\\<lambda>y. R y x)) xs') @ [])\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> set xs1 \\<Longrightarrow> R y x) &&&\n    (\\<And>y. y \\<in> set xs2 \\<Longrightarrow> \\<not> R y x)", "by simp_all"], ["proof (state)\nthis:\n  ?y \\<in> set xs1 \\<Longrightarrow> R ?y x\n  ?y \\<in> set xs2 \\<Longrightarrow> \\<not> R ?y x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "from xs2_props lin"], ["proof (chain)\npicking this:\n  ?y \\<in> set xs2 \\<Longrightarrow> \\<not> R ?y x\n  R ?x ?y \\<or> R ?y ?x", "have xs2_props': \"\\<And>y. y \\<in> set xs2 \\<Longrightarrow> (R x y)\""], ["proof (prove)\nusing this:\n  ?y \\<in> set xs2 \\<Longrightarrow> \\<not> R ?y x\n  R ?x ?y \\<or> R ?y ?x\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> set xs2 \\<Longrightarrow> R x y", "by blast"], ["proof (state)\nthis:\n  ?y \\<in> set xs2 \\<Longrightarrow> R x ?y\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "from xs2_props' xs1_props trans_R"], ["proof (chain)\npicking this:\n  ?y \\<in> set xs2 \\<Longrightarrow> R x ?y\n  ?y \\<in> set xs1 \\<Longrightarrow> R ?y x\n  \\<lbrakk>R ?x ?y; R ?y ?z\\<rbrakk> \\<Longrightarrow> R ?x ?z", "have xs1_props':\n      \"\\<And>y1 y2. y1 \\<in> set xs1 \\<Longrightarrow> y2 \\<in> set xs2 \\<Longrightarrow> (R y1 y2)\""], ["proof (prove)\nusing this:\n  ?y \\<in> set xs2 \\<Longrightarrow> R x ?y\n  ?y \\<in> set xs1 \\<Longrightarrow> R ?y x\n  \\<lbrakk>R ?x ?y; R ?y ?z\\<rbrakk> \\<Longrightarrow> R ?x ?z\n\ngoal (1 subgoal):\n 1. \\<And>y1 y2.\n       \\<lbrakk>y1 \\<in> set xs1; y2 \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> R y1 y2", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>?y1.0 \\<in> set xs1; ?y2.0 \\<in> set xs2\\<rbrakk>\n  \\<Longrightarrow> R ?y1.0 ?y2.0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "from part_rev_eq[symmetric]"], ["proof (chain)\npicking this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'", "have length_le: \"length xs1 < length xs\" \"length xs2 < length xs\""], ["proof (prove)\nusing this:\n  (xs1, xs2) = partition_rev (\\<lambda>y. R y x) ([], []) xs'\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "unfolding partition_rev_filter_conv"], ["proof (prove)\nusing this:\n  (xs1, xs2) =\n  (rev (filter (\\<lambda>y. R y x) xs') @ [],\n   rev (filter (Not \\<circ> (\\<lambda>y. R y x)) xs') @ [])\n\ngoal (1 subgoal):\n 1. length xs1 < length xs &&& length xs2 < length xs", "by (simp_all add: less_Suc_eq_le)"], ["proof (state)\nthis:\n  length xs1 < length xs\n  length xs2 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "note ind_hyps = ind_hyp[OF length_le(1)] ind_hyp[OF length_le(2)]"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort_by_rel R [] xs1)\n  sorted_wrt R (quicksort_by_rel R [] xs2)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt R (quicksort_by_rel R [] xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt R (quicksort_by_rel R [] xs1)\n  sorted_wrt R (quicksort_by_rel R [] xs2)\n\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort_by_rel R [] xs)", "by (simp add: quicksort_by_rel_remove_acc_guared sorted_wrt_append Ball_def\n                    xs1_props xs2_props' xs1_props')"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort_by_rel R [] xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort_by_rel R [] xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_quicksort_by_rel:\n  \"sorted (quicksort_by_rel (\\<le>) [] xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (quicksort_by_rel (\\<le>) [] xs)", "unfolding sorted_sorted_wrt"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<le>) (quicksort_by_rel (\\<le>) [] xs)", "by (rule sorted_wrt_quicksort_by_rel) auto"], ["", "lemma sort_quicksort_by_rel:\n  \"sort = quicksort_by_rel (\\<le>) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort = quicksort_by_rel (\\<le>) []", "apply (rule ext, rule properties_for_sort)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. mset (quicksort_by_rel (\\<le>) [] x) = mset x\n 2. \\<And>x. sorted (quicksort_by_rel (\\<le>) [] x)", "apply(simp_all add: sorted_quicksort_by_rel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [code]: \"quicksort = quicksort_by_rel (\\<le>) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort = quicksort_by_rel (\\<le>) []", "apply (subst sort_quicksort[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort = quicksort_by_rel (\\<le>) []", "by (rule sort_quicksort_by_rel)"], ["", "subsection \\<open>Mergesort by Relation\\<close>"], ["", "text \\<open>A functional implementation of mergesort on lists. It it similar to the\none in Isabelle/HOL's example directory. However, it uses tail-recursion for append and arbitrary\nrelations.\\<close>"], ["", "fun mergesort_by_rel_split :: \"('a list \\<times> 'a list) \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> 'a list)\" where\n   \"mergesort_by_rel_split (xs1, xs2) [] = (xs1, xs2)\"\n | \"mergesort_by_rel_split (xs1, xs2) [x] = (x # xs1, xs2)\"\n | \"mergesort_by_rel_split (xs1, xs2) (x1 # x2 # xs) =\n    mergesort_by_rel_split (x1 # xs1, x2 # xs2) xs\""], ["", "lemma list_induct_first2 [consumes 0, case_names Nil Sing Cons2]:\nassumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>x1 x2 xs. P xs \\<Longrightarrow> P (x1 # x2 #xs)\"\nshows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P ys \\<Longrightarrow>\n       P xs", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P ys \\<Longrightarrow>\n       P xs", "note ind_hyp = this"], ["proof (state)\nthis:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P ys \\<Longrightarrow>\n       P xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. P xs", "using assms(1)"], ["proof (prove)\nusing this:\n  xs = []\n  P []\n\ngoal (1 subgoal):\n 1. P xs", "by simp"], ["proof (state)\nthis:\n  P xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "case (Cons x1 xs')"], ["proof (state)\nthis:\n  xs = x1 # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x1 # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = x1 # xs'\n\ngoal (1 subgoal):\n 1. P xs", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x1 # xs'; xs' = []\\<rbrakk> \\<Longrightarrow> P xs\n 2. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "case Nil"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x1 # xs'; xs' = []\\<rbrakk> \\<Longrightarrow> P xs\n 2. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. P xs", "using assms(2)"], ["proof (prove)\nusing this:\n  xs' = []\n  P [?x]\n\ngoal (1 subgoal):\n 1. P xs", "by simp"], ["proof (state)\nthis:\n  P xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "case (Cons x2 xs'')"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "note xs'_eq[simp] = this"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "by (simp add: ind_hyp assms(3))"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mergesort_by_rel_split_length :\n  \"length (fst (mergesort_by_rel_split (xs1, xs2) xs)) = length xs1 + (length xs div 2) + (length xs mod 2) \\<and>\n   length (snd (mergesort_by_rel_split (xs1, xs2) xs)) = length xs2 + (length xs div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (mergesort_by_rel_split (xs1, xs2) xs)) =\n    length xs1 + length xs div 2 + length xs mod 2 \\<and>\n    length (snd (mergesort_by_rel_split (xs1, xs2) xs)) =\n    length xs2 + length xs div 2", "by (induct xs arbitrary: xs1 xs2 rule: list_induct_first2)\n   (simp_all)"], ["", "lemma mset_mergesort_by_rel_split [simp]:\n  \"mset (fst (mergesort_by_rel_split (xs1, xs2) xs)) +\n   mset (snd (mergesort_by_rel_split (xs1, xs2) xs)) =\n   mset xs + mset xs1 + mset xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (fst (mergesort_by_rel_split (xs1, xs2) xs)) +\n    mset (snd (mergesort_by_rel_split (xs1, xs2) xs)) =\n    mset xs + mset xs1 + mset xs2", "apply (induct xs arbitrary: xs1 xs2 rule: list_induct_first2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs1 xs2.\n       mset (fst (mergesort_by_rel_split (xs1, xs2) [])) +\n       mset (snd (mergesort_by_rel_split (xs1, xs2) [])) =\n       mset [] + mset xs1 + mset xs2\n 2. \\<And>x xs1 xs2.\n       mset (fst (mergesort_by_rel_split (xs1, xs2) [x])) +\n       mset (snd (mergesort_by_rel_split (xs1, xs2) [x])) =\n       mset [x] + mset xs1 + mset xs2\n 3. \\<And>x1 x2 xs xs1 xs2.\n       (\\<And>xs1 xs2.\n           mset (fst (mergesort_by_rel_split (xs1, xs2) xs)) +\n           mset (snd (mergesort_by_rel_split (xs1, xs2) xs)) =\n           mset xs + mset xs1 + mset xs2) \\<Longrightarrow>\n       mset (fst (mergesort_by_rel_split (xs1, xs2) (x1 # x2 # xs))) +\n       mset (snd (mergesort_by_rel_split (xs1, xs2) (x1 # x2 # xs))) =\n       mset (x1 # x2 # xs) + mset xs1 + mset xs2", "apply (simp_all add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun mergesort_by_rel_merge :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"mergesort_by_rel_merge R (x#xs) (y#ys) =\n     (if R x y then x # mergesort_by_rel_merge R xs (y#ys) else y # mergesort_by_rel_merge R (x#xs) ys)\"\n| \"mergesort_by_rel_merge R xs [] = xs\"\n| \"mergesort_by_rel_merge R [] ys = ys\""], ["", "declare mergesort_by_rel_merge.simps [simp del]"], ["", "lemma mergesort_by_rel_merge_simps[simp] :\n  \"mergesort_by_rel_merge R (x#xs) (y#ys) =\n     (if R x y then x # mergesort_by_rel_merge R xs (y#ys) else y # mergesort_by_rel_merge R (x#xs) ys)\"\n  \"mergesort_by_rel_merge R xs [] = xs\"\n  \"mergesort_by_rel_merge R [] ys = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_by_rel_merge R (x # xs) (y # ys) =\n    (if R x y then x # mergesort_by_rel_merge R xs (y # ys)\n     else y # mergesort_by_rel_merge R (x # xs) ys) &&&\n    mergesort_by_rel_merge R xs [] = xs &&&\n    mergesort_by_rel_merge R [] ys = ys", "apply (simp_all add: mergesort_by_rel_merge.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_by_rel_merge R [] ys = ys", "apply (cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> mergesort_by_rel_merge R [] ys = ys\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow> mergesort_by_rel_merge R [] ys = ys", "apply (simp_all add: mergesort_by_rel_merge.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mergesort_by_rel_merge_induct [consumes 0, case_names Nil1 Nil2 Cons1 Cons2]:\nassumes \"\\<And>xs::'a list. P xs []\" \"\\<And>ys::'b list. P [] ys\"\n        \"\\<And>x xs y ys. R x y \\<Longrightarrow> P xs (y # ys) \\<Longrightarrow> P (x # xs) (y # ys)\"\n        \"\\<And>x xs y ys. \\<not>(R x y) \\<Longrightarrow> P (x # xs) ys \\<Longrightarrow> P (x # xs) (y # ys)\"\nshows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. P [] x\n 2. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. P [] x\n 2. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P [] ys", "using assms(2)"], ["proof (prove)\nusing this:\n  P [] ?ys\n\ngoal (1 subgoal):\n 1. P [] ys", "by simp"], ["proof (state)\nthis:\n  P [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "case (Cons x xs)"], ["proof (state)\nthis:\n  P xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "note P_xs = this"], ["proof (state)\nthis:\n  P xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs x. (\\<And>x. P xs x) \\<Longrightarrow> P (a # xs) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (x # xs) ys", "proof (induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. P (x # xs) []\n 2. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P (x # xs) []\n 2. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (x # xs) []", "using assms(1)"], ["proof (prove)\nusing this:\n  P ?xs []\n\ngoal (1 subgoal):\n 1. P (x # xs) []", "by simp"], ["proof (state)\nthis:\n  P (x # xs) []\n\ngoal (1 subgoal):\n 1. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  P (x # xs) ys\n\ngoal (1 subgoal):\n 1. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "note P_x_xs_ys = this"], ["proof (state)\nthis:\n  P (x # xs) ys\n\ngoal (1 subgoal):\n 1. \\<And>a ys. P (x # xs) ys \\<Longrightarrow> P (x # xs) (a # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (x # xs) (y # ys)", "using assms(3,4)[of x y xs ys] P_x_xs_ys P_xs"], ["proof (prove)\nusing this:\n  \\<lbrakk>R x y; P xs (y # ys)\\<rbrakk>\n  \\<Longrightarrow> P (x # xs) (y # ys)\n  \\<lbrakk>\\<not> R x y; P (x # xs) ys\\<rbrakk>\n  \\<Longrightarrow> P (x # xs) (y # ys)\n  P (x # xs) ys\n  P xs ?ys\n\ngoal (1 subgoal):\n 1. P (x # xs) (y # ys)", "by metis"], ["proof (state)\nthis:\n  P (x # xs) (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (x # xs) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_mergesort_by_rel_merge [simp]:\n  \"mset (mergesort_by_rel_merge R xs ys) = mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel_merge R xs ys) = mset xs + mset ys", "by (induct R xs ys rule: mergesort_by_rel_merge.induct) (simp_all add: ac_simps)"], ["", "lemma set_mergesort_by_rel_merge [simp]:\n  \"set (mergesort_by_rel_merge R xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mergesort_by_rel_merge R xs ys) = set xs \\<union> set ys", "by (induct R xs ys rule: mergesort_by_rel_merge.induct) auto"], ["", "lemma sorted_wrt_mergesort_by_rel_merge [simp]:\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows  \"sorted_wrt R (mergesort_by_rel_merge R xs ys) \\<longleftrightarrow>\n          sorted_wrt R xs \\<and> sorted_wrt R ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel_merge R xs ys) =\n    (sorted_wrt R xs \\<and> sorted_wrt R ys)", "proof (induct xs ys rule: mergesort_by_rel_merge_induct[where R = R])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       sorted_wrt R (mergesort_by_rel_merge R xs []) =\n       (sorted_wrt R xs \\<and> sorted_wrt R [])\n 2. \\<And>ys.\n       sorted_wrt R (mergesort_by_rel_merge R [] ys) =\n       (sorted_wrt R [] \\<and> sorted_wrt R ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "case Nil1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       sorted_wrt R (mergesort_by_rel_merge R xs []) =\n       (sorted_wrt R xs \\<and> sorted_wrt R [])\n 2. \\<And>ys.\n       sorted_wrt R (mergesort_by_rel_merge R [] ys) =\n       (sorted_wrt R [] \\<and> sorted_wrt R ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel_merge R xs_ []) =\n    (sorted_wrt R xs_ \\<and> sorted_wrt R [])", "by simp"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel_merge R xs_ []) =\n  (sorted_wrt R xs_ \\<and> sorted_wrt R [])\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       sorted_wrt R (mergesort_by_rel_merge R [] ys) =\n       (sorted_wrt R [] \\<and> sorted_wrt R ys)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       sorted_wrt R (mergesort_by_rel_merge R [] ys) =\n       (sorted_wrt R [] \\<and> sorted_wrt R ys)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "case Nil2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       sorted_wrt R (mergesort_by_rel_merge R [] ys) =\n       (sorted_wrt R [] \\<and> sorted_wrt R ys)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel_merge R [] ys_) =\n    (sorted_wrt R [] \\<and> sorted_wrt R ys_)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel_merge R [] ys_) =\n  (sorted_wrt R [] \\<and> sorted_wrt R ys_)\n\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "case (Cons1 x xs y ys)"], ["proof (state)\nthis:\n  R x y\n  sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n  (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>R x y;\n        sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n        (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  R x y\n  sorted_wrt R (mergesort_by_rel_merge R xs (y # ys)) =\n  (sorted_wrt R xs \\<and> sorted_wrt R (y # ys))\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n    (sorted_wrt R (x # xs) \\<and> sorted_wrt R (y # ys))", "by (simp add: Ball_def) (metis trans_R)"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n  (sorted_wrt R (x # xs) \\<and> sorted_wrt R (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "case (Cons2 x xs y ys)"], ["proof (state)\nthis:\n  \\<not> R x y\n  sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n  (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n        (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R\n                          (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n                         (sorted_wrt R (x # xs) \\<and>\n                          sorted_wrt R (y # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> R x y\n  sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys) =\n  (sorted_wrt R (x # xs) \\<and> sorted_wrt R ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n    (sorted_wrt R (x # xs) \\<and> sorted_wrt R (y # ys))", "apply (auto simp add: Ball_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> R x y;\n     sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys);\n     \\<forall>xa. xa \\<in> set xs \\<longrightarrow> R x xa; sorted_wrt R xs;\n     \\<forall>x. x \\<in> set ys \\<longrightarrow> R y x;\n     sorted_wrt R ys\\<rbrakk>\n    \\<Longrightarrow> R y x\n 2. \\<And>xa.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys);\n        \\<forall>xa. xa \\<in> set xs \\<longrightarrow> R x xa;\n        sorted_wrt R xs; \\<forall>x. x \\<in> set ys \\<longrightarrow> R y x;\n        sorted_wrt R ys; xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> R y xa", "apply (metis lin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<not> R x y;\n        sorted_wrt R (mergesort_by_rel_merge R (x # xs) ys);\n        \\<forall>xa. xa \\<in> set xs \\<longrightarrow> R x xa;\n        sorted_wrt R xs; \\<forall>x. x \\<in> set ys \\<longrightarrow> R y x;\n        sorted_wrt R ys; xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> R y xa", "apply (metis lin trans_R)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel_merge R (x # xs) (y # ys)) =\n  (sorted_wrt R (x # xs) \\<and> sorted_wrt R (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "function mergesort_by_rel :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"mergesort_by_rel R xs =\n    (if length xs < 2 then xs else\n     (mergesort_by_rel_merge R\n       (mergesort_by_rel R (fst (mergesort_by_rel_split ([], []) xs)))\n       (mergesort_by_rel R (snd (mergesort_by_rel_split ([], []) xs)))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>R xs. x = (R, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>R xs Ra xsa.\n       (R, xs) = (Ra, xsa) \\<Longrightarrow>\n       (if length xs < 2 then xs\n        else mergesort_by_rel_merge R\n              (mergesort_by_rel_sumC\n                (R, fst (mergesort_by_rel_split ([], []) xs)))\n              (mergesort_by_rel_sumC\n                (R, snd (mergesort_by_rel_split ([], []) xs)))) =\n       (if length xsa < 2 then xsa\n        else mergesort_by_rel_merge Ra\n              (mergesort_by_rel_sumC\n                (Ra, fst (mergesort_by_rel_split ([], []) xsa)))\n              (mergesort_by_rel_sumC\n                (Ra, snd (mergesort_by_rel_split ([], []) xsa))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mergesort_by_rel_dom", "by (relation \"measure (\\<lambda>(_, xs). length xs)\")\n  (simp_all add: mergesort_by_rel_split_length not_less minus_div_mult_eq_mod [symmetric])"], ["", "declare mergesort_by_rel.simps [simp del]"], ["", "lemma mergesort_by_rel_simps [simp, code] :\n  \"mergesort_by_rel R [] = []\"\n  \"mergesort_by_rel R [x] = [x]\"\n  \"mergesort_by_rel R (x1 # x2 # xs) =\n   (let (xs1, xs2) = (mergesort_by_rel_split ([x1], [x2]) xs) in\n   mergesort_by_rel_merge R (mergesort_by_rel R xs1) (mergesort_by_rel R xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_by_rel R [] = [] &&&\n    mergesort_by_rel R [x] = [x] &&&\n    mergesort_by_rel R (x1 # x2 # xs) =\n    (let (xs1, xs2) = mergesort_by_rel_split ([x1], [x2]) xs\n     in mergesort_by_rel_merge R (mergesort_by_rel R xs1)\n         (mergesort_by_rel R xs2))", "apply (simp add: mergesort_by_rel.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mergesort_by_rel R [x] = [x]\n 2. mergesort_by_rel R (x1 # x2 # xs) =\n    (let (xs1, xs2) = mergesort_by_rel_split ([x1], [x2]) xs\n     in mergesort_by_rel_merge R (mergesort_by_rel R xs1)\n         (mergesort_by_rel R xs2))", "apply (simp add: mergesort_by_rel.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_by_rel R (x1 # x2 # xs) =\n    (let (xs1, xs2) = mergesort_by_rel_split ([x1], [x2]) xs\n     in mergesort_by_rel_merge R (mergesort_by_rel R xs1)\n         (mergesort_by_rel R xs2))", "apply (simp add: mergesort_by_rel.simps[of _ \"x1 # x2 # xs\"] split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mergesort_by_rel_permutes [simp]:\n  \"mset (mergesort_by_rel R xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "proof (induct xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          mset (mergesort_by_rel R ys) = mset ys \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     mset (mergesort_by_rel R ys) = mset ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          mset (mergesort_by_rel R ys) = mset ys \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "note ind_hyp = this"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     mset (mergesort_by_rel R ys) = mset ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          mset (mergesort_by_rel R ys) = mset ys \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> mset (mergesort_by_rel R xs) = mset xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> mset (mergesort_by_rel R xs) = mset xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "by simp"], ["proof (state)\nthis:\n  mset (mergesort_by_rel R xs) = mset xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "case (Cons x1 xs')"], ["proof (state)\nthis:\n  xs = x1 # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x1 # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow> mset (mergesort_by_rel R xs) = mset xs\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "case Nil"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow> mset (mergesort_by_rel R xs) = mset xs\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "by simp"], ["proof (state)\nthis:\n  mset (mergesort_by_rel R xs) = mset xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "case (Cons x2 xs'')"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "note xs'_eq[simp] = this"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "have \"length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\"\n           \"length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (mergesort_by_rel_split ([], []) xs)) < length xs &&&\n    length (snd (mergesort_by_rel_split ([], []) xs)) < length xs", "by (simp_all add: mergesort_by_rel_split_length)"], ["proof (state)\nthis:\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       mset (mergesort_by_rel R xs) = mset xs", "with ind_hyp"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     mset (mergesort_by_rel R ys) = mset ys\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     mset (mergesort_by_rel R ys) = mset ys\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. mset (mergesort_by_rel R xs) = mset xs", "unfolding mergesort_by_rel.simps[of _ xs]"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     mset (mergesort_by_rel R ys) = mset ys\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. mset\n     (if length xs < 2 then xs\n      else mergesort_by_rel_merge R\n            (mergesort_by_rel R (fst (mergesort_by_rel_split ([], []) xs)))\n            (mergesort_by_rel R\n              (snd (mergesort_by_rel_split ([], []) xs)))) =\n    mset xs", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  mset (mergesort_by_rel R xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (mergesort_by_rel R xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (mergesort_by_rel R xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_mergesort_by_rel [simp]: \"set (mergesort_by_rel R xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mergesort_by_rel R xs) = set xs", "unfolding set_mset_comp_mset [symmetric] o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset (mergesort_by_rel R xs)) = set_mset (mset xs)", "by simp"], ["", "lemma sorted_wrt_mergesort_by_rel:\n  fixes R:: \"'x \\<Rightarrow> 'x \\<Rightarrow> bool\"\n  assumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n      and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n  shows \"sorted_wrt R (mergesort_by_rel R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "proof (induct xs rule: measure_induct_rule[of \"length\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (mergesort_by_rel R y)) \\<Longrightarrow>\n       sorted_wrt R (mergesort_by_rel R x)", "case (less xs)"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (mergesort_by_rel R ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (mergesort_by_rel R y)) \\<Longrightarrow>\n       sorted_wrt R (mergesort_by_rel R x)", "note ind_hyp = this"], ["proof (state)\nthis:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (mergesort_by_rel R ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           length y < length x \\<Longrightarrow>\n           sorted_wrt R (mergesort_by_rel R y)) \\<Longrightarrow>\n       sorted_wrt R (mergesort_by_rel R x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel R xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "note xs_eq[simp] = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x # xs'; xs' = []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)\n 2. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "case Nil"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x # xs'; xs' = []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)\n 2. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel R xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "case (Cons x2 xs'')"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "note xs'_eq[simp] = this"], ["proof (state)\nthis:\n  xs' = x2 # xs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "have \"length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\"\n           \"length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (mergesort_by_rel_split ([], []) xs)) < length xs &&&\n    length (snd (mergesort_by_rel_split ([], []) xs)) < length xs", "by (simp_all add: mergesort_by_rel_split_length)"], ["proof (state)\nthis:\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x # xs'; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (mergesort_by_rel R xs)", "with ind_hyp"], ["proof (chain)\npicking this:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (mergesort_by_rel R ?y)\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (mergesort_by_rel R ?y)\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. sorted_wrt R (mergesort_by_rel R xs)", "unfolding mergesort_by_rel.simps[of _ xs]"], ["proof (prove)\nusing this:\n  length ?y < length xs \\<Longrightarrow>\n  sorted_wrt R (mergesort_by_rel R ?y)\n  length (fst (mergesort_by_rel_split ([], []) xs)) < length xs\n  length (snd (mergesort_by_rel_split ([], []) xs)) < length xs\n\ngoal (1 subgoal):\n 1. sorted_wrt R\n     (if length xs < 2 then xs\n      else mergesort_by_rel_merge R\n            (mergesort_by_rel R (fst (mergesort_by_rel_split ([], []) xs)))\n            (mergesort_by_rel R (snd (mergesort_by_rel_split ([], []) xs))))", "by (simp add: sorted_wrt_mergesort_by_rel_merge[OF lin trans_R])"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel R xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel R xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt R (mergesort_by_rel R xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_mergesort_by_rel:\n  \"sorted (mergesort_by_rel (\\<le>) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (mergesort_by_rel (\\<le>) xs)", "unfolding sorted_sorted_wrt"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<le>) (mergesort_by_rel (\\<le>) xs)", "by (rule sorted_wrt_mergesort_by_rel) auto"], ["", "lemma sort_mergesort_by_rel:\n  \"sort = mergesort_by_rel (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort = mergesort_by_rel (\\<le>)", "apply (rule ext, rule properties_for_sort)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. mset (mergesort_by_rel (\\<le>) x) = mset x\n 2. \\<And>x. sorted (mergesort_by_rel (\\<le>) x)", "apply(simp_all add: sorted_mergesort_by_rel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"mergesort = mergesort_by_rel (\\<le>)\""], ["", "lemma sort_mergesort: \"sort = mergesort\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort = mergesort", "unfolding mergesort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort = mergesort_by_rel (\\<le>)", "by (rule sort_mergesort_by_rel)"], ["", "subsubsection \\<open>Mergesort with Remdup\\<close>"], ["", "term merge"], ["", "fun merge :: \"'a::{linorder} list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n   \"merge [] l2 = l2\"\n | \"merge l1 [] = l1\"\n | \"merge (x1 # l1) (x2 # l2) =\n    (if (x1 < x2) then x1 # (merge l1 (x2 # l2)) else\n     (if (x1 = x2) then x1 # (merge l1 l2) else x2 # (merge (x1 # l1) l2)))\""], ["", "lemma merge_correct :\nassumes l1_OK: \"distinct l1 \\<and> sorted l1\"\nassumes l2_OK: \"distinct l2 \\<and> sorted l2\"\nshows \"distinct (merge l1 l2) \\<and> sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (merge l1 l2) \\<and>\n    sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2", "using assms"], ["proof (prove)\nusing this:\n  distinct l1 \\<and> sorted l1\n  distinct l2 \\<and> sorted l2\n\ngoal (1 subgoal):\n 1. distinct (merge l1 l2) \\<and>\n    sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2", "proof (induct l1 arbitrary: l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>distinct [] \\<and> sorted [];\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge [] l2) \\<and>\n                         sorted (merge [] l2) \\<and>\n                         set (merge [] l2) = set [] \\<union> set l2\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "case Nil"], ["proof (state)\nthis:\n  distinct [] \\<and> sorted []\n  distinct l2 \\<and> sorted l2\n\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>distinct [] \\<and> sorted [];\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge [] l2) \\<and>\n                         sorted (merge [] l2) \\<and>\n                         set (merge [] l2) = set [] \\<union> set l2\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "thus ?case"], ["proof (prove)\nusing this:\n  distinct [] \\<and> sorted []\n  distinct l2 \\<and> sorted l2\n\ngoal (1 subgoal):\n 1. distinct (merge [] l2) \\<and>\n    sorted (merge [] l2) \\<and> set (merge [] l2) = set [] \\<union> set l2", "by simp"], ["proof (state)\nthis:\n  distinct (merge [] l2) \\<and>\n  sorted (merge [] l2) \\<and> set (merge [] l2) = set [] \\<union> set l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "case (Cons x1 l1 l2)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct l1 \\<and> sorted l1;\n   distinct ?l2.0 \\<and> sorted ?l2.0\\<rbrakk>\n  \\<Longrightarrow> distinct (merge l1 ?l2.0) \\<and>\n                    sorted (merge l1 ?l2.0) \\<and>\n                    set (merge l1 ?l2.0) = set l1 \\<union> set ?l2.0\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)\n  distinct l2 \\<and> sorted l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "note x1_l1_props = Cons(2)"], ["proof (state)\nthis:\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "note l2_props = Cons(3)"], ["proof (state)\nthis:\n  distinct l2 \\<and> sorted l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "from x1_l1_props"], ["proof (chain)\npicking this:\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)", "have l1_props: \"distinct l1 \\<and> sorted l1\"\n                    and x1_nin_l1: \"x1 \\<notin> set l1\"\n                    and x1_le: \"\\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x\""], ["proof (prove)\nusing this:\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)\n\ngoal (1 subgoal):\n 1. distinct l1 \\<and> sorted l1 &&&\n    x1 \\<notin> set l1 &&&\n    (\\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x)", "by (simp_all add: Ball_def)"], ["proof (state)\nthis:\n  distinct l1 \\<and> sorted l1\n  x1 \\<notin> set l1\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "note ind_hyp_l1 = Cons(1)[OF l1_props]"], ["proof (state)\nthis:\n  distinct ?l2.0 \\<and> sorted ?l2.0 \\<Longrightarrow>\n  distinct (merge l1 ?l2.0) \\<and>\n  sorted (merge l1 ?l2.0) \\<and>\n  set (merge l1 ?l2.0) = set l1 \\<union> set ?l2.0\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>distinct l1 \\<and> sorted l1;\n                    distinct l2 \\<and> sorted l2\\<rbrakk>\n                   \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                                     sorted (merge l1 l2) \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        distinct (a # l1) \\<and> sorted (a # l1);\n        distinct l2 \\<and> sorted l2\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (a # l1) l2) \\<and>\n                         sorted (merge (a # l1) l2) \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) l2) \\<and>\n    sorted (merge (x1 # l1) l2) \\<and>\n    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2", "using l2_props"], ["proof (prove)\nusing this:\n  distinct l2 \\<and> sorted l2\n\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) l2) \\<and>\n    sorted (merge (x1 # l1) l2) \\<and>\n    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2", "proof (induct l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<and> sorted [] \\<Longrightarrow>\n    distinct (merge (x1 # l1) []) \\<and>\n    sorted (merge (x1 # l1) []) \\<and>\n    set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []\n 2. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "case Nil"], ["proof (state)\nthis:\n  distinct [] \\<and> sorted []\n\ngoal (2 subgoals):\n 1. distinct [] \\<and> sorted [] \\<Longrightarrow>\n    distinct (merge (x1 # l1) []) \\<and>\n    sorted (merge (x1 # l1) []) \\<and>\n    set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []\n 2. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "with x1_l1_props"], ["proof (chain)\npicking this:\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)\n  distinct [] \\<and> sorted []", "show ?case"], ["proof (prove)\nusing this:\n  distinct (x1 # l1) \\<and> sorted (x1 # l1)\n  distinct [] \\<and> sorted []\n\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) []) \\<and>\n    sorted (merge (x1 # l1) []) \\<and>\n    set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []", "by simp"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) []) \\<and>\n  sorted (merge (x1 # l1) []) \\<and>\n  set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "case (Cons x2 l2)"], ["proof (state)\nthis:\n  distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n  distinct (merge (x1 # l1) l2) \\<and>\n  sorted (merge (x1 # l1) l2) \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  distinct (x2 # l2) \\<and> sorted (x2 # l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "note x2_l2_props = Cons(2)"], ["proof (state)\nthis:\n  distinct (x2 # l2) \\<and> sorted (x2 # l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "from x2_l2_props"], ["proof (chain)\npicking this:\n  distinct (x2 # l2) \\<and> sorted (x2 # l2)", "have l2_props: \"distinct l2 \\<and> sorted l2\"\n                    and x2_nin_l2: \"x2 \\<notin> set l2\"\n                    and x2_le: \"\\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x\""], ["proof (prove)\nusing this:\n  distinct (x2 # l2) \\<and> sorted (x2 # l2)\n\ngoal (1 subgoal):\n 1. distinct l2 \\<and> sorted l2 &&&\n    x2 \\<notin> set l2 &&&\n    (\\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x)", "by (simp_all add: Ball_def)"], ["proof (state)\nthis:\n  distinct l2 \\<and> sorted l2\n  x2 \\<notin> set l2\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "note ind_hyp_l2 = Cons(1)[OF l2_props]"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) l2) \\<and>\n  sorted (merge (x1 # l1) l2) \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>distinct l2 \\<and> sorted l2 \\<Longrightarrow>\n                distinct (merge (x1 # l1) l2) \\<and>\n                sorted (merge (x1 # l1) l2) \\<and>\n                set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2;\n        distinct (a # l2) \\<and> sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> distinct (merge (x1 # l1) (a # l2)) \\<and>\n                         sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "proof (cases \"x1 < x2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "case True"], ["proof (state)\nthis:\n  x1 < x2\n\ngoal (2 subgoals):\n 1. x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "note x1_less_x2 = this"], ["proof (state)\nthis:\n  x1 < x2\n\ngoal (2 subgoals):\n 1. x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "from ind_hyp_l1[OF x2_l2_props] x1_less_x2 x1_nin_l1 x1_le x2_le"], ["proof (chain)\npicking this:\n  distinct (merge l1 (x2 # l2)) \\<and>\n  sorted (merge l1 (x2 # l2)) \\<and>\n  set (merge l1 (x2 # l2)) = set l1 \\<union> set (x2 # l2)\n  x1 < x2\n  x1 \\<notin> set l1\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (merge l1 (x2 # l2)) \\<and>\n  sorted (merge l1 (x2 # l2)) \\<and>\n  set (merge l1 (x2 # l2)) = set l1 \\<union> set (x2 # l2)\n  x1 < x2\n  x1 \\<notin> set l1\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "apply (auto simp add: Ball_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x1 < x2; x1 \\<notin> set l1;\n     \\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x;\n     \\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x;\n     distinct (merge l1 (x2 # l2)); sorted (merge l1 (x2 # l2));\n     set (merge l1 (x2 # l2)) = insert x2 (set l1 \\<union> set l2);\n     x1 \\<in> set l2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x1 < x2; x1 \\<notin> set l1;\n        \\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x;\n        \\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x;\n        distinct (merge l1 (x2 # l2)); sorted (merge l1 (x2 # l2));\n        set (merge l1 (x2 # l2)) = insert x2 (set l1 \\<union> set l2);\n        x \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> x", "apply (metis linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x1 < x2; x1 \\<notin> set l1;\n        \\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x;\n        \\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x;\n        distinct (merge l1 (x2 # l2)); sorted (merge l1 (x2 # l2));\n        set (merge l1 (x2 # l2)) = insert x2 (set l1 \\<union> set l2);\n        x \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> x", "apply (metis linorder_not_less xt1(6) xt1(9))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal (1 subgoal):\n 1. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "case False"], ["proof (state)\nthis:\n  \\<not> x1 < x2\n\ngoal (1 subgoal):\n 1. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "note x2_le_x1 = this"], ["proof (state)\nthis:\n  \\<not> x1 < x2\n\ngoal (1 subgoal):\n 1. \\<not> x1 < x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "proof (cases \"x1 = x2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 = x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "case True"], ["proof (state)\nthis:\n  x1 = x2\n\ngoal (2 subgoals):\n 1. x1 = x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "note x1_eq_x2 = this"], ["proof (state)\nthis:\n  x1 = x2\n\ngoal (2 subgoals):\n 1. x1 = x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n 2. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "from ind_hyp_l1[OF l2_props] x1_le x2_le x2_nin_l2 x1_eq_x2 x1_nin_l1"], ["proof (chain)\npicking this:\n  distinct (merge l1 l2) \\<and>\n  sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n  x2 \\<notin> set l2\n  x1 = x2\n  x1 \\<notin> set l1", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (merge l1 l2) \\<and>\n  sorted (merge l1 l2) \\<and> set (merge l1 l2) = set l1 \\<union> set l2\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n  x2 \\<notin> set l2\n  x1 = x2\n  x1 \\<notin> set l1\n\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "by (simp add: x1_eq_x2 Ball_def)"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "case False"], ["proof (state)\nthis:\n  x1 \\<noteq> x2\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "note x1_neq_x2 = this"], ["proof (state)\nthis:\n  x1 \\<noteq> x2\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "with x2_le_x1"], ["proof (chain)\npicking this:\n  \\<not> x1 < x2\n  x1 \\<noteq> x2", "have x2_less_x1 : \"x2 < x1\""], ["proof (prove)\nusing this:\n  \\<not> x1 < x2\n  x1 \\<noteq> x2\n\ngoal (1 subgoal):\n 1. x2 < x1", "by auto"], ["proof (state)\nthis:\n  x2 < x1\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "from ind_hyp_l2 x2_le_x1 x1_neq_x2 x2_le x2_nin_l2 x1_le"], ["proof (chain)\npicking this:\n  distinct (merge (x1 # l1) l2) \\<and>\n  sorted (merge (x1 # l1) l2) \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  \\<not> x1 < x2\n  x1 \\<noteq> x2\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n  x2 \\<notin> set l2\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (merge (x1 # l1) l2) \\<and>\n  sorted (merge (x1 # l1) l2) \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  \\<not> x1 < x2\n  x1 \\<noteq> x2\n  ?x \\<in> set l2 \\<Longrightarrow> x2 \\<le> ?x\n  x2 \\<notin> set l2\n  ?x \\<in> set l1 \\<Longrightarrow> x1 \\<le> ?x\n\ngoal (1 subgoal):\n 1. distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n    sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "apply (simp add: x2_less_x1 Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (merge (x1 # l1) l2) \\<and>\n             sorted (merge (x1 # l1) l2) \\<and>\n             set (merge (x1 # l1) l2) = insert x1 (set l1 \\<union> set l2);\n     \\<not> x1 < x2; x1 \\<noteq> x2;\n     \\<And>x. x \\<in> set l2 \\<Longrightarrow> x2 \\<le> x;\n     x2 \\<notin> set l2;\n     \\<And>x. x \\<in> set l1 \\<Longrightarrow> x1 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x2 \\<notin> set l1 \\<and>\n                      (\\<forall>x.\n                          (x = x1 \\<longrightarrow> x2 \\<le> x1) \\<and>\n                          (x \\<in> set l1 \\<longrightarrow> x2 \\<le> x))", "apply (metis linorder_not_le x2_less_x1 xt1(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) (x2 # l2)) \\<and>\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (merge (x1 # l1) l2) \\<and>\n  sorted (merge (x1 # l1) l2) \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n\ngoal:\nNo subgoals!", "qed"], ["", "function merge_list :: \"'a::{linorder} list list \\<Rightarrow> 'a list list \\<Rightarrow> 'a list\" where\n   \"merge_list [] [] = []\"\n | \"merge_list [] [l] = l\"\n | \"merge_list (la # acc2) [] = merge_list [] (la # acc2)\"\n | \"merge_list (la # acc2) [l] = merge_list [] (l # la # acc2)\"\n | \"merge_list acc2 (l1 # l2 # ls) =\n    merge_list ((merge l1 l2) # acc2) ls\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = ([], []) \\<Longrightarrow> P;\n        \\<And>l. x = ([], [l]) \\<Longrightarrow> P;\n        \\<And>la acc2. x = (la # acc2, []) \\<Longrightarrow> P;\n        \\<And>la acc2 l. x = (la # acc2, [l]) \\<Longrightarrow> P;\n        \\<And>acc2 l1 l2 ls.\n           x = (acc2, l1 # l2 # ls) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. ([], []) = ([], []) \\<Longrightarrow> [] = []\n 3. \\<And>l. ([], []) = ([], [l]) \\<Longrightarrow> [] = l\n 4. \\<And>la acc2.\n       ([], []) = (la # acc2, []) \\<Longrightarrow>\n       [] = merge_list_sumC ([], la # acc2)\n 5. \\<And>la acc2 l.\n       ([], []) = (la # acc2, [l]) \\<Longrightarrow>\n       [] = merge_list_sumC ([], l # la # acc2)\n 6. \\<And>acc2 l1 l2 ls.\n       ([], []) = (acc2, l1 # l2 # ls) \\<Longrightarrow>\n       [] = merge_list_sumC (merge l1 l2 # acc2, ls)\n 7. \\<And>l la. ([], [l]) = ([], [la]) \\<Longrightarrow> l = la\n 8. \\<And>l la acc2.\n       ([], [l]) = (la # acc2, []) \\<Longrightarrow>\n       l = merge_list_sumC ([], la # acc2)\n 9. \\<And>l la acc2 lb.\n       ([], [l]) = (la # acc2, [lb]) \\<Longrightarrow>\n       l = merge_list_sumC ([], lb # la # acc2)\n 10. \\<And>l acc2 l1 l2 ls.\n        ([], [l]) = (acc2, l1 # l2 # ls) \\<Longrightarrow>\n        l = merge_list_sumC (merge l1 l2 # acc2, ls)\nA total of 16 subgoals...", "by pat_completeness simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All merge_list_dom", "by (relation \"measure (\\<lambda>(acc, ls). 3 * length acc + 2 * length ls)\") (simp_all)"], ["", "lemma merge_list_correct :\nassumes ls_OK: \"\\<And>l. l \\<in> set ls \\<Longrightarrow> distinct l \\<and> sorted l\"\nassumes as_OK: \"\\<And>l. l \\<in> set as \\<Longrightarrow> distinct l \\<and> sorted l\"\nshows \"distinct (merge_list as ls) \\<and> sorted (merge_list as ls) \\<and>\n       set (merge_list as ls) = set (concat (as @ ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (merge_list as ls) \\<and>\n    sorted (merge_list as ls) \\<and>\n    set (merge_list as ls) = set (concat (as @ ls))", "using assms"], ["proof (prove)\nusing this:\n  ?l \\<in> set ls \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set as \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. distinct (merge_list as ls) \\<and>\n    sorted (merge_list as ls) \\<and>\n    set (merge_list as ls) = set (concat (as @ ls))", "proof (induct as ls rule: merge_list.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>l.\n                l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n     \\<And>l.\n        l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n    \\<Longrightarrow> distinct (merge_list [] []) \\<and>\n                      sorted (merge_list [] []) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la.\n                   la \\<in> set [l] \\<Longrightarrow>\n                   distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list [] [l]) \\<and>\n                         sorted (merge_list [] [l]) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case 1"], ["proof (state)\nthis:\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>l.\n                l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n     \\<And>l.\n        l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n    \\<Longrightarrow> distinct (merge_list [] []) \\<and>\n                      sorted (merge_list [] []) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la.\n                   la \\<in> set [l] \\<Longrightarrow>\n                   distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list [] [l]) \\<and>\n                         sorted (merge_list [] [l]) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "thus ?case"], ["proof (prove)\nusing this:\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. distinct (merge_list [] []) \\<and>\n    sorted (merge_list [] []) \\<and>\n    set (merge_list [] []) = set (concat ([] @ []))", "by simp"], ["proof (state)\nthis:\n  distinct (merge_list [] []) \\<and>\n  sorted (merge_list [] []) \\<and>\n  set (merge_list [] []) = set (concat ([] @ []))\n\ngoal (4 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>la.\n                   la \\<in> set [l] \\<Longrightarrow>\n                   distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list [] [l]) \\<and>\n                         sorted (merge_list [] [l]) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 2. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 3. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>la.\n                   la \\<in> set [l] \\<Longrightarrow>\n                   distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list [] [l]) \\<and>\n                         sorted (merge_list [] [l]) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 2. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 3. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case 2"], ["proof (state)\nthis:\n  ?l \\<in> set [l_] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (4 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>la.\n                   la \\<in> set [l] \\<Longrightarrow>\n                   distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list [] [l]) \\<and>\n                         sorted (merge_list [] [l]) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 2. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 3. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "thus ?case"], ["proof (prove)\nusing this:\n  ?l \\<in> set [l_] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. distinct (merge_list [] [l_]) \\<and>\n    sorted (merge_list [] [l_]) \\<and>\n    set (merge_list [] [l_]) = set (concat ([] @ [l_]))", "by simp"], ["proof (state)\nthis:\n  distinct (merge_list [] [l_]) \\<and>\n  sorted (merge_list [] [l_]) \\<and>\n  set (merge_list [] [l_]) = set (concat ([] @ [l_]))\n\ngoal (3 subgoals):\n 1. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 2. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 3. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 2. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 3. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case 3"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>l.\n              l \\<in> set (la_ # acc2_) \\<Longrightarrow>\n              distinct l \\<and> sorted l;\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list [] (la_ # acc2_)) \\<and>\n                    sorted (merge_list [] (la_ # acc2_)) \\<and>\n                    set (merge_list [] (la_ # acc2_)) =\n                    set (concat ([] @ la_ # acc2_))\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set (la_ # acc2_) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (3 subgoals):\n 1. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (la # acc2)) \\<and>\n                                  sorted (merge_list [] (la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l.\n           l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) []) \\<and>\n                         sorted (merge_list (la # acc2) []) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 2. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 3. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l.\n              l \\<in> set (la_ # acc2_) \\<Longrightarrow>\n              distinct l \\<and> sorted l;\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list [] (la_ # acc2_)) \\<and>\n                    sorted (merge_list [] (la_ # acc2_)) \\<and>\n                    set (merge_list [] (la_ # acc2_)) =\n                    set (concat ([] @ la_ # acc2_))\n  ?l \\<in> set [] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set (la_ # acc2_) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. distinct (merge_list (la_ # acc2_) []) \\<and>\n    sorted (merge_list (la_ # acc2_) []) \\<and>\n    set (merge_list (la_ # acc2_) []) = set (concat ((la_ # acc2_) @ []))", "by simp"], ["proof (state)\nthis:\n  distinct (merge_list (la_ # acc2_) []) \\<and>\n  sorted (merge_list (la_ # acc2_) []) \\<and>\n  set (merge_list (la_ # acc2_) []) = set (concat ((la_ # acc2_) @ []))\n\ngoal (2 subgoals):\n 1. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 2. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 2. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>lb.\n              lb \\<in> set (l_ # la_ # acc2_) \\<Longrightarrow>\n              distinct lb \\<and> sorted lb;\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list [] (l_ # la_ # acc2_)) \\<and>\n                    sorted (merge_list [] (l_ # la_ # acc2_)) \\<and>\n                    set (merge_list [] (l_ # la_ # acc2_)) =\n                    set (concat ([] @ l_ # la_ # acc2_))\n  ?l \\<in> set [l_] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set (la_ # acc2_) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (2 subgoals):\n 1. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            distinct lb \\<and> sorted lb;\n                 \\<And>l.\n                    l \\<in> set [] \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la.\n           la \\<in> set [l] \\<Longrightarrow> distinct la \\<and> sorted la;\n        \\<And>l.\n           l \\<in> set (la # acc2) \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list (la # acc2) [l]) \\<and>\n                         sorted (merge_list (la # acc2) [l]) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 2. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>lb.\n              lb \\<in> set (l_ # la_ # acc2_) \\<Longrightarrow>\n              distinct lb \\<and> sorted lb;\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list [] (l_ # la_ # acc2_)) \\<and>\n                    sorted (merge_list [] (l_ # la_ # acc2_)) \\<and>\n                    set (merge_list [] (l_ # la_ # acc2_)) =\n                    set (concat ([] @ l_ # la_ # acc2_))\n  ?l \\<in> set [l_] \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set (la_ # acc2_) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. distinct (merge_list (la_ # acc2_) [l_]) \\<and>\n    sorted (merge_list (la_ # acc2_) [l_]) \\<and>\n    set (merge_list (la_ # acc2_) [l_]) =\n    set (concat ((la_ # acc2_) @ [l_]))", "by auto"], ["proof (state)\nthis:\n  distinct (merge_list (la_ # acc2_) [l_]) \\<and>\n  sorted (merge_list (la_ # acc2_) [l_]) \\<and>\n  set (merge_list (la_ # acc2_) [l_]) = set (concat ((la_ # acc2_) @ [l_]))\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case (5 acc l1 l2 ls)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>l.\n              l \\<in> set ls \\<Longrightarrow> distinct l \\<and> sorted l;\n   \\<And>l.\n      l \\<in> set (merge l1 l2 # acc) \\<Longrightarrow>\n      distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n                    sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n                    set (merge_list (merge l1 l2 # acc) ls) =\n                    set (concat ((merge l1 l2 # acc) @ ls))\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "note ind_hyp = 5(1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>l.\n              l \\<in> set ls \\<Longrightarrow> distinct l \\<and> sorted l;\n   \\<And>l.\n      l \\<in> set (merge l1 l2 # acc) \\<Longrightarrow>\n      distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n                    sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n                    set (merge_list (merge l1 l2 # acc) ls) =\n                    set (concat ((merge l1 l2 # acc) @ ls))\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "note l12_l_OK = 5(2)"], ["proof (state)\nthis:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "note acc_OK = 5(3)"], ["proof (state)\nthis:\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "from l12_l_OK acc_OK merge_correct[of l1 l2]"], ["proof (chain)\npicking this:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  \\<lbrakk>distinct l1 \\<and> sorted l1;\n   distinct l2 \\<and> sorted l2\\<rbrakk>\n  \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                    sorted (merge l1 l2) \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2", "have set_merge_eq: \"set (merge l1 l2) = set l1 \\<union> set l2\""], ["proof (prove)\nusing this:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  \\<lbrakk>distinct l1 \\<and> sorted l1;\n   distinct l2 \\<and> sorted l2\\<rbrakk>\n  \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                    sorted (merge l1 l2) \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2\n\ngoal (1 subgoal):\n 1. set (merge l1 l2) = set l1 \\<union> set l2", "by auto"], ["proof (state)\nthis:\n  set (merge l1 l2) = set l1 \\<union> set l2\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "from l12_l_OK acc_OK merge_correct[of l1 l2]"], ["proof (chain)\npicking this:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  \\<lbrakk>distinct l1 \\<and> sorted l1;\n   distinct l2 \\<and> sorted l2\\<rbrakk>\n  \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                    sorted (merge l1 l2) \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2", "have \"distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n        sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n        set (merge_list (merge l1 l2 # acc) ls) =\n        set (concat ((merge l1 l2 # acc) @ ls))\""], ["proof (prove)\nusing this:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  ?l \\<in> set acc \\<Longrightarrow> distinct ?l \\<and> sorted ?l\n  \\<lbrakk>distinct l1 \\<and> sorted l1;\n   distinct l2 \\<and> sorted l2\\<rbrakk>\n  \\<Longrightarrow> distinct (merge l1 l2) \\<and>\n                    sorted (merge l1 l2) \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2\n\ngoal (1 subgoal):\n 1. distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n    sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n    set (merge_list (merge l1 l2 # acc) ls) =\n    set (concat ((merge l1 l2 # acc) @ ls))", "by (rule_tac ind_hyp) auto"], ["proof (state)\nthis:\n  distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n  sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n  set (merge_list (merge l1 l2 # acc) ls) =\n  set (concat ((merge l1 l2 # acc) @ ls))\n\ngoal (1 subgoal):\n 1. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set ls \\<Longrightarrow>\n                            distinct l \\<and> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    distinct l \\<and> sorted l\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l.\n           l \\<in> set (l1 # l2 # ls) \\<Longrightarrow>\n           distinct l \\<and> sorted l;\n        \\<And>l.\n           l \\<in> set acc2 \\<Longrightarrow>\n           distinct l \\<and> sorted l\\<rbrakk>\n       \\<Longrightarrow> distinct (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "with set_merge_eq"], ["proof (chain)\npicking this:\n  set (merge l1 l2) = set l1 \\<union> set l2\n  distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n  sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n  set (merge_list (merge l1 l2 # acc) ls) =\n  set (concat ((merge l1 l2 # acc) @ ls))", "show ?case"], ["proof (prove)\nusing this:\n  set (merge l1 l2) = set l1 \\<union> set l2\n  distinct (merge_list (merge l1 l2 # acc) ls) \\<and>\n  sorted (merge_list (merge l1 l2 # acc) ls) \\<and>\n  set (merge_list (merge l1 l2 # acc) ls) =\n  set (concat ((merge l1 l2 # acc) @ ls))\n\ngoal (1 subgoal):\n 1. distinct (merge_list acc (l1 # l2 # ls)) \\<and>\n    sorted (merge_list acc (l1 # l2 # ls)) \\<and>\n    set (merge_list acc (l1 # l2 # ls)) = set (concat (acc @ l1 # l2 # ls))", "by auto"], ["proof (state)\nthis:\n  distinct (merge_list acc (l1 # l2 # ls)) \\<and>\n  sorted (merge_list acc (l1 # l2 # ls)) \\<and>\n  set (merge_list acc (l1 # l2 # ls)) = set (concat (acc @ l1 # l2 # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mergesort_remdups where\n  \"mergesort_remdups xs = merge_list [] (map (\\<lambda>x. [x]) xs)\""], ["", "lemma mergesort_remdups_correct :\n  \"distinct (mergesort_remdups l)\n  \\<and> sorted (mergesort_remdups l)\n  \\<and> (set (mergesort_remdups l) = set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "let ?l' = \"map (\\<lambda>x. [x]) l\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "assume \"xs \\<in> set ?l'\""], ["proof (state)\nthis:\n  xs \\<in> set (map (\\<lambda>x. [x]) l)\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "then"], ["proof (chain)\npicking this:\n  xs \\<in> set (map (\\<lambda>x. [x]) l)", "obtain x where xs_eq: \"xs = [x]\""], ["proof (prove)\nusing this:\n  xs \\<in> set (map (\\<lambda>x. [x]) l)\n\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  xs = [x]\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "hence \"distinct xs \\<and> sorted xs\""], ["proof (prove)\nusing this:\n  xs = [x]\n\ngoal (1 subgoal):\n 1. distinct xs \\<and> sorted xs", "by simp"], ["proof (state)\nthis:\n  distinct xs \\<and> sorted xs\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "}"], ["proof (state)\nthis:\n  ?xs2 \\<in> set (map (\\<lambda>x. [x]) l) \\<Longrightarrow>\n  distinct ?xs2 \\<and> sorted ?xs2\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "note l'_OK = this"], ["proof (state)\nthis:\n  ?xs2 \\<in> set (map (\\<lambda>x. [x]) l) \\<Longrightarrow>\n  distinct ?xs2 \\<and> sorted ?xs2\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "from merge_list_correct[of \"?l'\" \"[]\", OF l'_OK]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>la.\n              la \\<in> set (map (\\<lambda>x. [x]) l) \\<Longrightarrow>\n              la \\<in> set (map (\\<lambda>x. [x]) l);\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    sorted (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    set (merge_list [] (map (\\<lambda>x. [x]) l)) =\n                    set (concat ([] @ map (\\<lambda>x. [x]) l))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>la.\n              la \\<in> set (map (\\<lambda>x. [x]) l) \\<Longrightarrow>\n              la \\<in> set (map (\\<lambda>x. [x]) l);\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    sorted (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    set (merge_list [] (map (\\<lambda>x. [x]) l)) =\n                    set (concat ([] @ map (\\<lambda>x. [x]) l))\n\ngoal (1 subgoal):\n 1. distinct (mergesort_remdups l) \\<and>\n    sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l", "unfolding mergesort_remdups_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>la.\n              la \\<in> set (map (\\<lambda>x. [x]) l) \\<Longrightarrow>\n              la \\<in> set (map (\\<lambda>x. [x]) l);\n   \\<And>l.\n      l \\<in> set [] \\<Longrightarrow> distinct l \\<and> sorted l\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    sorted (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n                    set (merge_list [] (map (\\<lambda>x. [x]) l)) =\n                    set (concat ([] @ map (\\<lambda>x. [x]) l))\n\ngoal (1 subgoal):\n 1. distinct (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n    sorted (merge_list [] (map (\\<lambda>x. [x]) l)) \\<and>\n    set (merge_list [] (map (\\<lambda>x. [x]) l)) = set l", "by simp"], ["proof (state)\nthis:\n  distinct (mergesort_remdups l) \\<and>\n  sorted (mergesort_remdups l) \\<and> set (mergesort_remdups l) = set l\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma ex1_eqI: \"\\<lbrakk>\\<exists>!x. P x; P a; P b\\<rbrakk> \\<Longrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>!x. P x; P a; P b\\<rbrakk> \\<Longrightarrow> a = b", "by blast"], ["", "lemma remdup_sort_mergesort_remdups:\n  \"remdups o sort = mergesort_remdups\" (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) = mergesort_remdups", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) x =\n       mergesort_remdups x", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) x =\n       mergesort_remdups x", "have \"set (?lhs l) = set l\" and \"sorted (?lhs l)\" and \"distinct (?lhs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) = set l &&&\n    sorted ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) &&&\n    distinct ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)", "by simp_all"], ["proof (state)\nthis:\n  set ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) = set l\n  sorted ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) x =\n       mergesort_remdups x", "moreover"], ["proof (state)\nthis:\n  set ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) = set l\n  sorted ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) x =\n       mergesort_remdups x", "note mergesort_remdups_correct"], ["proof (state)\nthis:\n  distinct (mergesort_remdups ?l) \\<and>\n  sorted (mergesort_remdups ?l) \\<and> set (mergesort_remdups ?l) = set ?l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) x =\n       mergesort_remdups x", "ultimately"], ["proof (chain)\npicking this:\n  set ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) = set l\n  sorted ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct (mergesort_remdups ?l) \\<and>\n  sorted (mergesort_remdups ?l) \\<and> set (mergesort_remdups ?l) = set ?l", "show \"?lhs l = ?rhs l\""], ["proof (prove)\nusing this:\n  set ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l) = set l\n  sorted ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct ((remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l)\n  distinct (mergesort_remdups ?l) \\<and>\n  sorted (mergesort_remdups ?l) \\<and> set (mergesort_remdups ?l) = set ?l\n\ngoal (1 subgoal):\n 1. (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l =\n    mergesort_remdups l", "by (auto intro!: ex1_eqI[OF finite_sorted_distinct_unique[OF finite_set]])"], ["proof (state)\nthis:\n  (remdups \\<circ>\\<circ> sort_key) (\\<lambda>x. x) l = mergesort_remdups l\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Native Integers\\<close>"], ["", "lemma int_of_integer_less_iff: \"int_of_integer x < int_of_integer y \\<longleftrightarrow> x<y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_integer x < int_of_integer y) = (x < y)", "by (simp add: less_integer_def)"], ["", "lemma nat_of_integer_less_iff: \"x\\<ge>0 \\<Longrightarrow> y\\<ge>0 \\<Longrightarrow> nat_of_integer x < nat_of_integer y \\<longleftrightarrow> x<y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (nat_of_integer x < nat_of_integer y) = (x < y)", "unfolding nat_of_integer.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (nat (int_of_integer x) < nat (int_of_integer y)) =\n                      (x < y)", "by (auto simp: int_of_integer_less_iff nat_less_eq_zless int_of_integer_less_iff[of 0, simplified])"], ["", "subsection \"Natural Numbers\""], ["", "lemma exists_leI:\n  assumes hyp: \"(\\<forall>n' < n. \\<not> P n') \\<Longrightarrow> P (n::nat)\"\n  shows \"\\<exists>n' \\<le> n. P n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'\\<le>n. P n'", "proof (rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>n'\\<le>n. P n') \\<Longrightarrow>\n    \\<exists>n'\\<le>n. P n'", "assume contra: \"\\<not> (\\<exists>n'\\<le>n. P n')\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>n'\\<le>n. P n')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>n'\\<le>n. P n') \\<Longrightarrow>\n    \\<exists>n'\\<le>n. P n'", "hence \"\\<forall>n' < n. \\<not> P n'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>n'\\<le>n. P n')\n\ngoal (1 subgoal):\n 1. \\<forall>n'<n. \\<not> P n'", "by auto"], ["proof (state)\nthis:\n  \\<forall>n'<n. \\<not> P n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>n'\\<le>n. P n') \\<Longrightarrow>\n    \\<exists>n'\\<le>n. P n'", "hence \"P n\""], ["proof (prove)\nusing this:\n  \\<forall>n'<n. \\<not> P n'\n\ngoal (1 subgoal):\n 1. P n", "by (rule hyp)"], ["proof (state)\nthis:\n  P n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>n'\\<le>n. P n') \\<Longrightarrow>\n    \\<exists>n'\\<le>n. P n'", "thus \"\\<exists>n'\\<le>n. P n'\""], ["proof (prove)\nusing this:\n  P n\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<le>n. P n'", "by auto"], ["proof (state)\nthis:\n  \\<exists>n'\\<le>n. P n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Induction on nat\\<close>"], ["", "lemma nat_compl_induct[case_names 0 Suc]: \"\\<lbrakk>P 0; \\<And>n . \\<forall>nn. nn \\<le> n \\<longrightarrow> P nn \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0;\n     \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P n", "apply(induct_tac n rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m; n = 0\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n nat.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_compl_induct'[case_names 0 Suc]: \"\\<lbrakk>P 0; !! n . \\<lbrakk>!! nn . nn \\<le> n \\<Longrightarrow> P nn\\<rbrakk> \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0;\n     \\<And>n.\n        (\\<And>nn. nn \\<le> n \\<Longrightarrow> P nn) \\<Longrightarrow>\n        P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P n", "apply(induct_tac n rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n.\n           (\\<And>nn. nn \\<le> n \\<Longrightarrow> P nn) \\<Longrightarrow>\n           P (Suc n);\n        \\<forall>m<n. P m\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n.\n           (\\<And>nn. nn \\<le> n \\<Longrightarrow> P nn) \\<Longrightarrow>\n           P (Suc n);\n        \\<forall>m<n. P m; n = 0\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n nat.\n       \\<lbrakk>P 0;\n        \\<And>n.\n           (\\<And>nn. nn \\<le> n \\<Longrightarrow> P nn) \\<Longrightarrow>\n           P (Suc n);\n        \\<forall>m<n. P m; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nz_le_conv_less: \"0<k \\<Longrightarrow> k \\<le> m \\<Longrightarrow> k - Suc 0 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk> \\<Longrightarrow> k - Suc 0 < m", "by auto"], ["", "lemma min_Suc_gt[simp]: \n    \"a<b \\<Longrightarrow> min (Suc a) b = Suc a\"  \n    \"a<b \\<Longrightarrow> min b (Suc a) = Suc a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b \\<Longrightarrow> min (Suc a) b = Suc a) &&&\n    (a < b \\<Longrightarrow> min b (Suc a) = Suc a)", "by auto"], ["", "subsection \\<open>Integer\\<close>"], ["", "text \\<open>Some setup from \\<open>int\\<close> transferred to \\<open>integer\\<close>\\<close>"], ["", "lemma atLeastLessThanPlusOne_atLeastAtMost_integer: \"{l..<u+1} = {l..(u::integer)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..<u + 1} = {l..u}", "apply (auto simp add: atLeastAtMost_def atLeastLessThan_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>l \\<le> x; x < u + 1\\<rbrakk> \\<Longrightarrow> x \\<le> u", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>l \\<le> x; x < u + 1\\<rbrakk> \\<Longrightarrow> x \\<le> u", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l u.\n       \\<lbrakk>l \\<le> x; x < u + 1\\<rbrakk> \\<Longrightarrow> x \\<le> u", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atLeastPlusOneAtMost_greaterThanAtMost_integer: \"{l+1..u} = {l<..(u::integer)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l + 1..u} = {l<..u}", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l + 1..u} = {l<..u}", "by (auto simp add: atLeastAtMost_def greaterThanAtMost_def, transfer, simp)"], ["", "lemma atLeastPlusOneLessThan_greaterThanLessThan_integer:\n    \"{l+1..<u} = {l<..<u::integer}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l + 1..<u} = {l<..<u}", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l + 1..<u} = {l<..<u}", "by (auto simp add: atLeastLessThan_def greaterThanLessThan_def, transfer, simp)"], ["", "lemma image_atLeastZeroLessThan_integer: \"0 \\<le> u \\<Longrightarrow>\n    {(0::integer)..<u} = of_nat ` {..<nat_of_integer u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u \\<Longrightarrow> {0..<u} = of_nat ` {..<nat_of_integer u}", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u \\<Longrightarrow> {0..<u} = of_nat ` {..<nat_of_integer u}", "apply (unfold image_def lessThan_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u \\<Longrightarrow>\n    {0..<u} = {y. \\<exists>x\\<in>{x. x < nat_of_integer u}. y = of_nat x}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<nat_of_integer u. x = of_nat xa\n 2. \\<And>xa.\n       \\<lbrakk>0 \\<le> u; xa < nat_of_integer u\\<rbrakk>\n       \\<Longrightarrow> of_nat xa < u", "apply (rule_tac x = \"nat_of_integer x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < u\\<rbrakk>\n       \\<Longrightarrow> nat_of_integer x < nat_of_integer u \\<and>\n                         x = of_nat (nat_of_integer x)\n 2. \\<And>xa.\n       \\<lbrakk>0 \\<le> u; xa < nat_of_integer u\\<rbrakk>\n       \\<Longrightarrow> of_nat xa < u", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x u.\n       \\<lbrakk>0 \\<le> x; x < u\\<rbrakk>\n       \\<Longrightarrow> nat x < nat u \\<and> x = int (nat x)\n 2. \\<And>xa.\n       \\<lbrakk>0 \\<le> u; xa < nat_of_integer u\\<rbrakk>\n       \\<Longrightarrow> of_nat xa < u", "apply (auto simp add: zless_nat_eq_int_zless [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<le> u; xa < nat_of_integer u\\<rbrakk>\n       \\<Longrightarrow> of_nat xa < u", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa u.\n       \\<lbrakk>0 \\<le> u; xa < nat u\\<rbrakk> \\<Longrightarrow> int xa < u", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma image_add_integer_atLeastLessThan:\n    \"(%x. x + (l::integer)) ` {0..<u-l} = {l..<u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u}", "apply (auto simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>l \\<le> x; x < u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>{0..<u - l}. x = xa + l", "apply (rule_tac x = \"x - l\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>l \\<le> x; x < u\\<rbrakk> \\<Longrightarrow> x = x - l + l\n 2. \\<And>x.\n       \\<lbrakk>l \\<le> x; x < u\\<rbrakk>\n       \\<Longrightarrow> x - l \\<in> {0..<u - l}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_atLeastZeroLessThan_integer: \"finite {(0::integer)..<u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<u}", "apply (cases \"0 \\<le> u\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> u \\<Longrightarrow> finite {0..<u}\n 2. \\<not> 0 \\<le> u \\<Longrightarrow> finite {0..<u}", "apply (subst image_atLeastZeroLessThan_integer, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> u \\<Longrightarrow> finite (of_nat ` {..<nat_of_integer u})\n 2. \\<not> 0 \\<le> u \\<Longrightarrow> finite {0..<u}", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> u \\<Longrightarrow> finite {..<nat_of_integer u}\n 2. \\<not> 0 \\<le> u \\<Longrightarrow> finite {0..<u}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_atLeastLessThan_integer [iff]: \"finite {l..<u::integer}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l..<u}", "apply (subgoal_tac \"(%x. x + l) ` {0..<u-l} = {l..<u}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u} \\<Longrightarrow>\n    finite {l..<u}\n 2. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u}", "apply (erule subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>x. x + l) ` {0..<u - l})\n 2. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u}", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {0..<u - l}\n 2. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u}", "apply (rule finite_atLeastZeroLessThan_integer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + l) ` {0..<u - l} = {l..<u}", "apply (rule image_add_integer_atLeastLessThan)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_atLeastAtMost_integer [iff]: \"finite {l..(u::integer)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l..u}", "by (subst atLeastLessThanPlusOne_atLeastAtMost_integer [THEN sym], simp)"], ["", "lemma finite_greaterThanAtMost_integer [iff]: \"finite {l<..(u::integer)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l<..u}", "by (subst atLeastPlusOneAtMost_greaterThanAtMost_integer [THEN sym], simp)"], ["", "lemma finite_greaterThanLessThan_integer [iff]: \"finite {l<..<u::integer}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l<..<u}", "by (subst atLeastPlusOneLessThan_greaterThanLessThan_integer [THEN sym], simp)"], ["", "subsection \\<open>Functions of type @{typ \"bool\\<Rightarrow>bool\"}\\<close>"], ["", "lemma boolfun_cases_helper: \"g=(\\<lambda>x. False) | g=(\\<lambda>x. x) | g=(\\<lambda>x. True) | g= (\\<lambda>x. \\<not>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"g False\" \"g True\""], ["proof (state)\nthis:\n  g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. True)\""], ["proof (prove)\nusing this:\n  g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. True)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"g False\" \"\\<not>g True\""], ["proof (state)\nthis:\n  g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. \\<not>x)\""], ["proof (prove)\nusing this:\n  g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = Not", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"\\<not>g False\" \"g True\""], ["proof (state)\nthis:\n  \\<not> g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. x)\""], ["proof (prove)\nusing this:\n  \\<not> g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. x)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"\\<not>g False\" \"\\<not>g True\""], ["proof (state)\nthis:\n  \\<not> g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. False)\""], ["proof (prove)\nusing this:\n  \\<not> g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "by fast"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma boolfun_cases[case_names False Id True Neg]: \"\\<lbrakk>g=(\\<lambda>x. False) \\<Longrightarrow> P; g=(\\<lambda>x. x) \\<Longrightarrow> P; g=(\\<lambda>x. True) \\<Longrightarrow> P; g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P;\n     g = Not \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P;\n     g = Not \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "note boolfun_cases_helper[of g]"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P;\n     g = Not \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P;\n     g = Not \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "assume \"g=(\\<lambda>x. False) \\<Longrightarrow> P\" \"g=(\\<lambda>x. x) \\<Longrightarrow> P\" \"g=(\\<lambda>x. True) \\<Longrightarrow> P\" \"g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<Longrightarrow> P\n  g = (\\<lambda>x. x) \\<Longrightarrow> P\n  g = (\\<lambda>x. True) \\<Longrightarrow> P\n  g = Not \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P;\n     g = Not \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n  g = (\\<lambda>x. False) \\<Longrightarrow> P\n  g = (\\<lambda>x. x) \\<Longrightarrow> P\n  g = (\\<lambda>x. True) \\<Longrightarrow> P\n  g = Not \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n  g = (\\<lambda>x. False) \\<Longrightarrow> P\n  g = (\\<lambda>x. x) \\<Longrightarrow> P\n  g = (\\<lambda>x. True) \\<Longrightarrow> P\n  g = Not \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by fast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definite and indefinite description\\<close>"], ["", "text \"Combined definite and indefinite description for binary predicate\""], ["", "lemma some_theI: assumes EX: \"\\<exists>a b . P a b\" and BUN: \"!! b1 b2 . \\<lbrakk>\\<exists>a . P a b1; \\<exists>a . P a b2\\<rbrakk> \\<Longrightarrow> b1=b2\"\n    shows \"P (SOME a . \\<exists>b . P a b) (THE b . \\<exists>a . P a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "from EX"], ["proof (chain)\npicking this:\n  \\<exists>a b. P a b", "have \"\\<exists>b. P (SOME a. \\<exists>b. P a b) b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>b. P (SOME a. \\<exists>b. P a b) b", "by (rule someI_ex)"], ["proof (state)\nthis:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "moreover"], ["proof (state)\nthis:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "from EX"], ["proof (chain)\npicking this:\n  \\<exists>a b. P a b", "have \"\\<exists>b. \\<exists>a. P a b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>b a. P a b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b a. P a b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "with BUN theI'[of \"\\<lambda>b. \\<exists>a. P a b\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n  \\<exists>!x. \\<exists>a. P a x \\<Longrightarrow>\n  \\<exists>a. P a (THE x. \\<exists>a. P a x)\n  \\<exists>b a. P a b", "have \"\\<exists>a. P a (THE b. \\<exists>a. P a b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n  \\<exists>!x. \\<exists>a. P a x \\<Longrightarrow>\n  \\<exists>a. P a (THE x. \\<exists>a. P a x)\n  \\<exists>b a. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>a. P a (THE b. \\<exists>a. P a b)", "by (unfold Ex1_def, blast)"], ["proof (state)\nthis:\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "moreover"], ["proof (state)\nthis:\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "note BUN"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "by (fast)"], ["proof (state)\nthis:\n  P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma some_insert_self[simp]: \"S\\<noteq>{} \\<Longrightarrow> insert (SOME x. x\\<in>S) S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> insert (SOME x. x \\<in> S) S = S", "by (auto intro: someI)"], ["", "lemma some_elem[simp]: \"S\\<noteq>{} \\<Longrightarrow> (SOME x. x\\<in>S) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> (SOME x. x \\<in> S) \\<in> S", "by (auto intro: someI)"], ["", "subsubsection\\<open>Hilbert Choice with option\\<close>"], ["", "definition Eps_Opt where\n  \"Eps_Opt P = (if (\\<exists>x. P x) then Some (SOME x. P x) else None)\""], ["", "lemma some_opt_eq_trivial[simp] :\n  \"Eps_Opt (\\<lambda>y. y = x) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eps_Opt (\\<lambda>y. y = x) = Some x", "unfolding Eps_Opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>y. y = x then Some (SOME y. y = x) else None) = Some x", "by simp"], ["", "lemma some_opt_sym_eq_trivial[simp] :\n  \"Eps_Opt ((=) x) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eps_Opt ((=) x) = Some x", "unfolding Eps_Opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Ex ((=) x) then Some (Eps ((=) x)) else None) = Some x", "by simp"], ["", "lemma some_opt_false_trivial[simp] :\n  \"Eps_Opt (\\<lambda>_. False) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eps_Opt (\\<lambda>_. False) = None", "unfolding Eps_Opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>_. False then Some (SOME uu_. False) else None) = None", "by simp"], ["", "lemma Eps_Opt_eq_None[simp] :\n  \"Eps_Opt P = None \\<longleftrightarrow> \\<not>(Ex P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Eps_Opt P = None) = (\\<not> Ex P)", "unfolding Eps_Opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if Ex P then Some (Eps P) else None) = None) = (\\<not> Ex P)", "by simp"], ["", "lemma Eps_Opt_eq_Some_implies :\n  \"Eps_Opt P = Some x \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eps_Opt P = Some x \\<Longrightarrow> P x", "unfolding Eps_Opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Ex P then Some (Eps P) else None) = Some x \\<Longrightarrow> P x", "by (metis option.inject option.simps(2) someI_ex)"], ["", "lemma Eps_Opt_eq_Some :\nassumes P_prop: \"\\<And>x'. P x \\<Longrightarrow> P x' \\<Longrightarrow> x' = x\"\nshows \"Eps_Opt P = Some x \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Eps_Opt P = Some x) = P x", "using P_prop"], ["proof (prove)\nusing this:\n  \\<lbrakk>P x; P ?x'\\<rbrakk> \\<Longrightarrow> ?x' = x\n\ngoal (1 subgoal):\n 1. (Eps_Opt P = Some x) = P x", "unfolding Eps_Opt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>P x; P ?x'\\<rbrakk> \\<Longrightarrow> ?x' = x\n\ngoal (1 subgoal):\n 1. ((if Ex P then Some (Eps P) else None) = Some x) = P x", "by (metis option.inject option.simps(2) someI_ex)"], ["", "subsection \\<open>Product Type\\<close>"], ["", "lemma nested_case_prod_simp: \"(\\<lambda>(a,b) c. f a b c) x y =\n  (case_prod (\\<lambda>a b. f a b y) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of (a, b) \\<Rightarrow> f a b) y =\n    (case x of (a, b) \\<Rightarrow> f a b y)", "by (auto split: prod.split)"], ["", "lemma fn_fst_conv: \"(\\<lambda>x. (f (fst x))) = (\\<lambda>(a,_). f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (fst x)) = (\\<lambda>(a, uu_). f a)", "by auto"], ["", "lemma fn_snd_conv: \"(\\<lambda>x. (f (snd x))) = (\\<lambda>(_,b). f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (snd x)) = (\\<lambda>(uu_, b). f b)", "by auto"], ["", "fun pairself where\n  \"pairself f (a,b) = (f a, f b)\""], ["", "lemma pairself_image_eq[simp]:\n  \"pairself f ` {(a,b). P a b} = {(f a, f b)| a b. P a b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairself f ` {(a, b). P a b} = {(f a, f b) |a b. P a b}", "by force"], ["", "lemma pairself_image_cart[simp]: \"pairself f ` (A\\<times>B) = f`A \\<times> f`B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairself f ` (A \\<times> B) = f ` A \\<times> f ` B", "by (auto simp: image_def)"], ["", "lemma in_prod_fst_sndI: \"fst x \\<in> A \\<Longrightarrow> snd x \\<in> B \\<Longrightarrow> x\\<in>A\\<times>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<in> A; snd x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A \\<times> B", "by (cases x) auto"], ["", "lemma inj_Pair[simp]:\n  \"inj_on (\\<lambda>x. (x,c x)) S\"\n  \"inj_on (\\<lambda>x. (c x,x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x, c x)) S &&& inj_on (\\<lambda>x. (c x, x)) S", "by (auto intro!: inj_onI)"], ["", "declare Product_Type.swap_inj_on[simp]"], ["", "lemma img_fst [intro]:\n  assumes \"(a,b) \\<in> S\"\n  shows \"a \\<in> fst ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> fst ` S", "by (rule image_eqI[OF _ assms]) simp"], ["", "lemma img_snd [intro]:\n  assumes \"(a,b) \\<in> S\"\n  shows \"b \\<in> snd ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> snd ` S", "by (rule image_eqI[OF _ assms]) simp"], ["", "lemma range_prod:\n  \"range f \\<subseteq> (range (fst \\<circ> f)) \\<times> (range (snd \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       x \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       x \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "assume \"y \\<in> range f\""], ["proof (state)\nthis:\n  y \\<in> range f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       x \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "then"], ["proof (chain)\npicking this:\n  y \\<in> range f", "obtain x where y: \"y = f x\""], ["proof (prove)\nusing this:\n  y \\<in> range f\n\ngoal (1 subgoal):\n 1. (\\<And>x. y = f x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y = f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       x \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "hence \"y = (fst(f x), snd(f x))\""], ["proof (prove)\nusing this:\n  y = f x\n\ngoal (1 subgoal):\n 1. y = (fst (f x), snd (f x))", "by simp"], ["proof (state)\nthis:\n  y = (fst (f x), snd (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       x \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "thus \"y \\<in> (range (fst \\<circ> f)) \\<times> (range (snd \\<circ> f))\""], ["proof (prove)\nusing this:\n  y = (fst (f x), snd (f x))\n\ngoal (1 subgoal):\n 1. y \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)", "by (fastforce simp add: image_def)"], ["proof (state)\nthis:\n  y \\<in> range (fst \\<circ> f) \\<times> range (snd \\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_range_prod:\n  assumes fst: \"finite (range (fst \\<circ> f))\"\n  and     snd: \"finite (range (snd \\<circ> f))\"\n  shows \"finite (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (range f)", "from fst snd"], ["proof (chain)\npicking this:\n  finite (range (fst \\<circ> f))\n  finite (range (snd \\<circ> f))", "have \"finite (range (fst \\<circ> f) \\<times> range (snd \\<circ> f))\""], ["proof (prove)\nusing this:\n  finite (range (fst \\<circ> f))\n  finite (range (snd \\<circ> f))\n\ngoal (1 subgoal):\n 1. finite (range (fst \\<circ> f) \\<times> range (snd \\<circ> f))", "by (rule finite_SigmaI)"], ["proof (state)\nthis:\n  finite (range (fst \\<circ> f) \\<times> range (snd \\<circ> f))\n\ngoal (1 subgoal):\n 1. finite (range f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (range (fst \\<circ> f) \\<times> range (snd \\<circ> f))\n\ngoal (1 subgoal):\n 1. finite (range f)", "by (rule finite_subset[OF range_prod])"], ["proof (state)\nthis:\n  finite (range f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fstE:\n  \"x = (a,b) \\<Longrightarrow> P (fst x) \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a, b); P (fst x)\\<rbrakk> \\<Longrightarrow> P a", "by (metis fst_conv)"], ["", "lemma sndE:\n  \"x = (a,b) \\<Longrightarrow> P (snd x) \\<Longrightarrow> P b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a, b); P (snd x)\\<rbrakk> \\<Longrightarrow> P b", "by (metis snd_conv)"], ["", "subsubsection \\<open>Uncurrying\\<close>"], ["", "(* TODO: Move to HOL/Product_Type? Lars H: \"It's equal to case_prod, should use an abbreviation\"*)"], ["", "definition uncurry :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> 'c\" where\n  \"uncurry f \\<equiv> \\<lambda>(a,b). f a b\""], ["", "lemma uncurry_apply[simp]: \"uncurry f (a,b) = f a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry f (a, b) = f a b", "unfolding uncurry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (a, b) of (a, b) \\<Rightarrow> f a b) = f a b", "by simp"], ["", "lemma curry_uncurry_id[simp]: \"curry (uncurry f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curry (uncurry f) = f", "unfolding uncurry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. curry (\\<lambda>(a, b). f a b) = f", "by simp"], ["", "lemma uncurry_curry_id[simp]: \"uncurry (curry f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry (curry f) = f", "unfolding uncurry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). curry f a b) = f", "by simp"], ["", "lemma do_curry: \"f (a,b) = curry f a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a, b) = curry f a b", "by simp"], ["", "lemma do_uncurry: \"f a b = uncurry f (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a b = uncurry f (a, b)", "by simp"], ["", "subsection \\<open>Sum Type\\<close>"], ["", "lemma map_sum_Inr_conv: \"map_sum fl fr s = Inr y \\<longleftrightarrow> (\\<exists>x. s=Inr x \\<and> y = fr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_sum fl fr s = Inr y) = (\\<exists>x. s = Inr x \\<and> y = fr x)", "by (cases s) auto"], ["", "lemma map_sum_Inl_conv: \"map_sum fl fr s = Inl y \\<longleftrightarrow> (\\<exists>x. s=Inl x \\<and> y = fl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_sum fl fr s = Inl y) = (\\<exists>x. s = Inl x \\<and> y = fl x)", "by (cases s) auto"], ["", "subsection \\<open>Directed Graphs and Relations\\<close>"], ["", "subsubsection \"Reflexive-Transitive Closure\""], ["", "lemma r_le_rtrancl[simp]: \"S\\<subseteq>S\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S\\<^sup>*", "by auto"], ["", "lemma rtrancl_mono_rightI: \"S\\<subseteq>S' \\<Longrightarrow> S\\<subseteq>S'\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S' \\<Longrightarrow> S \\<subseteq> S'\\<^sup>*", "by auto"], ["", "lemma trancl_sub:\n    \"R \\<subseteq> R\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> R\\<^sup>+", "by auto"], ["", "lemma trancl_single[simp]:\n    \"{(a,b)}\\<^sup>+ = {(a,b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b)}\\<^sup>+ = {(a, b)}", "by (auto simp: trancl_insert)"], ["", "text \\<open>Pick first non-reflexive step\\<close>"], ["", "lemma converse_rtranclE'[consumes 1, case_names base step]:\n    assumes \"(u,v)\\<in>R\\<^sup>*\"\n    obtains \"u=v\"\n    | vh where \"u\\<noteq>vh\" and \"(u,vh)\\<in>R\" and \"(vh,v)\\<in>R\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u = v \\<Longrightarrow> thesis;\n     \\<And>vh.\n        \\<lbrakk>u \\<noteq> vh; (u, vh) \\<in> R;\n         (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u = v \\<Longrightarrow> thesis;\n     \\<And>vh.\n        \\<lbrakk>u \\<noteq> vh; (u, vh) \\<in> R;\n         (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (induct rule: converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = v \\<Longrightarrow> thesis;\n     \\<And>vh.\n        \\<lbrakk>v \\<noteq> vh; (v, vh) \\<in> R;\n         (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, v) \\<in> R\\<^sup>*;\n        \\<lbrakk>z = v \\<Longrightarrow> thesis;\n         \\<And>vh.\n            \\<lbrakk>z \\<noteq> vh; (z, vh) \\<in> R;\n             (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        y = v \\<Longrightarrow> thesis;\n        \\<And>vh.\n           \\<lbrakk>y \\<noteq> vh; (y, vh) \\<in> R;\n            (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, v) \\<in> R\\<^sup>*;\n        \\<lbrakk>z = v \\<Longrightarrow> thesis;\n         \\<And>vh.\n            \\<lbrakk>z \\<noteq> vh; (z, vh) \\<in> R;\n             (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        y = v \\<Longrightarrow> thesis;\n        \\<And>vh.\n           \\<lbrakk>y \\<noteq> vh; (y, vh) \\<in> R;\n            (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac \"y=z\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, v) \\<in> R\\<^sup>*;\n        \\<lbrakk>z = v \\<Longrightarrow> thesis;\n         \\<And>vh.\n            \\<lbrakk>z \\<noteq> vh; (z, vh) \\<in> R;\n             (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        y = v \\<Longrightarrow> thesis;\n        \\<And>vh.\n           \\<lbrakk>y \\<noteq> vh; (y, vh) \\<in> R;\n            (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        y = z\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, v) \\<in> R\\<^sup>*;\n        \\<lbrakk>z = v \\<Longrightarrow> thesis;\n         \\<And>vh.\n            \\<lbrakk>z \\<noteq> vh; (z, vh) \\<in> R;\n             (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        y = v \\<Longrightarrow> thesis;\n        \\<And>vh.\n           \\<lbrakk>y \\<noteq> vh; (y, vh) \\<in> R;\n            (vh, v) \\<in> R\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        y \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_rtrancl_insert: \"x\\<in>R\\<^sup>* \\<Longrightarrow> x\\<in>(insert r R)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> R\\<^sup>* \\<Longrightarrow> x \\<in> (insert r R)\\<^sup>*", "by (metis in_mono rtrancl_mono subset_insertI)"], ["", "lemma rtrancl_apply_insert: \"R\\<^sup>*``(insert x S) = insert x (R\\<^sup>*``(S\\<union>R``{x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>* `` insert x S = insert x (R\\<^sup>* `` (S \\<union> R `` {x}))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>(x, xa) \\<in> R\\<^sup>*;\n        xa \\<notin> R\\<^sup>* `` (S \\<union> R `` {x})\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 2. \\<And>xa xaa.\n       \\<lbrakk>(xaa, xa) \\<in> R\\<^sup>*; (x, xaa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> R\\<^sup>* `` insert x S", "apply (erule converse_rtranclE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<notin> R\\<^sup>* `` (S \\<union> R `` {x});\n        x = xa\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> R\\<^sup>* `` (S \\<union> R `` {x});\n        (x, y) \\<in> R; (y, xa) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 3. \\<And>xa xaa.\n       \\<lbrakk>(xaa, xa) \\<in> R\\<^sup>*; (x, xaa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> R\\<^sup>* `` insert x S", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>(xaa, xa) \\<in> R\\<^sup>*; (x, xaa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> R\\<^sup>* `` insert x S", "apply (erule converse_rtranclE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>(x, xaa) \\<in> R; xaa = xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> R\\<^sup>* `` insert x S\n 2. \\<And>xa xaa y.\n       \\<lbrakk>(x, xaa) \\<in> R; (xaa, y) \\<in> R;\n        (y, xa) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> R\\<^sup>* `` insert x S", "apply (auto intro: converse_rtrancl_into_rtrancl) [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>A path in a graph either does not use nodes from S at all, or it has a prefix leading to a node in S and a suffix that does not use nodes in S\\<close>"], ["", "lemma rtrancl_last_visit[cases set, case_names no_visit last_visit_point]:\n    shows\n    \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*;\n       (q,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<Longrightarrow> P;\n       !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>+; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P\n     \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(q, q') \\<in> R\\<^sup>*;\n     (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n     \\<And>qt.\n        \\<lbrakk>qt \\<in> S; (q, qt) \\<in> R\\<^sup>+;\n         (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof (induct rule: converse_rtrancl_induct[case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(q', q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n             P;\n     \\<And>qt.\n        \\<lbrakk>qt \\<in> S; (q', qt) \\<in> R\\<^sup>+;\n         (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, q') \\<in> R\\<^sup>*;\n        \\<lbrakk>(z, q')\n                 \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n                 P;\n         \\<And>qt.\n            \\<lbrakk>qt \\<in> S; (z, qt) \\<in> R\\<^sup>+;\n             (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        (y, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n        \\<And>qt.\n           \\<lbrakk>qt \\<in> S; (y, qt) \\<in> R\\<^sup>+;\n            (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case refl"], ["proof (state)\nthis:\n  (q', q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n  \\<lbrakk>?qt \\<in> S; (q', ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(q', q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n             P;\n     \\<And>qt.\n        \\<lbrakk>qt \\<in> S; (q', qt) \\<in> R\\<^sup>+;\n         (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, q') \\<in> R\\<^sup>*;\n        \\<lbrakk>(z, q')\n                 \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n                 P;\n         \\<And>qt.\n            \\<lbrakk>qt \\<in> S; (z, qt) \\<in> R\\<^sup>+;\n             (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        (y, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n        \\<And>qt.\n           \\<lbrakk>qt \\<in> S; (y, qt) \\<in> R\\<^sup>+;\n            (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  (q', q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n  \\<lbrakk>?qt \\<in> S; (q', ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, q') \\<in> R\\<^sup>*;\n        \\<lbrakk>(z, q')\n                 \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n                 P;\n         \\<And>qt.\n            \\<lbrakk>qt \\<in> S; (z, qt) \\<in> R\\<^sup>+;\n             (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        (y, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n        \\<And>qt.\n           \\<lbrakk>qt \\<in> S; (y, qt) \\<in> R\\<^sup>+;\n            (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, q') \\<in> R\\<^sup>*;\n        \\<lbrakk>(z, q')\n                 \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n                 P;\n         \\<And>qt.\n            \\<lbrakk>qt \\<in> S; (z, qt) \\<in> R\\<^sup>+;\n             (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        (y, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n        \\<And>qt.\n           \\<lbrakk>qt \\<in> S; (y, qt) \\<in> R\\<^sup>+;\n            (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (step q qh)"], ["proof (state)\nthis:\n  (q, qh) \\<in> R\n  (qh, q') \\<in> R\\<^sup>*\n  \\<lbrakk>(qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n   \\<And>qt.\n      \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n       (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n  \\<lbrakk>?qt \\<in> S; (q, ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, q') \\<in> R\\<^sup>*;\n        \\<lbrakk>(z, q')\n                 \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow>\n                 P;\n         \\<And>qt.\n            \\<lbrakk>qt \\<in> S; (z, qt) \\<in> R\\<^sup>+;\n             (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        (y, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n        \\<And>qt.\n           \\<lbrakk>qt \\<in> S; (y, qt) \\<in> R\\<^sup>+;\n            (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "show P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (rule step.hyps(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume A: \"(qh,q')\\<in>(R-UNIV\\<times>S)\\<^sup>*\""], ["proof (state)\nthis:\n  (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "show P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases \"qh\\<in>S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qh \\<in> S \\<Longrightarrow> P\n 2. qh \\<notin> S \\<Longrightarrow> P", "case False"], ["proof (state)\nthis:\n  qh \\<notin> S\n\ngoal (2 subgoals):\n 1. qh \\<in> S \\<Longrightarrow> P\n 2. qh \\<notin> S \\<Longrightarrow> P", "with step.hyps(1) A"], ["proof (chain)\npicking this:\n  (q, qh) \\<in> R\n  (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  qh \\<notin> S", "have \"(q,q')\\<in>(R-UNIV\\<times>S)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (q, qh) \\<in> R\n  (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  qh \\<notin> S\n\ngoal (1 subgoal):\n 1. (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*", "by (auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n\ngoal (2 subgoals):\n 1. qh \\<in> S \\<Longrightarrow> P\n 2. qh \\<notin> S \\<Longrightarrow> P", "with step.prems(1)"], ["proof (chain)\npicking this:\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*", "show P"], ["proof (prove)\nusing this:\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P\n  (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. qh \\<in> S \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qh \\<in> S \\<Longrightarrow> P", "case True"], ["proof (state)\nthis:\n  qh \\<in> S\n\ngoal (1 subgoal):\n 1. qh \\<in> S \\<Longrightarrow> P", "from step.hyps(1)"], ["proof (chain)\npicking this:\n  (q, qh) \\<in> R", "have \"(q,qh)\\<in>R\\<^sup>+\""], ["proof (prove)\nusing this:\n  (q, qh) \\<in> R\n\ngoal (1 subgoal):\n 1. (q, qh) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (q, qh) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. qh \\<in> S \\<Longrightarrow> P", "with step.prems(2) True A"], ["proof (chain)\npicking this:\n  \\<lbrakk>?qt \\<in> S; (q, ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  qh \\<in> S\n  (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  (q, qh) \\<in> R\\<^sup>+", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>?qt \\<in> S; (q, ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  qh \\<in> S\n  (qh, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  (q, qh) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "fix qt"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume A: \"qt\\<in>S\" \"(qh,qt)\\<in>R\\<^sup>+\" \"(qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>*\""], ["proof (state)\nthis:\n  qt \\<in> S\n  (qh, qt) \\<in> R\\<^sup>+\n  (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with step.hyps(1)"], ["proof (chain)\npicking this:\n  (q, qh) \\<in> R\n  qt \\<in> S\n  (qh, qt) \\<in> R\\<^sup>+\n  (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*", "have \"(q,qt)\\<in>R\\<^sup>+\""], ["proof (prove)\nusing this:\n  (q, qh) \\<in> R\n  qt \\<in> S\n  (qh, qt) \\<in> R\\<^sup>+\n  (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (q, qt) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (q, qt) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> S; (qh, qt) \\<in> R\\<^sup>+;\n        (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with step.prems(2) A(1,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?qt \\<in> S; (q, ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  qt \\<in> S\n  (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  (q, qt) \\<in> R\\<^sup>+", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>?qt \\<in> S; (q, ?qt) \\<in> R\\<^sup>+;\n   (?qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  qt \\<in> S\n  (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\n  (q, qt) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Less general version of \\<open>rtrancl_last_visit\\<close>, but there's a short automatic proof\\<close>"], ["", "lemma rtrancl_last_visit': \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*; (q,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<Longrightarrow> P; !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>*; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(q, q') \\<in> R\\<^sup>*;\n     (q, q') \\<in> (R - UNIV \\<times> S)\\<^sup>* \\<Longrightarrow> P;\n     \\<And>qt.\n        \\<lbrakk>qt \\<in> S; (q, qt) \\<in> R\\<^sup>*;\n         (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_rtrancl_induct) (auto intro: converse_rtrancl_into_rtrancl)"], ["", "lemma rtrancl_last_visit_node:\n    assumes \"(s,s')\\<in>R\\<^sup>*\"\n    shows \"s\\<noteq>sh \\<and> (s,s')\\<in>(R \\<inter> (UNIV \\<times> (-{sh})))\\<^sup>* \\<or>\n            (s,sh)\\<in>R\\<^sup>* \\<and> (sh,s')\\<in>(R \\<inter> (UNIV \\<times> (-{sh})))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "proof (induct rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. s' \\<noteq> sh \\<and>\n    (s', s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s', sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. s' \\<noteq> sh \\<and>\n    (s', s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s', sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<noteq> sh \\<and>\n    (s', s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s', sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  s' \\<noteq> sh \\<and>\n  (s', s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s', sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "case (step s st)"], ["proof (state)\nthis:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "{"], ["proof (state)\nthis:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "assume P: \"(st,s')\\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\""], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "{"], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "assume \"st=sh\""], ["proof (state)\nthis:\n  st = sh\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "with step"], ["proof (chain)\npicking this:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  st = sh", "have ?case"], ["proof (prove)\nusing this:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  st = sh\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "}"], ["proof (state)\nthis:\n  st = sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  st = sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "{"], ["proof (state)\nthis:\n  st = sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "assume \"st\\<noteq>sh\""], ["proof (state)\nthis:\n  st \\<noteq> sh\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "with \\<open>(s,st)\\<in>R\\<close>"], ["proof (chain)\npicking this:\n  (s, st) \\<in> R\n  st \\<noteq> sh", "have \"(s,st)\\<in>(R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\""], ["proof (prove)\nusing this:\n  (s, st) \\<in> R\n  st \\<noteq> sh\n\ngoal (1 subgoal):\n 1. (s, st) \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (s, st) \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "also"], ["proof (state)\nthis:\n  (s, st) \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "note P"], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "have ?case"], ["proof (prove)\nusing this:\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "}"], ["proof (state)\nthis:\n  st \\<noteq> sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  st = sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  st \\<noteq> sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "have ?case"], ["proof (prove)\nusing this:\n  st = sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  st \\<noteq> sh \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "}"], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "{"], ["proof (state)\nthis:\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "assume P: \"(st, sh) \\<in> R\\<^sup>* \\<and> (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\""], ["proof (state)\nthis:\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "with step(1)"], ["proof (chain)\npicking this:\n  (s, st) \\<in> R\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "have ?case"], ["proof (prove)\nusing this:\n  (s, st) \\<in> R\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by (auto dest: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "}"], ["proof (state)\nthis:\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R; (z, s') \\<in> R\\<^sup>*;\n        z \\<noteq> sh \\<and>\n        (z, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n        (z, sh) \\<in> R\\<^sup>* \\<and>\n        (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> sh \\<and>\n                         (y, s')\n                         \\<in> (R \\<inter>\n                                UNIV \\<times> - {sh})\\<^sup>* \\<or>\n                         (y, sh) \\<in> R\\<^sup>* \\<and>\n                         (sh, s')\n                         \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (s, st) \\<in> R\n  (st, s') \\<in> R\\<^sup>*\n  st \\<noteq> sh \\<and>\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  (st, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n  (st, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<Longrightarrow>\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal (1 subgoal):\n 1. s \\<noteq> sh \\<and>\n    (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n    (s, sh) \\<in> R\\<^sup>* \\<and>\n    (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  s \\<noteq> sh \\<and>\n  (s, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>* \\<or>\n  (s, sh) \\<in> R\\<^sup>* \\<and>\n  (sh, s') \\<in> (R \\<inter> UNIV \\<times> - {sh})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Find last point where a path touches a set\\<close>"], ["", "lemma rtrancl_last_touch: \"\\<lbrakk> (q,q')\\<in>R\\<^sup>*; q\\<in>S; !!qt. \\<lbrakk> qt\\<in>S; (q,qt)\\<in>R\\<^sup>*; (qt,q')\\<in>(R-UNIV\\<times>S)\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(q, q') \\<in> R\\<^sup>*; q \\<in> S;\n     \\<And>qt.\n        \\<lbrakk>qt \\<in> S; (q, qt) \\<in> R\\<^sup>*;\n         (qt, q') \\<in> (R - UNIV \\<times> S)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (erule rtrancl_last_visit') auto"], ["", "text \\<open>A path either goes over edge once, or not at all\\<close>"], ["", "lemma trancl_over_edgeE:\n    assumes \"(u,w)\\<in>(insert (v1,v2) E)\\<^sup>+\"\n    obtains \"(u,w)\\<in>E\\<^sup>+\"\n    | \"(u,v1)\\<in>E\\<^sup>*\" and \"(v2,w)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, w) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n     \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, w) \\<in> E\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, w) \\<in> (insert (v1, v2) E)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, w) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n     \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, w) \\<in> E\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(u, y) \\<in> insert (v1, v2) E;\n        (u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (insert (v1, v2) E)\\<^sup>+;\n        (y, z) \\<in> insert (v1, v2) E;\n        \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n         \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base z)"], ["proof (state)\nthis:\n  (u, z) \\<in> insert (v1, v2) E\n  (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis\n  \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(u, y) \\<in> insert (v1, v2) E;\n        (u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (insert (v1, v2) E)\\<^sup>+;\n        (y, z) \\<in> insert (v1, v2) E;\n        \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n         \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, z) \\<in> insert (v1, v2) E\n  (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis\n  \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis insertE prod.inject r_into_trancl' rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (insert (v1, v2) E)\\<^sup>+;\n        (y, z) \\<in> insert (v1, v2) E;\n        \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n         \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (insert (v1, v2) E)\\<^sup>+;\n        (y, z) \\<in> insert (v1, v2) E;\n        \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n         \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step y z)"], ["proof (state)\nthis:\n  (u, y) \\<in> (insert (v1, v2) E)\\<^sup>+\n  (y, z) \\<in> insert (v1, v2) E\n  \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n   \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n   \\<Longrightarrow> thesis\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis\n  \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (insert (v1, v2) E)\\<^sup>+;\n        (y, z) \\<in> insert (v1, v2) E;\n        \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n         \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n        \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, y) \\<in> (insert (v1, v2) E)\\<^sup>+\n  (y, z) \\<in> insert (v1, v2) E\n  \\<lbrakk>(u, y) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis;\n   \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, y) \\<in> E\\<^sup>*\\<rbrakk>\n   \\<Longrightarrow> thesis\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (u, z) \\<in> E\\<^sup>+ \\<Longrightarrow> thesis\n  \\<lbrakk>(u, v1) \\<in> E\\<^sup>*; (v2, z) \\<in> E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (hide_lams, no_types)\n        Pair_inject insertE rtrancl.simps trancl.simps trancl_into_rtrancl)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl_image_advance: \"\\<lbrakk>q\\<in>R\\<^sup>* `` Q0; (q,x)\\<in>R\\<rbrakk> \\<Longrightarrow> x\\<in>R\\<^sup>* `` Q0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> R\\<^sup>* `` Q0; (q, x) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> x \\<in> R\\<^sup>* `` Q0", "by (auto intro: rtrancl_into_rtrancl)"], ["", "lemma trancl_image_by_rtrancl: \"(E\\<^sup>+)``Vi \\<union> Vi = (E\\<^sup>*)``Vi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` Vi \\<union> Vi = E\\<^sup>* `` Vi", "by (metis Image_Id Un_Image rtrancl_trancl_reflcl)"], ["", "lemma reachable_mono: \"\\<lbrakk>R\\<subseteq>R'; X\\<subseteq>X'\\<rbrakk> \\<Longrightarrow> R\\<^sup>*``X \\<subseteq> R'\\<^sup>*``X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<subseteq> R'; X \\<subseteq> X'\\<rbrakk>\n    \\<Longrightarrow> R\\<^sup>* `` X \\<subseteq> R'\\<^sup>* `` X'", "by (metis Image_mono rtrancl_mono)"], ["", "lemma finite_reachable_advance:\n    \"\\<lbrakk> finite (E\\<^sup>*``{v0}); (v0,v)\\<in>E\\<^sup>* \\<rbrakk> \\<Longrightarrow> finite (E\\<^sup>*``{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (E\\<^sup>* `` {v0}); (v0, v) \\<in> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> finite (E\\<^sup>* `` {v})", "by (erule finite_subset[rotated]) auto"], ["", "lemma rtrancl_mono_mp: \"U\\<subseteq>V \\<Longrightarrow> x\\<in>U\\<^sup>* \\<Longrightarrow> x\\<in>V\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>U \\<subseteq> V; x \\<in> U\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> x \\<in> V\\<^sup>*", "by (metis in_mono rtrancl_mono)"], ["", "lemma trancl_mono_mp: \"U\\<subseteq>V \\<Longrightarrow> x\\<in>U\\<^sup>+ \\<Longrightarrow> x\\<in>V\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>U \\<subseteq> V; x \\<in> U\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> x \\<in> V\\<^sup>+", "by (metis trancl_mono)"], ["", "lemma rtrancl_mapI: \"(a,b)\\<in>E\\<^sup>* \\<Longrightarrow> (f a, f b)\\<in>(pairself f `E)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E\\<^sup>* \\<Longrightarrow>\n    (f a, f b) \\<in> (pairself f ` E)\\<^sup>*", "apply (induction rule: rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (f a, f a) \\<in> (pairself f ` E)\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> E\\<^sup>*; (y, z) \\<in> E;\n        (f a, f y) \\<in> (pairself f ` E)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (f a, f z) \\<in> (pairself f ` E)\\<^sup>*", "apply (force intro: rtrancl.intros)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rtrancl_image_advance_rtrancl:\n  assumes \"q \\<in> R\\<^sup>*``Q0\"\n  assumes \"(q,x) \\<in> R\\<^sup>*\"\n  shows \"x \\<in> R\\<^sup>*``Q0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> R\\<^sup>* `` Q0", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> R\\<^sup>* `` Q0\n  (q, x) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> R\\<^sup>* `` Q0", "by (metis rtrancl_idemp rtrancl_image_advance)"], ["", "lemma nth_step_trancl:\n  \"\\<And>n m. \\<lbrakk> \\<And> n. n < length xs - 1 \\<Longrightarrow> (xs ! Suc n, xs ! n) \\<in> R \\<rbrakk> \\<Longrightarrow> n < length xs \\<Longrightarrow> m < n \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length xs - 1 \\<Longrightarrow>\n                   (xs ! Suc n, xs ! n) \\<in> R;\n        n < length xs; m < n\\<rbrakk>\n       \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+\n 2. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>\\<And>n.\n                               n < length xs - 1 \\<Longrightarrow>\n                               (xs ! Suc n, xs ! n) \\<in> R;\n                    n < length xs; m < n\\<rbrakk>\n                   \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length (a # xs) - 1 \\<Longrightarrow>\n           ((a # xs) ! Suc n, (a # xs) ! n) \\<in> R;\n        n < length (a # xs); m < n\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) ! n, (a # xs) ! m) \\<in> R\\<^sup>+", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+\n 2. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>\\<And>n.\n                               n < length xs - 1 \\<Longrightarrow>\n                               (xs ! Suc n, xs ! n) \\<in> R;\n                    n < length xs; m < n\\<rbrakk>\n                   \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length (a # xs) - 1 \\<Longrightarrow>\n           ((a # xs) ! Suc n, (a # xs) ! n) \\<in> R;\n        n < length (a # xs); m < n\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) ! n, (a # xs) ! m) \\<in> R\\<^sup>+", "hence \"\\<And>n. n < length xs - 1 \\<Longrightarrow> (xs ! Suc n, xs ! n) \\<in> R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length xs - 1 \\<Longrightarrow> (xs ! Suc n, xs ! n) \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>na < length xs - Suc 0;\n        \\<And>n m.\n           \\<lbrakk>\\<And>n.\n                       n < length xs - Suc 0 \\<Longrightarrow>\n                       (xs ! Suc n, xs ! n) \\<in> R;\n            n < length xs; m < n\\<rbrakk>\n           \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length xs \\<Longrightarrow> (xs ! n, (x # xs) ! n) \\<in> R;\n        n < Suc (length xs); m < n\\<rbrakk>\n       \\<Longrightarrow> (xs ! Suc na, xs ! na) \\<in> R", "by (metis One_nat_def diff_Suc_eq_diff_pred nth_Cons_Suc zero_less_diff)"], ["proof (state)\nthis:\n  ?n < length xs - 1 \\<Longrightarrow> (xs ! Suc ?n, xs ! ?n) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+\n 2. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>\\<And>n.\n                               n < length xs - 1 \\<Longrightarrow>\n                               (xs ! Suc n, xs ! n) \\<in> R;\n                    n < length xs; m < n\\<rbrakk>\n                   \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length (a # xs) - 1 \\<Longrightarrow>\n           ((a # xs) ! Suc n, (a # xs) ! n) \\<in> R;\n        n < length (a # xs); m < n\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) ! n, (a # xs) ! m) \\<in> R\\<^sup>+", "note IH = this[THEN Cons.IH]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n. n < length xs - 1 \\<Longrightarrow> n < length xs - 1;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+\n 2. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>\\<And>n.\n                               n < length xs - 1 \\<Longrightarrow>\n                               (xs ! Suc n, xs ! n) \\<in> R;\n                    n < length xs; m < n\\<rbrakk>\n                   \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length (a # xs) - 1 \\<Longrightarrow>\n           ((a # xs) ! Suc n, (a # xs) ! n) \\<in> R;\n        n < length (a # xs); m < n\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) ! n, (a # xs) ! m) \\<in> R\\<^sup>+", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n", "obtain n' where n': \"Suc n' = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n\ngoal (1 subgoal):\n 1. (\\<And>n'. Suc n' = n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) blast+"], ["proof (state)\nthis:\n  Suc n' = n\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+\n 2. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>\\<And>n.\n                               n < length xs - 1 \\<Longrightarrow>\n                               (xs ! Suc n, xs ! n) \\<in> R;\n                    n < length xs; m < n\\<rbrakk>\n                   \\<Longrightarrow> (xs ! n, xs ! m) \\<in> R\\<^sup>+;\n        \\<And>n.\n           n < length (a # xs) - 1 \\<Longrightarrow>\n           ((a # xs) ! Suc n, (a # xs) ! n) \\<in> R;\n        n < length (a # xs); m < n\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) ! n, (a # xs) ! m) \\<in> R\\<^sup>+", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "case \"0\""], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  m = 0", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  m = 0\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with \"0\" Cons.prems(1)[of m]"], ["proof (chain)\npicking this:\n  m = 0\n  m < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc m, (x # xs) ! m) \\<in> R\n  xs \\<noteq> []", "have \"(xs ! 0, x) \\<in> R\""], ["proof (prove)\nusing this:\n  m = 0\n  m < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc m, (x # xs) ! m) \\<in> R\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (xs ! 0, x) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (xs ! 0, x) \\<in> R\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (xs ! 0, x) \\<in> R\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "from IH[where m = 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n. n < length xs - 1 \\<Longrightarrow> n < length xs - 1;\n   ?n < length xs; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! 0) \\<in> R\\<^sup>+", "have \"\\<And>n. n < length xs \\<Longrightarrow> n > 0 \\<Longrightarrow> (xs ! n, xs ! 0) \\<in> R\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n. n < length xs - 1 \\<Longrightarrow> n < length xs - 1;\n   ?n < length xs; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! 0) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length xs; 0 < n\\<rbrakk>\n       \\<Longrightarrow> (xs ! n, xs ! 0) \\<in> R\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?n < length xs; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! 0) \\<in> R\\<^sup>+\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (xs ! 0, x) \\<in> R\n  \\<lbrakk>?n < length xs; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! 0) \\<in> R\\<^sup>+", "have \"\\<And>n. n < length xs \\<Longrightarrow> (xs ! n, x) \\<in> R\\<^sup>+\""], ["proof (prove)\nusing this:\n  (xs ! 0, x) \\<in> R\n  \\<lbrakk>?n < length xs; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! 0) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>n. n < length xs \\<Longrightarrow> (xs ! n, x) \\<in> R\\<^sup>+", "by (metis trancl_into_trancl gr0I r_into_trancl')"], ["proof (state)\nthis:\n  ?n < length xs \\<Longrightarrow> (xs ! ?n, x) \\<in> R\\<^sup>+\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with Cons \"0\""], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  m = 0\n  ?n < length xs \\<Longrightarrow> (xs ! ?n, x) \\<in> R\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n.\n              n < length xs - 1 \\<Longrightarrow>\n              (xs ! Suc n, xs ! n) \\<in> R;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  m = 0\n  ?n < length xs \\<Longrightarrow> (xs ! ?n, x) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "case (Suc m')"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with Cons.prems n'"], ["proof (chain)\npicking this:\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  Suc n' = n\n  m = Suc m'", "have \"n' < length xs\" \"m' < n'\""], ["proof (prove)\nusing this:\n  ?n < length (x # xs) - 1 \\<Longrightarrow>\n  ((x # xs) ! Suc ?n, (x # xs) ! ?n) \\<in> R\n  n < length (x # xs)\n  m < n\n  Suc n' = n\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. n' < length xs &&& m' < n'", "by auto"], ["proof (state)\nthis:\n  n' < length xs\n  m' < n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n. n < length xs - 1 \\<Longrightarrow> n < length xs - 1;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  n' < length xs\n  m' < n'", "have \"(xs ! n', xs ! m') \\<in> R\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n. n < length xs - 1 \\<Longrightarrow> n < length xs - 1;\n   ?n < length xs; ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?n, xs ! ?m) \\<in> R\\<^sup>+\n  n' < length xs\n  m' < n'\n\ngoal (1 subgoal):\n 1. (xs ! n', xs ! m') \\<in> R\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (xs ! n', xs ! m') \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "with Suc n'"], ["proof (chain)\npicking this:\n  m = Suc m'\n  Suc n' = n\n  (xs ! n', xs ! m') \\<in> R\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Suc m'\n  Suc n' = n\n  (xs ! n', xs ! m') \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((x # xs) ! n, (x # xs) ! m) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>n.\n                   n < length [] - 1 \\<Longrightarrow>\n                   ([] ! Suc n, [] ! n) \\<in> R;\n        n < length []; m < n\\<rbrakk>\n       \\<Longrightarrow> ([] ! n, [] ! m) \\<in> R\\<^sup>+", "qed simp"], ["", "lemma Image_empty_trancl_Image_empty:\n  \"R `` {v} = {} \\<Longrightarrow> R\\<^sup>+ `` {v} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {v} = {} \\<Longrightarrow> R\\<^sup>+ `` {v} = {}", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{v}. (x, y) \\<in> R} = {} \\<Longrightarrow>\n    {y. \\<exists>x\\<in>{v}. (x, y) \\<in> R\\<^sup>+} = {}", "by (auto elim: converse_tranclE)"], ["", "lemma Image_empty_rtrancl_Image_id:\n  \"R `` {v} = {} \\<Longrightarrow> R\\<^sup>* `` {v} = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {v} = {} \\<Longrightarrow> R\\<^sup>* `` {v} = {v}", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{v}. (x, y) \\<in> R} = {} \\<Longrightarrow>\n    {y. \\<exists>x\\<in>{v}. (x, y) \\<in> R\\<^sup>*} = {v}", "by (auto elim: converse_rtranclE)"], ["", "lemma trans_rtrancl_eq_reflcl:\n  \"trans A \\<Longrightarrow> A^* = A^=\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans A \\<Longrightarrow> A\\<^sup>* = A\\<^sup>=", "by (simp add: rtrancl_trancl_reflcl)"], ["", "lemma refl_on_reflcl_Image:\n  \"refl_on B A \\<Longrightarrow> C \\<subseteq> B \\<Longrightarrow> A^= `` C = A `` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refl_on B A; C \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> A\\<^sup>= `` C = A `` C", "by (auto simp add: Image_def dest: refl_onD)"], ["", "lemma Image_absorb_rtrancl:\n  \"\\<lbrakk> trans A; refl_on B A; C \\<subseteq> B \\<rbrakk> \\<Longrightarrow> A^* `` C = A `` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trans A; refl_on B A; C \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> A\\<^sup>* `` C = A `` C", "by (simp add: trans_rtrancl_eq_reflcl refl_on_reflcl_Image)"], ["", "lemma trancl_Image_unfold_left: \"E\\<^sup>+``S = E\\<^sup>*``E``S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` S = E\\<^sup>* `` E `` S", "by (auto simp: trancl_unfold_left)"], ["", "lemma trancl_Image_unfold_right: \"E\\<^sup>+``S = E``E\\<^sup>*``S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` S = E `` E\\<^sup>* `` S", "by (auto simp: trancl_unfold_right)"], ["", "lemma trancl_Image_advance_ss: \"(u,v)\\<in>E \\<Longrightarrow> E\\<^sup>+``{v} \\<subseteq> E\\<^sup>+``{u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow>\n    E\\<^sup>+ `` {v} \\<subseteq> E\\<^sup>+ `` {u}", "by auto"], ["", "lemma rtrancl_Image_advance_ss: \"(u,v)\\<in>E \\<Longrightarrow> E\\<^sup>*``{v} \\<subseteq> E\\<^sup>*``{u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow>\n    E\\<^sup>* `` {v} \\<subseteq> E\\<^sup>* `` {u}", "by auto"], ["", "(* FIXME: nicer name *)"], ["", "lemma trancl_union_outside:\n  assumes \"(v,w) \\<in> (E\\<union>U)\\<^sup>+\"\n  and \"(v,w) \\<notin> E\\<^sup>+\"\n  shows \"\\<exists>x y. (v,x) \\<in> (E\\<union>U)\\<^sup>* \\<and> (x,y) \\<in> U \\<and> (y,w) \\<in> (E\\<union>U)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y.\n       (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (v, w) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>x y.\n       (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*", "proof (induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(v, y) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ya.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, ya) \\<in> U \\<and>\n                            (ya, y) \\<in> (E \\<union> U)\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(v, y) \\<in> (E \\<union> U)\\<^sup>+;\n        (y, z) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n        \\<exists>x ya.\n           (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n           (x, ya) \\<in> U \\<and> (ya, y) \\<in> (E \\<union> U)\\<^sup>*;\n        (v, z) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, y) \\<in> U \\<and>\n                            (y, z) \\<in> (E \\<union> U)\\<^sup>*", "case base"], ["proof (state)\nthis:\n  (v, y_) \\<in> E \\<union> U\n  (v, y_) \\<notin> E\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(v, y) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ya.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, ya) \\<in> U \\<and>\n                            (ya, y) \\<in> (E \\<union> U)\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(v, y) \\<in> (E \\<union> U)\\<^sup>+;\n        (y, z) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n        \\<exists>x ya.\n           (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n           (x, ya) \\<in> U \\<and> (ya, y) \\<in> (E \\<union> U)\\<^sup>*;\n        (v, z) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, y) \\<in> U \\<and>\n                            (y, z) \\<in> (E \\<union> U)\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  (v, y_) \\<in> E \\<union> U\n  (v, y_) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>x ya.\n       (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (x, ya) \\<in> U \\<and> (ya, y_) \\<in> (E \\<union> U)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>x ya.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, ya) \\<in> U \\<and> (ya, y_) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(v, y) \\<in> (E \\<union> U)\\<^sup>+;\n        (y, z) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n        \\<exists>x ya.\n           (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n           (x, ya) \\<in> U \\<and> (ya, y) \\<in> (E \\<union> U)\\<^sup>*;\n        (v, z) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, y) \\<in> U \\<and>\n                            (y, z) \\<in> (E \\<union> U)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(v, y) \\<in> (E \\<union> U)\\<^sup>+;\n        (y, z) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n        \\<exists>x ya.\n           (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n           (x, ya) \\<in> U \\<and> (ya, y) \\<in> (E \\<union> U)\\<^sup>*;\n        (v, z) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, y) \\<in> U \\<and>\n                            (y, z) \\<in> (E \\<union> U)\\<^sup>*", "case (step w x)"], ["proof (state)\nthis:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(v, y) \\<in> (E \\<union> U)\\<^sup>+;\n        (y, z) \\<in> E \\<union> U;\n        (v, y) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n        \\<exists>x ya.\n           (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n           (x, ya) \\<in> U \\<and> (ya, y) \\<in> (E \\<union> U)\\<^sup>*;\n        (v, z) \\<notin> E\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n                            (x, y) \\<in> U \\<and>\n                            (y, z) \\<in> (E \\<union> U)\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "proof (cases \"(v,w)\\<in>E\\<^sup>+\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "case True"], ["proof (state)\nthis:\n  (v, w) \\<in> E\\<^sup>+\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "from step"], ["proof (chain)\npicking this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+", "have \"(v,w)\\<in>(E\\<union>U)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (E \\<union> U)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "from True step"], ["proof (chain)\npicking this:\n  (v, w) \\<in> E\\<^sup>+\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+", "have \"(w,x) \\<in> U\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> E\\<^sup>+\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (w, x) \\<in> U", "by (metis Un_iff trancl.simps)"], ["proof (state)\nthis:\n  (w, x) \\<in> U\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (w, x) \\<in> U\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "have \"(x,x) \\<in> (E\\<union>U)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<in> (E \\<union> U)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (x, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (v, w) \\<in> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n 2. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>*\n  (w, x) \\<in> U\n  (x, x) \\<in> (E \\<union> U)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>*\n  (w, x) \\<in> U\n  (x, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  \\<exists>xa y.\n     (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "case False"], ["proof (state)\nthis:\n  (v, w) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "with step.IH"], ["proof (chain)\npicking this:\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, w) \\<notin> E\\<^sup>+", "obtain a b where \"(v,a) \\<in> (E\\<union>U)\\<^sup>*\" \"(a,b) \\<in> U\" \"(b,w) \\<in> (E\\<union>U)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, w) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(v, a) \\<in> (E \\<union> U)\\<^sup>*; (a, b) \\<in> U;\n         (b, w) \\<in> (E \\<union> U)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "with step"], ["proof (chain)\npicking this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*", "have \"(b,x) \\<in> (E\\<union>U)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> (E \\<union> U)\\<^sup>+\n  (w, x) \\<in> E \\<union> U\n  (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (v, x) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (x, y) \\<in> U \\<and> (y, w) \\<in> (E \\<union> U)\\<^sup>*\n  (v, x) \\<notin> E\\<^sup>+\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (b, x) \\<in> (E \\<union> U)\\<^sup>*", "by (metis rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (b, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> E\\<^sup>+ \\<Longrightarrow>\n    \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*\n  (b, x) \\<in> (E \\<union> U)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a) \\<in> (E \\<union> U)\\<^sup>*\n  (a, b) \\<in> U\n  (b, w) \\<in> (E \\<union> U)\\<^sup>*\n  (b, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>xa y.\n       (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n       (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  \\<exists>xa y.\n     (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xa y.\n     (v, xa) \\<in> (E \\<union> U)\\<^sup>* \\<and>\n     (xa, y) \\<in> U \\<and> (y, x) \\<in> (E \\<union> U)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trancl_restrict_reachable:\n  assumes \"(u,v) \\<in> E\\<^sup>+\"\n  assumes \"E``S \\<subseteq> S\"\n  assumes \"u\\<in>S\"\n  shows \"(u,v) \\<in> (E\\<inter>S\\<times>S)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (Restr E S)\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>+\n  E `` S \\<subseteq> S\n  u \\<in> S\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (Restr E S)\\<^sup>+", "by (induction rule: converse_trancl_induct)\n     (auto intro: trancl_into_trancl2)"], ["", "lemma rtrancl_image_unfold_right: \"E``E\\<^sup>*``V \\<subseteq> E\\<^sup>*``V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` E\\<^sup>* `` V \\<subseteq> E\\<^sup>* `` V", "by (auto intro: rtrancl_into_rtrancl)"], ["", "lemma trancl_Image_in_Range:\n  \"R\\<^sup>+ `` V \\<subseteq> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+ `` V \\<subseteq> Range R", "by (auto elim: trancl.induct)"], ["", "lemma rtrancl_Image_in_Field:\n  \"R\\<^sup>* `` V \\<subseteq> Field R \\<union> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>* `` V \\<subseteq> Field R \\<union> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R\\<^sup>* `` V \\<subseteq> Field R \\<union> V", "from trancl_Image_in_Range"], ["proof (chain)\npicking this:\n  ?R\\<^sup>+ `` ?V \\<subseteq> Range ?R", "have \"R\\<^sup>+ `` V \\<subseteq> Field R\""], ["proof (prove)\nusing this:\n  ?R\\<^sup>+ `` ?V \\<subseteq> Range ?R\n\ngoal (1 subgoal):\n 1. R\\<^sup>+ `` V \\<subseteq> Field R", "unfolding Field_def"], ["proof (prove)\nusing this:\n  ?R\\<^sup>+ `` ?V \\<subseteq> Range ?R\n\ngoal (1 subgoal):\n 1. R\\<^sup>+ `` V \\<subseteq> Domain R \\<union> Range R", "by fast"], ["proof (state)\nthis:\n  R\\<^sup>+ `` V \\<subseteq> Field R\n\ngoal (1 subgoal):\n 1. R\\<^sup>* `` V \\<subseteq> Field R \\<union> V", "hence \"R\\<^sup>+ `` V \\<union> V \\<subseteq> Field R \\<union> V\""], ["proof (prove)\nusing this:\n  R\\<^sup>+ `` V \\<subseteq> Field R\n\ngoal (1 subgoal):\n 1. R\\<^sup>+ `` V \\<union> V \\<subseteq> Field R \\<union> V", "by blast"], ["proof (state)\nthis:\n  R\\<^sup>+ `` V \\<union> V \\<subseteq> Field R \\<union> V\n\ngoal (1 subgoal):\n 1. R\\<^sup>* `` V \\<subseteq> Field R \\<union> V", "with trancl_image_by_rtrancl"], ["proof (chain)\npicking this:\n  ?E\\<^sup>+ `` ?Vi \\<union> ?Vi = ?E\\<^sup>* `` ?Vi\n  R\\<^sup>+ `` V \\<union> V \\<subseteq> Field R \\<union> V", "show ?thesis"], ["proof (prove)\nusing this:\n  ?E\\<^sup>+ `` ?Vi \\<union> ?Vi = ?E\\<^sup>* `` ?Vi\n  R\\<^sup>+ `` V \\<union> V \\<subseteq> Field R \\<union> V\n\ngoal (1 subgoal):\n 1. R\\<^sup>* `` V \\<subseteq> Field R \\<union> V", "by metis"], ["proof (state)\nthis:\n  R\\<^sup>* `` V \\<subseteq> Field R \\<union> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl_sub_insert_rtrancl:\n  \"R\\<^sup>* \\<subseteq> (insert x R)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>* \\<subseteq> (insert x R)\\<^sup>*", "by (auto elim: rtrancl.induct rtrancl_into_rtrancl)"], ["", "lemma trancl_sub_insert_trancl:\n  \"R\\<^sup>+ \\<subseteq> (insert x R)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+ \\<subseteq> (insert x R)\\<^sup>+", "by (auto elim: trancl.induct trancl_into_trancl)"], ["", "lemma Restr_rtrancl_mono:\n  \"(v,w) \\<in> (Restr E U)\\<^sup>* \\<Longrightarrow> (v,w) \\<in> E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (Restr E U)\\<^sup>* \\<Longrightarrow>\n    (v, w) \\<in> E\\<^sup>*", "by (metis inf_le1 rtrancl_mono subsetCE)"], ["", "lemma Restr_trancl_mono:\n  \"(v,w) \\<in> (Restr E U)\\<^sup>+ \\<Longrightarrow> (v,w) \\<in> E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (Restr E U)\\<^sup>+ \\<Longrightarrow>\n    (v, w) \\<in> E\\<^sup>+", "by (metis inf_le1 trancl_mono)"], ["", "subsubsection \"Converse Relation\""], ["", "lemmas converse_add_simps = converse_Times trancl_converse[symmetric] converse_Un converse_Int"], ["", "lemma dom_ran_disj_comp[simp]: \"Domain R \\<inter> Range R = {} \\<Longrightarrow> R O R = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain R \\<inter> Range R = {} \\<Longrightarrow> R O R = {}", "by auto"], ["", "lemma below_Id_inv[simp]: \"R\\<inverse>\\<subseteq>Id \\<longleftrightarrow> R\\<subseteq>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R\\<inverse> \\<subseteq> Id) = (R \\<subseteq> Id)", "by (auto)"], ["", "subsubsection \"Cyclicity\""], ["", "lemma cyclicE: \"\\<lbrakk>\\<not>acyclic g; !!x. (x,x)\\<in>g\\<^sup>+ \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> acyclic g;\n     \\<And>x. (x, x) \\<in> g\\<^sup>+ \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold acyclic_def) blast"], ["", "lemma acyclic_insert_cyclic: \"\\<lbrakk>acyclic g; \\<not>acyclic (insert (x,y) g)\\<rbrakk> \\<Longrightarrow> (y,x)\\<in>g\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>acyclic g; \\<not> acyclic (insert (x, y) g)\\<rbrakk>\n    \\<Longrightarrow> (y, x) \\<in> g\\<^sup>*", "by (unfold acyclic_def) (auto simp add: trancl_insert)"], ["", "text \\<open>\n    This lemma makes a case distinction about a path in a graph where a couple of edges with the same\n    endpoint have been inserted: If there is a path from a to b, then there's such a path in the original graph, or\n    there's a path that uses an inserted edge only once.\n\n    Originally, this lemma was used to reason about the graph of an updated acquisition history. Any path in\n    this graph is either already contained in the original graph, or passes via an\n    inserted edge. Because all the inserted edges point to the same target node, in the\n    second case, the path can be short-circuited to use exactly one inserted edge.\n\\<close>"], ["", "lemma trancl_multi_insert[cases set, case_names orig via]:\n    \"\\<lbrakk> (a,b)\\<in>(r\\<union>X\\<times>{m})\\<^sup>+;\n      (a,b)\\<in>r\\<^sup>+ \\<Longrightarrow> P;\n       !!x. \\<lbrakk> x\\<in>X; (a,x)\\<in>r\\<^sup>*; (m,b)\\<in>r\\<^sup>* \\<rbrakk> \\<Longrightarrow> P\n    \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n         (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof (induct arbitrary: P rule: trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>(a, y) \\<in> r \\<union> X \\<times> {m};\n        (a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>y z P.\n       \\<lbrakk>(a, y) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n        (y, z) \\<in> r \\<union> X \\<times> {m};\n        \\<And>P.\n           \\<lbrakk>(a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n            \\<And>x.\n               \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n                (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n               \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        (a, z) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, z) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (base b)"], ["proof (state)\nthis:\n  (a, b) \\<in> r \\<union> X \\<times> {m}\n  (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, ?x) \\<in> r\\<^sup>*;\n   (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>(a, y) \\<in> r \\<union> X \\<times> {m};\n        (a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>y z P.\n       \\<lbrakk>(a, y) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n        (y, z) \\<in> r \\<union> X \\<times> {m};\n        \\<And>P.\n           \\<lbrakk>(a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n            \\<And>x.\n               \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n                (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n               \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        (a, z) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, z) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> r \\<union> X \\<times> {m}\n  (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, ?x) \\<in> r\\<^sup>*;\n   (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>y z P.\n       \\<lbrakk>(a, y) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n        (y, z) \\<in> r \\<union> X \\<times> {m};\n        \\<And>P.\n           \\<lbrakk>(a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n            \\<And>x.\n               \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n                (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n               \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        (a, z) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, z) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z P.\n       \\<lbrakk>(a, y) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n        (y, z) \\<in> r \\<union> X \\<times> {m};\n        \\<And>P.\n           \\<lbrakk>(a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n            \\<And>x.\n               \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n                (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n               \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        (a, z) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, z) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (step b c)"], ["proof (state)\nthis:\n  (a, b) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n  \\<lbrakk>(a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> ?P;\n   \\<And>x.\n      \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n       (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (a, c) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, ?x) \\<in> r\\<^sup>*;\n   (m, c) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>y z P.\n       \\<lbrakk>(a, y) \\<in> (r \\<union> X \\<times> {m})\\<^sup>+;\n        (y, z) \\<in> r \\<union> X \\<times> {m};\n        \\<And>P.\n           \\<lbrakk>(a, y) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n            \\<And>x.\n               \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n                (m, y) \\<in> r\\<^sup>*\\<rbrakk>\n               \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        (a, z) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n        \\<And>x.\n           \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n            (m, z) \\<in> r\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (rule step.hyps(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume A: \"(a,b)\\<in>r\\<^sup>+\""], ["proof (state)\nthis:\n  (a, b) \\<in> r\\<^sup>+\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "note step.hyps(2)"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"(b,c)\\<in>r\""], ["proof (state)\nthis:\n  (b, c) \\<in> r\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  (a, b) \\<in> r\\<^sup>+\n  (b, c) \\<in> r", "have \"(a,c)\\<in>r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> r\\<^sup>+\n  (b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (a, c) \\<in> r\\<^sup>+\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with step.prems"], ["proof (chain)\npicking this:\n  (a, c) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, ?x) \\<in> r\\<^sup>*;\n   (m, c) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  (a, c) \\<in> r\\<^sup>+", "have P"], ["proof (prove)\nusing this:\n  (a, c) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, ?x) \\<in> r\\<^sup>*;\n   (m, c) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n  (a, c) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"b\\<in>X\" \"c=m\""], ["proof (state)\nthis:\n  b \\<in> X\n  c = m\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  (a, b) \\<in> r\\<^sup>+\n  b \\<in> X\n  c = m", "have P"], ["proof (prove)\nusing this:\n  (a, b) \\<in> r\\<^sup>+\n  b \\<in> X\n  c = m\n\ngoal (1 subgoal):\n 1. P", "by (rule_tac step.prems(2)) simp+"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n  (b, c) \\<in> r \\<Longrightarrow> P\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P", "show P"], ["proof (prove)\nusing this:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n  (b, c) \\<in> r \\<Longrightarrow> P\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume A: \"x \\<in> X\" \"(a, x) \\<in> r\\<^sup>*\" \"(m, b) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  x \\<in> X\n  (a, x) \\<in> r\\<^sup>*\n  (m, b) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "note step.hyps(2)"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"(b,c)\\<in>r\""], ["proof (state)\nthis:\n  (b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with A(3)"], ["proof (chain)\npicking this:\n  (m, b) \\<in> r\\<^sup>*\n  (b, c) \\<in> r", "have \"(m,c)\\<in>r\\<^sup>*\""], ["proof (prove)\nusing this:\n  (m, b) \\<in> r\\<^sup>*\n  (b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (m, c) \\<in> r\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (m, c) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with step.prems(2)[OF A(1,2)]"], ["proof (chain)\npicking this:\n  (m, c) \\<in> r\\<^sup>* \\<Longrightarrow> P\n  (m, c) \\<in> r\\<^sup>*", "have P"], ["proof (prove)\nusing this:\n  (m, c) \\<in> r\\<^sup>* \\<Longrightarrow> P\n  (m, c) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  (b, c) \\<in> r \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"b\\<in>X\" \"c=m\""], ["proof (state)\nthis:\n  b \\<in> X\n  c = m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  x \\<in> X\n  (a, x) \\<in> r\\<^sup>*\n  (m, b) \\<in> r\\<^sup>*\n  b \\<in> X\n  c = m", "have P"], ["proof (prove)\nusing this:\n  x \\<in> X\n  (a, x) \\<in> r\\<^sup>*\n  (m, b) \\<in> r\\<^sup>*\n  b \\<in> X\n  c = m\n\ngoal (1 subgoal):\n 1. P", "by (rule_tac step.prems(2)) simp+"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X; (a, x) \\<in> r\\<^sup>*;\n        (m, b) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n  (b, c) \\<in> r \\<Longrightarrow> P\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P", "show P"], ["proof (prove)\nusing this:\n  (b, c) \\<in> r \\<union> X \\<times> {m}\n  (b, c) \\<in> r \\<Longrightarrow> P\n  \\<lbrakk>b \\<in> X; c = m\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    Version of @{thm [source] trancl_multi_insert} for inserted edges with the same startpoint.\n\\<close>"], ["", "lemma trancl_multi_insert2[cases set, case_names orig via]:\n    \"\\<lbrakk>(a,b)\\<in>(r\\<union>{m}\\<times>X)\\<^sup>+; (a,b)\\<in>r\\<^sup>+ \\<Longrightarrow> P; !!x. \\<lbrakk> x\\<in>X; (a,m)\\<in>r\\<^sup>*; (x,b)\\<in>r\\<^sup>* \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "case prems: 1"], ["proof (state)\nthis:\n  (a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+\n  (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P\n  \\<lbrakk>?x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n   (?x, b) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "from prems(1)"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+", "have \"(b,a)\\<in>((r\\<union>{m}\\<times>X)\\<^sup>+)\\<inverse>\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> ((r \\<union> {m} \\<times> X)\\<^sup>+)\\<inverse>", "by simp"], ["proof (state)\nthis:\n  (b, a) \\<in> ((r \\<union> {m} \\<times> X)\\<^sup>+)\\<inverse>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "also"], ["proof (state)\nthis:\n  (b, a) \\<in> ((r \\<union> {m} \\<times> X)\\<^sup>+)\\<inverse>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "have \"((r\\<union>{m}\\<times>X)\\<^sup>+)\\<inverse> = (r\\<inverse>\\<union>X\\<times>{m})\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r \\<union> {m} \\<times> X)\\<^sup>+)\\<inverse> =\n    (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+", "by (simp add: converse_add_simps)"], ["proof (state)\nthis:\n  ((r \\<union> {m} \\<times> X)\\<^sup>+)\\<inverse> =\n  (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "finally"], ["proof (chain)\npicking this:\n  (b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+", "have \"(b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+\""], ["proof (prove)\nusing this:\n  (b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+", "."], ["proof (state)\nthis:\n  (b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (r \\<union> {m} \\<times> X)\\<^sup>+;\n     (a, b) \\<in> r\\<^sup>+ \\<Longrightarrow> P;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; (a, m) \\<in> r\\<^sup>*;\n         (x, b) \\<in> r\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  (b, a) \\<in> (r\\<inverse> \\<union> X \\<times> {m})\\<^sup>+\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: trancl_multi_insert\n               intro: prems(2,3)\n            simp add: trancl_converse rtrancl_converse\n    )"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_subset:\n  \"\\<lbrakk> \\<not> acyclic R; R \\<subseteq> S \\<rbrakk> \\<Longrightarrow> \\<not> acyclic S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> acyclic R; R \\<subseteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<not> acyclic S", "unfolding acyclic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>x. (x, x) \\<notin> R\\<^sup>+);\n     R \\<subseteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>x. (x, x) \\<notin> S\\<^sup>+)", "by (blast intro: trancl_mono)"], ["", "subsubsection \\<open>Wellfoundedness\\<close>"], ["", "lemma wf_min: assumes A: \"wf R\" \"R\\<noteq>{}\" \"!!m. m\\<in>Domain R - Range R \\<Longrightarrow> P\" shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have H: \"!!x. wf R \\<Longrightarrow> \\<forall>y. (x,y)\\<in>R \\<longrightarrow> x\\<in>Domain R - Range R \\<or> (\\<exists>m. m\\<in>Domain R - Range R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       wf R \\<Longrightarrow>\n       \\<forall>y.\n          (x, y) \\<in> R \\<longrightarrow>\n          x \\<in> Domain R - Range R \\<or>\n          (\\<exists>m. m \\<in> Domain R - Range R)", "by (erule_tac wf_induct_rule[where P=\"\\<lambda>x. \\<forall>y. (x,y)\\<in>R \\<longrightarrow> x\\<in>Domain R - Range R \\<or> (\\<exists>m. m\\<in>Domain R - Range R)\"]) auto"], ["proof (state)\nthis:\n  wf R \\<Longrightarrow>\n  \\<forall>y.\n     (?x, y) \\<in> R \\<longrightarrow>\n     ?x \\<in> Domain R - Range R \\<or>\n     (\\<exists>m. m \\<in> Domain R - Range R)\n\ngoal (1 subgoal):\n 1. P", "from A(2)"], ["proof (chain)\npicking this:\n  R \\<noteq> {}", "obtain x y where \"(x,y)\\<in>R\""], ["proof (prove)\nusing this:\n  R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x y. (x, y) \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. P", "with A(1,3) H"], ["proof (chain)\npicking this:\n  wf R\n  ?m \\<in> Domain R - Range R \\<Longrightarrow> P\n  wf R \\<Longrightarrow>\n  \\<forall>y.\n     (?x, y) \\<in> R \\<longrightarrow>\n     ?x \\<in> Domain R - Range R \\<or>\n     (\\<exists>m. m \\<in> Domain R - Range R)\n  (x, y) \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  wf R\n  ?m \\<in> Domain R - Range R \\<Longrightarrow> P\n  wf R \\<Longrightarrow>\n  \\<forall>y.\n     (?x, y) \\<in> R \\<longrightarrow>\n     ?x \\<in> Domain R - Range R \\<or>\n     (\\<exists>m. m \\<in> Domain R - Range R)\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_wf_eq_wf_converse: \"finite R \\<Longrightarrow> wf (R\\<inverse>) \\<longleftrightarrow> wf R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow> wf (R\\<inverse>) = wf R", "by (metis acyclic_converse finite_acyclic_wf finite_acyclic_wf_converse wf_acyclic)"], ["", "lemma wf_max: assumes A: \"wf (R\\<inverse>)\" \"R\\<noteq>{}\" and C: \"!!m. m\\<in>Range R - Domain R \\<Longrightarrow> P\" shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A(2)"], ["proof (chain)\npicking this:\n  R \\<noteq> {}", "have NE: \"R\\<inverse>\\<noteq>{}\""], ["proof (prove)\nusing this:\n  R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. R\\<inverse> \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  R\\<inverse> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. P", "from wf_min[OF A(1) NE]"], ["proof (chain)\npicking this:\n  (\\<And>m.\n      m \\<in> Domain (R\\<inverse>) - Range (R\\<inverse>) \\<Longrightarrow>\n      ?P) \\<Longrightarrow>\n  ?P", "obtain m where \"m\\<in>Range R - Domain R\""], ["proof (prove)\nusing this:\n  (\\<And>m.\n      m \\<in> Domain (R\\<inverse>) - Range (R\\<inverse>) \\<Longrightarrow>\n      ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> Range R - Domain R \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> Range R - Domain R\n\ngoal (1 subgoal):\n 1. P", "thus P"], ["proof (prove)\nusing this:\n  m \\<in> Range R - Domain R\n\ngoal (1 subgoal):\n 1. P", "by (blast intro: C)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed\n\n    \\<comment> \\<open>Useful lemma to show well-foundedness of some process approaching a finite upper bound\\<close>"], ["", "lemma wf_bounded_supset: \"finite S \\<Longrightarrow> wf {(Q',Q). Q'\\<supset>Q \\<and> Q'\\<subseteq> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "assume [simp]: \"finite S\""], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "hence [simp]: \"!!x. finite (S-x)\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<And>x. finite (S - x)", "by auto"], ["proof (state)\nthis:\n  finite (S - ?x)\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "have \"{(Q',Q). Q\\<subset>Q' \\<and> Q'\\<subseteq> S} \\<subseteq> inv_image ({(s'::nat,s). s'<s}) (\\<lambda>Q. card (S-Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n    \\<subseteq> inv_image {(s', s). s' < s} (\\<lambda>Q. card (S - Q))", "proof (intro subsetI, case_tac x, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>b \\<subset> a \\<and> a \\<subseteq> S; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> card (S - a) < card (S - b)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>b \\<subset> a \\<and> a \\<subseteq> S; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> card (S - a) < card (S - b)", "assume A: \"b\\<subset>a \\<and> a\\<subseteq>S\""], ["proof (state)\nthis:\n  b \\<subset> a \\<and> a \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>b \\<subset> a \\<and> a \\<subseteq> S; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> card (S - a) < card (S - b)", "hence \"S-a \\<subset> S-b\""], ["proof (prove)\nusing this:\n  b \\<subset> a \\<and> a \\<subseteq> S\n\ngoal (1 subgoal):\n 1. S - a \\<subset> S - b", "by blast"], ["proof (state)\nthis:\n  S - a \\<subset> S - b\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>b \\<subset> a \\<and> a \\<subseteq> S; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> card (S - a) < card (S - b)", "thus \"card (S-a) < card (S-b)\""], ["proof (prove)\nusing this:\n  S - a \\<subset> S - b\n\ngoal (1 subgoal):\n 1. card (S - a) < card (S - b)", "by (auto simp add: psubset_card_mono)"], ["proof (state)\nthis:\n  card (S - a) < card (S - b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n  \\<subseteq> inv_image {(s', s). s' < s} (\\<lambda>Q. card (S - Q))\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "moreover"], ["proof (state)\nthis:\n  {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n  \\<subseteq> inv_image {(s', s). s' < s} (\\<lambda>Q. card (S - Q))\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "have \"wf ({(s'::nat,s). s'<s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s). s' < s}", "by (rule wf_less)"], ["proof (state)\nthis:\n  wf {(s', s). s' < s}\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "ultimately"], ["proof (chain)\npicking this:\n  {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n  \\<subseteq> inv_image {(s', s). s' < s} (\\<lambda>Q. card (S - Q))\n  wf {(s', s). s' < s}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n  \\<subseteq> inv_image {(s', s). s' < s} (\\<lambda>Q. card (S - Q))\n  wf {(s', s). s' < s}\n\ngoal (1 subgoal):\n 1. wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "by (blast intro: wf_inv_image wf_subset)"], ["proof (state)\nthis:\n  wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_no_path: \"Domain R \\<inter> Range R = {} \\<Longrightarrow> wf R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain R \\<inter> Range R = {} \\<Longrightarrow> wf R", "apply (rule wf_no_loop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain R \\<inter> Range R = {} \\<Longrightarrow> R O R = {}", "by simp"], ["", "text \\<open>Extend a wf-relation by a break-condition\\<close>"], ["", "definition \"brk_rel R \\<equiv>\n    {((False,x),(False,y)) | x y. (x,y)\\<in>R}\n  \\<union> {((True,x),(False,y)) | x y. True}\""], ["", "lemma brk_rel_wf[simp,intro!]:\n  assumes WF[simp]: \"wf R\"\n  shows \"wf (brk_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "have \"wf {((False,x),(False,y)) | x y. (x,y)\\<in>R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {((False, x), False, y) |x y. (x, y) \\<in> R}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {((False, x), False, y) |x y. (x, y) \\<in> R}", "have \"{((False,x),(False,y)) | x y. (x,y)\\<in>R} \\<subseteq> inv_image R snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {((False, x), False, y) |x y. (x, y) \\<in> R}\n    \\<subseteq> inv_image R snd", "by auto"], ["proof (state)\nthis:\n  {((False, x), False, y) |x y. (x, y) \\<in> R} \\<subseteq> inv_image R snd\n\ngoal (1 subgoal):\n 1. wf {((False, x), False, y) |x y. (x, y) \\<in> R}", "from wf_subset[OF wf_inv_image[OF WF] this]"], ["proof (chain)\npicking this:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}", "show ?thesis"], ["proof (prove)\nusing this:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. wf {((False, x), False, y) |x y. (x, y) \\<in> R}", "."], ["proof (state)\nthis:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "moreover"], ["proof (state)\nthis:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "have \"wf {((True,x),(False,y)) | x y. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {((True, x), False, y) |x y. True}", "by (rule wf_no_path) auto"], ["proof (state)\nthis:\n  wf {((True, x), False, y) |x y. True}\n\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "ultimately"], ["proof (chain)\npicking this:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n  wf {((True, x), False, y) |x y. True}", "show ?thesis"], ["proof (prove)\nusing this:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n  wf {((True, x), False, y) |x y. True}\n\ngoal (1 subgoal):\n 1. wf (brk_rel R)", "unfolding brk_rel_def"], ["proof (prove)\nusing this:\n  wf {((False, x), False, y) |x y. (x, y) \\<in> R}\n  wf {((True, x), False, y) |x y. True}\n\ngoal (1 subgoal):\n 1. wf ({((False, x), False, y) |x y. (x, y) \\<in> R} \\<union>\n        {((True, x), False, y) |x y. True})", "apply (subst Un_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf {((False, x), False, y) |x y. (x, y) \\<in> R};\n     wf {((True, x), False, y) |x y. True}\\<rbrakk>\n    \\<Longrightarrow> wf ({((True, x), False, y) |x y. True} \\<union>\n                          {((False, x), False, y) |x y. (x, y) \\<in> R})", "by (blast intro: wf_Un)"], ["proof (state)\nthis:\n  wf (brk_rel R)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Restrict Relation\\<close>"], ["", "definition rel_restrict :: \"('a \\<times> 'a) set \\<Rightarrow> 'a set \\<Rightarrow> ('a \\<times> 'a) set\"\nwhere\n  \"rel_restrict R A \\<equiv> {(v,w). (v,w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A}\""], ["", "lemma rel_restrict_alt_def:\n  \"rel_restrict R A = R \\<inter> (-A) \\<times> (-A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict R A = Restr R (- A)", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A} =\n    Restr R (- A)", "by auto"], ["", "lemma rel_restrict_empty[simp]:\n  \"rel_restrict R {} = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict R {} = R", "by (simp add: rel_restrict_def)"], ["", "lemma rel_restrict_notR:\n  assumes \"(x,y) \\<in> rel_restrict A R\"\n  shows \"x \\<notin> R\" and \"y \\<notin> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> R &&& y \\<notin> R", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> rel_restrict A R\n\ngoal (1 subgoal):\n 1. x \\<notin> R &&& y \\<notin> R", "unfolding rel_restrict_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(v, w). (v, w) \\<in> A \\<and> v \\<notin> R \\<and> w \\<notin> R}\n\ngoal (1 subgoal):\n 1. x \\<notin> R &&& y \\<notin> R", "by auto"], ["", "lemma rel_restrict_sub:\n  \"rel_restrict R A \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict R A \\<subseteq> R", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A}\n    \\<subseteq> R", "by auto"], ["", "lemma rel_restrict_Int_empty:\n  \"A \\<inter> Field R = {} \\<Longrightarrow> rel_restrict R A = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> Field R = {} \\<Longrightarrow> rel_restrict R A = R", "unfolding rel_restrict_def Field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> (Domain R \\<union> Range R) = {} \\<Longrightarrow>\n    {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A} = R", "by auto"], ["", "lemma Domain_rel_restrict:\n  \"Domain (rel_restrict R A) \\<subseteq> Domain R - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (rel_restrict R A) \\<subseteq> Domain R - A", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A}\n    \\<subseteq> Domain R - A", "by auto"], ["", "lemma Range_rel_restrict:\n  \"Range (rel_restrict R A) \\<subseteq> Range R - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (rel_restrict R A) \\<subseteq> Range R - A", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A}\n    \\<subseteq> Range R - A", "by auto"], ["", "lemma Field_rel_restrict:\n  \"Field (rel_restrict R A) \\<subseteq> Field R - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (rel_restrict R A) \\<subseteq> Field R - A", "unfolding rel_restrict_def Field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain\n     {(v, w).\n      (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A} \\<union>\n    Range {(v, w). (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A}\n    \\<subseteq> Domain R \\<union> Range R - A", "by auto"], ["", "lemma rel_restrict_compl:\n  \"rel_restrict R A \\<inter> rel_restrict R (-A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict R A \\<inter> rel_restrict R (- A) = {}", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w).\n     (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A} \\<inter>\n    {(v, w). (v, w) \\<in> R \\<and> v \\<notin> - A \\<and> w \\<notin> - A} =\n    {}", "by auto"], ["", "lemma finite_rel_restrict:\n  \"finite R \\<Longrightarrow> finite (rel_restrict R A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow> finite (rel_restrict R A)", "by (metis finite_subset rel_restrict_sub)"], ["", "lemma R_subset_Field: \"R \\<subseteq> Field R \\<times> Field R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> Field R \\<times> Field R", "unfolding Field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> (Domain R \\<union> Range R) \\<times>\n                  (Domain R \\<union> Range R)", "by auto"], ["", "lemma homo_rel_restrict_mono:\n  \"R \\<subseteq> B \\<times> B \\<Longrightarrow> rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B \\<Longrightarrow>\n    rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B \\<Longrightarrow>\n    rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "assume A: \"R \\<subseteq> B \\<times> B\""], ["proof (state)\nthis:\n  R \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B \\<Longrightarrow>\n    rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "hence \"Field R \\<subseteq> B\""], ["proof (prove)\nusing this:\n  R \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. Field R \\<subseteq> B", "unfolding Field_def"], ["proof (prove)\nusing this:\n  R \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. Domain R \\<union> Range R \\<subseteq> B", "by auto"], ["proof (state)\nthis:\n  Field R \\<subseteq> B\n\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B \\<Longrightarrow>\n    rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "with Field_rel_restrict"], ["proof (chain)\npicking this:\n  Field (rel_restrict ?R ?A) \\<subseteq> Field ?R - ?A\n  Field R \\<subseteq> B", "have \"Field (rel_restrict R A) \\<subseteq> B - A\""], ["proof (prove)\nusing this:\n  Field (rel_restrict ?R ?A) \\<subseteq> Field ?R - ?A\n  Field R \\<subseteq> B\n\ngoal (1 subgoal):\n 1. Field (rel_restrict R A) \\<subseteq> B - A", "by (metis Diff_mono order_refl order_trans)"], ["proof (state)\nthis:\n  Field (rel_restrict R A) \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B \\<Longrightarrow>\n    rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "with R_subset_Field"], ["proof (chain)\npicking this:\n  ?R \\<subseteq> Field ?R \\<times> Field ?R\n  Field (rel_restrict R A) \\<subseteq> B - A", "show ?thesis"], ["proof (prove)\nusing this:\n  ?R \\<subseteq> Field ?R \\<times> Field ?R\n  Field (rel_restrict R A) \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)", "by blast"], ["proof (state)\nthis:\n  rel_restrict R A \\<subseteq> (B - A) \\<times> (B - A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_restrict_union:\n  \"rel_restrict R (A \\<union> B) = rel_restrict (rel_restrict R A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict R (A \\<union> B) = rel_restrict (rel_restrict R A) B", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w).\n     (v, w) \\<in> R \\<and>\n     v \\<notin> A \\<union> B \\<and> w \\<notin> A \\<union> B} =\n    {(v, w).\n     (v, w)\n     \\<in> {(v, w).\n            (v, w) \\<in> R \\<and> v \\<notin> A \\<and> w \\<notin> A} \\<and>\n     v \\<notin> B \\<and> w \\<notin> B}", "by auto"], ["", "lemma rel_restrictI:\n  \"x \\<notin> R \\<Longrightarrow> y \\<notin> R \\<Longrightarrow> (x,y) \\<in> E \\<Longrightarrow> (x,y) \\<in> rel_restrict E R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> R; y \\<notin> R; (x, y) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> rel_restrict E R", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> R; y \\<notin> R; (x, y) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> (x, y)\n                      \\<in> {(v, w).\n                             (v, w) \\<in> E \\<and>\n                             v \\<notin> R \\<and> w \\<notin> R}", "by auto"], ["", "lemma rel_restrict_lift:\n  \"(x,y) \\<in> rel_restrict E R \\<Longrightarrow> (x,y) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> rel_restrict E R \\<Longrightarrow> (x, y) \\<in> E", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {(v, w).\n           (v, w) \\<in> E \\<and>\n           v \\<notin> R \\<and> w \\<notin> R} \\<Longrightarrow>\n    (x, y) \\<in> E", "by simp"], ["", "lemma rel_restrict_trancl_mem:\n  \"(a,b) \\<in> (rel_restrict A R)\\<^sup>+ \\<Longrightarrow> (a,b) \\<in> rel_restrict (A\\<^sup>+) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (rel_restrict A R)\\<^sup>+ \\<Longrightarrow>\n    (a, b) \\<in> rel_restrict (A\\<^sup>+) R", "by (induction rule: trancl_induct) (auto simp add: rel_restrict_def)"], ["", "lemma rel_restrict_trancl_sub:\n  \"(rel_restrict A R)\\<^sup>+ \\<subseteq> rel_restrict (A\\<^sup>+) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_restrict A R)\\<^sup>+ \\<subseteq> rel_restrict (A\\<^sup>+) R", "by (metis subrelI rel_restrict_trancl_mem)"], ["", "lemma rel_restrict_mono:\n  \"A \\<subseteq> B \\<Longrightarrow> rel_restrict A R \\<subseteq> rel_restrict B R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    rel_restrict A R \\<subseteq> rel_restrict B R", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    {(v, w). (v, w) \\<in> A \\<and> v \\<notin> R \\<and> w \\<notin> R}\n    \\<subseteq> {(v, w).\n                 (v, w) \\<in> B \\<and> v \\<notin> R \\<and> w \\<notin> R}", "by auto"], ["", "lemma rel_restrict_mono2:\n  \"R \\<subseteq> S \\<Longrightarrow> rel_restrict A S \\<subseteq> rel_restrict A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> S \\<Longrightarrow>\n    rel_restrict A S \\<subseteq> rel_restrict A R", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> S \\<Longrightarrow>\n    {(v, w). (v, w) \\<in> A \\<and> v \\<notin> S \\<and> w \\<notin> S}\n    \\<subseteq> {(v, w).\n                 (v, w) \\<in> A \\<and> v \\<notin> R \\<and> w \\<notin> R}", "by auto"], ["", "lemma rel_restrict_Sigma_sub:\n  \"rel_restrict ((A\\<times>A)\\<^sup>+) R \\<subseteq> ((A - R) \\<times> (A - R))\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict ((A \\<times> A)\\<^sup>+) R\n    \\<subseteq> ((A - R) \\<times> (A - R))\\<^sup>+", "unfolding rel_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w).\n     (v, w) \\<in> (A \\<times> A)\\<^sup>+ \\<and>\n     v \\<notin> R \\<and> w \\<notin> R}\n    \\<subseteq> ((A - R) \\<times> (A - R))\\<^sup>+", "by auto (metis DiffI converse_tranclE mem_Sigma_iff r_into_trancl tranclE)"], ["", "lemma finite_reachable_restrictedI:\n  assumes F: \"finite Q\"\n  assumes I: \"I\\<subseteq>Q\"\n  assumes R: \"Range E \\<subseteq> Q\"\n  shows \"finite (E\\<^sup>*``I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "from I R"], ["proof (chain)\npicking this:\n  I \\<subseteq> Q\n  Range E \\<subseteq> Q", "have \"E\\<^sup>*``I \\<subseteq> Q\""], ["proof (prove)\nusing this:\n  I \\<subseteq> Q\n  Range E \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` I \\<subseteq> Q", "by (force elim: rtrancl.cases)"], ["proof (state)\nthis:\n  E\\<^sup>* `` I \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "also"], ["proof (state)\nthis:\n  E\\<^sup>* `` I \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "note F"], ["proof (state)\nthis:\n  finite Q\n\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite (E\\<^sup>* `` I)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (E\\<^sup>* `` I)\n\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` I)", "."], ["proof (state)\nthis:\n  finite (E\\<^sup>* `` I)\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "private"], ["", "lemma rtrancl_restrictI_aux:\n    assumes \"(u,v)\\<in>(E-UNIV\\<times>R)\\<^sup>*\"\n    assumes \"u\\<notin>R\"\n    shows \"(u,v)\\<in>(rel_restrict E R)\\<^sup>* \\<and> v\\<notin>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (rel_restrict E R)\\<^sup>* \\<and> v \\<notin> R", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n  u \\<notin> R\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (rel_restrict E R)\\<^sup>* \\<and> v \\<notin> R", "by (induction) (auto simp: rel_restrict_def intro: rtrancl.intros)"], ["", "corollary rtrancl_restrictI:\n    assumes \"(u,v)\\<in>(E-UNIV\\<times>R)\\<^sup>*\"\n    assumes \"u\\<notin>R\"\n    shows \"(u,v)\\<in>(rel_restrict E R)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (rel_restrict E R)\\<^sup>*", "using rtrancl_restrictI_aux[OF assms]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (rel_restrict E R)\\<^sup>* \\<and> v \\<notin> R\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (rel_restrict E R)\\<^sup>*", ".."], ["", "end"], ["", "lemma E_closed_restr_reach_cases:\n  assumes P: \"(u,v)\\<in>E\\<^sup>*\"\n  assumes CL: \"E``R \\<subseteq> R\"\n  obtains \"v\\<in>R\" | \"u\\<notin>R\" \"(u,v)\\<in>(rel_restrict E R)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n     \\<lbrakk>u \\<notin> R; (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using P"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n     \\<lbrakk>u \\<notin> R; (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases rule: rtrancl_last_visit[where S=R])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n     \\<lbrakk>u \\<notin> R; (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "case no_visit"], ["proof (state)\nthis:\n  (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n     \\<lbrakk>u \\<notin> R; (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"u\\<in>R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> R \\<Longrightarrow> thesis\n 2. u \\<notin> R \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (2 subgoals):\n 1. u \\<in> R \\<Longrightarrow> thesis\n 2. u \\<notin> R \\<Longrightarrow> thesis", "with P"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> R", "have \"v\\<in>R\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. v \\<in> R", "using rtrancl_reachable_induct[OF _ CL, where I=\"{u}\"]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> R\n  {u} \\<subseteq> R \\<Longrightarrow> E\\<^sup>* `` {u} \\<subseteq> R\n\ngoal (1 subgoal):\n 1. v \\<in> R", "by auto"], ["proof (state)\nthis:\n  v \\<in> R\n\ngoal (2 subgoals):\n 1. u \\<in> R \\<Longrightarrow> thesis\n 2. u \\<notin> R \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> R\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. u \\<notin> R \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> R \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  u \\<notin> R\n\ngoal (1 subgoal):\n 1. u \\<notin> R \\<Longrightarrow> thesis", "with no_visit"], ["proof (chain)\npicking this:\n  (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n  u \\<notin> R", "have \"(u,v)\\<in>(rel_restrict E R)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n  u \\<notin> R\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (rel_restrict E R)\\<^sup>*", "by (rule rtrancl_restrictI)"], ["proof (state)\nthis:\n  (u, v) \\<in> (rel_restrict E R)\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<notin> R \\<Longrightarrow> thesis", "with False"], ["proof (chain)\npicking this:\n  u \\<notin> R\n  (u, v) \\<in> (rel_restrict E R)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> R\n  (u, v) \\<in> (rel_restrict E R)\\<^sup>*\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (last_visit_point x)"], ["proof (state)\nthis:\n  x \\<in> R\n  (u, x) \\<in> E\\<^sup>+\n  (x, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>(x, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (x, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*", "have \"(x,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> E\\<^sup>*", "by (rule rtrancl_mono_mp[rotated]) auto"], ["proof (state)\nthis:\n  (x, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>x\\<in>R\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> R\n  (x, v) \\<in> E\\<^sup>*", "have \"v\\<in>R\""], ["proof (prove)\nusing this:\n  x \\<in> R\n  (x, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> R", "using rtrancl_reachable_induct[OF _ CL, where I=\"{x}\"]"], ["proof (prove)\nusing this:\n  x \\<in> R\n  (x, v) \\<in> E\\<^sup>*\n  {x} \\<subseteq> R \\<Longrightarrow> E\\<^sup>* `` {x} \\<subseteq> R\n\ngoal (1 subgoal):\n 1. v \\<in> R", "by auto"], ["proof (state)\nthis:\n  v \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>v \\<in> R \\<Longrightarrow> thesis;\n        \\<lbrakk>u \\<notin> R;\n         (u, v) \\<in> (rel_restrict E R)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        qt \\<in> R; (u, qt) \\<in> E\\<^sup>+;\n        (qt, v) \\<in> (E - UNIV \\<times> R)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> R\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_restrict_trancl_notR:\n  assumes \"(v,w) \\<in> (rel_restrict E R)\\<^sup>+\"\n  shows \"v \\<notin> R\" and \"w \\<notin> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> R &&& w \\<notin> R", "using assms"], ["proof (prove)\nusing this:\n  (v, w) \\<in> (rel_restrict E R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<notin> R &&& w \\<notin> R", "by (metis rel_restrict_trancl_mem rel_restrict_notR)+"], ["", "lemma rel_restrict_tranclI:\n  assumes \"(x,y) \\<in> E\\<^sup>+\"\n  and \"x \\<notin> R\" \"y \\<notin> R\"\n  and \"E `` R \\<subseteq> R\"\n  shows \"(x,y) \\<in> (rel_restrict E R)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (rel_restrict E R)\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> E\\<^sup>+\n  x \\<notin> R\n  y \\<notin> R\n  E `` R \\<subseteq> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (rel_restrict E R)\\<^sup>+", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> E; x \\<notin> R; y \\<notin> R;\n        E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "case base"], ["proof (state)\nthis:\n  (x, y_) \\<in> E\n  x \\<notin> R\n  y_ \\<notin> R\n  E `` R \\<subseteq> R\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> E; x \\<notin> R; y \\<notin> R;\n        E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y_) \\<in> E\n  x \\<notin> R\n  y_ \\<notin> R\n  E `` R \\<subseteq> R\n\ngoal (1 subgoal):\n 1. (x, y_) \\<in> (rel_restrict E R)\\<^sup>+", "by (metis r_into_trancl rel_restrictI)"], ["proof (state)\nthis:\n  (x, y_) \\<in> (rel_restrict E R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> E\\<^sup>+\n  (y, z) \\<in> E\n  \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n  x \\<notin> R\n  z \\<notin> R\n  E `` R \\<subseteq> R\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "hence \"y \\<notin> R\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> E\\<^sup>+\n  (y, z) \\<in> E\n  \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n  x \\<notin> R\n  z \\<notin> R\n  E `` R \\<subseteq> R\n\ngoal (1 subgoal):\n 1. y \\<notin> R", "by auto"], ["proof (state)\nthis:\n  y \\<notin> R\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> E\\<^sup>+; (y, z) \\<in> E;\n        \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n        \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+;\n        x \\<notin> R; z \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "with step"], ["proof (chain)\npicking this:\n  (x, y) \\<in> E\\<^sup>+\n  (y, z) \\<in> E\n  \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n  x \\<notin> R\n  z \\<notin> R\n  E `` R \\<subseteq> R\n  y \\<notin> R", "show ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> E\\<^sup>+\n  (y, z) \\<in> E\n  \\<lbrakk>x \\<notin> R; y \\<notin> R; E `` R \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (rel_restrict E R)\\<^sup>+\n  x \\<notin> R\n  z \\<notin> R\n  E `` R \\<subseteq> R\n  y \\<notin> R\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> (rel_restrict E R)\\<^sup>+", "by (metis trancl_into_trancl rel_restrictI)"], ["proof (state)\nthis:\n  (x, z) \\<in> (rel_restrict E R)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Single-Valued Relations\\<close>"], ["", "lemma single_valued_inter1: \"single_valued R \\<Longrightarrow> single_valued (R\\<inter>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow> single_valued (R \\<inter> S)", "by (auto intro: single_valuedI dest: single_valuedD)"], ["", "lemma single_valued_inter2: \"single_valued R \\<Longrightarrow> single_valued (S\\<inter>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow> single_valued (S \\<inter> R)", "by (auto intro: single_valuedI dest: single_valuedD)"], ["", "lemma single_valued_below_Id: \"R\\<subseteq>Id \\<Longrightarrow> single_valued R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> Id \\<Longrightarrow> single_valued R", "by (auto intro: single_valuedI)"], ["", "subsubsection \\<open>Bijective Relations\\<close>"], ["", "definition \"bijective R \\<equiv>\n  (\\<forall>x y z. (x,y)\\<in>R \\<and> (x,z)\\<in>R \\<longrightarrow> y=z) \\<and>\n  (\\<forall>x y z. (x,z)\\<in>R \\<and> (y,z)\\<in>R \\<longrightarrow> x=y)\""], ["", "lemma bijective_alt: \"bijective R \\<longleftrightarrow> single_valued R \\<and> single_valued (R\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective R = (single_valued R \\<and> single_valued (R\\<inverse>))", "unfolding bijective_def single_valued_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x y z.\n         (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow>\n         y = z) \\<and>\n     (\\<forall>x y z.\n         (x, z) \\<in> R \\<and> (y, z) \\<in> R \\<longrightarrow> x = y)) =\n    ((\\<forall>x y.\n         (x, y) \\<in> R \\<longrightarrow>\n         (\\<forall>z. (x, z) \\<in> R \\<longrightarrow> y = z)) \\<and>\n     (\\<forall>x y.\n         (x, y) \\<in> R\\<inverse> \\<longrightarrow>\n         (\\<forall>z. (x, z) \\<in> R\\<inverse> \\<longrightarrow> y = z)))", "by blast"], ["", "lemma bijective_Id[simp, intro!]: \"bijective Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective Id", "by (auto simp: bijective_def)"], ["", "lemma bijective_Empty[simp, intro!]: \"bijective {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective {}", "by (auto simp: bijective_def)"], ["", "subsubsection \\<open>Miscellaneous\\<close>"], ["", "lemma pair_vimage_is_Image[simp]: \"(Pair u -` E) = E``{u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pair u -` E = E `` {u}", "by auto"], ["", "lemma fst_in_Field: \"fst ` R \\<subseteq> Field R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` R \\<subseteq> Field R", "by (simp add: Field_def fst_eq_Domain)"], ["", "lemma snd_in_Field: \"snd ` R \\<subseteq> Field R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` R \\<subseteq> Field R", "by (simp add: Field_def snd_eq_Range)"], ["", "lemma ran_map_of:\n  \"ran (map_of xs) \\<subseteq> snd ` set (xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_of xs) \\<subseteq> snd ` set xs", "by (induct xs) (auto simp add: ran_def)"], ["", "lemma Image_subset_snd_image:\n  \"A `` B \\<subseteq> snd ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A `` B \\<subseteq> snd ` A", "unfolding Image_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>B. (x, y) \\<in> A}\n    \\<subseteq> {y. \\<exists>x\\<in>A. y = snd x}", "by force"], ["", "lemma finite_Image_subset:\n  \"finite (A `` B) \\<Longrightarrow> C \\<subseteq> A \\<Longrightarrow> finite (C `` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (A `` B); C \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> finite (C `` B)", "by (metis Image_mono order_refl rev_finite_subset)"], ["", "lemma finite_Field_eq_finite[simp]: \"finite (Field R) \\<longleftrightarrow> finite R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Field R) = finite R", "by (metis finite_cartesian_product finite_subset R_subset_Field finite_Field)"], ["", "definition \"fun_of_rel R x \\<equiv> SOME y. (x,y)\\<in>R\""], ["", "lemma for_in_RI(*[intro]*): \"x\\<in>Domain R \\<Longrightarrow> (x,fun_of_rel R x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Domain R \\<Longrightarrow> (x, fun_of_rel R x) \\<in> R", "unfolding fun_of_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Domain R \\<Longrightarrow> (x, SOME y. (x, y) \\<in> R) \\<in> R", "by (auto intro: someI)"], ["", "lemma Field_not_elem:\n  \"v \\<notin> Field R \\<Longrightarrow> \\<forall>(x,y) \\<in> R. x \\<noteq> v \\<and> y \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> Field R \\<Longrightarrow>\n    \\<forall>(x, y)\\<in>R. x \\<noteq> v \\<and> y \\<noteq> v", "unfolding Field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> Domain R \\<union> Range R \\<Longrightarrow>\n    \\<forall>(x, y)\\<in>R. x \\<noteq> v \\<and> y \\<noteq> v", "by auto"], ["", "lemma Sigma_UNIV_cancel[simp]: \"(A \\<times> X - A \\<times> UNIV) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times> X - A \\<times> UNIV = {}", "by auto"], ["", "lemma same_fst_trancl[simp]: \"(same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "assume \"(x,y)\\<in>(same_fst P R)\\<^sup>+\""], ["proof (state)\nthis:\n  (x, y) \\<in> (same_fst P R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "hence \"(x,y)\\<in>same_fst P (\\<lambda>x. (R x)\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (same_fst P R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "by induction (auto simp: same_fst_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> (same_fst P R)\\<^sup>+ \\<Longrightarrow>\n  (?x2, ?y2) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> (same_fst P R)\\<^sup>+ \\<Longrightarrow>\n  (?x2, ?y2) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "{"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> (same_fst P R)\\<^sup>+ \\<Longrightarrow>\n  (?x2, ?y2) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "fix f f' x y"], ["proof (state)\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "assume \"((f,x),(f',y))\\<in>same_fst P (\\<lambda>x. (R x)\\<^sup>+)\""], ["proof (state)\nthis:\n  ((f, x), f', y) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "hence [simp]: \"f'=f\" \"P f\" and 1: \"(x,y)\\<in>(R f)\\<^sup>+\""], ["proof (prove)\nusing this:\n  ((f, x), f', y) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (f' = f &&& P f) &&& (x, y) \\<in> (R f)\\<^sup>+", "by (auto simp: same_fst_def)"], ["proof (state)\nthis:\n  f' = f\n  P f\n  (x, y) \\<in> (R f)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "from 1"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (R f)\\<^sup>+", "have \"((f,x),(f',y))\\<in>(same_fst P R)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (R f)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ((f, x), f', y) \\<in> (same_fst P R)\\<^sup>+", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (x, y) \\<in> R f \\<Longrightarrow>\n       ((f, x), f', y) \\<in> (same_fst P R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (R f)\\<^sup>+; (y, z) \\<in> R f;\n        ((f, x), f', y) \\<in> (same_fst P R)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> ((f, x), f', z) \\<in> (same_fst P R)\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y_) \\<in> R f \\<Longrightarrow>\n    ((f, x), f', y_) \\<in> (same_fst P R)\\<^sup>+", "by (rule r_into_trancl) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (R f)\\<^sup>+; (y, z) \\<in> R f;\n        ((f, x), f', y) \\<in> (same_fst P R)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> ((f, x), f', z) \\<in> (same_fst P R)\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y_) \\<in> (R f)\\<^sup>+; (y_, z_) \\<in> R f;\n     ((f, x), f', y_) \\<in> (same_fst P R)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> ((f, x), f', z_) \\<in> (same_fst P R)\\<^sup>+", "by (erule trancl_into_trancl) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((f, x), f', y) \\<in> (same_fst P R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "}"], ["proof (state)\nthis:\n  ((?f2, ?x2), ?f'2, ?y2)\n  \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+) \\<Longrightarrow>\n  ((?f2, ?x2), ?f'2, ?y2) \\<in> (same_fst P R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "ultimately"], ["proof (chain)\npicking this:\n  (?x2, ?y2) \\<in> (same_fst P R)\\<^sup>+ \\<Longrightarrow>\n  (?x2, ?y2) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n  ((?f2, ?x2), ?f'2, ?y2)\n  \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+) \\<Longrightarrow>\n  ((?f2, ?x2), ?f'2, ?y2) \\<in> (same_fst P R)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> (same_fst P R)\\<^sup>+ \\<Longrightarrow>\n  (?x2, ?y2) \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n  ((?f2, ?x2), ?f'2, ?y2)\n  \\<in> same_fst P (\\<lambda>x. (R x)\\<^sup>+) \\<Longrightarrow>\n  ((?f2, ?x2), ?f'2, ?y2) \\<in> (same_fst P R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)", "by auto"], ["proof (state)\nthis:\n  (same_fst P R)\\<^sup>+ = same_fst P (\\<lambda>x. (R x)\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>option\\<close> Datatype\\<close>"], ["", "lemma le_some_optE: \"\\<lbrakk>Some m\\<le>x; !!m'. \\<lbrakk>x=Some m'; m\\<le>m'\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some m \\<le> x;\n     \\<And>m'.\n        \\<lbrakk>x = Some m'; m \\<le> m'\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases x) auto"], ["", "lemma not_Some_eq2[simp]: \"(\\<forall>x y. v \\<noteq> Some (x,y)) = (v = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. v \\<noteq> Some (x, y)) = (v = None)", "by (cases v) auto"], ["", "subsection \"Maps\""], ["", "primrec the_default where\n    \"the_default _ (Some x) = x\"\n  | \"the_default x None = x\""], ["", "declare map_add_dom_app_simps[simp]"], ["", "declare map_add_upd_left[simp]"], ["", "lemma ran_add[simp]: \"dom f \\<inter> dom g = {} \\<Longrightarrow> ran (f++g) = ran f \\<union> ran g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom f \\<inter> dom g = {} \\<Longrightarrow>\n    ran (f ++ g) = ran f \\<union> ran g", "by (fastforce simp add: ran_def map_add_def split: option.split_asm option.split)"], ["", "lemma nempty_dom: \"\\<lbrakk>e\\<noteq>Map.empty; !!m. m\\<in>dom e \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<noteq> Map.empty;\n     \\<And>m. m \\<in> dom e \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (subgoal_tac \"dom e \\<noteq> {}\") (blast, auto)"], ["", "lemma le_map_dom_mono: \"m\\<le>m' \\<Longrightarrow> dom m \\<subseteq> dom m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow> dom m \\<subseteq> dom m'", "apply (safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>m \\<le> m'; m x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m' x = Some y", "apply (drule_tac x=x in le_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>m x = Some y; m x \\<le> m' x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m' x = Some y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>m x = Some y; Some y \\<le> m' x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m' x = Some y", "apply (erule le_some_optE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y m'a.\n       \\<lbrakk>m x = Some y; m' x = Some m'a; y \\<le> m'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m' x = Some y", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_add_first_le: fixes m::\"'a\\<rightharpoonup>('b::order)\" shows \"\\<lbrakk> m\\<le>m' \\<rbrakk> \\<Longrightarrow> m++n \\<le> m'++n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow> m ++ n \\<le> m' ++ n", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. m \\<le> m' \\<Longrightarrow> (m ++ n) x \\<le> (m' ++ n) x", "apply (auto simp add: map_add_def split: option.split elim: le_funE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_add_distinct_le: shows \"\\<lbrakk> m\\<le>m'; n\\<le>n'; dom m' \\<inter> dom n' = {} \\<rbrakk> \\<Longrightarrow> m++n \\<le> m'++n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {}\\<rbrakk>\n    \\<Longrightarrow> m ++ n \\<le> m' ++ n'", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {}\\<rbrakk>\n       \\<Longrightarrow> (m ++ n) x \\<le> (m' ++ n') x", "apply (auto simp add: map_add_def split: option.split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = None; n' x = None\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> m' x\n 2. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = None; n' x = Some x2\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 3. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 4. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (fastforce elim: le_funE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = None; n' x = Some x2\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 2. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 3. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (drule le_map_dom_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>n \\<le> n'; dom m' \\<inter> dom n' = {}; n x = None;\n        n' x = Some x2; dom m \\<subseteq> dom m'\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 2. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 3. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (drule le_map_dom_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>dom m' \\<inter> dom n' = {}; n x = None; n' x = Some x2;\n        dom m \\<subseteq> dom m'; dom n \\<subseteq> dom n'\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 2. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 3. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (case_tac \"m x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>dom m' \\<inter> dom n' = {}; n x = None; n' x = Some x2;\n        dom m \\<subseteq> dom m'; dom n \\<subseteq> dom n';\n        m x = None\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 2. \\<And>x x2 a.\n       \\<lbrakk>dom m' \\<inter> dom n' = {}; n x = None; n' x = Some x2;\n        dom m \\<subseteq> dom m'; dom n \\<subseteq> dom n';\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 3. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 4. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x2 a.\n       \\<lbrakk>dom m' \\<inter> dom n' = {}; n x = None; n' x = Some x2;\n        dom m \\<subseteq> dom m'; dom n \\<subseteq> dom n';\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> m x \\<le> Some x2\n 2. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 3. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = None\\<rbrakk>\n       \\<Longrightarrow> Some x2 \\<le> m' x\n 2. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (fastforce dest!: le_map_dom_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2 x2a.\n       \\<lbrakk>m \\<le> m'; n \\<le> n'; dom m' \\<inter> dom n' = {};\n        n x = Some x2; n' x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (erule le_funE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2 x2a.\n       \\<lbrakk>n \\<le> n'; dom m' \\<inter> dom n' = {}; n x = Some x2;\n        n' x = Some x2a;\n        m (?x111 x x2 x2a) \\<le> m' (?x111 x x2 x2a)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply (erule_tac x=x in le_funE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2 x2a.\n       \\<lbrakk>dom m' \\<inter> dom n' = {}; n x = Some x2; n' x = Some x2a;\n        m (?x111 x x2 x2a) \\<le> m' (?x111 x x2 x2a);\n        n x \\<le> n' x\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> x2a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_add_left_comm: assumes A: \"dom A \\<inter> dom B = {}\" shows \"A ++ (B ++ C) = B ++ (A ++ C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "have \"A ++ (B ++ C) = (A++B)++C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = A ++ B ++ C", "by simp"], ["proof (state)\nthis:\n  A ++ (B ++ C) = A ++ B ++ C\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "also"], ["proof (state)\nthis:\n  A ++ (B ++ C) = A ++ B ++ C\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "have \"\\<dots> = (B++A)++C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ++ B ++ C = B ++ A ++ C", "by (simp add: map_add_comm[OF A])"], ["proof (state)\nthis:\n  A ++ B ++ C = B ++ A ++ C\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "also"], ["proof (state)\nthis:\n  A ++ B ++ C = B ++ A ++ C\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "have \"\\<dots> = B++(A++C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B ++ A ++ C = B ++ (A ++ C)", "by simp"], ["proof (state)\nthis:\n  B ++ A ++ C = B ++ (A ++ C)\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "finally"], ["proof (chain)\npicking this:\n  A ++ (B ++ C) = B ++ (A ++ C)", "show ?thesis"], ["proof (prove)\nusing this:\n  A ++ (B ++ C) = B ++ (A ++ C)\n\ngoal (1 subgoal):\n 1. A ++ (B ++ C) = B ++ (A ++ C)", "."], ["proof (state)\nthis:\n  A ++ (B ++ C) = B ++ (A ++ C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas map_add_ac = map_add_assoc map_add_comm map_add_left_comm"], ["", "lemma le_map_restrict[simp]: fixes m :: \"'a \\<rightharpoonup> ('b::order)\" shows \"m |` X \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` X \\<le> m", "by (rule le_funI) (simp add: restrict_map_def)"], ["", "lemma map_of_distinct_upd:\n  \"x \\<notin> set (map fst xs) \\<Longrightarrow> [x \\<mapsto> y] ++ map_of xs = (map_of xs) (x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (map fst xs) \\<Longrightarrow>\n    [x \\<mapsto> y] ++ map_of xs = map_of xs(x \\<mapsto> y)", "by (induct xs) (auto simp add: fun_upd_twist)"], ["", "lemma map_of_distinct_upd2:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys))(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (map fst xs);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \n                      \\<mapsto> y)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (map fst []);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of ([] @ (x, y) # ys) = map_of ([] @ ys)(x \n                      \\<mapsto> y)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ (x, y) # ys) =\n                                  map_of (xs @ ys)(x \\<mapsto> y);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ (x, y) # ys) =\n                         map_of ((a # xs) @ ys)(x \\<mapsto> y)", "apply (auto intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_distinct_upd3:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ (x,y') # ys))(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ (x, y') # ys)(x \\<mapsto> y)", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (map fst xs);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (xs @ (x, y) # ys) = map_of (xs @ (x, y') # ys)\n                      (x \\<mapsto> y)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (map fst []);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of ([] @ (x, y) # ys) = map_of ([] @ (x, y') # ys)\n                      (x \\<mapsto> y)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ (x, y) # ys) =\n                                  map_of (xs @ (x, y') # ys)(x \\<mapsto> y);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ (x, y) # ys) =\n                         map_of ((a # xs) @ (x, y') # ys)(x \\<mapsto> y)", "apply (auto intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_distinct_upd4:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ ys) = (map_of (xs @ (x,y) # ys))(x := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ ys) = (map_of (xs @ (x, y) # ys))(x := None)", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> set (map fst xs)\n  x \\<notin> set (map fst ys)\n\ngoal (1 subgoal):\n 1. map_of (xs @ ys) = (map_of (xs @ (x, y) # ys))(x := None)", "by (induct xs) (auto simp: map_of_eq_None_iff)"], ["", "lemma map_of_distinct_lookup:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "have \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys)) (x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "using assms map_of_distinct_upd2"], ["proof (prove)\nusing this:\n  x \\<notin> set (map fst xs)\n  x \\<notin> set (map fst ys)\n  \\<lbrakk>?x \\<notin> set (map fst ?xs);\n   ?x \\<notin> set (map fst ?ys)\\<rbrakk>\n  \\<Longrightarrow> map_of (?xs @ (?x, ?y) # ?ys) = map_of (?xs @ ?ys)(?x \n                    \\<mapsto> ?y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "by simp"], ["proof (state)\nthis:\n  map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "by simp"], ["proof (state)\nthis:\n  map_of (xs @ (x, y) # ys) x = Some y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ran_distinct:\n  assumes dist: \"distinct (map fst al)\"\n  shows \"ran (map_of al) = snd ` set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst al)\n\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "proof (induct al)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> ran (map_of []) = snd ` set []\n 2. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> ran (map_of []) = snd ` set []\n 2. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. ran (map_of []) = snd ` set []", "by simp"], ["proof (state)\nthis:\n  ran (map_of []) = snd ` set []\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "case (Cons kv al)"], ["proof (state)\nthis:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))", "have \"ran (map_of al) = snd ` set al\""], ["proof (prove)\nusing this:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "by simp"], ["proof (state)\nthis:\n  ran (map_of al) = snd ` set al\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "moreover"], ["proof (state)\nthis:\n  ran (map_of al) = snd ` set al\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "from Cons.prems"], ["proof (chain)\npicking this:\n  distinct (map fst (kv # al))", "have \"map_of al (fst kv) = None\""], ["proof (prove)\nusing this:\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. map_of al (fst kv) = None", "by (simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  map_of al (fst kv) = None\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "ultimately"], ["proof (chain)\npicking this:\n  ran (map_of al) = snd ` set al\n  map_of al (fst kv) = None", "show ?case"], ["proof (prove)\nusing this:\n  ran (map_of al) = snd ` set al\n  map_of al (fst kv) = None\n\ngoal (1 subgoal):\n 1. ran (map_of (kv # al)) = snd ` set (kv # al)", "by (simp only: map_of.simps ran_map_upd) simp"], ["proof (state)\nthis:\n  ran (map_of (kv # al)) = snd ` set (kv # al)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ran_is_image:\n  \"ran M = (the \\<circ> M) ` (dom M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran M = (the \\<circ> M) ` dom M", "unfolding ran_def dom_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a. M a = Some b} =\n    {y. \\<exists>x\\<in>{a. M a \\<noteq> None}. y = (the \\<circ> M) x}", "by auto"], ["", "lemma map_card_eq_iff:\n  assumes finite: \"finite (dom M)\"\n  and card_eq: \"card (dom M) = card (ran M)\"\n  and indom: \"x \\<in> dom M\"\n  shows \"(M x = M y) \\<longleftrightarrow> (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "from ran_is_image finite card_eq"], ["proof (chain)\npicking this:\n  ran ?M = (the \\<circ> ?M) ` dom ?M\n  finite (dom M)\n  card (dom M) = card (ran M)", "have *: \"inj_on (the \\<circ> M) (dom M)\""], ["proof (prove)\nusing this:\n  ran ?M = (the \\<circ> ?M) ` dom ?M\n  finite (dom M)\n  card (dom M) = card (ran M)\n\ngoal (1 subgoal):\n 1. inj_on (the \\<circ> M) (dom M)", "using eq_card_imp_inj_on"], ["proof (prove)\nusing this:\n  ran ?M = (the \\<circ> ?M) ` dom ?M\n  finite (dom M)\n  card (dom M) = card (ran M)\n  \\<lbrakk>finite ?A; card (?f ` ?A) = card ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on (the \\<circ> M) (dom M)", "by metis"], ["proof (state)\nthis:\n  inj_on (the \\<circ> M) (dom M)\n\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (the \\<circ> M) (dom M)\n\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "proof (cases \"y \\<in> dom M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)\n 2. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<notin> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "case False"], ["proof (state)\nthis:\n  y \\<notin> dom M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)\n 2. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<notin> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "with indom"], ["proof (chain)\npicking this:\n  x \\<in> dom M\n  y \\<notin> dom M", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> dom M\n  y \\<notin> dom M\n\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "by auto"], ["proof (state)\nthis:\n  (M x = M y) = (x = y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "case True"], ["proof (state)\nthis:\n  y \\<in> dom M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "with indom"], ["proof (chain)\npicking this:\n  x \\<in> dom M\n  y \\<in> dom M", "have \"the (M x) = the (M y) \\<longleftrightarrow> (x = y)\""], ["proof (prove)\nusing this:\n  x \\<in> dom M\n  y \\<in> dom M\n\ngoal (1 subgoal):\n 1. (the (M x) = the (M y)) = (x = y)", "using inj_on_eq_iff[OF *]"], ["proof (prove)\nusing this:\n  x \\<in> dom M\n  y \\<in> dom M\n  \\<lbrakk>?x \\<in> dom M; ?y \\<in> dom M\\<rbrakk>\n  \\<Longrightarrow> ((the \\<circ> M) ?x = (the \\<circ> M) ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. (the (M x) = the (M y)) = (x = y)", "by auto"], ["proof (state)\nthis:\n  (the (M x) = the (M y)) = (x = y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (the \\<circ> M) (dom M); y \\<in> dom M\\<rbrakk>\n    \\<Longrightarrow> (M x = M y) = (x = y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (the (M x) = the (M y)) = (x = y)\n\ngoal (1 subgoal):\n 1. (M x = M y) = (x = y)", "by auto"], ["proof (state)\nthis:\n  (M x = M y) = (x = y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (M x = M y) = (x = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_dom_ran_finite:\n  \"finite (dom M) \\<Longrightarrow> finite (ran M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom M) \\<Longrightarrow> finite (ran M)", "by (simp add: ran_is_image)"], ["", "lemma map_update_eta_repair[simp]:\n  (* An update operation may get simplified, if it happens to be eta-expanded.\n    This lemma tries to repair some common expressions *)\n  \"dom (\\<lambda>x. if x=k then Some v else m x) = insert k (dom m)\"\n  \"m k = None \\<Longrightarrow> ran (\\<lambda>x. if x=k then Some v else m x) = insert v (ran m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. if x = k then Some v else m x) = insert k (dom m) &&&\n    (m k = None \\<Longrightarrow>\n     ran (\\<lambda>x. if x = k then Some v else m x) = insert v (ran m))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. m k = None \\<Longrightarrow>\n    ran (\\<lambda>x. if x = k then Some v else m x) = insert v (ran m)", "apply (force simp: ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_leI[intro?]: \"\\<lbrakk>\\<And>x v. m1 x = Some v \\<Longrightarrow> m2 x = Some v\\<rbrakk> \\<Longrightarrow> m1\\<subseteq>\\<^sub>mm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v.\n        m1 x = Some v \\<Longrightarrow> m2 x = Some v) \\<Longrightarrow>\n    m1 \\<subseteq>\\<^sub>m m2", "unfolding map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v.\n        m1 x = Some v \\<Longrightarrow> m2 x = Some v) \\<Longrightarrow>\n    \\<forall>a\\<in>dom m1. m1 a = m2 a", "by force"], ["", "lemma map_leD: \"m1\\<subseteq>\\<^sub>mm2 \\<Longrightarrow> m1 k = Some v \\<Longrightarrow> m2 k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m1 \\<subseteq>\\<^sub>m m2; m1 k = Some v\\<rbrakk>\n    \\<Longrightarrow> m2 k = Some v", "unfolding map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>dom m1. m1 a = m2 a; m1 k = Some v\\<rbrakk>\n    \\<Longrightarrow> m2 k = Some v", "by force"], ["", "lemma map_restrict_insert_none_simp: \"m x = None \\<Longrightarrow> m|`(-insert x s) = m|`(-s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m x = None \\<Longrightarrow> m |` (- insert x s) = m |` (- s)", "by (auto intro!: ext simp:restrict_map_def)"], ["", "(* TODO: Move *)"], ["", "lemma eq_f_restr_conv: \"s\\<subseteq>dom (f A) \\<and> A = f A |` (-s) \\<longleftrightarrow> A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<subseteq> dom (f A) \\<and> A = f A |` (- s)) =\n    (A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s)\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq>\\<^sub>m f A\n 2. \\<And>x y.\n       \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x \\<in> s;\n        A x = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x y.\n       \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x \\<notin> s;\n        f A x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. A x = Some y\n 4. \\<lbrakk>A \\<subseteq>\\<^sub>m f A; s = dom (f A) - dom A\\<rbrakk>\n    \\<Longrightarrow> A = f A |` (- dom (f A) \\<union> dom A)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s)\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq>\\<^sub>m f A", "by (metis map_leI restrict_map_eq(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x \\<in> s;\n        A x = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x \\<notin> s;\n        f A x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. A x = Some y\n 3. \\<lbrakk>A \\<subseteq>\\<^sub>m f A; s = dom (f A) - dom A\\<rbrakk>\n    \\<Longrightarrow> A = f A |` (- dom (f A) \\<union> dom A)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x_ \\<in> s;\n     A x_ = Some y_\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis ComplD restrict_map_eq(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x \\<notin> s;\n        f A x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. A x = Some y\n 2. \\<lbrakk>A \\<subseteq>\\<^sub>m f A; s = dom (f A) - dom A\\<rbrakk>\n    \\<Longrightarrow> A = f A |` (- dom (f A) \\<union> dom A)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<subseteq> dom (f A); A = f A |` (- s); x_ \\<notin> s;\n     f A x_ = Some y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. A x_ = Some y", "by (metis Compl_iff restrict_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq>\\<^sub>m f A; s = dom (f A) - dom A\\<rbrakk>\n    \\<Longrightarrow> A = f A |` (- dom (f A) \\<union> dom A)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq>\\<^sub>m f A; s = dom (f A) - dom A\\<rbrakk>\n    \\<Longrightarrow> A = f A |` (- dom (f A) \\<union> dom A)", "by (force simp: map_le_def restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary eq_f_restr_ss_eq: \"\\<lbrakk> s\\<subseteq>dom (f A) \\<rbrakk> \\<Longrightarrow> A = f A |` (-s) \\<longleftrightarrow> A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<subseteq> dom (f A) \\<Longrightarrow>\n    (A = f A |` (- s)) =\n    (A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A)", "using eq_f_restr_conv"], ["proof (prove)\nusing this:\n  (?s \\<subseteq> dom (?f ?A) \\<and> ?A = ?f ?A |` (- ?s)) =\n  (?A \\<subseteq>\\<^sub>m ?f ?A \\<and> ?s = dom (?f ?A) - dom ?A)\n\ngoal (1 subgoal):\n 1. s \\<subseteq> dom (f A) \\<Longrightarrow>\n    (A = f A |` (- s)) =\n    (A \\<subseteq>\\<^sub>m f A \\<and> s = dom (f A) - dom A)", "by blast"], ["", "subsubsection \\<open>Simultaneous Map Update\\<close>"], ["", "definition \"map_mmupd m K v k \\<equiv> if k\\<in>K then Some v else m k\""], ["", "lemma map_mmupd_empty[simp]: \"map_mmupd m {} v = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mmupd m {} v = m", "by (auto simp: map_mmupd_def)"], ["", "lemma mmupd_in_upd[simp]: \"k\\<in>K \\<Longrightarrow> map_mmupd m K v k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> K \\<Longrightarrow> map_mmupd m K v k = Some v", "by (auto simp: map_mmupd_def)"], ["", "lemma mmupd_notin_upd[simp]: \"k\\<notin>K \\<Longrightarrow> map_mmupd m K v k = m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> K \\<Longrightarrow> map_mmupd m K v k = m k", "by (auto simp: map_mmupd_def)"], ["", "lemma map_mmupdE:\n    assumes \"map_mmupd m K v k = Some x\"\n    obtains \"k\\<notin>K\" \"m k = Some x\"\n          | \"k\\<in>K\" \"x=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>k \\<notin> K; m k = Some x\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>k \\<in> K; x = v\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  map_mmupd m K v k = Some x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>k \\<notin> K; m k = Some x\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>k \\<in> K; x = v\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: map_mmupd_def split: if_split_asm)"], ["", "lemma dom_mmupd[simp]: \"dom (map_mmupd m K v) = dom m \\<union> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_mmupd m K v) = dom m \\<union> K", "by (auto simp: map_mmupd_def split: if_split_asm)"], ["", "lemma le_map_mmupd_not_dom[simp, intro!]: \"m \\<subseteq>\\<^sub>m map_mmupd m (K-dom m) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<subseteq>\\<^sub>m map_mmupd m (K - dom m) v", "by (auto simp: map_le_def)"], ["", "lemma map_mmupd_update_less: \"K\\<subseteq>K' \\<Longrightarrow> map_mmupd m (K - dom m) v \\<subseteq>\\<^sub>m map_mmupd m (K'-dom m) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> K' \\<Longrightarrow>\n    map_mmupd m (K - dom m) v \\<subseteq>\\<^sub>m map_mmupd m (K' - dom m) v", "by (auto simp: map_le_def map_mmupd_def)"], ["", "subsection\\<open>Connection between Maps and Sets of Key-Value Pairs\\<close>"], ["", "definition map_to_set where\n  \"map_to_set m = {(k, v) . m k = Some v}\""], ["", "definition set_to_map where\n  \"set_to_map S k = Eps_Opt (\\<lambda>v. (k, v) \\<in> S)\""], ["", "lemma set_to_map_simp :\nassumes inj_on_fst: \"inj_on fst S\"\nshows \"(set_to_map S k = Some v) \\<longleftrightarrow> (k, v) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_to_map S k = Some v) = ((k, v) \\<in> S)", "proof (cases \"\\<exists>v. (k, v) \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)\n 2. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "case True"], ["proof (state)\nthis:\n  \\<exists>v. (k, v) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<exists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)\n 2. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "note kv_ex = this"], ["proof (state)\nthis:\n  \\<exists>v. (k, v) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<exists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)\n 2. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. (k, v) \\<in> S", "obtain v' where kv'_in: \"(k, v') \\<in> S\""], ["proof (prove)\nusing this:\n  \\<exists>v. (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>v'. (k, v') \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (k, v') \\<in> S\n\ngoal (2 subgoals):\n 1. \\<exists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)\n 2. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "with inj_on_fst"], ["proof (chain)\npicking this:\n  inj_on fst S\n  (k, v') \\<in> S", "have kv''_in: \"\\<And>v''. (k, v'') \\<in> S \\<longleftrightarrow> v' = v''\""], ["proof (prove)\nusing this:\n  inj_on fst S\n  (k, v') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>v''. ((k, v'') \\<in> S) = (v' = v'')", "unfolding inj_on_def Ball_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>xa.\n         xa \\<in> S \\<longrightarrow>\n         fst x = fst xa \\<longrightarrow> x = xa)\n  (k, v') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>v''. ((k, v'') \\<in> S) = (v' = v'')", "by auto"], ["proof (state)\nthis:\n  ((k, ?v'') \\<in> S) = (v' = ?v'')\n\ngoal (2 subgoals):\n 1. \\<exists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)\n 2. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_to_map S k = Some v) = ((k, v) \\<in> S)", "unfolding set_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Eps_Opt (\\<lambda>v. (k, v) \\<in> S) = Some v) = ((k, v) \\<in> S)", "by (simp add: kv_ex kv''_in)"], ["proof (state)\nthis:\n  (set_to_map S k = Some v) = ((k, v) \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "case False"], ["proof (state)\nthis:\n  \\<nexists>v. (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "hence kv''_nin: \"\\<And>v''. (k, v'') \\<notin> S\""], ["proof (prove)\nusing this:\n  \\<nexists>v. (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>v''. (k, v'') \\<notin> S", "by simp"], ["proof (state)\nthis:\n  (k, ?v'') \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<nexists>v. (k, v) \\<in> S \\<Longrightarrow>\n    (set_to_map S k = Some v) = ((k, v) \\<in> S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (k, ?v'') \\<notin> S\n\ngoal (1 subgoal):\n 1. (set_to_map S k = Some v) = ((k, v) \\<in> S)", "by (simp add: set_to_map_def)"], ["proof (state)\nthis:\n  (set_to_map S k = Some v) = ((k, v) \\<in> S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_fst_map_to_set :\n  \"inj_on fst (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst (map_to_set m)", "unfolding map_to_set_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(k, v). m k = Some v}.\n       \\<forall>y\\<in>{(k, v). m k = Some v}.\n          fst x = fst y \\<longrightarrow> x = y", "by simp"], ["", "lemma map_to_set_inverse :\n   \"set_to_map (map_to_set m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) = m", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. set_to_map (map_to_set m) x = m x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. set_to_map (map_to_set m) x = m x", "show \"set_to_map (map_to_set m) k = m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) k = m k", "proof (cases \"m k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m k = None \\<Longrightarrow> set_to_map (map_to_set m) k = m k\n 2. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "case None"], ["proof (state)\nthis:\n  m k = None\n\ngoal (2 subgoals):\n 1. m k = None \\<Longrightarrow> set_to_map (map_to_set m) k = m k\n 2. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "note mk_eq = this"], ["proof (state)\nthis:\n  m k = None\n\ngoal (2 subgoals):\n 1. m k = None \\<Longrightarrow> set_to_map (map_to_set m) k = m k\n 2. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "hence \"\\<And>v. (k, v) \\<notin> map_to_set m\""], ["proof (prove)\nusing this:\n  m k = None\n\ngoal (1 subgoal):\n 1. \\<And>v. (k, v) \\<notin> map_to_set m", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  m k = None\n\ngoal (1 subgoal):\n 1. \\<And>v. (k, v) \\<notin> {(k, v). m k = Some v}", "by simp"], ["proof (state)\nthis:\n  (k, ?v) \\<notin> map_to_set m\n\ngoal (2 subgoals):\n 1. m k = None \\<Longrightarrow> set_to_map (map_to_set m) k = m k\n 2. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "with set_to_map_simp [OF inj_on_fst_map_to_set, of m k]"], ["proof (chain)\npicking this:\n  (set_to_map (map_to_set m) k = Some ?v) = ((k, ?v) \\<in> map_to_set m)\n  (k, ?v) \\<notin> map_to_set m", "show ?thesis"], ["proof (prove)\nusing this:\n  (set_to_map (map_to_set m) k = Some ?v) = ((k, ?v) \\<in> map_to_set m)\n  (k, ?v) \\<notin> map_to_set m\n\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) k = m k", "unfolding mk_eq"], ["proof (prove)\nusing this:\n  (set_to_map (map_to_set m) k = Some ?v) = ((k, ?v) \\<in> map_to_set m)\n  (k, ?v) \\<notin> map_to_set m\n\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) k = None", "by auto"], ["proof (state)\nthis:\n  set_to_map (map_to_set m) k = m k\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "case (Some v)"], ["proof (state)\nthis:\n  m k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "note mk_eq = this"], ["proof (state)\nthis:\n  m k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "hence \"(k, v) \\<in> map_to_set m\""], ["proof (prove)\nusing this:\n  m k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> map_to_set m", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  m k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> {(k, v). m k = Some v}", "by simp"], ["proof (state)\nthis:\n  (k, v) \\<in> map_to_set m\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m k = Some a \\<Longrightarrow> set_to_map (map_to_set m) k = m k", "with set_to_map_simp [OF inj_on_fst_map_to_set, of m k v]"], ["proof (chain)\npicking this:\n  (set_to_map (map_to_set m) k = Some v) = ((k, v) \\<in> map_to_set m)\n  (k, v) \\<in> map_to_set m", "show ?thesis"], ["proof (prove)\nusing this:\n  (set_to_map (map_to_set m) k = Some v) = ((k, v) \\<in> map_to_set m)\n  (k, v) \\<in> map_to_set m\n\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) k = m k", "unfolding mk_eq"], ["proof (prove)\nusing this:\n  (set_to_map (map_to_set m) k = Some v) = ((k, v) \\<in> map_to_set m)\n  (k, v) \\<in> map_to_set m\n\ngoal (1 subgoal):\n 1. set_to_map (map_to_set m) k = Some v", "by auto"], ["proof (state)\nthis:\n  set_to_map (map_to_set m) k = m k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_to_map (map_to_set m) k = m k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_to_map_inverse :\nassumes inj_on_fst_S: \"inj_on fst S\"\nshows \"map_to_set (set_to_map S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (set_to_map S) = S", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> map_to_set (set_to_map S)) = (x \\<in> S)", "fix kv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> map_to_set (set_to_map S)) = (x \\<in> S)", "from set_to_map_simp [OF inj_on_fst_S, of \"fst kv\" \"snd kv\"]"], ["proof (chain)\npicking this:\n  (set_to_map S (fst kv) = Some (snd kv)) = ((fst kv, snd kv) \\<in> S)", "show \"(kv \\<in> map_to_set (set_to_map S)) = (kv \\<in> S)\""], ["proof (prove)\nusing this:\n  (set_to_map S (fst kv) = Some (snd kv)) = ((fst kv, snd kv) \\<in> S)\n\ngoal (1 subgoal):\n 1. (kv \\<in> map_to_set (set_to_map S)) = (kv \\<in> S)", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  (set_to_map S (fst kv) = Some (snd kv)) = ((fst kv, snd kv) \\<in> S)\n\ngoal (1 subgoal):\n 1. (kv \\<in> {(k, v). set_to_map S k = Some v}) = (kv \\<in> S)", "by auto"], ["proof (state)\nthis:\n  (kv \\<in> map_to_set (set_to_map S)) = (kv \\<in> S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_to_set_empty[simp]: \"map_to_set Map.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set Map.empty = {}", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(k, v). None = Some v} = {}", "by simp"], ["", "lemma set_to_map_empty[simp]: \"set_to_map {} = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map {} = Map.empty", "unfolding set_to_map_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. Eps_Opt (\\<lambda>v. (k, v) \\<in> {})) = Map.empty", "by simp"], ["", "lemma map_to_set_empty_iff: \"map_to_set m = {} \\<longleftrightarrow> m = Map.empty\"\n                            \"{} = map_to_set m \\<longleftrightarrow> m = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_to_set m = {}) = (m = Map.empty) &&&\n    ({} = map_to_set m) = (m = Map.empty)", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(k, v). m k = Some v} = {}) = (m = Map.empty) &&&\n    ({} = {(k, v). m k = Some v}) = (m = Map.empty)", "by auto"], ["", "lemma set_to_map_empty_iff: \"set_to_map S = Map.empty \\<longleftrightarrow> S = {}\" (is ?T1)\n                            \"Map.empty = set_to_map S \\<longleftrightarrow> S = {}\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_to_map S = Map.empty) = (S = {}) &&&\n    (Map.empty = set_to_map S) = (S = {})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (set_to_map S = Map.empty) = (S = {})\n 2. (Map.empty = set_to_map S) = (S = {})", "show T1: ?T1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_to_map S = Map.empty) = (S = {})", "apply (simp only: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_to_map S = Map.empty) = (\\<forall>x. (x \\<in> S) = (x \\<in> {}))", "apply (simp only: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. set_to_map S x = None) =\n    (\\<forall>x. (x \\<in> S) = (x \\<in> {}))", "apply (simp add: set_to_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x v. (x, v) \\<notin> S) = (S = {})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (set_to_map S = Map.empty) = (S = {})\n\ngoal (1 subgoal):\n 1. (Map.empty = set_to_map S) = (S = {})", "from T1"], ["proof (chain)\npicking this:\n  (set_to_map S = Map.empty) = (S = {})", "show ?T2"], ["proof (prove)\nusing this:\n  (set_to_map S = Map.empty) = (S = {})\n\ngoal (1 subgoal):\n 1. (Map.empty = set_to_map S) = (S = {})", "by auto"], ["proof (state)\nthis:\n  (Map.empty = set_to_map S) = (S = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_to_set_upd[simp]: \"map_to_set (m (k \\<mapsto> v)) = insert (k, v) (map_to_set m - {(k, v') |v'. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set m - {(k, v') |v'. True})", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ka, va). (m(k \\<mapsto> v)) ka = Some va} =\n    insert (k, v) ({(k, v). m k = Some v} - {(k, v') |v'. True})", "apply (simp add: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b. (v = b) = (b = v)", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_to_map_insert:\nassumes k_nin: \"fst kv \\<notin> fst ` S\"\nshows \"set_to_map (insert kv S) = (set_to_map S) (fst kv \\<mapsto> snd kv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map (insert kv S) = set_to_map S(fst kv \\<mapsto> snd kv)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       set_to_map (insert kv S) x =\n       (set_to_map S(fst kv \\<mapsto> snd kv)) x", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       set_to_map (insert kv S) x =\n       (set_to_map S(fst kv \\<mapsto> snd kv)) x", "obtain k v where kv_eq[simp]: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       set_to_map (insert kv S) x =\n       (set_to_map S(fst kv \\<mapsto> snd kv)) x", "from k_nin"], ["proof (chain)\npicking this:\n  fst kv \\<notin> fst ` S", "have k_nin': \"\\<And>v'. (k, v') \\<notin> S\""], ["proof (prove)\nusing this:\n  fst kv \\<notin> fst ` S\n\ngoal (1 subgoal):\n 1. \\<And>v'. (k, v') \\<notin> S", "by (auto simp add: image_iff Ball_def)"], ["proof (state)\nthis:\n  (k, ?v') \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       set_to_map (insert kv S) x =\n       (set_to_map S(fst kv \\<mapsto> snd kv)) x", "show \"set_to_map (insert kv S) k' = (set_to_map S(fst kv \\<mapsto> snd kv)) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map (insert kv S) k' = (set_to_map S(fst kv \\<mapsto> snd kv)) k'", "by (simp add: set_to_map_def k_nin')"], ["proof (state)\nthis:\n  set_to_map (insert kv S) k' = (set_to_map S(fst kv \\<mapsto> snd kv)) k'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_to_set_dom :\n  \"dom m = fst ` (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m = fst ` map_to_set m", "unfolding dom_def map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. m a \\<noteq> None} = fst ` {(k, v). m k = Some v}", "by (auto simp add: image_iff)"], ["", "lemma map_to_set_ran :\n  \"ran m = snd ` (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran m = snd ` map_to_set m", "unfolding ran_def map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a. m a = Some b} = snd ` {(k, v). m k = Some v}", "by (auto simp add: image_iff)"], ["", "lemma set_to_map_dom :\n  \"dom (set_to_map S) = fst ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (set_to_map S) = fst ` S", "unfolding set_to_map_def[abs_def] dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. Eps_Opt (\\<lambda>v. (a, v) \\<in> S) \\<noteq> None} = fst ` S", "by (auto simp add: image_iff Bex_def)"], ["", "lemma set_to_map_ran :\n  \"ran (set_to_map S) \\<subseteq> snd ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (set_to_map S) \\<subseteq> snd ` S", "unfolding set_to_map_def[abs_def] ran_def subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t \\<in> {b. \\<exists>a.\n                      Eps_Opt (\\<lambda>v. (a, v) \\<in> S) =\n                      Some b} \\<longrightarrow>\n       t \\<in> snd ` S", "by (auto simp add: image_iff Bex_def)\n   (metis Eps_Opt_eq_Some)"], ["", "lemma finite_map_to_set:\n\"finite (map_to_set m) = finite (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (map_to_set m) = finite (dom m)", "unfolding map_to_set_def map_to_set_dom"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(k, v). m k = Some v} = finite (fst ` {(k, v). m k = Some v})", "apply (intro iffI finite_imageI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {(k, v). m k = Some v} \\<Longrightarrow>\n    finite {(k, v). m k = Some v}\n 2. finite (fst ` {(k, v). m k = Some v}) \\<Longrightarrow>\n    finite {(k, v). m k = Some v}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst ` {(k, v). m k = Some v}) \\<Longrightarrow>\n    finite {(k, v). m k = Some v}", "apply (rule finite_imageD[of fst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (fst ` {(k, v). m k = Some v}) \\<Longrightarrow>\n    finite (fst ` {(k, v). m k = Some v})\n 2. finite (fst ` {(k, v). m k = Some v}) \\<Longrightarrow>\n    inj_on fst {(k, v). m k = Some v}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst ` {(k, v). m k = Some v}) \\<Longrightarrow>\n    inj_on fst {(k, v). m k = Some v}", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma card_map_to_set :\n  \"card (map_to_set m) = card (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_to_set m) = card (dom m)", "unfolding map_to_set_def map_to_set_dom"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(k, v). m k = Some v} = card (fst ` {(k, v). m k = Some v})", "apply (rule card_image[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst {(k, v). m k = Some v}", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_map_to_set :\n\"distinct (map fst l) \\<Longrightarrow>\n map_of l = m \\<longleftrightarrow> set l = map_to_set m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    (map_of l = m) = (set l = map_to_set m)", "proof (induct l arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       distinct (map fst []) \\<Longrightarrow>\n       (map_of [] = m) = (set [] = map_to_set m)\n 2. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       distinct (map fst []) \\<Longrightarrow>\n       (map_of [] = m) = (set [] = map_to_set m)\n 2. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. (map_of [] = m) = (set [] = map_to_set m)", "by (simp add: map_to_set_empty_iff) blast"], ["proof (state)\nthis:\n  (map_of [] = m) = (set [] = map_to_set m)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "case (Cons kv l m)"], ["proof (state)\nthis:\n  distinct (map fst l) \\<Longrightarrow>\n  (map_of l = ?m) = (set l = map_to_set ?m)\n  distinct (map fst (kv # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "obtain k v where kv_eq[simp]: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (kv # l))", "have dist_l: \"distinct (map fst l)\" and kv'_nin: \"\\<And>v'. (k, v') \\<notin> set l\""], ["proof (prove)\nusing this:\n  distinct (map fst (kv # l))\n\ngoal (1 subgoal):\n 1. distinct (map fst l) &&& (\\<And>v'. (k, v') \\<notin> set l)", "by (auto simp add: image_iff)"], ["proof (state)\nthis:\n  distinct (map fst l)\n  (k, ?v') \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "note ind_hyp = Cons(1)[OF dist_l]"], ["proof (state)\nthis:\n  (map_of l = ?m) = (set l = map_to_set ?m)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "from kv'_nin"], ["proof (chain)\npicking this:\n  (k, ?v') \\<notin> set l", "have l_eq: \"set (kv # l) = map_to_set m \\<longleftrightarrow> (set l = map_to_set (m (k := None))) \\<and> m k = Some v\""], ["proof (prove)\nusing this:\n  (k, ?v') \\<notin> set l\n\ngoal (1 subgoal):\n 1. (set (kv # l) = map_to_set m) =\n    (set l = map_to_set (m(k := None)) \\<and> m k = Some v)", "apply (simp add: map_to_set_def restrict_map_def set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'. (k, v') \\<notin> set l) \\<Longrightarrow>\n    (\\<forall>a b.\n        (a = k \\<and> b = v \\<or> (a, b) \\<in> set l) = (m a = Some b)) =\n    ((\\<forall>a.\n         a \\<noteq> k \\<longrightarrow>\n         (\\<forall>b. ((a, b) \\<in> set l) = (m a = Some b))) \\<and>\n     m k = Some v)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>v'. (k, v') \\<notin> set l;\n        \\<forall>a.\n           a \\<noteq> k \\<longrightarrow>\n           (\\<forall>b. ((a, b) \\<in> set l) = (m a = Some b));\n        m k = Some v; (a, b) \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> m a = Some b\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>v'. (k, v') \\<notin> set l;\n        \\<forall>a.\n           a \\<noteq> k \\<longrightarrow>\n           (\\<forall>b. ((a, b) \\<in> set l) = (m a = Some b));\n        m k = Some v; m a = Some b; (a, b) \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> b = v", "apply (metis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>v'. (k, v') \\<notin> set l;\n        \\<forall>a.\n           a \\<noteq> k \\<longrightarrow>\n           (\\<forall>b. ((a, b) \\<in> set l) = (m a = Some b));\n        m k = Some v; m a = Some b; (a, b) \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> b = v", "apply (metis option.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (set (kv # l) = map_to_set m) =\n  (set l = map_to_set (m(k := None)) \\<and> m k = Some v)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "from kv'_nin"], ["proof (chain)\npicking this:\n  (k, ?v') \\<notin> set l", "have m_eq: \"map_of (kv # l) = m \\<longleftrightarrow> map_of l = (m (k := None)) \\<and> m k = Some v\""], ["proof (prove)\nusing this:\n  (k, ?v') \\<notin> set l\n\ngoal (1 subgoal):\n 1. (map_of (kv # l) = m) = (map_of l = m(k := None) \\<and> m k = Some v)", "apply (simp add: fun_eq_iff restrict_map_def map_of_eq_None_iff image_iff Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'. (k, v') \\<notin> set l) \\<Longrightarrow>\n    (\\<forall>x.\n        (x = k \\<longrightarrow> Some v = m k) \\<and>\n        (x \\<noteq> k \\<longrightarrow> map_of l x = m x)) =\n    ((\\<forall>x.\n         (x = k \\<longrightarrow>\n          (\\<forall>a.\n              (\\<exists>b. (a, b) \\<in> set l) \\<longrightarrow>\n              k \\<noteq> a)) \\<and>\n         (x \\<noteq> k \\<longrightarrow> map_of l x = m x)) \\<and>\n     m k = Some v)", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (map_of (kv # l) = m) = (map_of l = m(k := None) \\<and> m k = Some v)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   (map_of l = m) = (set l = map_to_set m);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> (map_of (a # l) = m) = (set (a # l) = map_to_set m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of (kv # l) = m) = (set (kv # l) = map_to_set m)", "unfolding m_eq l_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of l = m(k := None) \\<and> m k = Some v) =\n    (set l = map_to_set (m(k := None)) \\<and> m k = Some v)", "using ind_hyp[of \"m (k := None)\"]"], ["proof (prove)\nusing this:\n  (map_of l = m(k := None)) = (set l = map_to_set (m(k := None)))\n\ngoal (1 subgoal):\n 1. (map_of l = m(k := None) \\<and> m k = Some v) =\n    (set l = map_to_set (m(k := None)) \\<and> m k = Some v)", "by metis"], ["proof (state)\nthis:\n  (map_of (kv # l) = m) = (set (kv # l) = map_to_set m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_to_set_map_of :\n\"distinct (map fst l) \\<Longrightarrow> map_to_set (map_of l) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow> map_to_set (map_of l) = set l", "by (metis map_of_map_to_set)"], ["", "subsubsection \\<open>Mapping empty set to None\\<close>"], ["", "definition \"dflt_None_set S \\<equiv> if S={} then None else Some S\""], ["", "lemma the_dflt_None_empty[simp]: \"dflt_None_set {} = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dflt_None_set {} = None", "unfolding dflt_None_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if {} = {} then None else Some {}) = None", "by simp"], ["", "lemma the_dflt_None_nonempty[simp]: \"S\\<noteq>{} \\<Longrightarrow> dflt_None_set S = Some S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> dflt_None_set S = Some S", "unfolding dflt_None_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    (if S = {} then None else Some S) = Some S", "by simp"], ["", "lemma the_dflt_None_set[simp]: \"the_default {} (dflt_None_set x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_default {} (dflt_None_set x) = x", "unfolding dflt_None_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_default {} (if x = {} then None else Some x) = x", "by auto"], ["", "subsection \\<open>Orderings\\<close>"], ["", "lemma (in order) min_arg_le[simp]:\n  \"n \\<le> min m n \\<longleftrightarrow> min m n = n\"\n  \"m \\<le> min m n \\<longleftrightarrow> min m n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<le> min m n) = (min m n = n) &&& (m \\<le> min m n) = (min m n = m)", "by (auto simp: min_def)"], ["", "lemma (in linorder) min_arg_not_ge[simp]:\n  \"\\<not> min m n < m \\<longleftrightarrow> min m n = m\"\n  \"\\<not> min m n < n \\<longleftrightarrow> min m n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> min m n < m) = (min m n = m) &&&\n    (\\<not> min m n < n) = (min m n = n)", "by (auto simp: min_def)"], ["", "lemma (in linorder) min_eq_arg[simp]:\n  \"min m n = m \\<longleftrightarrow> m\\<le>n\"\n  \"min m n = n \\<longleftrightarrow> n\\<le>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min m n = m) = (m \\<le> n) &&& (min m n = n) = (n \\<le> m)", "by (auto simp: min_def)"], ["", "lemma min_simps[simp]:\n  \"a<(b::'a::order) \\<Longrightarrow> min a b = a\"\n  \"b<(a::'a::order) \\<Longrightarrow> min a b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b \\<Longrightarrow> min a b = a) &&&\n    (b < a \\<Longrightarrow> min a b = b)", "by (auto simp add: min_def dest: less_imp_le)"], ["", "lemma (in -) min_less_self_conv[simp]: \n  \"min a b < a \\<longleftrightarrow> b < (a::_::linorder)\" \n  \"min a b < b \\<longleftrightarrow> a < (b::_::linorder)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min a b < a) = (b < a) &&& (min a b < b) = (a < b)", "by (auto simp: min_def)"], ["", "lemma ord_eq_le_eq_trans: \"\\<lbrakk> a=b; b\\<le>c; c=d \\<rbrakk> \\<Longrightarrow> a\\<le>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = b; b \\<le> c; c = d\\<rbrakk> \\<Longrightarrow> a \\<le> d", "by auto"], ["", "lemma zero_comp_diff_simps[simp]: \n  \"(0::'a::linordered_idom) \\<le> a - b \\<longleftrightarrow> b \\<le> a\" \n  \"(0::'a::linordered_idom) < a - b \\<longleftrightarrow> b < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) \\<le> a - b) = (b \\<le> a) &&& ((0::'a) < a - b) = (b < a)", "by auto"], ["", "subsubsection \\<open>Termination Measures\\<close>"], ["", "text \\<open>Lexicographic measure, assuming upper bound for second component\\<close>"], ["", "lemma mlex_fst_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a<a'\"\n  assumes \"b<N\" \"b'<N\"\n  shows \"a*N + b < a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"a*N + b + 1 \\<le> a*N + N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b + 1 \\<le> a * N + N", "using \\<open>b<N\\<close>"], ["proof (prove)\nusing this:\n  b < N\n\ngoal (1 subgoal):\n 1. a * N + b + 1 \\<le> a * N + N", "by linarith"], ["proof (state)\nthis:\n  a * N + b + 1 \\<le> a * N + N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "also"], ["proof (state)\nthis:\n  a * N + b + 1 \\<le> a * N + N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"\\<dots> \\<le> a'*N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + N \\<le> a' * N", "using \\<open>a<a'\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n\ngoal (1 subgoal):\n 1. a * N + N \\<le> a' * N", "by (metis Suc_leI ab_semigroup_add_class.add.commute \n      ab_semigroup_mult_class.mult.commute mult_Suc_right mult_le_mono2)"], ["proof (state)\nthis:\n  a * N + N \\<le> a' * N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "also"], ["proof (state)\nthis:\n  a * N + N \\<le> a' * N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"\\<dots> \\<le> a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' * N \\<le> a' * N + b'", "by auto"], ["proof (state)\nthis:\n  a' * N \\<le> a' * N + b'\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "finally"], ["proof (chain)\npicking this:\n  a * N + b + 1 \\<le> a' * N + b'", "show ?thesis"], ["proof (prove)\nusing this:\n  a * N + b + 1 \\<le> a' * N + b'\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "by auto"], ["proof (state)\nthis:\n  a * N + b < a' * N + b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mlex_leI:\n  fixes a a' b b' N :: nat\n  assumes \"a\\<le>a'\"\n  assumes \"b\\<le>b'\"\n  shows \"a*N + b \\<le> a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b \\<le> a' * N + b'", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> a'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. a * N + b \\<le> a' * N + b'", "by (auto intro!: add_mono)"], ["", "lemma mlex_snd_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a=a'\"\n  assumes \"b<b'\"\n  shows \"a*N + b < a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "using assms"], ["proof (prove)\nusing this:\n  a = a'\n  b < b'\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "by (auto)"], ["", "lemma mlex_bound:  \n  fixes a b :: nat\n  assumes \"a<A\"\n  assumes \"b<N\"\n  shows \"a*N + b < A*N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b < A * N", "using assms"], ["proof (prove)\nusing this:\n  a < A\n  b < N\n\ngoal (1 subgoal):\n 1. a * N + b < A * N", "using mlex_fst_decrI"], ["proof (prove)\nusing this:\n  a < A\n  b < N\n  \\<lbrakk>?a < ?a'; ?b < ?N; ?b' < ?N\\<rbrakk>\n  \\<Longrightarrow> ?a * ?N + ?b < ?a' * ?N + ?b'\n\ngoal (1 subgoal):\n 1. a * N + b < A * N", "by fastforce"], ["", "subsection \\<open>CCPOs\\<close>"], ["", "context ccpo\nbegin"], ["", "lemma ccpo_Sup_mono:\n  assumes C: \"Complete_Partial_Order.chain (\\<le>) A\"\n    \"Complete_Partial_Order.chain (\\<le>) B\"\n  assumes B: \"\\<forall>x\\<in>A. \\<exists>y\\<in>B. x\\<le>y\"\n  shows \"Sup A \\<le> Sup B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup A \\<le> Sup B", "proof (rule ccpo_Sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "assume \"x\\<in>A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "with B"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>A. \\<exists>y\\<in>B. x \\<le> y\n  x \\<in> A", "obtain y where I: \"y\\<in>B\" and L: \"x\\<le>y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A. \\<exists>y\\<in>B. x \\<le> y\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> B; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> B\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "note L"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "also"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "from I ccpo_Sup_upper"], ["proof (chain)\npicking this:\n  y \\<in> B\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup ?A", "have \"y\\<le>Sup B\""], ["proof (prove)\nusing this:\n  y \\<in> B\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup ?A\n\ngoal (1 subgoal):\n 1. y \\<le> Sup B", "by (blast intro: C)"], ["proof (state)\nthis:\n  y \\<le> Sup B\n\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup B", "finally"], ["proof (chain)\npicking this:\n  x \\<le> Sup B", "show \"x\\<le>Sup B\""], ["proof (prove)\nusing this:\n  x \\<le> Sup B\n\ngoal (1 subgoal):\n 1. x \\<le> Sup B", "."], ["proof (state)\nthis:\n  x \\<le> Sup B\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) A", "qed (rule C)"], ["", "lemma fixp_mono:\n  assumes M: \"monotone (\\<le>) (\\<le>) f\" \"monotone (\\<le>) (\\<le>) g\"\n  assumes LE: \"\\<And>Z. f Z \\<le> g Z\"\n  shows \"ccpo_class.fixp f \\<le> ccpo_class.fixp g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo_class.fixp f \\<le> ccpo_class.fixp g", "unfolding fixp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (ccpo_class.iterates f) \\<le> Sup (ccpo_class.iterates g)", "apply (rule ccpo_Sup_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) (ccpo_class.iterates f)\n 2. Complete_Partial_Order.chain (\\<le>) (ccpo_class.iterates g)\n 3. \\<forall>x\\<in>ccpo_class.iterates f.\n       \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "apply (rule chain_iterates M)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ccpo_class.iterates f.\n       \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "proof rule"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ccpo_class.iterates f \\<Longrightarrow>\n       \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ccpo_class.iterates f \\<Longrightarrow>\n       \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "assume \"x\\<in>ccpo_class.iterates f\""], ["proof (state)\nthis:\n  x \\<in> ccpo_class.iterates f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ccpo_class.iterates f \\<Longrightarrow>\n       \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "thus \"\\<exists>y\\<in>ccpo_class.iterates g. x\\<le>y\""], ["proof (prove)\nusing this:\n  x \\<in> ccpo_class.iterates f\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ccpo_class.iterates f;\n        \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\n 2. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "case (step x)"], ["proof (state)\nthis:\n  x \\<in> ccpo_class.iterates f\n  \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ccpo_class.iterates f;\n        \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\n 2. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "then"], ["proof (chain)\npicking this:\n  x \\<in> ccpo_class.iterates f\n  \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y", "obtain y where I: \"y\\<in>ccpo_class.iterates g\" and L: \"x\\<le>y\""], ["proof (prove)\nusing this:\n  x \\<in> ccpo_class.iterates f\n  \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> ccpo_class.iterates g\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ccpo_class.iterates f;\n        \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\n 2. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "hence \"g y \\<in> ccpo_class.iterates g\" and \"f x \\<le> g y\""], ["proof (prove)\nusing this:\n  y \\<in> ccpo_class.iterates g\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. g y \\<in> ccpo_class.iterates g &&& f x \\<le> g y", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> g y \\<in> ccpo_class.iterates g\n 2. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f x \\<le> g y", "apply (erule iterates.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f x \\<le> g y", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f x \\<le> ?y5\n 2. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ?y5 \\<le> g y", "apply (erule monotoneD[OF M(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> ccpo_class.iterates g; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f y \\<le> g y", "apply (rule LE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  g y \\<in> ccpo_class.iterates g\n  f x \\<le> g y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ccpo_class.iterates f;\n        \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\n 2. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "thus \"\\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\""], ["proof (prove)\nusing this:\n  g y \\<in> ccpo_class.iterates g\n  f x \\<le> g y\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y", ".."], ["proof (state)\nthis:\n  \\<exists>y\\<in>ccpo_class.iterates g. f x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "case (Sup M)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) M\n  \\<forall>x\\<in>M.\n     x \\<in> ccpo_class.iterates f \\<and>\n     (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "define N where \"N = {SOME y. y\\<in>ccpo_class.iterates g \\<and> x\\<le>y | x. x\\<in>M}\""], ["proof (state)\nthis:\n  N = {SOME y. y \\<in> ccpo_class.iterates g \\<and> x \\<le> y |x. x \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "have N1: \"\\<forall>y\\<in>N. y\\<in>ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x\\<le>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>N.\n       y \\<in> ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x \\<le> y)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{SOME y. y \\<in> ccpo_class.iterates g \\<and> x \\<le> y |\n                    x. x \\<in> M}.\n       y \\<in> ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x \\<le> y)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       (SOME y. y \\<in> ccpo_class.iterates g \\<and> x \\<le> y)\n       \\<in> ccpo_class.iterates g\n 2. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       \\<exists>xa\\<in>M.\n          xa \\<le> (SOME y. y \\<in> ccpo_class.iterates g \\<and> x \\<le> y)", "apply (metis (lifting) Sup.hyps(2) tfl_some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       \\<exists>xa\\<in>M.\n          xa \\<le> (SOME y. y \\<in> ccpo_class.iterates g \\<and> x \\<le> y)", "by (metis (lifting) Sup.hyps(2) tfl_some)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>N.\n     y \\<in> ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "have N2: \"\\<forall>x\\<in>M. \\<exists>y\\<in>N. x\\<le>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M. \\<exists>y\\<in>N. x \\<le> y", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M.\n       \\<exists>y\\<in>{SOME y.\n                          y \\<in> ccpo_class.iterates g \\<and> x \\<le> y |\n                       x. x \\<in> M}.\n          x \\<le> y", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>x.\n              xa =\n              (SOME y.\n                  y \\<in> ccpo_class.iterates g \\<and> x \\<le> y) \\<and>\n              x \\<in> M) \\<and>\n          x \\<le> xa", "by (metis (lifting) Sup.hyps(2) tfl_some)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>M. \\<exists>y\\<in>N. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "have \"N \\<subseteq> ccpo_class.iterates g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq> ccpo_class.iterates g", "using Sup"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  \\<forall>x\\<in>M.\n     x \\<in> ccpo_class.iterates f \\<and>\n     (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\n\ngoal (1 subgoal):\n 1. N \\<subseteq> ccpo_class.iterates g", "using N1"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  \\<forall>x\\<in>M.\n     x \\<in> ccpo_class.iterates f \\<and>\n     (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\n  \\<forall>y\\<in>N.\n     y \\<in> ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x \\<le> y)\n\ngoal (1 subgoal):\n 1. N \\<subseteq> ccpo_class.iterates g", "by auto"], ["proof (state)\nthis:\n  N \\<subseteq> ccpo_class.iterates g\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "hence C_chain: \"Complete_Partial_Order.chain (\\<le>) N\""], ["proof (prove)\nusing this:\n  N \\<subseteq> ccpo_class.iterates g\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) N", "using chain_iterates[OF M(2)]"], ["proof (prove)\nusing this:\n  N \\<subseteq> ccpo_class.iterates g\n  Complete_Partial_Order.chain (\\<le>) (ccpo_class.iterates g)\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) N", "unfolding chain_def"], ["proof (prove)\nusing this:\n  N \\<subseteq> ccpo_class.iterates g\n  \\<forall>x\\<in>ccpo_class.iterates g.\n     \\<forall>y\\<in>ccpo_class.iterates g. x \\<le> y \\<or> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>N. \\<forall>y\\<in>N. x \\<le> y \\<or> y \\<le> x", "by auto"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) N\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "have \"Sup N \\<in> ccpo_class.iterates g\" and \"Sup M \\<le> Sup N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup N \\<in> ccpo_class.iterates g &&& Sup M \\<le> Sup N", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. Sup N \\<in> ccpo_class.iterates g\n 2. Sup M \\<le> Sup N", "apply (rule iterates.Sup[OF C_chain])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>N. x \\<in> ccpo_class.iterates g\n 2. Sup M \\<le> Sup N", "using N1"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>N.\n     y \\<in> ccpo_class.iterates g \\<and> (\\<exists>x\\<in>M. x \\<le> y)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>N. x \\<in> ccpo_class.iterates g\n 2. Sup M \\<le> Sup N", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup M \\<le> Sup N", "apply (rule ccpo_Sup_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) M\n 2. Complete_Partial_Order.chain (\\<le>) N\n 3. \\<forall>x\\<in>M. \\<exists>y\\<in>N. x \\<le> y", "apply (rule Sup.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) N\n 2. \\<forall>x\\<in>M. \\<exists>y\\<in>N. x \\<le> y", "apply (rule C_chain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M. \\<exists>y\\<in>N. x \\<le> y", "apply (rule N2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Sup N \\<in> ccpo_class.iterates g\n  Sup M \\<le> Sup N\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) M;\n        \\<forall>x\\<in>M.\n           x \\<in> ccpo_class.iterates f \\<and>\n           (\\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "thus ?case"], ["proof (prove)\nusing this:\n  Sup N \\<in> ccpo_class.iterates g\n  Sup M \\<le> Sup N\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y\\<in>ccpo_class.iterates g. Sup M \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>ccpo_class.iterates g. x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Code\\<close>"], ["", "text \\<open>Constant for code-abort. If that gets executed, an abort-exception is raised.\\<close>"], ["", "definition [simp]: \"CODE_ABORT f = f ()\""], ["", "declare [[code abort: CODE_ABORT]]"], ["", "end"]]}