{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Lib/Refine_Util.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma shift_lambda_left: \"(f \\<equiv> \\<lambda>x. g x) \\<Longrightarrow> (\\<And>x. f x \\<equiv> g x)\""], "translations": [["", "lemma shift_lambda_left: \"(f \\<equiv> \\<lambda>x. g x) \\<Longrightarrow> (\\<And>x. f x \\<equiv> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<equiv> g \\<Longrightarrow> (\\<And>x. f x \\<equiv> g x)", "by simp"], ["", "ML \\<open>\n  infix 0 THEN_ELSE' THEN_ELSE_COMB'\n  infix 1 THEN_ALL_NEW_FWD THEN_INTERVAL\n  infix 2 ORELSE_INTERVAL\n  infix 3 ->>\n\n  signature BASIC_REFINE_UTIL = sig\n    include BASIC_REFINE_UTIL\n    (* Resolution with matching *)\n    val RSm: Proof.context -> thm -> thm -> thm\n\n    val is_Abs: term -> bool\n    val is_Comb: term -> bool\n    val has_Var: term -> bool\n\n    val is_TFree: typ -> bool\n\n    val is_def_thm: thm -> bool\n\n    (* Tacticals *)\n    type tactic' = int -> tactic\n    type itactic = int -> int -> tactic\n\n    val IF_EXGOAL: (int -> tactic) -> tactic'\n    val COND': (term -> bool) -> tactic'\n    val CONCL_COND': (term -> bool) -> tactic'\n    \n    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'\n    val THEN_ELSE_COMB': \n      tactic' * ((tactic'*tactic'->tactic') * tactic' * tactic') -> tactic'\n\n    val INTERVAL_FWD: tactic' -> int -> int -> tactic\n    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'\n    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'\n    val REPEAT_DETERM': tactic' -> tactic'\n    val REPEAT': tactic' -> tactic'\n    val ALL_GOALS_FWD': tactic' -> tactic'\n    val ALL_GOALS_FWD: tactic' -> tactic\n\n    val APPEND_LIST': tactic' list -> tactic'\n\n    val SINGLE_INTERVAL: itactic -> tactic'\n    val THEN_INTERVAL: itactic * itactic -> itactic\n    val ORELSE_INTERVAL: itactic * itactic -> itactic\n\n    val CAN': tactic' -> tactic'\n\n    val NTIMES': tactic' -> int -> tactic'\n\n    (* Only consider results that solve subgoal. If none, return all results unchanged. *)\n    val TRY_SOLVED': tactic' -> tactic'\n\n    (* Case distinction with tactics. Generalization of THEN_ELSE to lists. *)\n    val CASES': (tactic' * tactic) list -> tactic'\n\n    (* Tactic that depends on subgoal term structure *)\n    val WITH_subgoal: (term -> tactic') -> tactic'\n    (* Tactic that depends on subgoal's conclusion term structure *)\n    val WITH_concl: (term -> tactic') -> tactic'\n\n    (* Tactic version of Variable.trade. Import, apply tactic, and export results.\n      One effect is that schematic variables in the goal are fixed, and thus cannot \n      be instantiated by the tactic.\n    *)\n    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'\n\n\n    (* Tactics *)\n    val fo_rtac: thm -> Proof.context -> tactic'\n    val fo_resolve_tac: thm list -> Proof.context -> tactic'\n    val rprems_tac: Proof.context -> tactic'\n    val rprem_tac: int -> Proof.context -> tactic'\n    val elim_all_tac: Proof.context -> thm list -> tactic\n\n    val prefer_tac: int -> tactic\n\n    val insert_subgoal_tac: cterm -> tactic'\n    val insert_subgoals_tac: cterm list -> tactic'\n\n    val eqsubst_inst_tac: Proof.context -> bool -> int list \n      -> ((indexname * Position.T) * string) list -> thm -> int -> tactic\n\n    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser\n\n    (* Parsing *)\n    val ->> : 'a context_parser *('a * Context.generic -> 'b * Context.generic)\n      -> 'b context_parser\n\n  end\n\n  signature REFINE_UTIL = sig\n    include BASIC_REFINE_UTIL\n\n    val order_by: ('a * 'a -> order) -> ('b -> 'a) -> 'b list -> 'b list\n    val build_res_net: thm list -> (int * thm) Net.net\n\n    (* Terms *)\n    val fo_matchp: theory -> cterm -> term -> term list option\n    val fo_matches: theory -> cterm -> term -> bool\n\n    val anorm_typ: typ -> typ\n    val anorm_term: term -> term\n\n    val import_cterms: bool -> cterm list -> Proof.context -> \n      cterm list * Proof.context\n\n    val subsume_sort: ('a -> term) -> theory -> 'a list -> 'a list\n    val subsume_sort_gen: ('a -> term) -> Context.generic \n      -> 'a list -> 'a list\n\n    val mk_compN1: typ list -> int -> term -> term -> term\n    val mk_compN: int -> term -> term -> term\n\n    val dest_itselfT: typ -> typ\n    val dummify_tvars: term -> term\n\n    (* a\\<equiv>\\<lambda>x. f x  \\<mapsto>  a ?x \\<equiv> f ?x *)\n    val shift_lambda_left: thm -> thm\n    val shift_lambda_leftN: int -> thm -> thm\n\n    (* Left-Bracketed Structures *)\n\n    (* Map [] to z, and [x1,...,xN] to f(...f(f(x1,x2),x3)...) *)\n    val list_binop_left: 'a -> ('a * 'a -> 'a) -> 'a list -> 'a\n    (* Map [] to z, [x] to i x, [x1,...,xN] to f(...f(f(x1,x2),x3)...), thread state *)\n    val fold_binop_left: ('c -> 'b * 'c) -> ('a -> 'c -> 'b * 'c) -> ('b * 'b -> 'b) \n          -> 'a list -> 'c -> 'b * 'c\n\n    (* Tuples, handling () as empty tuple *)      \n    val strip_prodT_left: typ -> typ list\n    val list_prodT_left: typ list -> typ\n    val mk_ltuple: term list -> term\n    (* Fix a tuple of new frees *)\n    val fix_left_tuple_from_Ts: string -> typ list -> Proof.context -> term * Proof.context\n\n    (* HO-Patterns with tuples *)\n    (* Lambda-abstraction over list of terms, recognizing tuples *)\n    val lambda_tuple: term list -> term -> term\n    (* Instantiate tuple-types in specified variables *)\n    val instantiate_tuples: Proof.context -> (indexname*typ) list -> thm -> thm\n    (* Instantiate tuple-types in variables from given term *)\n    val instantiate_tuples_from_term_tac: Proof.context -> term -> tactic\n    (* Instantiate tuple types in variables of subgoal *)\n    val instantiate_tuples_subgoal_tac: Proof.context -> tactic'\n\n\n\n\n    (* Rules *)\n    val abs_def: Proof.context -> thm -> thm\n\n    (* Rule combinators *)\n    \n    (* Iterate rule on theorem until it fails *)  \n    val repeat_rule: (thm -> thm) -> thm -> thm\n    (* Apply rule on theorem and assert that theorem was changed *)\n    val changed_rule: (thm -> thm) -> thm -> thm\n    (* Try rule on theorem, return theorem unchanged if rule fails *)\n    val try_rule: (thm -> thm) -> thm -> thm\n    (* Singleton version of Variable.trade *)\n    val trade_rule: (Proof.context -> thm -> thm) -> Proof.context -> thm -> thm\n    (* Combine with first matching theorem *)\n    val RS_fst: thm -> thm list -> thm\n    (* Instantiate first matching theorem *)\n    val OF_fst: thm list -> thm list -> thm\n\n\n    (* Conversion *)\n    val trace_conv: conv\n    val monitor_conv: string -> conv -> conv\n    val monitor_conv': string -> (Proof.context -> conv) -> Proof.context -> conv\n\n    val fixup_vars: cterm -> thm -> thm\n    val fixup_vars_conv: conv -> conv\n    val fixup_vars_conv': (Proof.context -> conv) -> Proof.context -> conv\n\n    val pat_conv': cterm -> (string -> Proof.context -> conv) -> Proof.context\n      -> conv\n    val pat_conv: cterm -> (Proof.context -> conv) -> Proof.context -> conv\n\n    val HOL_concl_conv: (Proof.context -> conv) -> Proof.context -> conv\n\n    val import_conv: (Proof.context -> conv) -> Proof.context -> conv\n\n    val fix_conv: Proof.context -> conv -> conv\n    val ite_conv: conv -> conv -> conv -> conv\n\n    val cfg_trace_f_tac_conv: bool Config.T\n    val f_tac_conv: Proof.context -> (term -> term) -> tactic -> conv\n\n    (* Conversion combinators to choose first matching position *)\n    (* Try argument, then function *)\n    val fcomb_conv: conv -> conv\n    (* Descend over function or abstraction *)\n    val fsub_conv: (Proof.context -> conv) -> Proof.context -> conv \n    (* Apply to topmost matching position *)\n    val ftop_conv: (Proof.context -> conv) -> Proof.context -> conv\n\n\n    (* Parsing *)\n    val parse_bool_config: string -> bool Config.T -> bool context_parser\n    val parse_paren_list: 'a context_parser -> 'a list context_parser\n    val parse_paren_lists: 'a context_parser -> 'a list list context_parser\n\n    (* 2-step configuration parser *)\n    (* Parse boolean config, name or no_name. *)\n    val parse_bool_config': string -> bool Config.T -> Token.T list -> (bool Config.T * bool) * Token.T list\n    (* Parse optional (p1,...,pn). Empty list if nothing parsed. *)\n    val parse_paren_list': 'a parser -> Token.T list -> 'a list * Token.T list\n    (* Apply list of (config,value) pairs *)\n    val apply_configs: ('a Config.T * 'a) list -> Proof.context -> Proof.context\n\n\n  end\n\n\n  structure Refine_Util: REFINE_UTIL = struct\n    open Basic_Refine_Util\n\n    fun RSm ctxt thA thB = let\n      val (thA, ctxt') = ctxt\n        |> Variable.declare_thm thA\n        |> Variable.declare_thm thB\n        |> yield_singleton (apfst snd oo Variable.import true) thA\n      val thm = thA RS thB\n      val thm = singleton (Variable.export ctxt' ctxt) thm\n        |> Drule.zero_var_indexes\n    in \n      thm\n    end\n\n    fun is_Abs (Abs _) = true | is_Abs _ = false\n    fun is_Comb (_$_) = true | is_Comb _ = false\n\n    fun has_Var (Var _) = true\n      | has_Var (Abs (_,_,t)) = has_Var t\n      | has_Var (t1$t2) = has_Var t1 orelse has_Var t2\n      | has_Var _ = false\n\n    fun is_TFree (TFree _) = true\n      | is_TFree _ = false\n\n    fun is_def_thm thm = case thm |> Thm.prop_of of\n      Const (@{const_name \"Pure.eq\"},_)$_$_ => true | _ => false\n\n\n    type tactic' = int -> tactic\n    type itactic = int -> int -> tactic\n\n    (* Fail if subgoal does not exist *)\n    fun IF_EXGOAL tac i st = if i <= Thm.nprems_of st then\n      tac i st\n    else no_tac st;\n\n    fun COND' P = IF_EXGOAL (fn i => fn st => \n      (if P (Thm.prop_of st |> curry Logic.nth_prem i) then\n      all_tac st else no_tac st) \n      handle TERM _ => no_tac st\n      | Pattern.MATCH => no_tac st\n    )\n\n    (* FIXME: Subtle difference between Logic.concl_of_goal and this:\n         concl_of_goal converts loose bounds to frees!\n    *)\n    fun CONCL_COND' P = COND' (strip_all_body #> Logic.strip_imp_concl #> P)\n\n    fun (tac1 THEN_ELSE' (tac2,tac3)) x = tac1 x THEN_ELSE (tac2 x,tac3 x);  \n\n    (* If first tactic succeeds, combine its effect with \"comb tac2\", \n      otherwise use tac_else. Example: \n        tac1 THEN_ELSE_COMB ((THEN_ALL_NEW),tac2,tac_else)  *)\n    fun (tac1 THEN_ELSE_COMB' (comb,tac2,tac_else)) i st = let\n      val rseq = tac1 i st\n    in\n      case seq_is_empty rseq of\n        (true,_) => tac_else i st\n      | (false,rseq) => comb (K(K( rseq )), tac2) i st\n\n    end\n\n    (* Apply tactic to subgoals in interval, in a forward manner, skipping over\n      emerging subgoals *)\n    fun INTERVAL_FWD tac l u st =\n      if l>u then all_tac st \n      else (tac l THEN (fn st' => let\n          val ofs = Thm.nprems_of st' - Thm.nprems_of st;\n        in\n          if ofs < ~1 then raise THM (\n            \"INTERVAL_FWD: Tac solved more than one goal\",~1,[st,st'])\n          else INTERVAL_FWD tac (l+1+ofs) (u+ofs) st'\n        end)) st;\n\n    (* Apply tac2 to all subgoals emerged from tac1, in forward manner. *)\n    fun (tac1 THEN_ALL_NEW_FWD tac2) i st =\n      (tac1 i \n        THEN (fn st' => INTERVAL_FWD tac2 i (i + Thm.nprems_of st' - Thm.nprems_of st) st')\n      ) st;\n\n    fun REPEAT_ALL_NEW_FWD tac =\n      tac THEN_ALL_NEW_FWD (TRY o (fn i => REPEAT_ALL_NEW_FWD tac i));\n\n    (* Repeat tac on subgoal. Determinize each step. \n       Stop if tac fails or subgoal is solved. *)\n    fun REPEAT_DETERM' tac i st = let\n      val n = Thm.nprems_of st \n    in\n      REPEAT_DETERM (COND (has_fewer_prems n) no_tac (tac i)) st\n    end\n\n    fun REPEAT' tac i st = let\n      val n = Thm.nprems_of st \n    in\n      REPEAT (COND (has_fewer_prems n) no_tac (tac i)) st\n    end\n\n    (* Apply tactic to all goals in a forward manner.\n      Newly generated goals are ignored.\n    *)\n    fun ALL_GOALS_FWD' tac i st =\n      (tac i THEN (fn st' => \n        let\n          val i' = i + Thm.nprems_of st' + 1 - Thm.nprems_of st;\n        in\n          if i' <= Thm.nprems_of st' then\n            ALL_GOALS_FWD' tac i' st'\n          else\n            all_tac st'\n        end\n      )) st;\n\n    fun ALL_GOALS_FWD tac = ALL_GOALS_FWD' tac 1;\n\n    fun APPEND_LIST' tacs = fold_rev (curry (op APPEND')) tacs (K no_tac);\n\n    fun SINGLE_INTERVAL tac i = tac i i\n\n    fun ((tac1:itactic) THEN_INTERVAL (tac2:itactic)) = \n      (fn i => fn j => fn st =>\n        ( tac1 i j\n          THEN (fn st' => tac2 i (j + Thm.nprems_of st' - Thm.nprems_of st) st')\n        ) st\n      ):itactic\n\n    fun tac1 ORELSE_INTERVAL tac2 = (fn i => fn j => tac1 i j ORELSE tac2 i j)\n\n    (* Fail if tac fails, otherwise do nothing *)\n    fun CAN' tac i st = \n      case tac i st |> Seq.pull of\n        NONE => Seq.empty\n      | SOME _ => Seq.single st\n\n    (* Repeat tactic n times *)\n    fun NTIMES' _ 0 _ st = Seq.single st\n      | NTIMES' tac n i st = (tac THEN' NTIMES' tac (n-1)) i st\n\n    (* Resolve with rule. Use first-order unification.\n      From cookbook, added exception handling *)\n    fun fo_rtac thm = Subgoal.FOCUS (fn {context = ctxt, concl, ...} => \n    let\n      val concl_pat = Drule.strip_imp_concl (Thm.cprop_of thm)\n      val insts = Thm.first_order_match (concl_pat, concl)\n    in\n      resolve_tac ctxt [Drule.instantiate_normalize insts thm] 1\n    end handle Pattern.MATCH => no_tac )\n\n    fun fo_resolve_tac thms ctxt = \n      FIRST' (map (fn thm => fo_rtac thm ctxt) thms);\n\n    (* Resolve with premises. Copied and adjusted from Goal.assume_rule_tac. *)\n    fun rprems_tac ctxt = Goal.norm_hhf_tac ctxt THEN' CSUBGOAL (fn (goal, i) =>\n      let\n        fun non_atomic (Const (@{const_name Pure.imp}, _) $ _ $ _) = true\n          | non_atomic (Const (@{const_name Pure.all}, _) $ _) = true\n          | non_atomic _ = false;\n\n        val ((_, goal'), ctxt') = Variable.focus_cterm NONE goal ctxt;\n        val goal'' = Drule.cterm_rule \n          (singleton (Variable.export ctxt' ctxt)) goal';\n        val Rs = filter (non_atomic o Thm.term_of) \n          (Drule.strip_imp_prems goal'');\n\n        val ethms = Rs |> map (fn R =>\n          (Simplifier.norm_hhf ctxt (Thm.trivial R)));\n      in eresolve_tac ctxt ethms i end\n      );\n\n    (* Resolve with premise. Copied and adjusted from Goal.assume_rule_tac. *)\n    fun rprem_tac n ctxt = Goal.norm_hhf_tac ctxt THEN' CSUBGOAL (fn (goal, i) =>\n      let\n        val ((_, goal'), ctxt') = Variable.focus_cterm NONE goal ctxt;\n        val goal'' = Drule.cterm_rule \n          (singleton (Variable.export ctxt' ctxt)) goal';\n\n        val R = nth (Drule.strip_imp_prems goal'') (n - 1)\n        val rl = Simplifier.norm_hhf ctxt (Thm.trivial R)\n      in\n        eresolve_tac ctxt [rl] i\n      end\n      );\n\n    fun elim_all_tac ctxt thms = ALLGOALS (REPEAT_ALL_NEW (ematch_tac ctxt thms))\n\n    fun prefer_tac i = defer_tac i THEN PRIMITIVE (Thm.permute_prems 0 ~1)\n\n    fun order_by ord f = sort (ord o apply2 f)\n\n    (* CLONE from tactic.ML *)\n    local\n      (*insert one tagged rl into the net*)\n      fun insert_krl (krl as (_,th)) =\n        Net.insert_term (K false) (Thm.concl_of th, krl);\n    in\n      (*build a net of rules for resolution*)\n      fun build_res_net rls =\n        fold_rev insert_krl (tag_list 1 rls) Net.empty;\n    end\n\n    fun insert_subgoals_tac cts i = PRIMITIVE (\n      Thm.permute_prems 0 (i - 1)\n      #> fold_rev Thm.implies_intr cts\n      #> Thm.permute_prems 0 (~i + 1)\n    )\n\n    fun insert_subgoal_tac ct i = insert_subgoals_tac [ct] i\n\n  local\n    (* Substitution with dynamic instantiation of parameters.\n       By Lars Noschinski. *)\n    fun eqsubst_tac' ctxt asm =\n      if asm then EqSubst.eqsubst_asm_tac ctxt else EqSubst.eqsubst_tac ctxt\n\n    fun subst_method inst_tac tac =\n      Args.goal_spec --\n      Scan.lift (Args.mode \"asm\" -- Scan.optional (Args.parens (Scan.repeat Parse.nat)) [0]) --\n      Scan.optional (Scan.lift\n        (Parse.and_list1 \n          (Parse.position Args.var -- (Args.$$$ \"=\" |-- Parse.!!! Args.embedded_inner_syntax)) --|\n          Args.$$$ \"in\")) [] --\n      Attrib.thms >>\n      (fn (((quant, (asm, occL)), insts), thms) => fn ctxt => METHOD \n        (fn facts =>\n          if null insts then \n            quant (Method.insert_tac ctxt facts THEN' tac ctxt asm occL thms)\n          else\n            (case thms of\n              [thm] => quant (\n                Method.insert_tac ctxt facts THEN' inst_tac ctxt asm occL insts thm)\n            | _ => error \"Cannot have instantiations with multiple rules\")));\n\n  in\n    fun eqsubst_inst_tac ctxt asm occL insts thm = \n      Subgoal.FOCUS (\n        fn {context=ctxt,...} => let\n          val ctxt' = ctxt |> Proof_Context.set_mode Proof_Context.mode_schematic  (* FIXME !? *)\n          val thm' = thm |> Rule_Insts.read_instantiate ctxt' insts []\n        in eqsubst_tac' ctxt asm occL [thm'] 1 end\n      ) ctxt\n\n\n    val eqsubst_inst_meth = subst_method eqsubst_inst_tac eqsubst_tac'\n  end\n\n    (* Match pattern against term, and return list of values for non-dummy\n      variables. A variable is considered dummy if its name starts with \n      an underscore (_)*)\n    fun fo_matchp thy cpat t = let\n      fun ignore (Var ((name,_),_)) = String.isPrefix \"_\" name\n        | ignore _ = true;\n\n      val pat = Thm.term_of cpat;\n      val pvars = fold_aterms (\n        fn t => fn l => if is_Var t andalso not (ignore t)\n          then t::l else l\n      ) pat [] |> rev\n      val inst = Pattern.first_order_match thy (pat,t) \n        (Vartab.empty,Vartab.empty);\n    in SOME (map (Envir.subst_term inst) pvars) end \n    handle Pattern.MATCH => NONE;\n\n    val fo_matches = is_some ooo fo_matchp\n\n\n    fun anorm_typ ty = let\n      val instT = Term.add_tvarsT ty []\n      |> map_index (fn (i,(n,s)) => (n,TVar ((\"t\"^string_of_int i,0),s)))\n      val ty = Term.typ_subst_TVars instT ty;\n    in ty end;\n\n    fun anorm_term t = let\n      val instT = Term.add_tvars t []\n      |> map_index (fn (i,(n,s)) => (n,TVar ((\"t\"^string_of_int i,0),s)))\n      val t = Term.subst_TVars instT t;\n      val inst = Term.add_vars t []\n      |> map_index (fn (i,(n,s)) => (n,Var ((\"v\"^string_of_int i,0),s)))\n      val t = Term.subst_Vars inst t;\n    in t end;\n\n    fun import_cterms is_open cts ctxt = let\n      val ts = map Thm.term_of cts\n      val (ts', ctxt') = Variable.import_terms is_open ts ctxt\n      val cts' = map (Thm.cterm_of ctxt) ts'\n    in (cts', ctxt') end\n\n\n    (* Order a list of items such that more specific items come\n       before less specific ones. The term to be compared is\n       extracted by a function that is given as parameter.\n    *)\n    fun subsume_sort f thy items = let\n      val rhss = map (Envir.beta_eta_contract o f) items\n      fun freqf thy net rhs = Net.match_term net rhs \n        |> filter (fn p => Pattern.matches thy (p,rhs))\n        |> length\n\n      val net = fold \n        (fn rhs => Net.insert_term_safe (op =) (rhs,rhs)) rhss Net.empty \n\n      val freqs = map (freqf thy net) rhss\n\n      val res = freqs ~~ items \n        |> sort (rev_order o int_ord o apply2 fst)\n        |> map snd\n  \n    in res end\n\n    fun subsume_sort_gen f = subsume_sort f o Context.theory_of\n\n    fun mk_comp1 env (f, g) =\n      let\n        val fT = fastype_of1 (env, f);\n        val gT = fastype_of1 (env, g);\n        val compT = fT --> gT --> domain_type gT --> range_type fT;\n      in Const (\"Fun.comp\", compT) $ f $ g end;\n\n    fun mk_compN1 _   0 f g = f$g\n      | mk_compN1 env 1 f g = mk_comp1 env (f, g)\n      | mk_compN1 env n f g = let\n          val T = fastype_of1 (env, g) |> domain_type\n          val g = incr_boundvars 1 g $ Bound 0\n          val env = T::env\n        in\n          Abs (\"x\"^string_of_int n,T,mk_compN1 env (n-1) f g)\n        end\n\n    val mk_compN = mk_compN1 []    \n\n    fun abs_def ctxt = Local_Defs.meta_rewrite_rule ctxt #> Drule.abs_def\n\n    fun trace_conv ct = (tracing (@{make_string} ct); Conv.all_conv ct);\n\n    fun monitor_conv msg conv ct = let\n      val _ = tracing (msg ^ \" (gets): \" ^ @{make_string} ct);\n      val res = conv ct \n        handle exc =>\n         (if Exn.is_interrupt exc then Exn.reraise exc\n          else tracing (msg ^ \" (raises): \" ^ @{make_string} exc);\n          Exn.reraise exc)\n      val _ = tracing (msg ^ \" (yields): \" ^ @{make_string} res);\n    in res end\n\n    fun monitor_conv' msg conv ctxt ct = monitor_conv msg (conv ctxt) ct\n\n    fun fixup_vars ct thm = let\n      val lhs = Thm.lhs_of thm\n      val inst = Thm.first_order_match (lhs,ct)\n      val thm' = Thm.instantiate inst thm\n    in thm' end\n\n    fun fixup_vars_conv conv ct = fixup_vars ct (conv ct)\n\n    fun fixup_vars_conv' conv ctxt = fixup_vars_conv (conv ctxt)\n\n    local\n      fun tag_ct ctxt name ct = let\n        val t = Thm.term_of ct;\n        val ty = fastype_of t;\n        val t' = Const (@{const_name conv_tag},@{typ unit}-->ty-->ty)\n          $Free (name,@{typ unit})$t;\n        val ct' = Thm.cterm_of ctxt t';\n      in ct' end\n\n      fun mpat_conv pat ctxt ct = let\n        val (tym,tm) = Thm.first_order_match (pat,ct);\n        val tm' = map (fn (pt as ((name, _), _),ot) => (pt, tag_ct ctxt name ot)) tm;\n        val ct' = Thm.instantiate_cterm (tym,tm') pat;\n        val rthm =\n          Goal.prove_internal ctxt []\n            (Thm.cterm_of ctxt (Logic.mk_equals (apply2 Thm.term_of (ct, ct'))))\n            (K (simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms conv_tag_def}) 1))\n        |> Goal.norm_result ctxt\n      in \n        fixup_vars ct rthm \n      end handle Pattern.MATCH \n        => raise (CTERM (\"mpat_conv: No match\",[pat,ct]));\n\n      fun tag_conv cnv ctxt ct = case Thm.term_of ct of\n        Const (@{const_name conv_tag},_)$Free(name,_)$_ => (\n          (Conv.rewr_conv (@{thm conv_tag_def}) then_conv (cnv name) ctxt) ct)\n      | _ => Conv.all_conv ct;\n\n      fun all_tag_conv cnv = Conv.bottom_conv (tag_conv cnv);\n    in \n      (* Match against pattern, and apply parameter conversion to matches of\n         variables prefixed by hole_prefix.\n      *)\n      fun pat_conv' cpat cnv ctxt = \n        mpat_conv cpat ctxt\n        then_conv (all_tag_conv cnv ctxt);\n\n      fun pat_conv cpat conv = pat_conv' cpat \n        (fn name => case name of \"HOLE\" => conv | _ => K Conv.all_conv);\n    end\n\n    fun HOL_concl_conv cnv = Conv.params_conv ~1 \n      (fn ctxt => Conv.concl_conv ~1 (\n        HOLogic.Trueprop_conv (cnv ctxt)));\n\n\n    fun import_conv conv ctxt ct = let\n      val (ct',ctxt') = yield_singleton (import_cterms true) ct ctxt\n      val res = conv ctxt' ct'\n      val res' = singleton (Variable.export ctxt' ctxt) res |> fixup_vars ct\n    in res' end\n\n\n    fun fix_conv ctxt conv ct = let\n      val thm = conv ct\n      val eq = Logic.mk_equals (Thm.term_of ct, Thm.term_of ct) |> head_of\n    in if (Thm.term_of (Thm.lhs_of thm) aconv Thm.term_of ct)\n      then thm\n      else thm RS Thm.trivial (Thm.mk_binop (Thm.cterm_of ctxt eq) ct (Thm.rhs_of thm))\n    end\n\n    fun ite_conv cv cv1 cv2 ct =\n      let \n        val eq1 = SOME (cv ct) \n          handle THM _ => NONE\n            | CTERM _ => NONE\n            | TERM _ => NONE\n            | TYPE _ => NONE;\n        val res = case eq1 of\n          NONE => cv2 ct\n        | SOME eq1 => let val eq2 = cv1 (Thm.rhs_of eq1) in \n            if Thm.is_reflexive eq1 then eq2\n            else if Thm.is_reflexive eq2 then eq1\n            else Thm.transitive eq1 eq2\n          end\n      in res end\n\n      val cfg_trace_f_tac_conv = \n        Attrib.setup_config_bool @{binding trace_f_tac_conv} (K false)\n\n      (* Transform term and prove equality to original by tactic *)\n      fun f_tac_conv ctxt f tac ct = let\n        val t = Thm.term_of ct\n        val t' = f t\n        val goal = Logic.mk_equals (t,t')\n        val _ = if Config.get ctxt cfg_trace_f_tac_conv then\n          tracing (Syntax.string_of_term ctxt goal)\n        else ()\n\n        val goal = Thm.cterm_of ctxt goal\n\n        val thm = Goal.prove_internal ctxt [] goal (K tac)\n      in\n        thm\n      end\n\n    (* Apply function to result and context *)\n    fun (p->>f) ctks = let\n      val (res,(context,tks)) = p ctks\n      val (res,context) = f (res, context)\n    in\n      (res,(context,tks))\n    end\n\n    fun parse_bool_config name cfg = (\n      Scan.lift (Args.$$$ name)\n        ->> (apsnd (Config.put_generic cfg true) #>> K true)\n      || \n      Scan.lift (Args.$$$ (\"no_\"^name))\n        ->> (apsnd (Config.put_generic cfg false) #>> K false)\n      )\n\n    fun parse_paren_list p = \n      Scan.lift (\n        Args.$$$ \"(\") |-- Parse.enum1' \",\" p --| Scan.lift (Args.$$$ \")\"\n      )\n\n    fun parse_paren_lists p = Scan.repeat (parse_paren_list p)\n\n    val _ = Theory.setup\n      (Method.setup @{binding fo_rule} \n        (Attrib.thms >> (fn thms => fn ctxt => SIMPLE_METHOD' (\n          fo_resolve_tac thms ctxt))) \n        \"resolve using first-order matching\"\n     #>\n      Method.setup @{binding rprems} \n        (Scan.lift (Scan.option Parse.nat) >> (fn i => fn ctxt => \n          SIMPLE_METHOD' (\n            case i of\n              NONE => rprems_tac ctxt\n            | SOME i => rprem_tac i ctxt\n          ))\n        )\n        \"resolve with premises\"\n      #> Method.setup @{binding elim_all}\n         (Attrib.thms >> (fn thms => fn ctxt => SIMPLE_METHOD (elim_all_tac ctxt thms)))\n         \"repeteadly apply elimination rules to all subgoals\"\n      #> Method.setup @{binding subst_tac} eqsubst_inst_meth\n         \"single-step substitution (dynamic instantiation)\"\n      #> Method.setup @{binding clarsimp_all} (\n           Method.sections Clasimp.clasimp_modifiers >> K (fn ctxt => SIMPLE_METHOD (\n             CHANGED_PROP (ALLGOALS (Clasimp.clarsimp_tac ctxt))))\n         ) \"simplify and clarify all subgoals\")\n\n\n\n    \n\n\n      (* Filter alternatives that solve a subgoal. \n        If no alternative solves goal, return result sequence unchanged *)\n      fun TRY_SOLVED' tac i st = let\n        val res = tac i st\n        val solved = Seq.filter (fn st' => Thm.nprems_of st' < Thm.nprems_of st) res\n      in \n        case Seq.pull solved of\n          SOME _ => solved\n        | NONE => res  \n      end\n    \n      local\n        fun CASES_aux [] = no_tac\n          | CASES_aux ((tac1, tac2)::cs) = tac1 1 THEN_ELSE (tac2, CASES_aux cs)    \n      in\n        (* \n          Accepts a list of pairs of (pattern_tac', worker_tac), and applies\n          worker_tac to results of first successful pattern_tac'.\n        *)\n        val CASES' = SELECT_GOAL o CASES_aux\n      end    \n\n      (* TODO/FIXME: There seem to be no guarantees when eta-long forms are introduced by unification.\n        So, we have to expect eta-long forms everywhere, which may be a problem when matching terms\n        syntactically.\n      *)\n      fun WITH_subgoal tac = \n        CONVERSION Thm.eta_conversion THEN' \n        IF_EXGOAL (fn i => fn st => tac (nth (Thm.prems_of st) (i - 1)) i st)\n  \n      fun WITH_concl tac = \n        CONVERSION Thm.eta_conversion THEN' \n        IF_EXGOAL (fn i => fn st => \n          tac (Logic.concl_of_goal (Thm.prop_of st) i) i st\n        )\n\n      fun TRADE tac ctxt i st = let\n        val orig_ctxt = ctxt\n        val (st,ctxt) = yield_singleton (apfst snd oo Variable.import true) st ctxt\n        val seq = tac ctxt i st\n          |> Seq.map (singleton (Variable.export ctxt orig_ctxt))\n      in\n        seq\n      end\n\n      (* Try argument, then function *)\n      fun fcomb_conv conv = let open Conv in\n        arg_conv conv else_conv fun_conv conv\n      end\n  \n      (* Descend over function or abstraction *)\n      fun fsub_conv conv ctxt = let \n        open Conv \n      in\n        fcomb_conv (conv ctxt) else_conv\n        abs_conv (conv o snd) ctxt else_conv\n        no_conv\n      end\n  \n      (* Apply to topmost matching position *)\n      fun ftop_conv conv ctxt ct = \n        (conv ctxt else_conv fsub_conv (ftop_conv conv) ctxt) ct\n  \n      (* Iterate rule on theorem until it fails *)  \n      fun repeat_rule n thm = case try n thm of\n        SOME thm => repeat_rule n thm\n      | NONE => thm\n  \n      (* Apply rule on theorem and assert that theorem was changed *)\n      fun changed_rule n thm = let\n        val thm' = n thm\n      in\n        if Thm.eq_thm_prop (thm, thm') then raise THM (\"Same\",~1,[thm,thm'])\n        else thm'\n      end\n\n      (* Try rule on theorem *)\n      fun try_rule n thm = case try n thm of\n        SOME thm => thm | NONE => thm\n\n      fun trade_rule f ctxt thm = \n        singleton (Variable.trade (map o f) ctxt) thm\n\n      fun RS_fst thm thms = let\n        fun r [] = raise THM (\"RS_fst, no matches\",~1,thm::thms)\n          | r (thm'::thms) = case try (op RS) (thm,thm') of\n              NONE => r thms | SOME thm => thm\n  \n      in\n        r thms\n      end\n\n      fun OF_fst thms insts = let\n        fun r [] = raise THM (\"OF_fst, no matches\",length thms,thms@insts)\n          | r (thm::thms) = case try (op OF) (thm,insts) of\n              NONE => r thms | SOME thm => thm\n      in\n        r thms\n      end\n\n      (* Map [] to z, and [x1,...,xN] to f(...f(f(x1,x2),x3)...) *)\n      fun list_binop_left z f = let\n        fun r [] = z\n          | r [T] = T\n          | r (T::Ts) = f (r Ts,T)\n      in\n        fn l => r (rev l)\n      end    \n\n      (* Map [] to z, [x] to i x, [x1,...,xN] to f(...f(f(x1,x2),x3)...), thread state *)\n      fun fold_binop_left z i f = let\n        fun r [] ctxt = z ctxt\n          | r [T] ctxt = i T ctxt\n          | r (T::Ts) ctxt = let \n              val (Ti,ctxt) = i T ctxt\n              val (Tsi,ctxt) = r Ts ctxt\n            in\n              (f (Tsi,Ti),ctxt)\n            end\n      in\n        fn l => fn ctxt => r (rev l) ctxt\n      end    \n\n  \n  \n      fun strip_prodT_left (Type (@{type_name Product_Type.prod},[A,B])) = strip_prodT_left A @ [B]\n        | strip_prodT_left (Type (@{type_name Product_Type.unit},[])) = []\n        | strip_prodT_left T = [T]\n  \n      val list_prodT_left = list_binop_left HOLogic.unitT HOLogic.mk_prodT\n\n      (* Make tuple with left-bracket structure *)\n      val mk_ltuple = list_binop_left HOLogic.unit HOLogic.mk_prod\n\n\n  \n      (* Fix a tuple of new frees *)\n      fun fix_left_tuple_from_Ts name = fold_binop_left\n        (fn ctxt => (@{term \"()\"},ctxt))\n        (fn T => fn ctxt => let \n            val (x,ctxt) = yield_singleton Variable.variant_fixes name ctxt\n            val x = Free (x,T)\n          in \n            (x,ctxt)\n          end)\n        HOLogic.mk_prod  \n\n      (* Replace all type-vars by dummyT *)\n      val dummify_tvars = map_types (map_type_tvar (K dummyT))\n\n      fun dest_itselfT (Type (@{type_name itself},[A])) = A\n        | dest_itselfT T = raise TYPE(\"dest_itselfT\",[T],[])\n\n\n      fun shift_lambda_left thm = thm RS @{thm shift_lambda_left}\n      fun shift_lambda_leftN i = funpow i shift_lambda_left\n  \n\n      (* TODO: Naming should be without ' for basic parse, and with ' for context_parser! *)\n      fun parse_bool_config' name cfg =\n           (Args.$$$ name #>> K (cfg,true))\n        || (Args.$$$ (\"no_\"^name) #>> K (cfg,false))  \n  \n      fun parse_paren_list' p = Scan.optional (Args.parens (Parse.enum1 \",\" p)) []\n  \n      fun apply_configs l ctxt = fold (fn (cfg,v) => fn ctxt => Config.put cfg v ctxt) l ctxt\n      \n      fun lambda_tuple [] t = t\n        | lambda_tuple (@{mpat \"(?a,?b)\"}::l) t = let\n            val body = lambda_tuple (a::b::l) t\n          in\n            @{mk_term \"case_prod ?body\"}\n          end\n        | lambda_tuple (x::l) t = lambda x (lambda_tuple l t)\n  \n      fun get_tuple_inst ctxt (iname,T) = let\n        val (argTs,T) = strip_type T\n  \n        fun cr (Type (@{type_name prod},[T1,T2])) ctxt = let\n              val (x1,ctxt) = cr T1 ctxt\n              val (x2,ctxt) = cr T2 ctxt\n            in\n              (HOLogic.mk_prod (x1,x2), ctxt)\n            end\n          | cr T ctxt = let\n              val (name, ctxt) = yield_singleton Variable.variant_fixes \"x\" ctxt\n            in\n              (Free (name,T),ctxt)\n            end\n  \n        val ctxt = Variable.set_body false ctxt (* Prevent generation of skolem-names *)\n\n        val (args,ctxt) = fold_map cr argTs ctxt\n        fun fl (@{mpat \"(?x,?y)\"}) = fl x @ fl y\n          | fl t = [t]\n  \n        val fargs = flat (map fl args)\n        val fTs = map fastype_of fargs\n  \n        val v = Var (iname,fTs ---> T)\n        val v = list_comb (v,fargs)\n        val v = lambda_tuple args v\n      in \n        Thm.cterm_of ctxt v\n      end\n  \n      fun instantiate_tuples ctxt inTs = let\n        val inst = inTs ~~ map (get_tuple_inst ctxt) inTs\n      in\n        Thm.instantiate ([],inst)\n      end\n  \n      val _ = COND'\n  \n      fun instantiate_tuples_from_term_tac ctxt t st = let\n        val vars = Term.add_vars t []\n      in\n        PRIMITIVE (instantiate_tuples ctxt vars) st\n      end\n  \n      fun instantiate_tuples_subgoal_tac ctxt = WITH_subgoal (fn t => K (instantiate_tuples_from_term_tac ctxt t))\n\n  end\n\n  structure Basic_Refine_Util: BASIC_REFINE_UTIL = Refine_Util\n  open Basic_Refine_Util\n\n\\<close>"], ["", "attribute_setup zero_var_indexes = \\<open>\n  Scan.succeed (Thm.rule_attribute [] (K Drule.zero_var_indexes))\n\\<close> \"Set variable indexes to zero, renaming to avoid clashes\""], ["", "end"]]}