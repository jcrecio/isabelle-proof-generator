{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Tool/Autoref_Translate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma autoref_ABS: \n  \"\\<lbrakk> \\<And>x x'. (x,x')\\<in>Ra \\<Longrightarrow> (c x, a x')\\<in>Rr \\<rbrakk> \\<Longrightarrow> (c, \\<lambda>'x. a x)\\<in>Ra\\<rightarrow>Rr\"", "lemma autoref_APP:\n  \"\\<lbrakk> (c,a)\\<in>Ra\\<rightarrow>Rr; (x,x')\\<in>Ra \\<rbrakk> \\<Longrightarrow> (c$x, a $ x')\\<in>Rr\"", "lemma autoref_beta: \n  assumes \"(c,a x)\\<in>R\"\n  shows \"(c,(\\<lambda>'x. a x)$x)\\<in>R\"", "lemmas dflt_trans_rules = autoref_beta autoref_ABS autoref_APP", "lemma REMOVE_INTERNAL_EQI: \"REMOVE_INTERNAL_EQ a a\"", "lemma autoref_REMOVE_INTERNAL_EQ: \n  assumes \"(c,a)\\<in>R\"\n  assumes \"REMOVE_INTERNAL_EQ c c'\"\n  shows \"(c',a)\\<in>R\"", "lemma PRECOND_tagI: \"P ==> PRECOND_tag P\"", "lemma PRECOND_OPT_tagI: \"P ==> PRECOND_OPT_tag P\""], "translations": [["", "lemma autoref_ABS: \n  \"\\<lbrakk> \\<And>x x'. (x,x')\\<in>Ra \\<Longrightarrow> (c x, a x')\\<in>Rr \\<rbrakk> \\<Longrightarrow> (c, \\<lambda>'x. a x)\\<in>Ra\\<rightarrow>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'.\n        (x, x') \\<in> Ra \\<Longrightarrow>\n        (c x, a x') \\<in> Rr) \\<Longrightarrow>\n    (c, \\<lambda>'x. a x) \\<in> Ra \\<rightarrow> Rr", "by auto"], ["", "lemma autoref_APP:\n  \"\\<lbrakk> (c,a)\\<in>Ra\\<rightarrow>Rr; (x,x')\\<in>Ra \\<rbrakk> \\<Longrightarrow> (c$x, a $ x')\\<in>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, a) \\<in> Ra \\<rightarrow> Rr; (x, x') \\<in> Ra\\<rbrakk>\n    \\<Longrightarrow> (c $ x, a $ x') \\<in> Rr", "by (auto dest: fun_relD)"], ["", "(*lemma autoref_ANNOT:\n  \"\\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> (x,x':::R)\\<in>R\" by (auto simp: ANNOT_def)\n*)"], ["", "lemma autoref_beta: \n  assumes \"(c,a x)\\<in>R\"\n  shows \"(c,(\\<lambda>'x. a x)$x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, (\\<lambda>'x. a x) $ x) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (c, a x) \\<in> R\n\ngoal (1 subgoal):\n 1. (c, (\\<lambda>'x. a x) $ x) \\<in> R", "by auto"], ["", "lemmas dflt_trans_rules = autoref_beta autoref_ABS autoref_APP"], ["", "subsubsection \\<open>Side Conditions\\<close>"], ["", "text \\<open>\n  Rules can have prefer and defer side-conditions. Prefer conditions must\n  be solvable in order for the rule to apply, and defer conditions must\n  hold after the rule has been applied and the recursive translations have been\n  performed. Thus, prefer-conditions typically restrict on the abstract \n  expression, while defer conditions restrict the translated expression.\n\n  In order to solve the actual side conditions, we use the \n  \\<open>Tagged_Solver\\<close>-infrastructure. The solvers are applied after \n  the \\<open>PREFER\\<close>/\\<open>DEFER\\<close> tag has been removed.\n\\<close>"], ["", "text \\<open>\n  Tag to remove internal stuff from term.\n  Before a prefer/defer side condition is evaluated, all terms inside these \n  tags are purged from autoref-specific annotations, i.e., operator-annotations,\n  relator annotations, and tagged applications.\n\\<close>"], ["", "definition [simp, autoref_tag_defs]: \"REMOVE_INTERNAL x \\<equiv> x\""], ["", "text \\<open>Useful abbreviation to require some property that is not related\n  to teh refinement framework\\<close>"], ["", "abbreviation \"PREFER nt \\<Phi> \\<equiv> PREFER_tag (nt (REMOVE_INTERNAL \\<Phi>))\""], ["", "abbreviation \"DEFER nt \\<Phi> \\<equiv> DEFER_tag (nt (REMOVE_INTERNAL \\<Phi>))\""], ["", "definition [simp]: \"REMOVE_INTERNAL_EQ a b \\<equiv> a=b\""], ["", "lemma REMOVE_INTERNAL_EQI: \"REMOVE_INTERNAL_EQ a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REMOVE_INTERNAL_EQ a a", "by simp"], ["", "lemma autoref_REMOVE_INTERNAL_EQ: \n  assumes \"(c,a)\\<in>R\"\n  assumes \"REMOVE_INTERNAL_EQ c c'\"\n  shows \"(c',a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c', a) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (c, a) \\<in> R\n  REMOVE_INTERNAL_EQ c c'\n\ngoal (1 subgoal):\n 1. (c', a) \\<in> R", "by simp"], ["", "ML \\<open>\n  signature AUTOREF_TACTICALS = sig\n    val is_prefer_cond: int -> thm -> bool\n    val is_defer_cond: int -> thm -> bool\n\n    val REPEAT_INTERVAL: tactic' -> itactic\n    val COND'': (int -> thm -> bool) -> tactic' -> tactic' -> tactic'\n    val REPEAT_ON_SUBGOAL: tactic' -> tactic'\n    val IF_SOLVED: tactic' -> tactic' -> tactic' -> tactic'\n  end\n\n  structure Autoref_Tacticals :AUTOREF_TACTICALS = struct\n    fun is_prefer_cond i st =\n      case Logic.concl_of_goal (Thm.prop_of st) i of\n        @{mpat \"Trueprop (PREFER_tag _)\"} => true\n      | _ => false\n\n    fun is_defer_cond i st =\n      case Logic.concl_of_goal (Thm.prop_of st) i of\n        @{mpat \"Trueprop (DEFER_tag _)\"} => true\n      | _ => false\n\n    fun REPEAT_INTERVAL tac i j st = let\n      val n = Thm.nprems_of st - (j - i)\n      fun r st = (\n        COND \n          (has_fewer_prems n) \n          (all_tac) \n          (tac i THEN_ELSE (r,all_tac))\n        ) st\n    in\n      r st\n    end\n\n    fun COND'' cond tac1 tac2 = IF_EXGOAL (fn i => fn st => \n      if cond i st then tac1 i st else tac2 i st\n    )\n\n    fun REPEAT_ON_SUBGOAL tac i = REPEAT_INTERVAL tac i i\n\n    fun IF_SOLVED tac tac1 tac2 i st = let\n      val n = Thm.nprems_of st\n    in\n      (tac i THEN COND (has_fewer_prems n) (tac1 i) (tac2 i)) st\n    end\n  end\n\n\n  signature AUTOREF_TRANSLATE = sig\n    type trans_net = (int * thm) Net.net\n\n    val add_post_rule: thm -> Context.generic -> Context.generic\n    val delete_post_rule: thm -> Context.generic -> Context.generic\n    val get_post_rules: Proof.context -> thm list\n\n    val compute_trans_net: Autoref_Fix_Rel.thm_pairs -> Proof.context\n      -> trans_net\n\n    val side_tac: Proof.context -> tactic'\n    val side_dbg_tac: Proof.context -> tactic'\n\n    val trans_step_only_tac: Proof.context -> tactic'\n    val trans_dbg_step_tac: Proof.context -> tactic'\n    val trans_step_tac: Proof.context -> tactic'\n    val trans_tac: Proof.context -> itactic\n\n    val trans_analyze: Proof.context -> int -> int -> thm -> bool\n    val trans_pretty_failure: Proof.context -> int -> int -> thm -> Pretty.T\n\n    val trans_phase: Autoref_Phases.phase\n\n    val setup: theory -> theory\n  end\n\n\n  structure Autoref_Translate :AUTOREF_TRANSLATE = struct\n    type trans_net = (int * thm) Net.net\n\n\n    (**************************)\n    (*       Translation      *)\n    (**************************)\n    \n    structure autoref_post_simps = Named_Thms ( \n      val name = @{binding autoref_post_simps}\n      val description = \"Refinement Framework: \" ^\n          \"Automatic refinement post simplification rules\" \n    );\n\n    val add_post_rule = autoref_post_simps.add_thm\n    val delete_post_rule = autoref_post_simps.del_thm\n    val get_post_rules = autoref_post_simps.get\n\n\n    fun compute_trans_net thm_pairs _ = \n      thm_pairs\n      |> map #2\n      |> (fn thms => thms @ @{thms dflt_trans_rules})\n      |> Tactic.build_net \n\n    structure trans_netD = Autoref_Data (\n      type T = trans_net\n      fun compute ctxt = \n        compute_trans_net (Autoref_Fix_Rel.thm_pairsD_get ctxt) ctxt\n      val prereq = [Autoref_Fix_Rel.thm_pairsD_init]\n    )\n\n    fun REMOVE_INTERNAL_conv ctxt = \n      Conv.top_sweep_conv (\n        fn _ => fn ct => (case Thm.term_of ct of\n          @{mpat \"REMOVE_INTERNAL _\"} => \n            Conv.rewr_conv @{thm REMOVE_INTERNAL_def}\n            then_conv Autoref_Tagging.untag_conv ctxt\n          | _ => Conv.no_conv) ct\n      ) ctxt\n\n    fun REMOVE_INTERNAL_tac ctxt = CONVERSION (REMOVE_INTERNAL_conv ctxt)\n\n    fun side_tac ctxt =\n      resolve_tac ctxt @{thms SIDEI}\n      THEN' REMOVE_INTERNAL_tac ctxt\n      THEN' Tagged_Solver.solve_tac ctxt\n\n    fun side_dbg_tac ctxt = let\n      val ctxt = Config.put Tagged_Solver.cfg_keep true ctxt\n    in\n      resolve_tac ctxt @{thms SIDEI}\n      THEN' REMOVE_INTERNAL_tac ctxt\n      THEN' TRY o Tagged_Solver.solve_tac ctxt\n    end\n\n    local\n      open Autoref_Tacticals\n      fun trans_rule_tac ctxt net = resolve_from_net_tac ctxt net\n        THEN_ALL_NEW (TRY o match_tac ctxt [@{thm PRIO_TAGI}])\n\n    in\n      (* Do not even attempt to solve side conditions *)\n      fun trans_step_only_tac ctxt = let\n        val net = trans_netD.get ctxt\n      in\n        (\n          COND'' is_defer_cond \n            (K no_tac)\n            (assume_tac ctxt ORELSE' trans_rule_tac ctxt net)\n        )\n      end\n\n      (* Leave unsolved side conditions *)\n      fun trans_dbg_step_tac ctxt = let\n        val net = trans_netD.get ctxt\n        val s_tac = side_tac ctxt\n      in DETERM o (\n        COND'' is_defer_cond \n          (SOLVED' s_tac)\n          (\n            assume_tac ctxt\n            ORELSE'\n            (trans_rule_tac ctxt net \n              THEN_ALL_NEW_FWD \n                COND'' is_prefer_cond\n                  (TRY o DETERM o SOLVED' s_tac)\n                  (K all_tac)\n            )\n          )\n        )\n      end\n\n      fun trans_step_tac ctxt = let\n        val net = trans_netD.get ctxt\n        val s_tac = side_tac ctxt\n      in DETERM o (\n        COND'' is_defer_cond \n          (SOLVED' s_tac)\n          (\n            assume_tac ctxt\n            ORELSE'\n            (trans_rule_tac ctxt net \n              THEN_ALL_NEW_FWD \n                COND'' is_prefer_cond\n                  (DETERM o SOLVED' s_tac)\n                  (K all_tac)\n            )\n          )\n        )\n      end\n\n      fun trans_tac ctxt = let\n        val ss = put_simpset HOL_basic_ss ctxt\n          addsimps @{thms APP_def PROTECT_def ANNOT_def}\n          addsimps get_post_rules ctxt\n        val trans_opt_tac = \n          resolve_tac ctxt @{thms autoref_REMOVE_INTERNAL_EQ} \n          THEN' \n          IF_SOLVED (REPEAT_ON_SUBGOAL (trans_step_tac ctxt))\n            (simp_tac ss THEN' resolve_tac ctxt @{thms REMOVE_INTERNAL_EQI})\n            (K all_tac)\n      in\n        Seq.INTERVAL trans_opt_tac\n      end\n\n    end\n\n    fun trans_analyze _ i j _ = j < i\n\n    fun trans_pretty_failure ctxt i j st = \n      if j < i then Pretty.str \"No failure\"\n      else let\n        val goal = Logic.get_goal (Thm.prop_of st) i\n        val concl = strip_all_body goal |> Logic.strip_imp_concl\n\n        val msg = case concl of\n          @{mpat \"Trueprop (DEFER_tag _)\"} \n            => Pretty.str \"Could not solve defered side condition\"\n        | @{mpat \"Trueprop ((_,_)\\<in>_)\"} \n            => Pretty.str \"Could not refine subterm\"\n        | _ => Pretty.str \"Internal: Unexpected goal\"\n      in \n        Pretty.block [\n          msg,\n          Pretty.fbrk,\n          Syntax.pretty_term ctxt goal\n        ]\n      end\n\n    val trans_phase = {\n      init = trans_netD.init,\n      tac = trans_tac,\n      analyze = trans_analyze,\n      pretty_failure = trans_pretty_failure\n    }\n\n\n    val setup = I\n      #> autoref_post_simps.setup \n\n  end\n\\<close>"], ["", "setup Autoref_Translate.setup"], ["", "subsubsection \\<open>Standard side-tactics\\<close>"], ["", "text \\<open>Preconditions\\<close>"], ["", "definition [simp, autoref_tag_defs]: \"PRECOND_tag P == P\""], ["", "lemma PRECOND_tagI: \"P ==> PRECOND_tag P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> PRECOND_tag P", "by simp"], ["", "abbreviation \"SIDE_PRECOND P == PREFER PRECOND_tag P\""], ["", "declaration \\<open>\n  Tagged_Solver.declare_solver @{thms PRECOND_tagI} @{binding PRECOND} \n    \"Refinement: Solve preconditions\" \n    ( fn ctxt => SOLVED' (\n        SELECT_GOAL (auto_tac ctxt)\n      )\n    )\n\\<close>"], ["", "text \\<open>Optional preconditions\\<close>"], ["", "definition [simp, autoref_tag_defs]: \"PRECOND_OPT_tag P == P\""], ["", "lemma PRECOND_OPT_tagI: \"P ==> PRECOND_OPT_tag P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> PRECOND_OPT_tag P", "by simp"], ["", "abbreviation \"SIDE_PRECOND_OPT P == PREFER PRECOND_OPT_tag P\""], ["", "declaration \\<open>\n  Tagged_Solver.declare_solver @{thms PRECOND_OPT_tagI} @{binding PRECOND_OPT} \n    \"Refinement: Solve optional preconditions\" \n    ( fn ctxt => SOLVED' (asm_full_simp_tac ctxt))\n\\<close>"], ["", "end"]]}