{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Parametricity/Param_HOL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma param_empty[param]:\n  \"({},{})\\<in>\\<langle>R\\<rangle>set_rel\"", "lemma param_member[param]:\n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<in>), (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\"", "lemma param_insert[param]:\n  \"(insert,insert)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>set_rel\\<rightarrow>\\<langle>R\\<rangle>set_rel\"", "lemma param_union[param]:\n  \"((\\<union>), (\\<union>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\"", "lemma param_inter[param]:\n  assumes \"single_valued R\" \"single_valued (R\\<inverse>)\"\n  shows \"((\\<inter>), (\\<inter>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\"", "lemma param_diff[param]:\n  assumes \"single_valued R\" \"single_valued (R\\<inverse>)\"\n  shows \"((-), (-)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\"", "lemma param_subseteq[param]: \n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<subseteq>), (\\<subseteq>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\"", "lemma param_subset[param]: \n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<subset>), (\\<subset>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\"", "lemma param_Ball[param]: \"(Ball,Ball)\\<in>\\<langle>Ra\\<rangle>set_rel\\<rightarrow>(Ra\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma param_Bex[param]: \"(Bex,Bex)\\<in>\\<langle>Ra\\<rangle>set_rel\\<rightarrow>(Ra\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma param_set[param]: \n  \"single_valued Ra \\<Longrightarrow> (set,set)\\<in>\\<langle>Ra\\<rangle>list_rel \\<rightarrow> \\<langle>Ra\\<rangle>set_rel\"", "lemma param_Collect[param]: \n  \"\\<lbrakk>Domain A = UNIV; Range A = UNIV\\<rbrakk> \\<Longrightarrow> (Collect,Collect)\\<in>(A\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>set_rel\"", "lemma param_finite[param]: \"\\<lbrakk>\n    single_valued R; single_valued (R\\<inverse>)\n  \\<rbrakk> \\<Longrightarrow> (finite,finite) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\"", "lemma param_if[param]: \n  assumes \"(c,c')\\<in>Id\"\n  assumes \"\\<lbrakk>c;c'\\<rbrakk> \\<Longrightarrow> (t,t')\\<in>R\"\n  assumes \"\\<lbrakk>\\<not>c;\\<not>c'\\<rbrakk> \\<Longrightarrow> (e,e')\\<in>R\"\n  shows \"(If c t e, If c' t' e')\\<in>R\"", "lemma param_Let[param]: \n  \"(Let,Let)\\<in>Ra \\<rightarrow> (Ra\\<rightarrow>Rr) \\<rightarrow> Rr\"", "lemma param_id[param]: \"(id,id)\\<in>R\\<rightarrow>R\"", "lemma param_fun_comp[param]: \"((o), (o)) \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> (Rc\\<rightarrow>Ra) \\<rightarrow> Rc\\<rightarrow>Rb\"", "lemma param_fun_upd[param]: \"\n  ((=), (=)) \\<in> Ra\\<rightarrow>Ra\\<rightarrow>Id \n  \\<Longrightarrow> (fun_upd,fun_upd) \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb\"", "lemma rec_bool_is_case: \"old.rec_bool = case_bool\"", "lemma param_bool[param]:\n  \"(True,True)\\<in>Id\"\n  \"(False,False)\\<in>Id\"\n  \"(conj,conj)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"(disj,disj)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"(Not,Not)\\<in>Id\\<rightarrow>Id\"\n  \"(case_bool,case_bool)\\<in>R\\<rightarrow>R\\<rightarrow>Id\\<rightarrow>R\"\n  \"(old.rec_bool,old.rec_bool)\\<in>R\\<rightarrow>R\\<rightarrow>Id\\<rightarrow>R\"\n  \"((\\<longleftrightarrow>), (\\<longleftrightarrow>))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((\\<longrightarrow>), (\\<longrightarrow>))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"", "lemma param_and_cong1: \"\\<lbrakk> (a,a')\\<in>bool_rel; \\<lbrakk>a; a'\\<rbrakk> \\<Longrightarrow> (b,b')\\<in>bool_rel \\<rbrakk> \\<Longrightarrow> (a\\<and>b,a'\\<and>b')\\<in>bool_rel\"", "lemma param_and_cong2: \"\\<lbrakk> (a,a')\\<in>bool_rel; \\<lbrakk>a; a'\\<rbrakk> \\<Longrightarrow> (b,b')\\<in>bool_rel \\<rbrakk> \\<Longrightarrow> (b\\<and>a,b'\\<and>a')\\<in>bool_rel\"", "lemma param_nat1[param]:\n  \"(0, 0::nat) \\<in> Id\"\n  \"(Suc, Suc) \\<in> Id \\<rightarrow> Id\"\n  \"(1, 1::nat) \\<in> Id\"\n  \"(numeral n::nat,numeral n::nat) \\<in> Id\"\n  \"((<), (<) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((\\<le>), (\\<le>) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((=), (=) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((+) ::nat\\<Rightarrow>_,(+))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((-) ::nat\\<Rightarrow>_,(-))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((*) ::nat\\<Rightarrow>_,(*))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((div) ::nat\\<Rightarrow>_,(div))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((mod) ::nat\\<Rightarrow>_,(mod))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"", "lemma param_case_nat[param]:\n  \"(case_nat,case_nat)\\<in>Ra \\<rightarrow> (Id \\<rightarrow> Ra) \\<rightarrow> Id \\<rightarrow> Ra\"", "lemma param_rec_nat[param]: \n  \"(rec_nat,rec_nat) \\<in> R \\<rightarrow> (Id \\<rightarrow> R \\<rightarrow> R) \\<rightarrow> Id \\<rightarrow> R\"", "lemma param_int[param]:\n  \"(0, 0::int) \\<in> Id\"\n  \"(1, 1::int) \\<in> Id\"\n  \"(numeral n::int,numeral n::int) \\<in> Id\"\n  \"((<), (<) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((\\<le>), (\\<le>) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((=), (=) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((+) ::int\\<Rightarrow>_,(+))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((-) ::int\\<Rightarrow>_,(-))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((*) ::int\\<Rightarrow>_,(*))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((div) ::int\\<Rightarrow>_,(div))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((mod) ::int\\<Rightarrow>_,(mod))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"", "lemma param_unit[param]: \"((),())\\<in>unit_rel\"", "lemma rec_prod_is_case: \"old.rec_prod = case_prod\"", "lemma param_prod[param]:\n  \"(Pair,Pair)\\<in>Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel\"\n  \"(case_prod,case_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n  \"(old.rec_prod,old.rec_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n  \"(fst,fst)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Ra\"\n  \"(snd,snd)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rb\"", "lemma param_case_prod':\n  \"\\<lbrakk> (p,p')\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel;\n     \\<And>a b a' b'. \\<lbrakk> p=(a,b); p'=(a',b'); (a,a')\\<in>Ra; (b,b')\\<in>Rb \\<rbrakk> \n      \\<Longrightarrow> (f a b, f' a' b')\\<in>R\n    \\<rbrakk> \\<Longrightarrow> (case_prod f p, case_prod f' p') \\<in> R\"", "lemma param_case_prod'': (* TODO: Really needed? *)\n  \"\\<lbrakk> \n    \\<And>a b a' b'. \\<lbrakk>p=(a,b); p'=(a',b')\\<rbrakk> \\<Longrightarrow> (f a b,f' a' b')\\<in>R  \n  \\<rbrakk> \\<Longrightarrow> (case_prod f p, case_prod f' p')\\<in>R\"", "lemma param_map_prod[param]: \n  \"(map_prod, map_prod) \n  \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> (Rc\\<rightarrow>Rd) \\<rightarrow> \\<langle>Ra,Rc\\<rangle>prod_rel \\<rightarrow> \\<langle>Rb,Rd\\<rangle>prod_rel\"", "lemma param_apfst[param]: \n  \"(apfst,apfst)\\<in>(Ra\\<rightarrow>Rb)\\<rightarrow>\\<langle>Ra,Rc\\<rangle>prod_rel\\<rightarrow>\\<langle>Rb,Rc\\<rangle>prod_rel\"", "lemma param_apsnd[param]: \n  \"(apsnd,apsnd)\\<in>(Rb\\<rightarrow>Rc)\\<rightarrow>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rightarrow>\\<langle>Ra,Rc\\<rangle>prod_rel\"", "lemma param_curry[param]: \n  \"(curry,curry) \\<in> (\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rc) \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Rc\"", "lemma param_uncurry[param]: \"(uncurry,uncurry) \\<in> (A\\<rightarrow>B\\<rightarrow>C) \\<rightarrow> A\\<times>\\<^sub>rB\\<rightarrow>C\"", "lemma param_prod_swap[param]: \"(prod.swap, prod.swap)\\<in>A\\<times>\\<^sub>rB \\<rightarrow> B\\<times>\\<^sub>rA\"", "lemma \n    assumes M: \"monotone le_fun le_fun F\" \n    and M': \"monotone le_fun le_fun F'\"\n    assumes ADM: \n      \"admissible (\\<lambda>a. \\<forall>x xa. (x, xa) \\<in> Rb \\<longrightarrow> (a x, fixp_fun F' xa) \\<in> Ra)\"\n    assumes bot: \"\\<And>x xa. (x, xa) \\<in> Rb \\<Longrightarrow> (lub {}, fixp_fun F' xa) \\<in> Ra\"\n    assumes F: \"(F,F')\\<in>(Rb\\<rightarrow>Ra)\\<rightarrow>Rb\\<rightarrow>Ra\"\n    assumes A: \"(x,x')\\<in>Rb\"\n    shows \"(fixp_fun F x, fixp_fun F' x')\\<in>Ra\"", "lemma param_option[param]:\n  \"(None,None)\\<in>\\<langle>R\\<rangle>option_rel\"\n  \"(Some,Some)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>option_rel\"\n  \"(case_option,case_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"\n  \"(rec_option,rec_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"", "lemma param_map_option[param]: \"(map_option, map_option) \\<in> (A \\<rightarrow> B) \\<rightarrow> \\<langle>A\\<rangle>option_rel \\<rightarrow> \\<langle>B\\<rangle>option_rel\"", "lemma param_case_option':\n  \"\\<lbrakk> (x,x')\\<in>\\<langle>Rv\\<rangle>option_rel; \n     \\<lbrakk>x=None; x'=None \\<rbrakk> \\<Longrightarrow> (fn,fn')\\<in>R;  \n     \\<And>v v'. \\<lbrakk> x=Some v; x'=Some v'; (v,v')\\<in>Rv \\<rbrakk> \\<Longrightarrow> (fs v, fs' v')\\<in>R\n   \\<rbrakk> \\<Longrightarrow> (case_option fn fs x, case_option fn' fs' x') \\<in> R\"", "lemma the_paramL: \"\\<lbrakk>l\\<noteq>None; (l,r)\\<in>\\<langle>R\\<rangle>option_rel\\<rbrakk> \\<Longrightarrow> (the l, the r)\\<in>R\"", "lemma the_paramR: \"\\<lbrakk>r\\<noteq>None; (l,r)\\<in>\\<langle>R\\<rangle>option_rel\\<rbrakk> \\<Longrightarrow> (the l, the r)\\<in>R\"", "lemma the_default_param[param]: \n  \"(the_default, the_default) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R\"", "lemma rec_sum_is_case: \"old.rec_sum = case_sum\"", "lemma param_sum[param]:\n  \"(Inl,Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(Inr,Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(case_sum,case_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"\n  \"(old.rec_sum,old.rec_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"", "lemma param_case_sum':\n  \"\\<lbrakk> (s,s')\\<in>\\<langle>Rl,Rr\\<rangle>sum_rel;\n     \\<And>l l'. \\<lbrakk> s=Inl l; s'=Inl l'; (l,l')\\<in>Rl \\<rbrakk> \\<Longrightarrow> (fl l, fl' l')\\<in>R;\n     \\<And>r r'. \\<lbrakk> s=Inr r; s'=Inr r'; (r,r')\\<in>Rr \\<rbrakk> \\<Longrightarrow> (fr r, fr' r')\\<in>R\n   \\<rbrakk> \\<Longrightarrow> (case_sum fl fr s, case_sum fl' fr' s')\\<in>R\"", "lemma is_Inl_param[param]: \"(is_Inl,is_Inl) \\<in> \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> bool_rel\"", "lemma is_Inr_param[param]: \"(is_Inr,is_Inr) \\<in> \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> bool_rel\"", "lemma sum_projl_param[param]: \n  \"\\<lbrakk>is_Inl s; (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n  \\<Longrightarrow> (Sum_Type.sum.projl s',Sum_Type.sum.projl s) \\<in> Ra\"", "lemma sum_projr_param[param]: \n  \"\\<lbrakk>is_Inr s; (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n  \\<Longrightarrow> (Sum_Type.sum.projr s',Sum_Type.sum.projr s) \\<in> Rb\"", "lemma list_rel_append1: \"(as @ bs, l) \\<in> \\<langle>R\\<rangle>list_rel \n  \\<longleftrightarrow> (\\<exists>cs ds. l = cs@ds \\<and> (as,cs)\\<in>\\<langle>R\\<rangle>list_rel \\<and> (bs,ds)\\<in>\\<langle>R\\<rangle>list_rel)\"", "lemma list_rel_append2: \"(l,as @ bs) \\<in> \\<langle>R\\<rangle>list_rel \n  \\<longleftrightarrow> (\\<exists>cs ds. l = cs@ds \\<and> (cs,as)\\<in>\\<langle>R\\<rangle>list_rel \\<and> (ds,bs)\\<in>\\<langle>R\\<rangle>list_rel)\"", "lemma param_append[param]: \n  \"(append, append)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma param_list1[param]:\n  \"(Nil,Nil)\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"(Cons,Cons)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"\n  \"(case_list,case_list)\\<in>Rr\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr\"", "lemma param_rec_list[param]: \n  \"(rec_list,rec_list) \n  \\<in> Ra \\<rightarrow> (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra) \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra\"", "lemma param_case_list':\n  \"\\<lbrakk> (l,l')\\<in>\\<langle>Rb\\<rangle>list_rel;\n     \\<lbrakk>l=[]; l'=[]\\<rbrakk> \\<Longrightarrow> (n,n')\\<in>Ra;  \n     \\<And>x xs x' xs'. \\<lbrakk> l=x#xs; l'=x'#xs'; (x,x')\\<in>Rb; (xs,xs')\\<in>\\<langle>Rb\\<rangle>list_rel \\<rbrakk> \n     \\<Longrightarrow> (c x xs, c' x' xs')\\<in>Ra\n   \\<rbrakk> \\<Longrightarrow> (case_list n c l, case_list n' c' l') \\<in> Ra\"", "lemma param_map[param]: \n  \"(map,map)\\<in>(R1\\<rightarrow>R2) \\<rightarrow> \\<langle>R1\\<rangle>list_rel \\<rightarrow> \\<langle>R2\\<rangle>list_rel\"", "lemma param_fold[param]: \n  \"(fold,fold)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"\n  \"(foldl,foldl)\\<in>(Rs\\<rightarrow>Re\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs\"\n  \"(foldr,foldr)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"", "lemma param_list_all[param]: \"(list_all,list_all) \\<in> (A\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma list_all2_alt: \"list_all2 P xs ys = list_all2_alt P xs ys\"", "lemma param_list_all2[param]: \"(list_all2, list_all2) \\<in> (A\\<rightarrow>B\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>B\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma param_hd[param]: \"l\\<noteq>[] \\<Longrightarrow> (l',l)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> (hd l', hd l)\\<in>A\"", "lemma param_last[param]: \n  assumes \"y \\<noteq> []\" \n  assumes \"(x, y) \\<in> \\<langle>A\\<rangle>list_rel\"  \n  shows \"(last x, last y) \\<in> A\"", "lemma param_rotate1[param]: \"(rotate1, rotate1) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\"", "lemma param_list_eq[param]: \"\n  (list_eq,list_eq) \\<in> \n    (R \\<rightarrow> R \\<rightarrow> Id) \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\"", "lemma id_list_eq_aux[simp]: \"(list_eq (=)) = (=)\"", "lemma param_list_equals[param]:\n  \"\\<lbrakk> ((=), (=)) \\<in> R\\<rightarrow>R\\<rightarrow>Id \\<rbrakk> \n  \\<Longrightarrow> ((=), (=)) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\"", "lemma param_tl[param]:\n  \"(tl,tl) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma list_all_rec_eq: \"(\\<forall>x\\<in>set l. P x) = list_all_rec P l\"", "lemma list_ex_rec_eq: \"(\\<exists>x\\<in>set l. P x) = list_ex_rec P l\"", "lemma param_list_ball[param]:\n  \"\\<lbrakk>(P,P')\\<in>(Ra\\<rightarrow>Id); (l,l')\\<in>\\<langle>Ra\\<rangle> list_rel\\<rbrakk> \n    \\<Longrightarrow> (\\<forall>x\\<in>set l. P x, \\<forall>x\\<in>set l'. P' x) \\<in> Id\"", "lemma param_list_bex[param]:\n  \"\\<lbrakk>(P,P')\\<in>(Ra\\<rightarrow>Id); (l,l')\\<in>\\<langle>Ra\\<rangle> list_rel\\<rbrakk> \n    \\<Longrightarrow> (\\<exists>x\\<in>set l. P x, \\<exists>x\\<in>set l'. P' x) \\<in> Id\"", "lemma param_rev[param]: \"(rev,rev) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma param_foldli[param]: \"(foldli, foldli) \n  \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow> (Rs\\<rightarrow>Id) \\<rightarrow> (Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> Rs\"", "lemma param_foldri[param]: \"(foldri, foldri) \n  \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow> (Rs\\<rightarrow>Id) \\<rightarrow> (Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> Rs\"", "lemma param_nth[param]: \n  assumes I: \"i'<length l'\"\n  assumes IR: \"(i,i')\\<in>nat_rel\"\n  assumes LR: \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\" \n  shows \"(l!i,l'!i') \\<in> R\"", "lemma param_replicate[param]:\n  \"(replicate,replicate) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma param_list_update[param]: \n  \"(list_update,list_update) \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> nat_rel \\<rightarrow> Ra \\<rightarrow> \\<langle>Ra\\<rangle>list_rel\"", "lemma param_zip[param]:\n  \"(zip, zip) \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma param_upt[param]:\n  \"(upt, upt) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel\"", "lemma param_concat[param]: \"(concat, concat) \\<in> \n    \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma param_all_interval_nat[param]: \n  \"(List.all_interval_nat, List.all_interval_nat) \n  \\<in> (nat_rel \\<rightarrow> bool_rel) \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"", "lemma param_dropWhile[param]: \n  \"(dropWhile, dropWhile) \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>a\\<rangle>list_rel \\<rightarrow> \\<langle>a\\<rangle>list_rel\"", "lemma param_takeWhile[param]: \n  \"(takeWhile, takeWhile) \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>a\\<rangle>list_rel \\<rightarrow> \\<langle>a\\<rangle>list_rel\""], "translations": [["", "lemma param_empty[param]:\n  \"({},{})\\<in>\\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({}, {}) \\<in> \\<langle>R\\<rangle>set_rel", "by (auto simp: set_rel_def)"], ["", "lemma param_member[param]:\n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<in>), (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<in>), (\\<in>))\n                      \\<in> R \\<rightarrow>\n                            \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            bool_rel", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<in>), (\\<in>))\n                      \\<in> R \\<rightarrow>\n                            {(A, B).\n                             (\\<forall>x\\<in>A.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>A.\n                                    (x, y) \\<in> R)} \\<rightarrow>\n                            bool_rel", "by (blast dest: single_valuedD)"], ["", "lemma param_insert[param]:\n  \"(insert,insert)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>set_rel\\<rightarrow>\\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert, insert)\n    \\<in> R \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "by (auto simp: set_rel_def)"], ["", "lemma param_union[param]:\n  \"((\\<union>), (\\<union>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<union>), (\\<union>))\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "by (auto simp: set_rel_def)"], ["", "lemma param_inter[param]:\n  assumes \"single_valued R\" \"single_valued (R\\<inverse>)\"\n  shows \"((\\<inter>), (\\<inter>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<inter>), (\\<inter>))\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "using assms"], ["proof (prove)\nusing this:\n  single_valued R\n  single_valued (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. ((\\<inter>), (\\<inter>))\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "unfolding set_rel_def"], ["proof (prove)\nusing this:\n  single_valued R\n  single_valued (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. ((\\<inter>), (\\<inter>))\n    \\<in> {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B.\n               \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<rightarrow>\n          {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B.\n               \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<rightarrow>\n          {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}", "by (blast dest: single_valuedD)"], ["", "lemma param_diff[param]:\n  assumes \"single_valued R\" \"single_valued (R\\<inverse>)\"\n  shows \"((-), (-)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((-), (-))\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "using assms"], ["proof (prove)\nusing this:\n  single_valued R\n  single_valued (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. ((-), (-))\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>set_rel", "unfolding set_rel_def"], ["proof (prove)\nusing this:\n  single_valued R\n  single_valued (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. ((-), (-))\n    \\<in> {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B.\n               \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<rightarrow>\n          {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B.\n               \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<rightarrow>\n          {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}", "by (blast dest: single_valuedD)"], ["", "lemma param_subseteq[param]: \n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<subseteq>), (\\<subseteq>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<subseteq>), (\\<subseteq>))\n                      \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            bool_rel", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<subseteq>), (\\<subseteq>))\n                      \\<in> {(A, B).\n                             (\\<forall>x\\<in>A.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>A.\n                                    (x, y) \\<in> R)} \\<rightarrow>\n                            {(A, B).\n                             (\\<forall>x\\<in>A.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>A.\n                                    (x, y) \\<in> R)} \\<rightarrow>\n                            bool_rel", "by (blast dest: single_valuedD)"], ["", "lemma param_subset[param]: \n  \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> ((\\<subset>), (\\<subset>)) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<subset>), (\\<subset>))\n                      \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            bool_rel", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((\\<subset>), (\\<subset>))\n                      \\<in> {(A, B).\n                             (\\<forall>x\\<in>A.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>A.\n                                    (x, y) \\<in> R)} \\<rightarrow>\n                            {(A, B).\n                             (\\<forall>x\\<in>A.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>A.\n                                    (x, y) \\<in> R)} \\<rightarrow>\n                            bool_rel", "by (blast dest: single_valuedD)"], ["", "lemma param_Ball[param]: \"(Ball,Ball)\\<in>\\<langle>Ra\\<rangle>set_rel\\<rightarrow>(Ra\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ball, Ball)\n    \\<in> \\<langle>Ra\\<rangle>set_rel \\<rightarrow>\n          (Ra \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "by (force simp: set_rel_alt dest: fun_relD)"], ["", "lemma param_Bex[param]: \"(Bex,Bex)\\<in>\\<langle>Ra\\<rangle>set_rel\\<rightarrow>(Ra\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bex, Bex)\n    \\<in> \\<langle>Ra\\<rangle>set_rel \\<rightarrow>\n          (Ra \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "by (fastforce simp: set_rel_def dest: fun_relD)"], ["", "lemma param_set[param]: \n  \"single_valued Ra \\<Longrightarrow> (set,set)\\<in>\\<langle>Ra\\<rangle>list_rel \\<rightarrow> \\<langle>Ra\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued Ra \\<Longrightarrow>\n    (set, set)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Ra\\<rangle>set_rel", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued Ra;\n        (a, a') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (set a, set a') \\<in> \\<langle>Ra\\<rangle>set_rel", "fix l l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued Ra;\n        (a, a') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (set a, set a') \\<in> \\<langle>Ra\\<rangle>set_rel", "assume A: \"single_valued Ra\""], ["proof (state)\nthis:\n  single_valued Ra\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued Ra;\n        (a, a') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (set a, set a') \\<in> \\<langle>Ra\\<rangle>set_rel", "assume \"(l,l')\\<in>\\<langle>Ra\\<rangle>list_rel\""], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued Ra;\n        (a, a') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (set a, set a') \\<in> \\<langle>Ra\\<rangle>set_rel", "thus \"(set l, set l')\\<in>\\<langle>Ra\\<rangle>set_rel\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel", "apply (induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (set [], set []) \\<in> \\<langle>Ra\\<rangle>set_rel\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> (set (x # l), set (x' # l'))\n                         \\<in> \\<langle>Ra\\<rangle>set_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> (set (x # l), set (x' # l'))\n                         \\<in> \\<langle>Ra\\<rangle>set_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> (insert x (set l), insert x' (set l'))\n                         \\<in> \\<langle>Ra\\<rangle>set_rel", "using A"], ["proof (prove)\nusing this:\n  single_valued Ra\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> (insert x (set l), insert x' (set l'))\n                         \\<in> \\<langle>Ra\\<rangle>set_rel", "apply (parametricity)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (set l, set l') \\<in> \\<langle>Ra\\<rangle>set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_Collect[param]: \n  \"\\<lbrakk>Domain A = UNIV; Range A = UNIV\\<rbrakk> \\<Longrightarrow> (Collect,Collect)\\<in>(A\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV\\<rbrakk>\n    \\<Longrightarrow> (Collect, Collect)\n                      \\<in> (A \\<rightarrow> bool_rel) \\<rightarrow>\n                            \\<langle>A\\<rangle>set_rel", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV\\<rbrakk>\n    \\<Longrightarrow> (Collect, Collect)\n                      \\<in> (A \\<rightarrow> bool_rel) \\<rightarrow>\n                            {(Aa, B).\n                             (\\<forall>x\\<in>Aa.\n                                 \\<exists>y\\<in>B. (x, y) \\<in> A) \\<and>\n                             (\\<forall>y\\<in>B.\n                                 \\<exists>x\\<in>Aa. (x, y) \\<in> A)}", "apply (clarsimp; safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x.\n       \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n        (a, a') \\<in> A \\<rightarrow> bool_rel; a x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a' y \\<and> (x, y) \\<in> A\n 2. \\<And>a a' y.\n       \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n        (a, a') \\<in> A \\<rightarrow> bool_rel; a' y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. a x \\<and> (x, y) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n     (a_, a'_) \\<in> A \\<rightarrow> bool_rel; a_ x_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. a'_ y \\<and> (x_, y) \\<in> A", "using fun_relD1"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f, ?f') \\<in> ?Ra \\<rightarrow> ?Rr; ?f ?x = ?r\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x'.\n                       (?x, x') \\<in> ?Ra \\<longrightarrow>\n                       (?r, ?f' x') \\<in> ?Rr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n     (a_, a'_) \\<in> A \\<rightarrow> bool_rel; a_ x_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. a'_ y \\<and> (x_, y) \\<in> A", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' y.\n       \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n        (a, a') \\<in> A \\<rightarrow> bool_rel; a' y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. a x \\<and> (x, y) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n     (a_, a'_) \\<in> A \\<rightarrow> bool_rel; a'_ y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a_ x \\<and> (x, y_) \\<in> A", "using fun_relD2"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f, ?f') \\<in> ?Ra \\<rightarrow> ?Rr; ?f' ?x' = ?r'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x.\n                       (x, ?x') \\<in> ?Ra \\<longrightarrow>\n                       (?f x, ?r') \\<in> ?Rr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Domain A = UNIV; Range A = UNIV;\n     (a_, a'_) \\<in> A \\<rightarrow> bool_rel; a'_ y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a_ x \\<and> (x, y_) \\<in> A", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_finite[param]: \"\\<lbrakk>\n    single_valued R; single_valued (R\\<inverse>)\n  \\<rbrakk> \\<Longrightarrow> (finite,finite) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (finite, finite)\n                      \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            bool_rel", "using finite_set_rel_transfer finite_set_rel_transfer_back"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>?R\\<rangle>set_rel; single_valued ?R;\n   finite ?s\\<rbrakk>\n  \\<Longrightarrow> finite ?s'\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>?R\\<rangle>set_rel;\n   single_valued (?R\\<inverse>); finite ?s'\\<rbrakk>\n  \\<Longrightarrow> finite ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (finite, finite)\n                      \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n                            bool_rel", "by blast"], ["", "subsection \\<open>Standard HOL Constructs\\<close>"], ["", "lemma param_if[param]: \n  assumes \"(c,c')\\<in>Id\"\n  assumes \"\\<lbrakk>c;c'\\<rbrakk> \\<Longrightarrow> (t,t')\\<in>R\"\n  assumes \"\\<lbrakk>\\<not>c;\\<not>c'\\<rbrakk> \\<Longrightarrow> (e,e')\\<in>R\"\n  shows \"(If c t e, If c' t' e')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c then t else e, if c' then t' else e') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (c, c') \\<in> bool_rel\n  \\<lbrakk>c; c'\\<rbrakk> \\<Longrightarrow> (t, t') \\<in> R\n  \\<lbrakk>\\<not> c; \\<not> c'\\<rbrakk> \\<Longrightarrow> (e, e') \\<in> R\n\ngoal (1 subgoal):\n 1. (if c then t else e, if c' then t' else e') \\<in> R", "by auto"], ["", "lemma param_Let[param]: \n  \"(Let,Let)\\<in>Ra \\<rightarrow> (Ra\\<rightarrow>Rr) \\<rightarrow> Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let, Let) \\<in> Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr", "by (auto dest: fun_relD)"], ["", "subsection \\<open>Functions\\<close>"], ["", "lemma param_id[param]: \"(id,id)\\<in>R\\<rightarrow>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, id) \\<in> R \\<rightarrow> R", "unfolding id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x, \\<lambda>x. x) \\<in> R \\<rightarrow> R", "by parametricity"], ["", "lemma param_fun_comp[param]: \"((o), (o)) \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> (Rc\\<rightarrow>Ra) \\<rightarrow> Rc\\<rightarrow>Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<circ>), (\\<circ>))\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          (Rc \\<rightarrow> Ra) \\<rightarrow> Rc \\<rightarrow> Rb", "unfolding comp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f g x. f (g x), \\<lambda>f g x. f (g x))\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          (Rc \\<rightarrow> Ra) \\<rightarrow> Rc \\<rightarrow> Rb", "by parametricity"], ["", "lemma param_fun_upd[param]: \"\n  ((=), (=)) \\<in> Ra\\<rightarrow>Ra\\<rightarrow>Id \n  \\<Longrightarrow> (fun_upd,fun_upd) \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> Ra \\<rightarrow> Ra \\<rightarrow> bool_rel \\<Longrightarrow>\n    (fun_upd, fun_upd)\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb", "unfolding fun_upd_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> Ra \\<rightarrow> Ra \\<rightarrow> bool_rel \\<Longrightarrow>\n    (\\<lambda>f a b x. if x = a then b else f x,\n     \\<lambda>f a b x. if x = a then b else f x)\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb", "by (parametricity)"], ["", "subsection \\<open>Boolean\\<close>"], ["", "lemma rec_bool_is_case: \"old.rec_bool = case_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.rec_bool = case_bool", "by (rule ext)+ (auto split: bool.split)"], ["", "lemma param_bool[param]:\n  \"(True,True)\\<in>Id\"\n  \"(False,False)\\<in>Id\"\n  \"(conj,conj)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"(disj,disj)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"(Not,Not)\\<in>Id\\<rightarrow>Id\"\n  \"(case_bool,case_bool)\\<in>R\\<rightarrow>R\\<rightarrow>Id\\<rightarrow>R\"\n  \"(old.rec_bool,old.rec_bool)\\<in>R\\<rightarrow>R\\<rightarrow>Id\\<rightarrow>R\"\n  \"((\\<longleftrightarrow>), (\\<longleftrightarrow>))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((\\<longrightarrow>), (\\<longrightarrow>))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((True, True) \\<in> bool_rel &&& (False, False) \\<in> bool_rel) &&&\n     ((\\<and>), (\\<and>))\n     \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel &&&\n     ((\\<or>), (\\<or>))\n     \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel) &&&\n    ((Not, Not) \\<in> bool_rel \\<rightarrow> bool_rel &&&\n     (case_bool, case_bool)\n     \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<rightarrow> R) &&&\n    (old.rec_bool, old.rec_bool)\n    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<rightarrow> R &&&\n    ((=), (=))\n    \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel &&&\n    ((\\<longrightarrow>), (\\<longrightarrow>))\n    \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel", "by (auto split: bool.split simp: rec_bool_is_case)"], ["", "lemma param_and_cong1: \"\\<lbrakk> (a,a')\\<in>bool_rel; \\<lbrakk>a; a'\\<rbrakk> \\<Longrightarrow> (b,b')\\<in>bool_rel \\<rbrakk> \\<Longrightarrow> (a\\<and>b,a'\\<and>b')\\<in>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> bool_rel;\n     \\<lbrakk>a; a'\\<rbrakk>\n     \\<Longrightarrow> (b, b') \\<in> bool_rel\\<rbrakk>\n    \\<Longrightarrow> (a \\<and> b, a' \\<and> b') \\<in> bool_rel", "by blast"], ["", "lemma param_and_cong2: \"\\<lbrakk> (a,a')\\<in>bool_rel; \\<lbrakk>a; a'\\<rbrakk> \\<Longrightarrow> (b,b')\\<in>bool_rel \\<rbrakk> \\<Longrightarrow> (b\\<and>a,b'\\<and>a')\\<in>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> bool_rel;\n     \\<lbrakk>a; a'\\<rbrakk>\n     \\<Longrightarrow> (b, b') \\<in> bool_rel\\<rbrakk>\n    \\<Longrightarrow> (b \\<and> a, b' \\<and> a') \\<in> bool_rel", "by blast"], ["", "subsection \\<open>Nat\\<close>"], ["", "lemma param_nat1[param]:\n  \"(0, 0::nat) \\<in> Id\"\n  \"(Suc, Suc) \\<in> Id \\<rightarrow> Id\"\n  \"(1, 1::nat) \\<in> Id\"\n  \"(numeral n::nat,numeral n::nat) \\<in> Id\"\n  \"((<), (<) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((\\<le>), (\\<le>) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((=), (=) ::nat \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((+) ::nat\\<Rightarrow>_,(+))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((-) ::nat\\<Rightarrow>_,(-))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((*) ::nat\\<Rightarrow>_,(*))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((div) ::nat\\<Rightarrow>_,(div))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((mod) ::nat\\<Rightarrow>_,(mod))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0, 0) \\<in> nat_rel &&&\n      (Suc, Suc) \\<in> nat_rel \\<rightarrow> nat_rel &&&\n      (1, 1) \\<in> nat_rel) &&&\n     (numeral n, numeral n) \\<in> nat_rel &&&\n     ((<), (<))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel &&&\n     ((\\<le>), (\\<le>))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel) &&&\n    (((=), (=))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel &&&\n     ((+), (+))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n     ((-), (-))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel) &&&\n    ((*), (*)) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n    ((div), (div))\n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n    ((mod), (mod)) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by auto"], ["", "lemma param_case_nat[param]:\n  \"(case_nat,case_nat)\\<in>Ra \\<rightarrow> (Id \\<rightarrow> Ra) \\<rightarrow> Id \\<rightarrow> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_nat, case_nat)\n    \\<in> Ra \\<rightarrow>\n          (nat_rel \\<rightarrow> Ra) \\<rightarrow> nat_rel \\<rightarrow> Ra", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra; (aa, a'a) \\<in> nat_rel \\<rightarrow> Ra;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case ab of 0 \\<Rightarrow> a\n                          | Suc x \\<Rightarrow> aa x,\n                          case a'b of 0 \\<Rightarrow> a'\n                          | Suc x \\<Rightarrow> a'a x)\n                         \\<in> Ra", "apply (auto split: nat.split dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_rec_nat[param]: \n  \"(rec_nat,rec_nat) \\<in> R \\<rightarrow> (Id \\<rightarrow> R \\<rightarrow> R) \\<rightarrow> Id \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_nat, rec_nat)\n    \\<in> R \\<rightarrow>\n          (nat_rel \\<rightarrow> R \\<rightarrow> R) \\<rightarrow>\n          nat_rel \\<rightarrow> R", "proof (intro fun_relI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat a aa ab, rec_nat a' a'a a'b) \\<in> R", "case (1 s s' f f' n n')"], ["proof (state)\nthis:\n  (s, s') \\<in> R\n  (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat a aa ab, rec_nat a' a'a a'b) \\<in> R", "thus ?case"], ["proof (prove)\nusing this:\n  (s, s') \\<in> R\n  (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (rec_nat s f n, rec_nat s' f' n') \\<in> R", "apply (induct n' arbitrary: n s s')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n s s'.\n       \\<lbrakk>(s, s') \\<in> R;\n        (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (n, 0) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' 0) \\<in> R\n 2. \\<And>n' n s s'.\n       \\<lbrakk>\\<And>n s s'.\n                   \\<lbrakk>(s, s') \\<in> R;\n                    (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n                    (n, n') \\<in> nat_rel\\<rbrakk>\n                   \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' n')\n                                     \\<in> R;\n        (s, s') \\<in> R;\n        (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (n, Suc n') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' (Suc n')) \\<in> R", "apply (fastforce simp: fun_rel_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_nat s f n, rec_nat s' f' n') \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Int\\<close>"], ["", "lemma param_int[param]:\n  \"(0, 0::int) \\<in> Id\"\n  \"(1, 1::int) \\<in> Id\"\n  \"(numeral n::int,numeral n::int) \\<in> Id\"\n  \"((<), (<) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((\\<le>), (\\<le>) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((=), (=) ::int \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"\n  \"((+) ::int\\<Rightarrow>_,(+))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((-) ::int\\<Rightarrow>_,(-))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((*) ::int\\<Rightarrow>_,(*))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((div) ::int\\<Rightarrow>_,(div))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"\n  \"((mod) ::int\\<Rightarrow>_,(mod))\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0, 0) \\<in> int_rel &&& (1, 1) \\<in> int_rel) &&&\n     (numeral n, numeral n) \\<in> int_rel &&&\n     ((<), (<))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel &&&\n     ((\\<le>), (\\<le>))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel) &&&\n    (((=), (=))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel &&&\n     ((+), (+))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n     ((-), (-))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel) &&&\n    ((*), (*)) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n    ((div), (div))\n    \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n    ((mod), (mod)) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel", "by auto"], ["", "subsection \\<open>Product\\<close>"], ["", "lemma param_unit[param]: \"((),())\\<in>unit_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), ()) \\<in> unit_rel", "by auto"], ["", "lemma rec_prod_is_case: \"old.rec_prod = case_prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.rec_prod = case_prod", "by (rule ext)+ (auto split: bool.split)"], ["", "lemma param_prod[param]:\n  \"(Pair,Pair)\\<in>Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel\"\n  \"(case_prod,case_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n  \"(old.rec_prod,old.rec_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n  \"(fst,fst)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Ra\"\n  \"(snd,snd)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Pair, Pair)\n     \\<in> Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<times>\\<^sub>r Rb &&&\n     (case_prod, case_prod)\n     \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow>\n           Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rr) &&&\n    (old.rec_prod, old.rec_prod)\n    \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rr &&&\n    (fst, fst) \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow> Ra &&&\n    (snd, snd) \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rb", "by (auto dest: fun_relD split: prod.split \n    simp: prod_rel_def rec_prod_is_case)"], ["", "lemma param_case_prod':\n  \"\\<lbrakk> (p,p')\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel;\n     \\<And>a b a' b'. \\<lbrakk> p=(a,b); p'=(a',b'); (a,a')\\<in>Ra; (b,b')\\<in>Rb \\<rbrakk> \n      \\<Longrightarrow> (f a b, f' a' b')\\<in>R\n    \\<rbrakk> \\<Longrightarrow> (case_prod f p, case_prod f' p') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, p') \\<in> Ra \\<times>\\<^sub>r Rb;\n     \\<And>a b a' b'.\n        \\<lbrakk>p = (a, b); p' = (a', b'); (a, a') \\<in> Ra;\n         (b, b') \\<in> Rb\\<rbrakk>\n        \\<Longrightarrow> (f a b, f' a' b') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (case p of (x, xa) \\<Rightarrow> f x xa,\n                       case p' of (x, xa) \\<Rightarrow> f' x xa)\n                      \\<in> R", "by (auto split: prod.split)"], ["", "lemma param_case_prod'': (* TODO: Really needed? *)\n  \"\\<lbrakk> \n    \\<And>a b a' b'. \\<lbrakk>p=(a,b); p'=(a',b')\\<rbrakk> \\<Longrightarrow> (f a b,f' a' b')\\<in>R  \n  \\<rbrakk> \\<Longrightarrow> (case_prod f p, case_prod f' p')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b a' b'.\n        \\<lbrakk>p = (a, b); p' = (a', b')\\<rbrakk>\n        \\<Longrightarrow> (f a b, f' a' b') \\<in> R) \\<Longrightarrow>\n    (case p of (x, xa) \\<Rightarrow> f x xa,\n     case p' of (x, xa) \\<Rightarrow> f' x xa)\n    \\<in> R", "by (auto split: prod.split)"], ["", "lemma param_map_prod[param]: \n  \"(map_prod, map_prod) \n  \\<in> (Ra\\<rightarrow>Rb) \\<rightarrow> (Rc\\<rightarrow>Rd) \\<rightarrow> \\<langle>Ra,Rc\\<rangle>prod_rel \\<rightarrow> \\<langle>Rb,Rd\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod, map_prod)\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          (Rc \\<rightarrow> Rd) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rc \\<rightarrow> Rb \\<times>\\<^sub>r Rd", "unfolding map_prod_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f g (x, y). (f x, g y), \\<lambda>f g (x, y). (f x, g y))\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          (Rc \\<rightarrow> Rd) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rc \\<rightarrow> Rb \\<times>\\<^sub>r Rd", "by parametricity"], ["", "lemma param_apfst[param]: \n  \"(apfst,apfst)\\<in>(Ra\\<rightarrow>Rb)\\<rightarrow>\\<langle>Ra,Rc\\<rangle>prod_rel\\<rightarrow>\\<langle>Rb,Rc\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (apfst, apfst)\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rc \\<rightarrow> Rb \\<times>\\<^sub>r Rc", "unfolding apfst_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. map_prod f id, \\<lambda>f. map_prod f id)\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rc \\<rightarrow> Rb \\<times>\\<^sub>r Rc", "by parametricity"], ["", "lemma param_apsnd[param]: \n  \"(apsnd,apsnd)\\<in>(Rb\\<rightarrow>Rc)\\<rightarrow>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rightarrow>\\<langle>Ra,Rc\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (apsnd, apsnd)\n    \\<in> (Rb \\<rightarrow> Rc) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rb \\<rightarrow> Ra \\<times>\\<^sub>r Rc", "unfolding apsnd_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod id, map_prod id)\n    \\<in> (Rb \\<rightarrow> Rc) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rb \\<rightarrow> Ra \\<times>\\<^sub>r Rc", "by parametricity"], ["", "lemma param_curry[param]: \n  \"(curry,curry) \\<in> (\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rc) \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Rc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (curry, curry)\n    \\<in> (Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rc) \\<rightarrow>\n          Ra \\<rightarrow> Rb \\<rightarrow> Rc", "unfolding curry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c x y. c (x, y), \\<lambda>c x y. c (x, y))\n    \\<in> (Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rc) \\<rightarrow>\n          Ra \\<rightarrow> Rb \\<rightarrow> Rc", "by parametricity"], ["", "lemma param_uncurry[param]: \"(uncurry,uncurry) \\<in> (A\\<rightarrow>B\\<rightarrow>C) \\<rightarrow> A\\<times>\\<^sub>rB\\<rightarrow>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry, uncurry)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> C) \\<rightarrow>\n          A \\<times>\\<^sub>r B \\<rightarrow> C", "unfolding uncurry_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_prod, case_prod)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> C) \\<rightarrow>\n          A \\<times>\\<^sub>r B \\<rightarrow> C", "by parametricity"], ["", "lemma param_prod_swap[param]: \"(prod.swap, prod.swap)\\<in>A\\<times>\\<^sub>rB \\<rightarrow> B\\<times>\\<^sub>rA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod.swap, prod.swap)\n    \\<in> A \\<times>\\<^sub>r B \\<rightarrow> B \\<times>\\<^sub>r A", "by auto"], ["", "context partial_function_definitions begin"], ["", "lemma \n    assumes M: \"monotone le_fun le_fun F\" \n    and M': \"monotone le_fun le_fun F'\"\n    assumes ADM: \n      \"admissible (\\<lambda>a. \\<forall>x xa. (x, xa) \\<in> Rb \\<longrightarrow> (a x, fixp_fun F' xa) \\<in> Ra)\"\n    assumes bot: \"\\<And>x xa. (x, xa) \\<in> Rb \\<Longrightarrow> (lub {}, fixp_fun F' xa) \\<in> Ra\"\n    assumes F: \"(F,F')\\<in>(Rb\\<rightarrow>Ra)\\<rightarrow>Rb\\<rightarrow>Ra\"\n    assumes A: \"(x,x')\\<in>Rb\"\n    shows \"(fixp_fun F x, fixp_fun F' x')\\<in>Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fixp_fun F x, fixp_fun F' x') \\<in> Ra", "using A"], ["proof (prove)\nusing this:\n  (x, x') \\<in> Rb\n\ngoal (1 subgoal):\n 1. (fixp_fun F x, fixp_fun F' x') \\<in> Ra", "apply (induct arbitrary: x x' rule: ccpo.fixp_induct[OF ccpo _ M])"], ["proof (prove)\ngoal (3 subgoals):\n 1. admissible\n     (\\<lambda>a.\n         \\<forall>x xa.\n            (x, xa) \\<in> Rb \\<longrightarrow>\n            (a x, fixp_fun F' xa) \\<in> Ra)\n 2. \\<And>x x'.\n       (x, x') \\<in> Rb \\<Longrightarrow>\n       (lub_fun {} x, fixp_fun F' x') \\<in> Ra\n 3. \\<And>x xa x'.\n       \\<lbrakk>\\<And>xa x'.\n                   (xa, x') \\<in> Rb \\<Longrightarrow>\n                   (x xa, fixp_fun F' x') \\<in> Ra;\n        (xa, x') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (F x xa, fixp_fun F' x') \\<in> Ra", "apply (rule ADM)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       (x, x') \\<in> Rb \\<Longrightarrow>\n       (lub_fun {} x, fixp_fun F' x') \\<in> Ra\n 2. \\<And>x xa x'.\n       \\<lbrakk>\\<And>xa x'.\n                   (xa, x') \\<in> Rb \\<Longrightarrow>\n                   (x xa, fixp_fun F' x') \\<in> Ra;\n        (xa, x') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (F x xa, fixp_fun F' x') \\<in> Ra", "apply(simp add: fun_lub_def bot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa x'.\n       \\<lbrakk>\\<And>xa x'.\n                   (xa, x') \\<in> Rb \\<Longrightarrow>\n                   (x xa, fixp_fun F' x') \\<in> Ra;\n        (xa, x') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (F x xa, fixp_fun F' x') \\<in> Ra", "apply (subst ccpo.fixp_unfold[OF ccpo M'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa x'.\n       \\<lbrakk>\\<And>xa x'.\n                   (xa, x') \\<in> Rb \\<Longrightarrow>\n                   (x xa, fixp_fun F' x') \\<in> Ra;\n        (xa, x') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (F x xa, F' (fixp_fun F') x') \\<in> Ra", "apply (parametricity add: F)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Option\\<close>"], ["", "lemma param_option[param]:\n  \"(None,None)\\<in>\\<langle>R\\<rangle>option_rel\"\n  \"(Some,Some)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>option_rel\"\n  \"(case_option,case_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"\n  \"(rec_option,rec_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((None, None) \\<in> \\<langle>R\\<rangle>option_rel &&&\n     (Some, Some) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel) &&&\n    (case_option, case_option)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> Rr &&&\n    (rec_option, rec_option)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> Rr", "by (auto split: option.split \n    simp: option_rel_def case_option_def[symmetric]\n    dest: fun_relD)"], ["", "lemma param_map_option[param]: \"(map_option, map_option) \\<in> (A \\<rightarrow> B) \\<rightarrow> \\<langle>A\\<rangle>option_rel \\<rightarrow> \\<langle>B\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_option, map_option)\n    \\<in> (A \\<rightarrow> B) \\<rightarrow>\n          \\<langle>A\\<rangle>option_rel \\<rightarrow>\n          \\<langle>B\\<rangle>option_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (map_option a aa, map_option a' a'a)\n                         \\<in> \\<langle>B\\<rangle>option_rel", "apply (auto elim!: option_relE dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_case_option':\n  \"\\<lbrakk> (x,x')\\<in>\\<langle>Rv\\<rangle>option_rel; \n     \\<lbrakk>x=None; x'=None \\<rbrakk> \\<Longrightarrow> (fn,fn')\\<in>R;  \n     \\<And>v v'. \\<lbrakk> x=Some v; x'=Some v'; (v,v')\\<in>Rv \\<rbrakk> \\<Longrightarrow> (fs v, fs' v')\\<in>R\n   \\<rbrakk> \\<Longrightarrow> (case_option fn fs x, case_option fn' fs' x') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, x') \\<in> \\<langle>Rv\\<rangle>option_rel;\n     \\<lbrakk>x = None; x' = None\\<rbrakk>\n     \\<Longrightarrow> (fn, fn') \\<in> R;\n     \\<And>v v'.\n        \\<lbrakk>x = Some v; x' = Some v'; (v, v') \\<in> Rv\\<rbrakk>\n        \\<Longrightarrow> (fs v, fs' v') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (case x of None \\<Rightarrow> fn\n                       | Some x \\<Rightarrow> fs x,\n                       case x' of None \\<Rightarrow> fn'\n                       | Some x \\<Rightarrow> fs' x)\n                      \\<in> R", "by (auto split: option.split)"], ["", "lemma the_paramL: \"\\<lbrakk>l\\<noteq>None; (l,r)\\<in>\\<langle>R\\<rangle>option_rel\\<rbrakk> \\<Longrightarrow> (the l, the r)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> None;\n     (l, r) \\<in> \\<langle>R\\<rangle>option_rel\\<rbrakk>\n    \\<Longrightarrow> (the l, the r) \\<in> R", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l \\<noteq> None; (l, r) \\<in> \\<langle>R\\<rangle>option_rel;\n     l = None\\<rbrakk>\n    \\<Longrightarrow> (the l, the r) \\<in> R\n 2. \\<And>a.\n       \\<lbrakk>l \\<noteq> None; (l, r) \\<in> \\<langle>R\\<rangle>option_rel;\n        l = Some a\\<rbrakk>\n       \\<Longrightarrow> (the l, the r) \\<in> R", "by (auto elim: option_relE)"], ["", "lemma the_paramR: \"\\<lbrakk>r\\<noteq>None; (l,r)\\<in>\\<langle>R\\<rangle>option_rel\\<rbrakk> \\<Longrightarrow> (the l, the r)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> None;\n     (l, r) \\<in> \\<langle>R\\<rangle>option_rel\\<rbrakk>\n    \\<Longrightarrow> (the l, the r) \\<in> R", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<noteq> None; (l, r) \\<in> \\<langle>R\\<rangle>option_rel;\n     l = None\\<rbrakk>\n    \\<Longrightarrow> (the l, the r) \\<in> R\n 2. \\<And>a.\n       \\<lbrakk>r \\<noteq> None; (l, r) \\<in> \\<langle>R\\<rangle>option_rel;\n        l = Some a\\<rbrakk>\n       \\<Longrightarrow> (the l, the r) \\<in> R", "by (auto elim: option_relE)"], ["", "lemma the_default_param[param]: \n  \"(the_default, the_default) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_default, the_default)\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R", "unfolding the_default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua. rec_option (\\<lambda>x. x) (\\<lambda>x _. x) uua uu,\n     \\<lambda>uu uua. rec_option (\\<lambda>x. x) (\\<lambda>x _. x) uua uu)\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R", "by parametricity"], ["", "subsection \\<open>Sum\\<close>"], ["", "lemma rec_sum_is_case: \"old.rec_sum = case_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.rec_sum = case_sum", "by (rule ext)+ (auto split: sum.split)"], ["", "lemma param_sum[param]:\n  \"(Inl,Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(Inr,Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(case_sum,case_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"\n  \"(old.rec_sum,old.rec_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Inl, Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel &&&\n     (Inr, Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel) &&&\n    (case_sum, case_sum)\n    \\<in> (Rl \\<rightarrow> R) \\<rightarrow>\n          (Rr \\<rightarrow> R) \\<rightarrow>\n          \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow> R &&&\n    (old.rec_sum, old.rec_sum)\n    \\<in> (Rl \\<rightarrow> R) \\<rightarrow>\n          (Rr \\<rightarrow> R) \\<rightarrow>\n          \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow> R", "by (fastforce split: sum.split dest: fun_relD \n    simp: rec_sum_is_case)+"], ["", "lemma param_case_sum':\n  \"\\<lbrakk> (s,s')\\<in>\\<langle>Rl,Rr\\<rangle>sum_rel;\n     \\<And>l l'. \\<lbrakk> s=Inl l; s'=Inl l'; (l,l')\\<in>Rl \\<rbrakk> \\<Longrightarrow> (fl l, fl' l')\\<in>R;\n     \\<And>r r'. \\<lbrakk> s=Inr r; s'=Inr r'; (r,r')\\<in>Rr \\<rbrakk> \\<Longrightarrow> (fr r, fr' r')\\<in>R\n   \\<rbrakk> \\<Longrightarrow> (case_sum fl fr s, case_sum fl' fr' s')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel;\n     \\<And>l l'.\n        \\<lbrakk>s = Inl l; s' = Inl l'; (l, l') \\<in> Rl\\<rbrakk>\n        \\<Longrightarrow> (fl l, fl' l') \\<in> R;\n     \\<And>r r'.\n        \\<lbrakk>s = Inr r; s' = Inr r'; (r, r') \\<in> Rr\\<rbrakk>\n        \\<Longrightarrow> (fr r, fr' r') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (case s of Inl x \\<Rightarrow> fl x\n                       | Inr x \\<Rightarrow> fr x,\n                       case s' of Inl x \\<Rightarrow> fl' x\n                       | Inr x \\<Rightarrow> fr' x)\n                      \\<in> R", "by (auto split: sum.split)"], ["", "primrec is_Inl where \"is_Inl (Inl _) = True\" | \"is_Inl (Inr _) = False\""], ["", "primrec is_Inr where \"is_Inr (Inr _) = True\" | \"is_Inr (Inl _) = False\""], ["", "lemma is_Inl_param[param]: \"(is_Inl,is_Inl) \\<in> \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Inl, is_Inl)\n    \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> bool_rel", "unfolding is_Inl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu.\n        case uu of Inl uu_ \\<Rightarrow> True | Inr uv_ \\<Rightarrow> False,\n     \\<lambda>uu.\n        case uu of Inl uu_ \\<Rightarrow> True | Inr uv_ \\<Rightarrow> False)\n    \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma is_Inr_param[param]: \"(is_Inr,is_Inr) \\<in> \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Inr, is_Inr)\n    \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> bool_rel", "unfolding is_Inr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu.\n        case uu of Inl uv_ \\<Rightarrow> False | Inr uu_ \\<Rightarrow> True,\n     \\<lambda>uu.\n        case uu of Inl uv_ \\<Rightarrow> False | Inr uu_ \\<Rightarrow> True)\n    \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma sum_projl_param[param]: \n  \"\\<lbrakk>is_Inl s; (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n  \\<Longrightarrow> (Sum_Type.sum.projl s',Sum_Type.sum.projl s) \\<in> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Inl s;\n     (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (projl s', projl s) \\<in> Ra", "apply (cases s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>is_Inl s; (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel;\n        s = Inl a\\<rbrakk>\n       \\<Longrightarrow> (projl s', projl s) \\<in> Ra\n 2. \\<And>b.\n       \\<lbrakk>is_Inl s; (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel;\n        s = Inr b\\<rbrakk>\n       \\<Longrightarrow> (projl s', projl s) \\<in> Ra", "apply (auto elim: sum_relE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_projr_param[param]: \n  \"\\<lbrakk>is_Inr s; (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n  \\<Longrightarrow> (Sum_Type.sum.projr s',Sum_Type.sum.projr s) \\<in> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Inr s;\n     (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (projr s', projr s) \\<in> Rb", "apply (cases s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>is_Inr s; (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel;\n        s = Inl a\\<rbrakk>\n       \\<Longrightarrow> (projr s', projr s) \\<in> Rb\n 2. \\<And>b.\n       \\<lbrakk>is_Inr s; (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel;\n        s = Inr b\\<rbrakk>\n       \\<Longrightarrow> (projr s', projr s) \\<in> Rb", "apply (auto elim: sum_relE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>List\\<close>"], ["", "lemma list_rel_append1: \"(as @ bs, l) \\<in> \\<langle>R\\<rangle>list_rel \n  \\<longleftrightarrow> (\\<exists>cs ds. l = cs@ds \\<and> (as,cs)\\<in>\\<langle>R\\<rangle>list_rel \\<and> (bs,ds)\\<in>\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((as @ bs, l) \\<in> \\<langle>R\\<rangle>list_rel) =\n    (\\<exists>cs ds.\n        l = cs @ ds \\<and>\n        (as, cs) \\<in> \\<langle>R\\<rangle>list_rel \\<and>\n        (bs, ds) \\<in> \\<langle>R\\<rangle>list_rel)", "apply (simp add: list_rel_def list_all2_append1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us vs.\n        l = us @ vs \\<and>\n        length us = length as \\<and>\n        length vs = length bs \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) as us \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) bs vs) =\n    (\\<exists>cs ds.\n        l = cs @ ds \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) as cs \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) bs ds)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs ds.\n       \\<lbrakk>l = cs @ ds;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) as cs;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) bs ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            cs @ ds = us @ vs \\<and>\n                            length us = length as \\<and>\n                            length vs = length bs \\<and>\n                            list_all2 (\\<lambda>x x'. (x, x') \\<in> R) as\n                             us \\<and>\n                            list_all2 (\\<lambda>x x'. (x, x') \\<in> R) bs vs", "apply (metis list_all2_lengthD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_rel_append2: \"(l,as @ bs) \\<in> \\<langle>R\\<rangle>list_rel \n  \\<longleftrightarrow> (\\<exists>cs ds. l = cs@ds \\<and> (cs,as)\\<in>\\<langle>R\\<rangle>list_rel \\<and> (ds,bs)\\<in>\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, as @ bs) \\<in> \\<langle>R\\<rangle>list_rel) =\n    (\\<exists>cs ds.\n        l = cs @ ds \\<and>\n        (cs, as) \\<in> \\<langle>R\\<rangle>list_rel \\<and>\n        (ds, bs) \\<in> \\<langle>R\\<rangle>list_rel)", "apply (simp add: list_rel_def list_all2_append2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us vs.\n        l = us @ vs \\<and>\n        length us = length as \\<and>\n        length vs = length bs \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) us as \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) vs bs) =\n    (\\<exists>cs ds.\n        l = cs @ ds \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) cs as \\<and>\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ds bs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs ds.\n       \\<lbrakk>l = cs @ ds;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) cs as;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ds bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            cs @ ds = us @ vs \\<and>\n                            length us = length as \\<and>\n                            length vs = length bs \\<and>\n                            list_all2 (\\<lambda>x x'. (x, x') \\<in> R) us\n                             as \\<and>\n                            list_all2 (\\<lambda>x x'. (x, x') \\<in> R) vs bs", "apply (metis list_all2_lengthD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_append[param]: \n  \"(append, append)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((@), (@))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by (auto simp: list_rel_def list_all2_appendI)"], ["", "lemma param_list1[param]:\n  \"(Nil,Nil)\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"(Cons,Cons)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"\n  \"(case_list,case_list)\\<in>Rr\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], []) \\<in> \\<langle>R\\<rangle>list_rel &&&\n    ((#), (#))\n    \\<in> R \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel &&&\n    (case_list, case_list)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow>\n           \\<langle>R\\<rangle>list_rel \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> Rr", "apply (force dest: fun_relD split: list.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_rec_list[param]: \n  \"(rec_list,rec_list) \n  \\<in> Ra \\<rightarrow> (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra) \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list, rec_list)\n    \\<in> Ra \\<rightarrow>\n          (Rb \\<rightarrow>\n           \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n           Ra \\<rightarrow> Ra) \\<rightarrow>\n          \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra", "proof (intro fun_relI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (aa, a'a)\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra;\n        (ab, a'b) \\<in> \\<langle>Rb\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_list a aa ab, rec_list a' a'a a'b) \\<in> Ra", "case prems: (1 a a' f f' l l')"], ["proof (state)\nthis:\n  (a, a') \\<in> Ra\n  (f, f')\n  \\<in> Rb \\<rightarrow>\n        \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (aa, a'a)\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra;\n        (ab, a'b) \\<in> \\<langle>Rb\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_list a aa ab, rec_list a' a'a a'b) \\<in> Ra", "from prems(3)"], ["proof (chain)\npicking this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel", "show ?case"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (rec_list a f l, rec_list a' f' l') \\<in> Ra", "using prems(1,2)"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n  (a, a') \\<in> Ra\n  (f, f')\n  \\<in> Rb \\<rightarrow>\n        \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra\n\ngoal (1 subgoal):\n 1. (rec_list a f l, rec_list a' f' l') \\<in> Ra", "apply (induct arbitrary: a a')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f [], rec_list a' f' []) \\<in> Ra\n 2. \\<And>x x' l l' a a'.\n       \\<lbrakk>(x, x') \\<in> Rb;\n        (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel;\n        \\<And>a a'.\n           \\<lbrakk>(a, a') \\<in> Ra;\n            (f, f')\n            \\<in> Rb \\<rightarrow>\n                  \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n                  Ra \\<rightarrow> Ra\\<rbrakk>\n           \\<Longrightarrow> (rec_list a f l, rec_list a' f' l') \\<in> Ra;\n        (a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f (x # l), rec_list a' f' (x' # l'))\n                         \\<in> Ra", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' a a'.\n       \\<lbrakk>(x, x') \\<in> Rb;\n        (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel;\n        \\<And>a a'.\n           \\<lbrakk>(a, a') \\<in> Ra;\n            (f, f')\n            \\<in> Rb \\<rightarrow>\n                  \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n                  Ra \\<rightarrow> Ra\\<rbrakk>\n           \\<Longrightarrow> (rec_list a f l, rec_list a' f' l') \\<in> Ra;\n        (a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f (x # l), rec_list a' f' (x' # l'))\n                         \\<in> Ra", "apply (fastforce dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_list a f l, rec_list a' f' l') \\<in> Ra\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_case_list':\n  \"\\<lbrakk> (l,l')\\<in>\\<langle>Rb\\<rangle>list_rel;\n     \\<lbrakk>l=[]; l'=[]\\<rbrakk> \\<Longrightarrow> (n,n')\\<in>Ra;  \n     \\<And>x xs x' xs'. \\<lbrakk> l=x#xs; l'=x'#xs'; (x,x')\\<in>Rb; (xs,xs')\\<in>\\<langle>Rb\\<rangle>list_rel \\<rbrakk> \n     \\<Longrightarrow> (c x xs, c' x' xs')\\<in>Ra\n   \\<rbrakk> \\<Longrightarrow> (case_list n c l, case_list n' c' l') \\<in> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, l') \\<in> \\<langle>Rb\\<rangle>list_rel;\n     \\<lbrakk>l = []; l' = []\\<rbrakk> \\<Longrightarrow> (n, n') \\<in> Ra;\n     \\<And>x xs x' xs'.\n        \\<lbrakk>l = x # xs; l' = x' # xs'; (x, x') \\<in> Rb;\n         (xs, xs') \\<in> \\<langle>Rb\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> (c x xs, c' x' xs') \\<in> Ra\\<rbrakk>\n    \\<Longrightarrow> (case l of [] \\<Rightarrow> n\n                       | x # xa \\<Rightarrow> c x xa,\n                       case l' of [] \\<Rightarrow> n'\n                       | x # xa \\<Rightarrow> c' x xa)\n                      \\<in> Ra", "by (auto split: list.split)"], ["", "lemma param_map[param]: \n  \"(map,map)\\<in>(R1\\<rightarrow>R2) \\<rightarrow> \\<langle>R1\\<rangle>list_rel \\<rightarrow> \\<langle>R2\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map, map)\n    \\<in> (R1 \\<rightarrow> R2) \\<rightarrow>\n          \\<langle>R1\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R2\\<rangle>list_rel", "unfolding map_rec[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. rec_list [] (\\<lambda>x _. (#) (f x)),\n     \\<lambda>f. rec_list [] (\\<lambda>x _. (#) (f x)))\n    \\<in> (R1 \\<rightarrow> R2) \\<rightarrow>\n          \\<langle>R1\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R2\\<rangle>list_rel", "by (parametricity)"], ["", "lemma param_fold[param]: \n  \"(fold,fold)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"\n  \"(foldl,foldl)\\<in>(Rs\\<rightarrow>Re\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs\"\n  \"(foldr,foldr)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold, fold)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs &&&\n    (foldl, foldl)\n    \\<in> (Rs \\<rightarrow> Re \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs &&&\n    (foldr, foldr)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs", "unfolding List.fold_def List.foldr_def List.foldl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (xsa f \\<circ>\\<circ> f) x) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (xsa f \\<circ>\\<circ> f) x) uua uu)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs &&&\n    (\\<lambda>uu uua uub.\n        rec_list (\\<lambda>f a. a) (\\<lambda>x xs xsa f a. xsa f (f a x))\n         uub uu uua,\n     \\<lambda>uu uua uub.\n        rec_list (\\<lambda>f a. a) (\\<lambda>x xs xsa f a. xsa f (f a x))\n         uub uu uua)\n    \\<in> (Rs \\<rightarrow> Re \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs &&&\n    (\\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (f x \\<circ>\\<circ> xsa) f) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (f x \\<circ>\\<circ> xsa) f) uua uu)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs", "by (parametricity)+"], ["", "lemma param_list_all[param]: \"(list_all,list_all) \\<in> (A\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all, list_all)\n    \\<in> (A \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "by (fold rel2p_def) (simp add: rel2p List.list_all_transfer)"], ["", "context begin"], ["", "private"], ["", "primrec list_all2_alt :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> bool\" where\n    \"list_all2_alt P [] ys \\<longleftrightarrow> (case ys of [] \\<Rightarrow> True | _ \\<Rightarrow> False)\"\n  | \"list_all2_alt P (x#xs) ys \\<longleftrightarrow> (case ys of [] \\<Rightarrow> False | y#ys \\<Rightarrow> P x y \\<and> list_all2_alt P xs ys)\""], ["", "private"], ["", "lemma list_all2_alt: \"list_all2 P xs ys = list_all2_alt P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 P xs ys = list_all2_alt P xs ys", "by (induction xs arbitrary: ys) (auto split: list.splits)"], ["", "lemma param_list_all2[param]: \"(list_all2, list_all2) \\<in> (A\\<rightarrow>B\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>B\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2, list_all2)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>B\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding list_all2_alt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2_alt, list_all2_alt)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>B\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding list_all2_alt_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>P xs.\n        rec_list (\\<lambda>P. case_list True (\\<lambda>a list. False))\n         (\\<lambda>x xs xsa P.\n             case_list False (\\<lambda>y ys. P x y \\<and> xsa P ys))\n         xs P,\n     \\<lambda>P xs.\n        rec_list (\\<lambda>P. case_list True (\\<lambda>a list. False))\n         (\\<lambda>x xs xsa P.\n             case_list False (\\<lambda>y ys. P x y \\<and> xsa P ys))\n         xs P)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>B\\<rangle>list_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "end"], ["", "lemma param_hd[param]: \"l\\<noteq>[] \\<Longrightarrow> (l',l)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> (hd l', hd l)\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> [];\n     (l', l) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (hd l', hd l) \\<in> A", "unfolding hd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> [];\n     (l', l) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (case l' of x21 # x22 \\<Rightarrow> x21,\n                       case l of x21 # x22 \\<Rightarrow> x21)\n                      \\<in> A", "by (auto split: list.splits)"], ["", "lemma param_last[param]: \n  assumes \"y \\<noteq> []\" \n  assumes \"(x, y) \\<in> \\<langle>A\\<rangle>list_rel\"  \n  shows \"(last x, last y) \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last x, last y) \\<in> A", "using assms(2,1)"], ["proof (prove)\nusing this:\n  (x, y) \\<in> \\<langle>A\\<rangle>list_rel\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. (last x, last y) \\<in> A", "by (induction rule: list_rel_induct) auto"], ["", "lemma param_rotate1[param]: \"(rotate1, rotate1) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotate1, rotate1)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel", "unfolding rotate1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list [] (\\<lambda>x xs xsa. xs @ [x]),\n     rec_list [] (\\<lambda>x xs xsa. xs @ [x]))\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel", "by parametricity"], ["", "schematic_goal param_take[param]: \"(take,take)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take, take) \\<in> ?R", "unfolding take_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> [] | Suc m \\<Rightarrow> x # xsa m)\n         uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> [] | Suc m \\<Rightarrow> x # xsa m)\n         uua uu)\n    \\<in> ?R", "by (parametricity)"], ["", "schematic_goal param_drop[param]: \"(drop,drop)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (drop, drop) \\<in> ?R", "unfolding drop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> x # xs | Suc m \\<Rightarrow> xsa m)\n         uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> x # xs | Suc m \\<Rightarrow> xsa m)\n         uua uu)\n    \\<in> ?R", "by (parametricity)"], ["", "schematic_goal param_length[param]: \n  \"(length,length)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, length) \\<in> ?R", "unfolding size_list_overloaded_def size_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list 0 (\\<lambda>x xa xb. 0 + xb + Suc 0),\n     rec_list 0 (\\<lambda>x xa xb. 0 + xb + Suc 0))\n    \\<in> ?R", "by (parametricity)"], ["", "fun list_eq :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"list_eq eq [] [] \\<longleftrightarrow> True\"\n| \"list_eq eq (a#l) (a'#l') \n     \\<longleftrightarrow> (if eq a a' then list_eq eq l l' else False)\"\n| \"list_eq _ _ _ \\<longleftrightarrow> False\""], ["", "lemma param_list_eq[param]: \"\n  (list_eq,list_eq) \\<in> \n    (R \\<rightarrow> R \\<rightarrow> Id) \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_eq, list_eq)\n    \\<in> (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "proof (intro fun_relI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, a'b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq a aa ab, list_eq a' a'a a'b)\n                         \\<in> bool_rel", "case prems: (1 eq eq' l1 l1' l2 l2')"], ["proof (state)\nthis:\n  (eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\n  (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel\n  (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, a'b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq a aa ab, list_eq a' a'a a'b)\n                         \\<in> bool_rel", "thus ?case"], ["proof (prove)\nusing this:\n  (eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\n  (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel\n  (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (list_eq eq l1 l2, list_eq eq' l1' l2') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n     (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel;\n     (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (list_eq eq l1 l2, list_eq eq' l1' l2') \\<in> bool_rel", "apply (induct eq' l1' l2' arbitrary: l1 l2 rule: list_eq.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>eqa l1 l2.\n       \\<lbrakk>(eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq eq l1 l2, list_eq eqa [] [])\n                         \\<in> bool_rel\n 2. \\<And>eqa a l a' l' l1 l2.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (list_eq eq l1 l2, list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq eq l1 l2, list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq eq l1 l2, list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 4. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_eq eq l1 l2, list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (simp_all only: list_eq.simps |\n      elim list_relE |\n      parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (list_eq eq l1 l2, list_eq eq' l1' l2') \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma id_list_eq_aux[simp]: \"(list_eq (=)) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_eq (=) = (=)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. list_eq (=) x xa = (x = xa)", "fix l1 l2 :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. list_eq (=) x xa = (x = xa)", "show \"list_eq (=) l1 l2 = (l1 = l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_eq (=) l1 l2 = (l1 = l2)", "apply (induct \"(=) :: 'a \\<Rightarrow> _\" l1 l2 rule: list_eq.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_eq (=) [] [] = ([] = [])\n 2. \\<And>a l a' l'.\n       (a = a' \\<Longrightarrow>\n        list_eq (=) l l' = (l = l')) \\<Longrightarrow>\n       list_eq (=) (a # l) (a' # l') = (a # l = a' # l')\n 3. \\<And>v va. list_eq (=) (v # va) [] = (v # va = [])\n 4. \\<And>v va. list_eq (=) [] (v # va) = ([] = v # va)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_eq (=) l1 l2 = (l1 = l2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_list_equals[param]:\n  \"\\<lbrakk> ((=), (=)) \\<in> R\\<rightarrow>R\\<rightarrow>Id \\<rbrakk> \n  \\<Longrightarrow> ((=), (=)) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<Longrightarrow>\n    ((=), (=))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding id_list_eq_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<Longrightarrow>\n    (list_eq (=), list_eq (=))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "by (parametricity)"], ["", "lemma param_tl[param]:\n  \"(tl,tl) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tl, tl)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "unfolding tl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>list.\n        case list of [] \\<Rightarrow> [] | x21 # x22 \\<Rightarrow> x22,\n     \\<lambda>list.\n        case list of [] \\<Rightarrow> [] | x21 # x22 \\<Rightarrow> x22)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by (parametricity)"], ["", "primrec list_all_rec where\n  \"list_all_rec P [] \\<longleftrightarrow> True\"\n| \"list_all_rec P (a#l) \\<longleftrightarrow> P a \\<and> list_all_rec P l\""], ["", "primrec list_ex_rec where\n  \"list_ex_rec P [] \\<longleftrightarrow> False\"\n| \"list_ex_rec P (a#l) \\<longleftrightarrow> P a \\<or> list_ex_rec P l\""], ["", "lemma list_all_rec_eq: \"(\\<forall>x\\<in>set l. P x) = list_all_rec P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set l. P x) = list_all_rec P l", "by (induct l) auto"], ["", "lemma list_ex_rec_eq: \"(\\<exists>x\\<in>set l. P x) = list_ex_rec P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>set l. P x) = list_ex_rec P l", "by (induct l) auto"], ["", "lemma param_list_ball[param]:\n  \"\\<lbrakk>(P,P')\\<in>(Ra\\<rightarrow>Id); (l,l')\\<in>\\<langle>Ra\\<rangle> list_rel\\<rbrakk> \n    \\<Longrightarrow> (\\<forall>x\\<in>set l. P x, \\<forall>x\\<in>set l'. P' x) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>set l. P x,\n                       \\<forall>x\\<in>set l'. P' x)\n                      \\<in> bool_rel", "unfolding list_all_rec_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (list_all_rec P l, list_all_rec P' l') \\<in> bool_rel", "unfolding list_all_rec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (rec_list (\\<lambda>P. True)\n                        (\\<lambda>a l la P. P a \\<and> la P) l P,\n                       rec_list (\\<lambda>P. True)\n                        (\\<lambda>a l la P. P a \\<and> la P) l' P')\n                      \\<in> bool_rel", "by (parametricity)"], ["", "lemma param_list_bex[param]:\n  \"\\<lbrakk>(P,P')\\<in>(Ra\\<rightarrow>Id); (l,l')\\<in>\\<langle>Ra\\<rangle> list_rel\\<rbrakk> \n    \\<Longrightarrow> (\\<exists>x\\<in>set l. P x, \\<exists>x\\<in>set l'. P' x) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x\\<in>set l. P x,\n                       \\<exists>x\\<in>set l'. P' x)\n                      \\<in> bool_rel", "unfolding list_ex_rec_eq[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (list_ex_rec P l, list_ex_rec P' l') \\<in> bool_rel", "unfolding list_ex_rec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P, P') \\<in> Ra \\<rightarrow> bool_rel;\n     (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (rec_list (\\<lambda>P. False)\n                        (\\<lambda>a l la P. P a \\<or> la P) l P,\n                       rec_list (\\<lambda>P. False)\n                        (\\<lambda>a l la P. P a \\<or> la P) l' P')\n                      \\<in> bool_rel", "by (parametricity)"], ["", "lemma param_rev[param]: \"(rev,rev) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev, rev)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "unfolding rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list [] (\\<lambda>x xs xsa. xsa @ [x]),\n     rec_list [] (\\<lambda>x xs xsa. xsa @ [x]))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by (parametricity)"], ["", "lemma param_foldli[param]: \"(foldli, foldli) \n  \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow> (Rs\\<rightarrow>Id) \\<rightarrow> (Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli, foldli)\n    \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow>\n          (Rs \\<rightarrow> bool_rel) \\<rightarrow>\n          (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> Rs", "unfolding foldli_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list (\\<lambda>c f \\<sigma>. \\<sigma>)\n      (\\<lambda>x xs xsa c f \\<sigma>.\n          if c \\<sigma> then xsa c f (f x \\<sigma>) else \\<sigma>),\n     rec_list (\\<lambda>c f \\<sigma>. \\<sigma>)\n      (\\<lambda>x xs xsa c f \\<sigma>.\n          if c \\<sigma> then xsa c f (f x \\<sigma>) else \\<sigma>))\n    \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow>\n          (Rs \\<rightarrow> bool_rel) \\<rightarrow>\n          (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> Rs", "by parametricity"], ["", "lemma param_foldri[param]: \"(foldri, foldri) \n  \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow> (Rs\\<rightarrow>Id) \\<rightarrow> (Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldri, foldri)\n    \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow>\n          (Rs \\<rightarrow> bool_rel) \\<rightarrow>\n          (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> Rs", "unfolding foldri_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. foldli (rev l), \\<lambda>l. foldli (rev l))\n    \\<in> \\<langle>Re\\<rangle>list_rel \\<rightarrow>\n          (Rs \\<rightarrow> bool_rel) \\<rightarrow>\n          (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> Rs", "by parametricity"], ["", "lemma param_nth[param]: \n  assumes I: \"i'<length l'\"\n  assumes IR: \"(i,i')\\<in>nat_rel\"\n  assumes LR: \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\" \n  shows \"(l!i,l'!i') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i, l' ! i') \\<in> R", "using LR I IR"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n  i' < length l'\n  (i, i') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (l ! i, l' ! i') \\<in> R", "by (induct arbitrary: i i' rule: list_rel_induct) \n     (auto simp: nth.simps split: nat.split)"], ["", "lemma param_replicate[param]:\n  \"(replicate,replicate) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate, replicate)\n    \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel", "unfolding replicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_nat (\\<lambda>x. []) (\\<lambda>n na x. x # na x),\n     rec_nat (\\<lambda>x. []) (\\<lambda>n na x. x # na x))\n    \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel", "by parametricity"], ["", "term list_update"], ["", "lemma param_list_update[param]: \n  \"(list_update,list_update) \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> nat_rel \\<rightarrow> Ra \\<rightarrow> \\<langle>Ra\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_update, list_update)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          Ra \\<rightarrow> \\<langle>Ra\\<rangle>list_rel", "unfolding list_update_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list (\\<lambda>i v. [])\n      (\\<lambda>x xs xsa i v.\n          case i of 0 \\<Rightarrow> v # xs\n          | Suc j \\<Rightarrow> x # xsa j v),\n     rec_list (\\<lambda>i v. [])\n      (\\<lambda>x xs xsa i v.\n          case i of 0 \\<Rightarrow> v # xs\n          | Suc j \\<Rightarrow> x # xsa j v))\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          Ra \\<rightarrow> \\<langle>Ra\\<rangle>list_rel", "by parametricity"], ["", "lemma param_zip[param]:\n  \"(zip, zip) \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip, zip)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Ra \\<times>\\<^sub>r Rb\\<rangle>list_rel", "unfolding zip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>xs. [])\n         (\\<lambda>y ys ysa xs.\n             case xs of [] \\<Rightarrow> []\n             | z # zs \\<Rightarrow> (z, y) # ysa zs)\n         uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>xs. [])\n         (\\<lambda>y ys ysa xs.\n             case xs of [] \\<Rightarrow> []\n             | z # zs \\<Rightarrow> (z, y) # ysa zs)\n         uua uu)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Ra \\<times>\\<^sub>r Rb\\<rangle>list_rel", "by parametricity"], ["", "lemma param_upt[param]:\n  \"(upt, upt) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (upt, upt)\n    \\<in> nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel", "unfolding upt_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_nat (\\<lambda>i. [])\n         (\\<lambda>j ja i. if i \\<le> j then ja i @ [j] else []) uua uu,\n     \\<lambda>uu uua.\n        rec_nat (\\<lambda>i. [])\n         (\\<lambda>j ja i. if i \\<le> j then ja i @ [j] else []) uua uu)\n    \\<in> nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel", "by parametricity"], ["", "lemma param_concat[param]: \"(concat, concat) \\<in> \n    \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat, concat)\n    \\<in> \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "unfolding concat_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list [] (\\<lambda>x xs. (@) x), rec_list [] (\\<lambda>x xs. (@) x))\n    \\<in> \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by parametricity"], ["", "lemma param_all_interval_nat[param]: \n  \"(List.all_interval_nat, List.all_interval_nat) \n  \\<in> (nat_rel \\<rightarrow> bool_rel) \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (List.all_interval_nat, List.all_interval_nat)\n    \\<in> (nat_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel", "unfolding List.all_interval_nat_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>P i j. Ball {i..<j} P, \\<lambda>P i j. Ball {i..<j} P)\n    \\<in> (nat_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> nat_rel \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> nat_rel; (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ({aa..<ab}, {a'a..<a'b})\n                         \\<in> \\<langle>nat_rel\\<rangle>set_rel", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_dropWhile[param]: \n  \"(dropWhile, dropWhile) \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>a\\<rangle>list_rel \\<rightarrow> \\<langle>a\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dropWhile, dropWhile)\n    \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel", "unfolding dropWhile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>P. [])\n         (\\<lambda>x xs xsa P. if P x then xsa P else x # xs) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>P. [])\n         (\\<lambda>x xs xsa P. if P x then xsa P else x # xs) uua uu)\n    \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel", "by parametricity"], ["", "lemma param_takeWhile[param]: \n  \"(takeWhile, takeWhile) \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>a\\<rangle>list_rel \\<rightarrow> \\<langle>a\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (takeWhile, takeWhile)\n    \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel", "unfolding takeWhile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>P. [])\n         (\\<lambda>x xs xsa P. if P x then x # xsa P else []) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>P. [])\n         (\\<lambda>x xs xsa P. if P x then x # xsa P else []) uua uu)\n    \\<in> (a \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel \\<rightarrow>\n          \\<langle>a\\<rangle>list_rel", "by parametricity"], ["", "end"]]}