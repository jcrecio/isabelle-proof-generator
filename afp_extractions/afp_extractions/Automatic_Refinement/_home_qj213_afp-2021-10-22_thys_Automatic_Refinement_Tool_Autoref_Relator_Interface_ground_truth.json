{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Tool/Autoref_Relator_Interface.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma REL_INTFI: \"REL_INTF R I\""], "translations": [["", "lemma REL_INTFI: \"REL_INTF R I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_INTF R I", "by simp"], ["", "ML \\<open>\n  (* Keeping track of relator - interface bindings *)\n  signature AUTOREF_RELATOR_INTERFACE = sig\n    val mk_intfAPP: term -> term -> term\n\n    val declare_rel_intf: thm -> Context.generic -> Context.generic\n    val delete_rel_intf: thm -> Context.generic -> Context.generic\n    val get_rel_intfs: Proof.context -> thm list\n\n    val intf_of_rel: Proof.context -> term -> term\n    val list_invented_intf: term -> term list\n    val warn_invented_intf: Proof.context -> term -> unit\n\n    val itype_of_rule: Proof.context -> thm -> (term * term) option\n\n    val setup: theory -> theory\n  end\n\n  structure Autoref_Relator_Interface :AUTOREF_RELATOR_INTERFACE = struct\n\n    structure relator_intf = Named_Thms (\n      val name = @{binding autoref_rel_intf}\n      val description = \"Relator interface declaration\"\n    )\n  \n    val declare_rel_intf = relator_intf.add_thm\n    val delete_rel_intf = relator_intf.del_thm\n    val get_rel_intfs = relator_intf.get\n\n    fun mk_intfAPP I J = let\n      val JT = fastype_of J\n      val rT = range_type JT\n    in\n      Const (@{const_name intfAPP},JT --> @{typ interface} --> rT) $ J $ I\n    end\n\n    fun intf_of_rel ctxt R = let\n      fun dest_ri thm = case Thm.prop_of thm of\n        @{mpat \"Trueprop (REL_INTF ?R ?I)\"} => SOME (R,I)\n      | _ => NONE\n\n      val rel_intfs = relator_intf.get ctxt\n        |> map Drule.zero_var_indexes\n        |> map_filter dest_ri\n\n      val thy = Proof_Context.theory_of ctxt\n\n      fun get_ri R = \n        find_first (fn (p,_) => Pattern.matches thy (p,R)) rel_intfs\n      |> map_option #2\n\n      val idx = Term.maxidx_of_term R + 1\n\n      fun mk_i_of R T = \n        Const (@{const_name i_of_rel}, fastype_of R --> T)$R\n\n      fun r @{mpat \"\\<langle>?Ra\\<rangle>?Rf\"} i = mk_intfAPP (r Ra 0) (r Rf (i+1))\n        | r R i = (case get_ri R of \n            SOME I => I |> Logic.incr_indexes ([], [], idx)\n          | NONE => let\n              val T = replicate i @{typ interface} ---> @{typ interface}\n            in \n              case R of\n                Free (_,_) => mk_i_of R T\n              | Var ((name,idx'),_) => Var ((name,idx+idx'+2),T)\n              | _ => mk_i_of R T\n            end\n          )\n\n    in\n      r R 0\n    |> Term_Subst.zero_var_indexes \n    end\n\n    fun \n      list_invented_intf @{mpat \"i_of_rel ?c\"} = [c] \n    | list_invented_intf (f$x) =\n        list_invented_intf f @ list_invented_intf x\n    | list_invented_intf (Abs (_,_,t)) = list_invented_intf t\n    | list_invented_intf _ = []\n\n    fun warn_invented_intf ctxt I = case list_invented_intf I of\n      [] => ()\n    | l => Pretty.block [\n        Pretty.str \"No interfaces known for constant(s):\",\n        Pretty.brk 1,\n        Pretty.block (Pretty.commas (map (Syntax.pretty_term ctxt) l))\n      ] |> Pretty.string_of |> warning\n\n    fun itype_of_rule ctxt thm = \n      case try (Autoref_Fix_Rel.constraint_of_thm ctxt) thm of\n        NONE => NONE\n      | SOME (_,(f,R)) => let\n          val I = intf_of_rel ctxt R\n        in\n          SOME (f,I)\n        end\n\n  \n    val setup = relator_intf.setup\n  end\n\\<close>"], ["", "setup Autoref_Relator_Interface.setup"], ["", "attribute_setup autoref_rules = \\<open>\n  Scan.lift (Args.mode \"overloaded\")\n  >> (fn overl => Thm.declaration_attribute (fn thm => fn context => let\n    val context = Autoref_Rules.add_thm thm context\n    val ctxt = Context.proof_of context\n  in\n    case Autoref_Relator_Interface.itype_of_rule ctxt thm of\n      NONE => (warning \"Strange autoref rule: Could not infer relator\"; context)\n    | SOME (c,I) => Autoref_Id_Ops.decl_derived_typing overl c I context\n  end\n  ))\n\\<close>"], ["", "end"]]}