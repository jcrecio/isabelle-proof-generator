{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Parametricity/Param_Tool.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma tag_both: \"\\<lbrakk> (Let x f,Let x' f')\\<in>R \\<rbrakk> \\<Longrightarrow> (f x,f' x')\\<in>R\"", "lemma tag_rhs: \"\\<lbrakk> (c,Let x f)\\<in>R \\<rbrakk> \\<Longrightarrow> (c,f x)\\<in>R\"", "lemma tag_lhs: \"\\<lbrakk> (Let x f,a)\\<in>R \\<rbrakk> \\<Longrightarrow> (f x,a)\\<in>R\"", "lemma tagged_fun_relD_both: \n    \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (Let x f,Let x' f')\\<in>B\"\n    and tagged_fun_relD_rhs: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x,Let x' f')\\<in>B\"\n    and tagged_fun_relD_lhs: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (Let x f,f' x')\\<in>B\"\n    and tagged_fun_relD_none: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x,f' x')\\<in>B\""], "translations": [["", "lemma tag_both: \"\\<lbrakk> (Let x f,Let x' f')\\<in>R \\<rbrakk> \\<Longrightarrow> (f x,f' x')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let x f, Let x' f') \\<in> R \\<Longrightarrow> (f x, f' x') \\<in> R", "by simp"], ["", "lemma tag_rhs: \"\\<lbrakk> (c,Let x f)\\<in>R \\<rbrakk> \\<Longrightarrow> (c,f x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, Let x f) \\<in> R \\<Longrightarrow> (c, f x) \\<in> R", "by simp"], ["", "lemma tag_lhs: \"\\<lbrakk> (Let x f,a)\\<in>R \\<rbrakk> \\<Longrightarrow> (f x,a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let x f, a) \\<in> R \\<Longrightarrow> (f x, a) \\<in> R", "by simp"], ["", "lemma tagged_fun_relD_both: \n    \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (Let x f,Let x' f')\\<in>B\"\n    and tagged_fun_relD_rhs: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x,Let x' f')\\<in>B\"\n    and tagged_fun_relD_lhs: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (Let x f,f' x')\\<in>B\"\n    and tagged_fun_relD_none: \"\\<lbrakk> (f,f')\\<in>A\\<rightarrow>B; (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x,f' x')\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n      \\<Longrightarrow> (Let x f, Let x' f') \\<in> B) &&&\n     (\\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n      \\<Longrightarrow> (f x, Let x' f') \\<in> B)) &&&\n    (\\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n     \\<Longrightarrow> (Let x f, f' x') \\<in> B) &&&\n    (\\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n     \\<Longrightarrow> (f x, f' x') \\<in> B)", "by (simp_all add: fun_relD)"], ["", "subsection \\<open>ML-Setup\\<close>"], ["", "ML \\<open>\n    signature PARAMETRICITY = sig\n      type param_ruleT = {\n        lhs: term,\n        rhs: term,\n        R: term,\n        rhs_head: term,\n        arity: int\n      }\n    \n      val dest_param_term: term -> param_ruleT\n      val dest_param_rule: thm -> param_ruleT\n      val dest_param_goal: int -> thm -> param_ruleT\n\n      val safe_fun_relD_tac: Proof.context -> tactic'\n\n      val adjust_arity: int -> thm -> thm\n      val adjust_arity_tac: int -> Proof.context -> tactic'\n      val unlambda_tac: Proof.context -> tactic'\n      val prepare_tac: Proof.context -> tactic'\n\n      val fo_rule: thm -> thm\n\n      (*** Basic tactics ***)\n      val param_rule_tac: Proof.context -> thm -> tactic'\n      val param_rules_tac: Proof.context -> thm list -> tactic'\n      val asm_param_tac: Proof.context -> tactic'\n\n\n      (*** Nets of parametricity rules ***)\n      type param_net\n      val net_empty: param_net\n      val net_add: thm -> param_net -> param_net\n      val net_del: thm -> param_net -> param_net\n      val net_add_int: Context.generic -> thm -> param_net -> param_net\n      val net_del_int: Context.generic -> thm -> param_net -> param_net\n      val net_tac: param_net -> Proof.context -> tactic'\n    \n      (*** Default parametricity rules ***)\n      val add_dflt: thm -> Context.generic -> Context.generic\n      val add_dflt_attr: attribute\n      val del_dflt: thm -> Context.generic -> Context.generic\n      val del_dflt_attr: attribute\n      val get_dflt: Proof.context -> param_net\n\n      (** Configuration **)\n      val cfg_use_asm: bool Config.T\n      val cfg_single_step: bool Config.T\n\n      (** Setup **)\n      val setup: theory -> theory\n    end\n\n    structure Parametricity : PARAMETRICITY = struct\n      type param_ruleT = {\n        lhs: term,\n        rhs: term,\n        R: term,\n        rhs_head: term,\n        arity: int\n      }\n\n      fun dest_param_term t = \n        case \n          strip_all_body t |> Logic.strip_imp_concl |> HOLogic.dest_Trueprop\n        of \n          @{mpat \"(?lhs,?rhs):?R\"} => let \n            val (rhs_head,arity) = \n              case strip_comb rhs of\n                (c as Const _,l) => (c,length l)\n              | (c as Free _,l) => (c,length l)\n              | (c as Abs _,l) => (c,length l)\n              | _ => raise TERM (\"dest_param_term: Head\",[t])\n          in \n            { lhs = lhs, rhs = rhs, R=R, rhs_head = rhs_head, arity = arity }\n          end\n        | t => raise TERM (\"dest_param_term: Expected (_,_):_\",[t])\n\n      val dest_param_rule = dest_param_term o Thm.prop_of\n      fun dest_param_goal i st = \n        if i > Thm.nprems_of st then\n          raise THM (\"dest_param_goal\",i,[st])\n        else\n          dest_param_term (Logic.concl_of_goal (Thm.prop_of st) i)\n\n\n      fun safe_fun_relD_tac ctxt = let\n        fun t a b = fo_resolve_tac [a] ctxt THEN' resolve_tac ctxt [b]\n      in\n        DETERM o (\n          t @{thm tag_both} @{thm tagged_fun_relD_both} ORELSE'\n          t @{thm tag_rhs} @{thm tagged_fun_relD_rhs} ORELSE'\n          t @{thm tag_lhs} @{thm tagged_fun_relD_lhs} ORELSE'\n          resolve_tac ctxt @{thms tagged_fun_relD_none}\n        )\n      end\n\n      fun adjust_arity i thm = \n        if i = 0 then thm \n        else if i<0 then funpow (~i) (fn thm => thm RS @{thm fun_relI}) thm\n        else funpow i (fn thm => thm RS @{thm fun_relD}) thm\n\n      fun NTIMES k tac = \n        if k <= 0 then K all_tac \n        else tac THEN' NTIMES (k-1) tac\n\n      fun adjust_arity_tac n ctxt i st = \n        (if n = 0 then K all_tac\n        else if n>0 then NTIMES n (DETERM o resolve_tac ctxt @{thms fun_relI})\n        else NTIMES (~n) (safe_fun_relD_tac ctxt)) i st\n\n      fun unlambda_tac ctxt i st = \n        case try (dest_param_goal i) st of\n          NONE => Seq.empty\n        | SOME g => let\n            val n = Term.strip_abs (#rhs_head g) |> #1 |> length\n          in NTIMES n (resolve_tac ctxt @{thms fun_relI}) i st end\n\n      fun prepare_tac ctxt = \n        Subgoal.FOCUS (K (PRIMITIVE (Drule.eta_contraction_rule))) ctxt\n        THEN' unlambda_tac ctxt\n\n\n      fun could_param_rl rl i st = \n        if i > Thm.nprems_of st then NONE\n        else (\n          case (try (dest_param_goal i) st, try dest_param_term rl) of\n            (SOME g, SOME r) =>\n              if Term.could_unify (#rhs_head g, #rhs_head r) then\n                SOME (#arity r - #arity g)\n              else NONE\n          | _ => NONE\n        )\n\n      fun param_rule_tac_aux ctxt rl i st = \n        case could_param_rl (Thm.prop_of rl) i st of\n          SOME adj => (adjust_arity_tac adj ctxt THEN' resolve_tac ctxt [rl]) i st\n        | _ => Seq.empty\n\n      fun param_rule_tac ctxt rl = \n        prepare_tac ctxt THEN' param_rule_tac_aux ctxt rl\n\n      fun param_rules_tac ctxt rls = \n        prepare_tac ctxt THEN' FIRST' (map (param_rule_tac_aux ctxt) rls)\n\n      fun asm_param_tac_aux ctxt i st = \n        if i > Thm.nprems_of st then Seq.empty\n        else let\n          val prems = Logic.prems_of_goal (Thm.prop_of st) i |> tag_list 1\n          \n          fun tac (n,t) i st = case could_param_rl t i st of\n            SOME adj => (adjust_arity_tac adj ctxt THEN' rprem_tac n ctxt) i st\n          | NONE => Seq.empty\n        in\n          FIRST' (map tac prems) i st\n        end\n\n      fun asm_param_tac ctxt = prepare_tac ctxt THEN' asm_param_tac_aux ctxt\n    \n      type param_net = (param_ruleT * thm) Item_Net.T\n\n      local\n        val param_get_key = single o #rhs_head o #1\n      in \n        val net_empty = Item_Net.init (Thm.eq_thm o apply2 #2) param_get_key\n      end\n\n      fun wrap_pr_op f context thm = case try (`dest_param_rule) thm of\n        NONE => \n          let \n            val msg = \"Ignoring invalid parametricity theorem: \"\n              ^ Thm.string_of_thm (Context.proof_of context) thm\n            val _ = warning msg\n          in I end\n      | SOME p => f p\n    \n      val net_add_int = wrap_pr_op Item_Net.update \n      val net_del_int = wrap_pr_op Item_Net.remove\n\n      val net_add = Item_Net.update o `dest_param_rule\n      val net_del = Item_Net.remove o `dest_param_rule\n\n      fun net_tac_aux net ctxt i st = \n        if i > Thm.nprems_of st then \n          Seq.empty \n        else\n          let\n            val g = dest_param_goal i st\n            val rls = Item_Net.retrieve net (#rhs_head g)\n        \n            fun tac (r,thm) = \n              adjust_arity_tac (#arity r - #arity g) ctxt \n              THEN' DETERM o resolve_tac ctxt [thm]\n          in \n            FIRST' (map tac rls) i st\n          end\n\n      fun net_tac net ctxt = prepare_tac ctxt THEN' net_tac_aux net ctxt\n\n      structure dflt_rules = Generic_Data (\n        type T = param_net\n        val empty = net_empty\n        val extend = I\n        val merge = Item_Net.merge\n      )\n        \n      fun add_dflt thm context = dflt_rules.map (net_add_int context thm) context\n      fun del_dflt thm context = dflt_rules.map (net_del_int context thm) context\n      val add_dflt_attr = Thm.declaration_attribute add_dflt\n      val del_dflt_attr = Thm.declaration_attribute del_dflt\n\n      val get_dflt = dflt_rules.get o Context.Proof\n\n      val cfg_use_asm = \n        Attrib.setup_config_bool @{binding param_use_asm} (K true)\n      val cfg_single_step = \n        Attrib.setup_config_bool @{binding param_single_step} (K false)\n\n      local\n        open Refine_Util\n\n        val param_modifiers =\n          [Args.add -- Args.colon >> K (Method.modifier add_dflt_attr \\<^here>),\n           Args.del -- Args.colon >> K (Method.modifier del_dflt_attr \\<^here>),\n           Args.$$$ \"only\" -- Args.colon >>\n            K {init = Context.proof_map (dflt_rules.map (K net_empty)),\n                attribute = add_dflt_attr, pos = \\<^here>}]\n\n        val param_flags = \n           parse_bool_config \"use_asm\" cfg_use_asm\n        || parse_bool_config \"single_step\" cfg_single_step\n\n      in\n          \n        val parametricity_method = \n          parse_paren_lists param_flags |-- Method.sections param_modifiers >> \n          (fn _ => fn ctxt => \n            let\n              val net2 = get_dflt ctxt\n              val asm_tac = \n                if Config.get ctxt cfg_use_asm then \n                  asm_param_tac ctxt\n                else K no_tac\n   \n              val RPT = \n                if Config.get ctxt cfg_single_step then I\n                else REPEAT_ALL_NEW_FWD\n  \n            in\n              SIMPLE_METHOD' (\n                RPT (\n                  (assume_tac ctxt \n                    ORELSE' net_tac net2 ctxt\n                    ORELSE' asm_tac)\n                ) \n              )\n            end\n          )\n      end\n\n      fun fo_rule thm = case Thm.concl_of thm of\n            @{mpat \"Trueprop ((_,_)\\<in>_\\<rightarrow>_)\"} => fo_rule (thm RS @{thm fun_relD})\n          | _ => thm \n          \n      val param_fo_attr = Scan.succeed (Thm.rule_attribute [] (K fo_rule))\n\n      val setup = I\n        #> Attrib.setup @{binding param} \n            (Attrib.add_del add_dflt_attr del_dflt_attr)\n            \"declaration of parametricity theorem\"\n        #> Global_Theory.add_thms_dynamic (@{binding param}, \n             map #2 o Item_Net.content o dflt_rules.get)\n        #> Method.setup @{binding parametricity} parametricity_method \n             \"Parametricity solver\"\n        #> Attrib.setup @{binding param_fo} param_fo_attr \n             \"Parametricity: Rule in first-order form\"\n\n    end\n\\<close>"], ["", "setup Parametricity.setup"], ["", "subsection \\<open>Convenience Tools\\<close>"], ["", "ML \\<open>\n    (* Prefix p_ or wrong type supresses generation of relAPP *)\n  \n    fun cnv_relAPP t = let\n      fun consider (Var ((name,_),T)) =\n        if String.isPrefix \"p_\" name then false   \n        else (\n          case T of\n            Type(@{type_name set},[Type(@{type_name prod},_)]) => true\n          | _ => false)\n      | consider _ = true\n  \n      fun strip_rcomb u : term * term list =\n        let \n          fun stripc (x as (f$t, ts)) = \n            if consider t then stripc (f, t::ts) else x\n          | stripc  x =  x\n        in  stripc(u,[])  end;\n  \n      val (f,a) = strip_rcomb t\n    in \n      Relators.list_relAPP a f\n    end\n  \n    fun to_relAPP_conv ctxt = Refine_Util.f_tac_conv ctxt \n      cnv_relAPP \n      (ALLGOALS (simp_tac \n        (put_simpset HOL_basic_ss ctxt addsimps @{thms relAPP_def})))\n  \n  \n    val to_relAPP_attr = Thm.rule_attribute [] (fn context => let\n      val ctxt = Context.proof_of context\n    in\n      Conv.fconv_rule (Conv.arg1_conv (to_relAPP_conv ctxt))\n    end)\n\\<close>"], ["", "attribute_setup to_relAPP = \\<open>Scan.succeed (to_relAPP_attr)\\<close> \n    \"Convert relator definition to prefix-form\""], ["", "end"]]}