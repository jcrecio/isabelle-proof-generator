{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Lib/Foldi.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma foldli_not_cond [simp] :\n   \"\\<not>(c \\<sigma>) \\<Longrightarrow>foldli xs c f \\<sigma> = \\<sigma>\"", "lemma foldli_cong [fundef_cong]:\n  assumes \"l = l'\" \"\\<sigma> = \\<sigma>'\" \"c = c'\"\n  and ff': \"\\<And>\\<sigma> x. \\<lbrakk> x \\<in> set l'; c' \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> = f' x \\<sigma>\"\n  shows \"foldli l c f \\<sigma> = foldli l' c' f' \\<sigma>'\"", "lemma foldli_foldl :\n  \"foldli xs (\\<lambda>_. True) f \\<sigma> = foldl (\\<lambda>\\<sigma> x. f x \\<sigma>) \\<sigma> xs\"", "lemma foldli_append :\n   \"foldli (xs1 @ xs2) c f \\<sigma> =\n    foldli xs2 c f (foldli xs1 c f \\<sigma>)\"", "lemma foldli_concat :\n   \"foldli (concat xs) c f \\<sigma> =\n    foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\"", "lemma foldli_map :\n  \"foldli (map f1 xs) c f2 \\<sigma> =\n   foldli xs c (f2 \\<circ> f1) \\<sigma>\"", "lemma foldli_snoc :\n   \"foldli (xs @ [x]) c f \\<sigma> =\n    (if c (foldli xs c f \\<sigma>) then \n     f x (foldli xs c f \\<sigma>) else (foldli xs c f \\<sigma>))\"", "lemma foldli_snoc_id[simp]: \"foldli l (\\<lambda>_. True) (\\<lambda>x l. l@[x]) l0 = l0@l\"", "lemma foldli_foldli_prod_conv: \n  \"foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s = foldli (List.product l2 l1) ctd (\\<lambda>(i,j). f i j) s\"\n  (is \"?lhs=?rhs\")", "lemma fold_fold_prod_conv: \"fold (\\<lambda>i. fold (f i) l1) l2 s = fold (\\<lambda>(i,j). f i j) (List.product l2 l1) s\"", "lemma foldri_simp[simp] : \n  \"foldri [] c f \\<sigma> = \\<sigma>\"\n  \"foldri (l@[x]) c f \\<sigma> = (if c \\<sigma> then foldri l c f (f x \\<sigma>) else \\<sigma>)\"", "lemma foldri_simp_Cons[simp] : \n  \"foldri (x # l) c f \\<sigma> = (if (c (foldri l c f \\<sigma>)) then  f x (foldri l c f \\<sigma>) else (foldri l c f \\<sigma>))\"", "lemma foldri_code[code] : \n  \"foldri [] c f \\<sigma> = \\<sigma>\"\n  \"foldri (x # l) c f \\<sigma> = (let \\<sigma>' = foldri l c f \\<sigma> in if c \\<sigma>' then  f x \\<sigma>' else \\<sigma>')\"", "lemma foldri_not_cond [simp] :\n   \"\\<not>(c \\<sigma>) \\<Longrightarrow>foldri xs c f \\<sigma> = \\<sigma>\"", "lemma foldri_cong [fundef_cong]:\n  assumes \"l = l'\" \"\\<sigma> = \\<sigma>'\" \"c = c'\"\n  and ff': \"\\<And>\\<sigma> x. \\<lbrakk> x \\<in> set l'; c' \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> = f' x \\<sigma>\"\n  shows \"foldri l c f \\<sigma> = foldri l' c' f' \\<sigma>'\"", "lemma foldri_foldr :\n  \"foldri xs (\\<lambda>_. True) f \\<sigma> = foldr (\\<lambda>x \\<sigma>. f x \\<sigma>) xs \\<sigma>\"", "lemma foldri_append :\n   \"foldri (xs1 @ xs2) c f \\<sigma> =\n    foldri xs1 c f (foldri xs2 c f \\<sigma>)\"", "lemma foldri_concat :\n   \"foldri (concat xs) c f \\<sigma> =\n    foldri xs c (\\<lambda>x. foldri x c f) \\<sigma>\"", "lemma foldri_map :\n  \"foldri (map f1 xs) c f2 \\<sigma> =\n   foldri xs c (f2 \\<circ> f1) \\<sigma>\"", "lemma foldri_cons_id[simp]: \"foldri l (\\<lambda>_. True) (\\<lambda>x l. x#l) [] = l\""], "translations": [["", "lemma foldli_not_cond [simp] :\n   \"\\<not>(c \\<sigma>) \\<Longrightarrow>foldli xs c f \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow> foldli xs c f \\<sigma> = \\<sigma>", "by (cases xs, simp_all)"], ["", "lemma foldli_cong [fundef_cong]:\n  assumes \"l = l'\" \"\\<sigma> = \\<sigma>'\" \"c = c'\"\n  and ff': \"\\<And>\\<sigma> x. \\<lbrakk> x \\<in> set l'; c' \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> = f' x \\<sigma>\"\n  shows \"foldli l c f \\<sigma> = foldli l' c' f' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = foldli l' c' f' \\<sigma>'", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l' c' f \\<sigma>' = foldli l' c' f' \\<sigma>'", "using ff'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set l'; c' ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> = f' ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. foldli l' c' f \\<sigma>' = foldli l' c' f' \\<sigma>'", "by(induct l' arbitrary: \\<sigma>') auto"], ["", "text \\<open>Notice that @{term foldli} is a generalisation of folding that respects the abortion condition.\\<close>"], ["", "lemma foldli_foldl :\n  \"foldli xs (\\<lambda>_. True) f \\<sigma> = foldl (\\<lambda>\\<sigma> x. f x \\<sigma>) \\<sigma> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli xs (\\<lambda>_. True) f \\<sigma> =\n    foldl (\\<lambda>\\<sigma> x. f x \\<sigma>) \\<sigma> xs", "by (induct xs arbitrary: \\<sigma>) simp_all"], ["", "lemma foldli_append :\n   \"foldli (xs1 @ xs2) c f \\<sigma> =\n    foldli xs2 c f (foldli xs1 c f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (xs1 @ xs2) c f \\<sigma> =\n    foldli xs2 c f (foldli xs1 c f \\<sigma>)", "by (induct xs1 arbitrary: \\<sigma>, simp_all)"], ["", "lemma foldli_concat :\n   \"foldli (concat xs) c f \\<sigma> =\n    foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (concat xs) c f \\<sigma> =\n    foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>", "by (induct xs arbitrary: \\<sigma>, simp_all add: foldli_append)"], ["", "lemma foldli_map :\n  \"foldli (map f1 xs) c f2 \\<sigma> =\n   foldli xs c (f2 \\<circ> f1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (map f1 xs) c f2 \\<sigma> = foldli xs c (f2 \\<circ> f1) \\<sigma>", "by (induct xs arbitrary: \\<sigma>, simp_all)"], ["", "lemma foldli_snoc :\n   \"foldli (xs @ [x]) c f \\<sigma> =\n    (if c (foldli xs c f \\<sigma>) then \n     f x (foldli xs c f \\<sigma>) else (foldli xs c f \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (xs @ [x]) c f \\<sigma> =\n    (if c (foldli xs c f \\<sigma>) then f x (foldli xs c f \\<sigma>)\n     else foldli xs c f \\<sigma>)", "by (induct xs arbitrary: \\<sigma>, simp_all)"], ["", "lemma foldli_snoc_id[simp]: \"foldli l (\\<lambda>_. True) (\\<lambda>x l. l@[x]) l0 = l0@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) l0 = l0 @ l", "by (induct l arbitrary: l0) (auto)"], ["", "lemma foldli_foldli_prod_conv: \n  \"foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s = foldli (List.product l2 l1) ctd (\\<lambda>(i,j). f i j) s\"\n  (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s =\n    foldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s =\n    foldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "have [simp]: \"foldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s = foldli l ctd (f a) s\"\n    for a l s"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s =\n    foldli l ctd (f a) s", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       foldli (map (Pair a) []) ctd (\\<lambda>(x, y). f x y) s =\n       foldli [] ctd (f a) s\n 2. \\<And>aa l s.\n       (\\<And>s.\n           foldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s =\n           foldli l ctd (f a) s) \\<Longrightarrow>\n       foldli (map (Pair a) (aa # l)) ctd (\\<lambda>(x, y). f x y) s =\n       foldli (aa # l) ctd (f a) s", "by (auto simp:)"], ["proof (state)\nthis:\n  foldli (map (Pair ?a) ?l) ctd (\\<lambda>(x, y). f x y) ?s =\n  foldli ?l ctd (f ?a) ?s\n\ngoal (1 subgoal):\n 1. foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s =\n    foldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s =\n    foldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "by (induction l2 arbitrary: l1 s) (auto simp: foldli_append)"], ["proof (state)\nthis:\n  foldli l2 ctd (\\<lambda>i. foldli l1 ctd (f i)) s =\n  foldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_fold_prod_conv: \"fold (\\<lambda>i. fold (f i) l1) l2 s = fold (\\<lambda>(i,j). f i j) (List.product l2 l1) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>i. fold (f i) l1) l2 s =\n    fold (\\<lambda>(i, j). f i j) (List.product l2 l1) s", "using foldli_foldli_prod_conv[of l2 \"\\<lambda>_. True\" l1 f s]"], ["proof (prove)\nusing this:\n  foldli l2 (\\<lambda>_. True)\n   (\\<lambda>i. foldli l1 (\\<lambda>_. True) (f i)) s =\n  foldli (List.product l2 l1) (\\<lambda>_. True) (\\<lambda>(i, j). f i j) s\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>i. fold (f i) l1) l2 s =\n    fold (\\<lambda>(i, j). f i j) (List.product l2 l1) s", "by (simp add: foldli_foldl foldl_conv_fold)"], ["", "subsection \\<open>Right folding\\<close>"], ["", "definition foldri :: \"'x list \\<Rightarrow> ('\\<sigma> \\<Rightarrow> bool) \\<Rightarrow> ('x \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\"  where\n  \"foldri l = foldli (rev l)\""], ["", "lemma foldri_simp[simp] : \n  \"foldri [] c f \\<sigma> = \\<sigma>\"\n  \"foldri (l@[x]) c f \\<sigma> = (if c \\<sigma> then foldri l c f (f x \\<sigma>) else \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri [] c f \\<sigma> = \\<sigma> &&&\n    foldri (l @ [x]) c f \\<sigma> =\n    (if c \\<sigma> then foldri l c f (f x \\<sigma>) else \\<sigma>)", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (rev []) c f \\<sigma> = \\<sigma> &&&\n    foldli (rev (l @ [x])) c f \\<sigma> =\n    (if c \\<sigma> then foldli (rev l) c f (f x \\<sigma>) else \\<sigma>)", "by simp_all"], ["", "lemma foldri_simp_Cons[simp] : \n  \"foldri (x # l) c f \\<sigma> = (if (c (foldri l c f \\<sigma>)) then  f x (foldri l c f \\<sigma>) else (foldri l c f \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri (x # l) c f \\<sigma> =\n    (if c (foldri l c f \\<sigma>) then f x (foldri l c f \\<sigma>)\n     else foldri l c f \\<sigma>)", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (rev (x # l)) c f \\<sigma> =\n    (if c (foldli (rev l) c f \\<sigma>)\n     then f x (foldli (rev l) c f \\<sigma>)\n     else foldli (rev l) c f \\<sigma>)", "by (simp add: foldli_append)"], ["", "lemma foldri_code[code] : \n  \"foldri [] c f \\<sigma> = \\<sigma>\"\n  \"foldri (x # l) c f \\<sigma> = (let \\<sigma>' = foldri l c f \\<sigma> in if c \\<sigma>' then  f x \\<sigma>' else \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri [] c f \\<sigma> = \\<sigma> &&&\n    foldri (x # l) c f \\<sigma> =\n    (let \\<sigma>' = foldri l c f \\<sigma>\n     in if c \\<sigma>' then f x \\<sigma>' else \\<sigma>')", "by simp_all"], ["", "lemma foldri_not_cond [simp] :\n   \"\\<not>(c \\<sigma>) \\<Longrightarrow>foldri xs c f \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow> foldri xs c f \\<sigma> = \\<sigma>", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    foldli (rev xs) c f \\<sigma> = \\<sigma>", "by simp"], ["", "lemma foldri_cong [fundef_cong]:\n  assumes \"l = l'\" \"\\<sigma> = \\<sigma>'\" \"c = c'\"\n  and ff': \"\\<And>\\<sigma> x. \\<lbrakk> x \\<in> set l'; c' \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> = f' x \\<sigma>\"\n  shows \"foldri l c f \\<sigma> = foldri l' c' f' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri l c f \\<sigma> = foldri l' c' f' \\<sigma>'", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri l' c' f \\<sigma>' = foldri l' c' f' \\<sigma>'", "using ff'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set l'; c' ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> = f' ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. foldri l' c' f \\<sigma>' = foldri l' c' f' \\<sigma>'", "by(induct l' arbitrary: \\<sigma>') auto"], ["", "text \\<open>Notice that @{term foldli} is a generalisation of folding that respects the abortion condition.\\<close>"], ["", "lemma foldri_foldr :\n  \"foldri xs (\\<lambda>_. True) f \\<sigma> = foldr (\\<lambda>x \\<sigma>. f x \\<sigma>) xs \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri xs (\\<lambda>_. True) f \\<sigma> = foldr f xs \\<sigma>", "by (induct xs arbitrary: \\<sigma>) simp_all"], ["", "lemma foldri_append :\n   \"foldri (xs1 @ xs2) c f \\<sigma> =\n    foldri xs1 c f (foldri xs2 c f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri (xs1 @ xs2) c f \\<sigma> =\n    foldri xs1 c f (foldri xs2 c f \\<sigma>)", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (rev (xs1 @ xs2)) c f \\<sigma> =\n    foldli (rev xs1) c f (foldli (rev xs2) c f \\<sigma>)", "by (simp add: foldli_append)"], ["", "lemma foldri_concat :\n   \"foldri (concat xs) c f \\<sigma> =\n    foldri xs c (\\<lambda>x. foldri x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri (concat xs) c f \\<sigma> =\n    foldri xs c (\\<lambda>x. foldri x c f) \\<sigma>", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (rev (concat xs)) c f \\<sigma> =\n    foldli (rev xs) c (\\<lambda>x. foldli (rev x) c f) \\<sigma>", "by (simp add: rev_concat foldli_concat foldli_map o_def)"], ["", "lemma foldri_map :\n  \"foldri (map f1 xs) c f2 \\<sigma> =\n   foldri xs c (f2 \\<circ> f1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri (map f1 xs) c f2 \\<sigma> = foldri xs c (f2 \\<circ> f1) \\<sigma>", "unfolding foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (rev (map f1 xs)) c f2 \\<sigma> =\n    foldli (rev xs) c (f2 \\<circ> f1) \\<sigma>", "by (simp add: rev_map foldli_map)"], ["", "lemma foldri_cons_id[simp]: \"foldri l (\\<lambda>_. True) (\\<lambda>x l. x#l) [] = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldri l (\\<lambda>_. True) (#) [] = l", "by (induct l) (auto)"], ["", "end"]]}