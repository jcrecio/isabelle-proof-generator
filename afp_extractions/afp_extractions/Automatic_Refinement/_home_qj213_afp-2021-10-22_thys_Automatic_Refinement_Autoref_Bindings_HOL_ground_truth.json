{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Autoref_Bindings_HOL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma STRUCT_EQ_tagI: \"x=y \\<Longrightarrow> STRUCT_EQ_tag x y\"", "lemma REL_IS_ID_trigger: \"R=Id \\<Longrightarrow> REL_IS_ID R\"", "lemma REL_FORCE_ID_trigger: \"R=Id \\<Longrightarrow> REL_FORCE_ID R\"", "lemmas [autoref_rel_intf] = REL_INTFI[of fun_rel i_fun]", "lemmas [autoref_rel_intf] = REL_INTFI[of bool_rel i_bool]", "lemma [autoref_itype]:\n    \"True ::\\<^sub>i i_bool\"\n    \"False ::\\<^sub>i i_bool\"\n    \"conj ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<longleftrightarrow>) ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<longrightarrow>) ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"disj ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"Not ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"case_bool ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I\"\n    \"old.rec_bool ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I\"", "lemma autoref_bool[autoref_rules]:\n    \"(x,x)\\<in>bool_rel\"\n    \"(conj,conj)\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"(disj,disj)\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"(Not,Not)\\<in>bool_rel\\<rightarrow>bool_rel\"\n    \"(case_bool,case_bool)\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\\<rightarrow>R\"\n    \"(old.rec_bool,old.rec_bool)\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\\<rightarrow>R\"\n    \"((\\<longleftrightarrow>), (\\<longleftrightarrow>))\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"((\\<longrightarrow>), (\\<longrightarrow>))\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"", "lemma [autoref_itype]:\n    \"(<) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<le>) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(=) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(+) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(-) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(div) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(mod) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(*) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"0 ::\\<^sub>i I\"\n    \"1 ::\\<^sub>i I\"\n    \"numeral x ::\\<^sub>i I\"\n    \"uminus ::\\<^sub>i I \\<rightarrow>\\<^sub>i I\"", "lemma pat_num_generic[autoref_op_pat]:\n    \"0 \\<equiv> OP 0 :::\\<^sub>i I\"\n    \"1 \\<equiv> OP 1 :::\\<^sub>i I\"\n    \"numeral x \\<equiv> (OP (numeral x) :::\\<^sub>i I)\"", "lemma [autoref_rules]: \n    assumes \"PRIO_TAG_GEN_ALGO\"\n    shows \"((<), (<)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"((\\<le>), (\\<le>)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"((=), (=)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"(numeral x,OP (numeral x) ::: Id) \\<in> Id\"\n    and \"(uminus,uminus) \\<in> Id \\<rightarrow> Id\"\n    and \"(0,0) \\<in> Id\"\n    and \"(1,1) \\<in> Id\"", "lemma [autoref_itype]: \"id ::\\<^sub>i I \\<rightarrow>\\<^sub>i I\"", "lemma autoref_id[autoref_rules]: \"(id,id)\\<in>R\\<rightarrow>R\"", "lemma [autoref_itype]: \"(\\<circ>) ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i (Ic \\<rightarrow>\\<^sub>i Ia) \\<rightarrow>\\<^sub>i Ic \\<rightarrow>\\<^sub>i Ib\"", "lemma autoref_comp[autoref_rules]: \n    \"((o), (o)) \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow> (Rc \\<rightarrow> Ra) \\<rightarrow> Rc \\<rightarrow> Rb\"", "lemma [autoref_itype]: \"If ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"", "lemma autoref_If[autoref_rules]: \"(If,If)\\<in>Id\\<rightarrow>R\\<rightarrow>R\\<rightarrow>R\"", "lemma autoref_If_cong[autoref_rules]:\n    assumes \"(c',c)\\<in>Id\"\n    assumes \"REMOVE_INTERNAL c \\<Longrightarrow> (t',t)\\<in>R\"\n    assumes \"\\<not> REMOVE_INTERNAL c \\<Longrightarrow> (e',e)\\<in>R\"\n    shows \"(If c' t' e',(OP If ::: Id\\<rightarrow>R\\<rightarrow>R\\<rightarrow>R)$c$t$e)\\<in>R\"", "lemma [autoref_itype]: \"Let ::\\<^sub>i Ix \\<rightarrow>\\<^sub>i (Ix\\<rightarrow>\\<^sub>iIy) \\<rightarrow>\\<^sub>i Iy\"", "lemma autoref_Let: \n    \"(Let,Let)\\<in>Ra \\<rightarrow> (Ra\\<rightarrow>Rr) \\<rightarrow> Rr\"", "lemma autoref_Let_cong[autoref_rules]:\n    assumes \"(x',x)\\<in>Ra\"\n    assumes \"\\<And>y y'. REMOVE_INTERNAL (x=y) \\<Longrightarrow> (y',y)\\<in>Ra \\<Longrightarrow> (f' y', f$y)\\<in>Rr\"\n    shows \"(Let x' f',(OP Let ::: Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr)$x$f)\\<in>Rr\"", "lemmas [autoref_rel_intf] = REL_INTFI[of unit_rel i_unit]", "lemma [autoref_rules]: \"((),())\\<in>unit_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of nat_rel i_nat]", "lemma pat_num_nat[autoref_op_pat]:\n      \"0::nat \\<equiv> OP 0 :::\\<^sub>i i_nat\"\n      \"1::nat \\<equiv> OP 1 :::\\<^sub>i i_nat\"\n      \"(numeral x)::nat \\<equiv> (OP (numeral x) :::\\<^sub>i i_nat)\"", "lemma autoref_nat[autoref_rules]:\n      \"(0, 0::nat) \\<in> nat_rel\"\n      \"(Suc, Suc) \\<in> nat_rel \\<rightarrow> nat_rel\"\n      \"(1, 1::nat) \\<in> nat_rel\"\n      \"(numeral n::nat,numeral n::nat) \\<in> nat_rel\"\n      \"((<), (<) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((\\<le>), (\\<le>) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((=), (=) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((+) ::nat\\<Rightarrow>_,(+))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((-) ::nat\\<Rightarrow>_,(-))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((div) ::nat\\<Rightarrow>_,(div))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((*), (*))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((mod), (mod))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"", "lemma autoref_case_nat[autoref_rules]: \n      \"(case_nat,case_nat)\\<in>Ra \\<rightarrow> (Id \\<rightarrow> Ra) \\<rightarrow> Id \\<rightarrow> Ra\"", "lemma autoref_rec_nat: \"(rec_nat,rec_nat) \\<in> R \\<rightarrow> (Id \\<rightarrow> R \\<rightarrow> R) \\<rightarrow> Id \\<rightarrow> R\"", "lemmas [autoref_rel_intf] = REL_INTFI[of int_rel i_int]", "lemma pat_num_int[autoref_op_pat]:\n      \"0::int \\<equiv> OP 0 :::\\<^sub>i i_int\"\n      \"1::int \\<equiv> OP 1 :::\\<^sub>i i_int\"\n      \"(numeral x)::int \\<equiv> (OP (numeral x) :::\\<^sub>i i_int)\"", "lemma autoref_int[autoref_rules (overloaded)]:\n      \"(0, 0::int) \\<in> int_rel\"\n      \"(1, 1::int) \\<in> int_rel\"\n      \"(numeral n::int,numeral n::int) \\<in> int_rel\"\n      \"((<), (<) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((\\<le>), (\\<le>) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((=), (=) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((+) ::int\\<Rightarrow>_,(+))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((-) ::int\\<Rightarrow>_,(-))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((div) ::int\\<Rightarrow>_,(div))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"(uminus,uminus)\\<in>int_rel\\<rightarrow>int_rel\"\n      \"((*), (*))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((mod), (mod))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of prod_rel i_prod]", "lemma prod_refine[autoref_rules]:\n      \"(Pair,Pair)\\<in>Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel\"\n      \"(case_prod,case_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n      \"(old.rec_prod,old.rec_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n      \"(fst,fst)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Ra\"\n      \"(snd,snd)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rb\"", "lemma prod_eq_autoref[autoref_rules (overloaded)]:\n      \"\\<lbrakk>GEN_OP eqa (=) (Ra\\<rightarrow>Ra\\<rightarrow>Id); GEN_OP eqb (=) (Rb\\<rightarrow>Rb\\<rightarrow>Id)\\<rbrakk> \n      \\<Longrightarrow> (prod_eq eqa eqb,(=)) \\<in> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Id\"", "lemma prod_eq_expand[autoref_struct_expand]: \"(=) = prod_eq (=) (=)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of option_rel i_option]", "lemma autoref_opt[autoref_rules]:\n      \"(None,None)\\<in>\\<langle>R\\<rangle>option_rel\"\n      \"(Some,Some)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>option_rel\"\n      \"(case_option,case_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"\n      \"(rec_option,rec_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"", "lemma autoref_the[autoref_rules]:\n      assumes \"SIDE_PRECOND (x\\<noteq>None)\"\n      assumes \"(x',x)\\<in>\\<langle>R\\<rangle>option_rel\"\n      shows \"(the x', (OP the ::: \\<langle>R\\<rangle>option_rel \\<rightarrow> R)$x) \\<in> R\"", "lemma autoref_the_default[autoref_rules]:\n      \"(the_default, the_default) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R\"", "lemma pat_isNone[autoref_op_pat]:\n      \"a=None \\<equiv> (OP is_None :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool)$a\"\n      \"None=a \\<equiv> (OP is_None :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool)$a\"", "lemma autoref_is_None[param,autoref_rules]: \n      \"(is_None,is_None)\\<in>\\<langle>R\\<rangle>option_rel \\<rightarrow> Id\"", "lemma fold_is_None: \"x=None \\<longleftrightarrow> is_None x\"", "lemma option_eq_autoref[autoref_rules (overloaded)]:\n      \"\\<lbrakk>GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>Id)\\<rbrakk> \n      \\<Longrightarrow> (option_eq eq,(=)) \\<in> \\<langle>R\\<rangle>option_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> Id\"", "lemma option_eq_expand[autoref_struct_expand]: \n      \"(=) = option_eq (=)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of sum_rel i_sum]", "lemma autoref_sum[autoref_rules]:\n    \"(Inl,Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n    \"(Inr,Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n    \"(case_sum,case_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"\n    \"(old.rec_sum,old.rec_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"", "lemma sum_eq_autoref[autoref_rules (overloaded)]:\n    \"\\<lbrakk>GEN_OP eql (=) (Rl\\<rightarrow>Rl\\<rightarrow>Id); GEN_OP eqr (=) (Rr\\<rightarrow>Rr\\<rightarrow>Id)\\<rbrakk> \n    \\<Longrightarrow> (sum_eq eql eqr,(=)) \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> Id\"", "lemma sum_eq_expand[autoref_struct_expand]: \"(=) = sum_eq (=) (=)\"", "lemmas [autoref_rules] = is_Inl_param is_Inr_param", "lemma autoref_sum_Projl[autoref_rules]: \n    \"\\<lbrakk>SIDE_PRECOND (is_Inl s); (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n    \\<Longrightarrow> (Sum_Type.sum.projl s', (OP Sum_Type.sum.projl ::: \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> Ra)$s)\\<in>Ra\"", "lemma autoref_sum_Projr[autoref_rules]: \n    \"\\<lbrakk>SIDE_PRECOND (is_Inr s); (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n    \\<Longrightarrow> (Sum_Type.sum.projr s', (OP Sum_Type.sum.projr ::: \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> Rb)$s)\\<in>Rb\"", "lemmas [autoref_rel_intf] = REL_INTFI[of list_rel i_list]", "lemma autoref_append[autoref_rules]: \n    \"(append, append)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma refine_list[autoref_rules]:\n    \"(Nil,Nil)\\<in>\\<langle>R\\<rangle>list_rel\"\n    \"(Cons,Cons)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"\n    \"(case_list,case_list)\\<in>Rr\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr\"", "lemma autoref_rec_list[autoref_rules]: \"(rec_list,rec_list) \n    \\<in> Ra \\<rightarrow> (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra) \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra\"", "lemma refine_map[autoref_rules]: \n    \"(map,map)\\<in>(R1\\<rightarrow>R2) \\<rightarrow> \\<langle>R1\\<rangle>list_rel \\<rightarrow> \\<langle>R2\\<rangle>list_rel\"", "lemma refine_fold[autoref_rules]: \n    \"(fold,fold)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"\n    \"(foldl,foldl)\\<in>(Rs\\<rightarrow>Re\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs\"\n    \"(foldr,foldr)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"", "lemma autoref_nth[autoref_rules]: \n    assumes \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\"\n    assumes \"(i,i')\\<in>Id\"\n    assumes \"SIDE_PRECOND (i' < length l')\"\n    shows \"(nth l i,(OP nth ::: \\<langle>R\\<rangle>list_rel \\<rightarrow> Id \\<rightarrow> R)$l'$i')\\<in>R\"", "lemma autoref_list_eq_aux: \"\n    (list_eq,list_eq) \\<in> \n      (R \\<rightarrow> R \\<rightarrow> Id) \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\"", "lemma list_eq_expand[autoref_struct_expand]: \"(=) = (list_eq (=))\"", "lemma autoref_list_eq[autoref_rules (overloaded)]:\n    \"GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>Id) \\<Longrightarrow> (list_eq eq, (=)) \n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\"", "lemma autoref_hd[autoref_rules]:\n    \"\\<lbrakk> SIDE_PRECOND (l'\\<noteq>[]); (l,l') \\<in> \\<langle>R\\<rangle>list_rel \\<rbrakk> \\<Longrightarrow>\n      (hd l,(OP hd ::: \\<langle>R\\<rangle>list_rel \\<rightarrow> R)$l') \\<in> R\"", "lemma autoref_tl[autoref_rules]:\n    \"(tl,tl) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma is_Nil_pat[autoref_op_pat]:\n    \"a=[] \\<equiv> (OP is_Nil :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool)$a\"\n    \"[]=a \\<equiv> (OP is_Nil :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool)$a\"", "lemma autoref_is_Nil[param,autoref_rules]: \n    \"(is_Nil,is_Nil)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma conv_to_is_Nil: \n    \"l=[] \\<longleftrightarrow> is_Nil l\"\n    \"[]=l \\<longleftrightarrow> is_Nil l\"", "lemma autoref_butlast[param, autoref_rules]: \n    \"(butlast,butlast) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma op_list_singleton_pat[autoref_op_pat]:\n    \"[x] \\<equiv> (OP op_list_singleton :::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list)$x\"", "lemma autoref_list_singleton[autoref_rules]: \n    \"(\\<lambda>a. [a],op_list_singleton) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma pat_list_append_elem[autoref_op_pat]: \n    \"s@[x] \\<equiv> (OP op_list_append_elem :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list)$s$x\"", "lemma autoref_list_append_elem[autoref_rules]: \n    \"(\\<lambda>s x. s@[x], op_list_append_elem) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\"", "lemma [autoref_op_pat]: \n    \"(\\<forall>i<u. P i) \\<equiv> OP List.all_interval_nat P 0 u\"\n    \"(\\<forall>i\\<le>u. P i) \\<equiv> OP List.all_interval_nat P 0 (Suc u)\"\n    \"(\\<forall>i<u. l\\<le>i \\<longrightarrow> P i) \\<equiv> OP List.all_interval_nat P l u\"\n    \"(\\<forall>i\\<le>u. l\\<le>i \\<longrightarrow> P i) \\<equiv> OP List.all_interval_nat P l (Suc u)\"", "lemmas [autoref_rules] = param_dropWhile param_takeWhile"], "translations": [["", "lemma STRUCT_EQ_tagI: \"x=y \\<Longrightarrow> STRUCT_EQ_tag x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> STRUCT_EQ_tag x y", "by simp"], ["", "ML \\<open>\n  structure Autoref_Struct_Expand = struct\n    structure autoref_struct_expand = Named_Thms (\n      val name = @{binding autoref_struct_expand}\n      val description = \"Autoref: Structural expansion lemmas\"\n    )\n\n    fun expand_tac ctxt = let\n      val ss = put_simpset HOL_basic_ss ctxt addsimps autoref_struct_expand.get ctxt\n    in\n      SOLVED' (asm_simp_tac ss)\n    end\n\n\n    val setup = autoref_struct_expand.setup\n    val decl_setup = fn phi =>\n      Tagged_Solver.declare_solver @{thms STRUCT_EQ_tagI} @{binding STRUCT_EQ} \n        \"Autoref: Equality modulo structural expansion\" \n        (expand_tac) phi\n\n  end\n\\<close>"], ["", "setup Autoref_Struct_Expand.setup"], ["", "declaration Autoref_Struct_Expand.decl_setup"], ["", "text \\<open>Sometimes, also relators must be expanded. Usually to check them to be the identity relator\\<close>"], ["", "definition [simp]: \"REL_IS_ID R \\<equiv> R=Id\""], ["", "definition [simp]: \"REL_FORCE_ID R \\<equiv> R=Id\""], ["", "lemma REL_IS_ID_trigger: \"R=Id \\<Longrightarrow> REL_IS_ID R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> REL_IS_ID R", "by simp"], ["", "lemma REL_FORCE_ID_trigger: \"R=Id \\<Longrightarrow> REL_FORCE_ID R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> REL_FORCE_ID R", "by simp"], ["", "declaration \\<open>Tagged_Solver.add_triggers \n  \"Relators.relator_props_solver\" @{thms REL_IS_ID_trigger}\\<close>"], ["", "declaration \\<open>Tagged_Solver.add_triggers \n  \"Relators.force_relator_props_solver\" @{thms REL_FORCE_ID_trigger}\\<close>"], ["", "abbreviation \"PREFER_id R \\<equiv> PREFER REL_IS_ID R\""], ["", "(* TODO: Most of these are parametricity theorems! *)"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of fun_rel i_fun]"], ["", "subsection \"Booleans\""], ["", "consts\n    i_bool :: interface"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of bool_rel i_bool]"], ["", "lemma [autoref_itype]:\n    \"True ::\\<^sub>i i_bool\"\n    \"False ::\\<^sub>i i_bool\"\n    \"conj ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<longleftrightarrow>) ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<longrightarrow>) ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"disj ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"Not ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool\"\n    \"case_bool ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I\"\n    \"old.rec_bool ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((True ::\\<^sub>i i_bool &&& False ::\\<^sub>i i_bool) &&&\n     (\\<and>) ::\\<^sub>i\n     i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool &&&\n     (=) ::\\<^sub>i\n     i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool) &&&\n    ((\\<longrightarrow>) ::\\<^sub>i\n     i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool &&&\n     (\\<or>) ::\\<^sub>i\n     i_bool \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool) &&&\n    Not ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i i_bool &&&\n    case_bool ::\\<^sub>i\n    I \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I &&&\n    old.rec_bool ::\\<^sub>i\n    I \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I", "by auto"], ["", "lemma autoref_bool[autoref_rules]:\n    \"(x,x)\\<in>bool_rel\"\n    \"(conj,conj)\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"(disj,disj)\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"(Not,Not)\\<in>bool_rel\\<rightarrow>bool_rel\"\n    \"(case_bool,case_bool)\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\\<rightarrow>R\"\n    \"(old.rec_bool,old.rec_bool)\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\\<rightarrow>R\"\n    \"((\\<longleftrightarrow>), (\\<longleftrightarrow>))\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\"\n    \"((\\<longrightarrow>), (\\<longrightarrow>))\\<in>bool_rel\\<rightarrow>bool_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((x, x) \\<in> bool_rel &&&\n      ((\\<and>), (\\<and>))\n      \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel) &&&\n     ((\\<or>), (\\<or>))\n     \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel &&&\n     (Not, Not) \\<in> bool_rel \\<rightarrow> bool_rel) &&&\n    ((case_bool, case_bool)\n     \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<rightarrow> R &&&\n     (old.rec_bool, old.rec_bool)\n     \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<rightarrow> R) &&&\n    ((=), (=))\n    \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel &&&\n    ((\\<longrightarrow>), (\\<longrightarrow>))\n    \\<in> bool_rel \\<rightarrow> bool_rel \\<rightarrow> bool_rel", "by (auto split: bool.split simp: rec_bool_is_case)"], ["", "subsection \"Standard Type Classes\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n    We allow these operators for all interfaces.\n\\<close>"], ["", "lemma [autoref_itype]:\n    \"(<) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(\\<le>) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(=) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool\"\n    \"(+) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(-) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(div) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(mod) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"(*) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\"\n    \"0 ::\\<^sub>i I\"\n    \"1 ::\\<^sub>i I\"\n    \"numeral x ::\\<^sub>i I\"\n    \"uminus ::\\<^sub>i I \\<rightarrow>\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((<) ::\\<^sub>i\n      I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool &&&\n      (\\<le>) ::\\<^sub>i\n      I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool &&&\n      (=) ::\\<^sub>i\n      I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i i_bool) &&&\n     (+) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I &&&\n     (-) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I &&&\n     (div) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I) &&&\n    ((mod) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I &&&\n     (*) ::\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I &&&\n     (0::'i) ::\\<^sub>i I) &&&\n    (1::'j) ::\\<^sub>i I &&&\n    numeral x ::\\<^sub>i I &&& uminus ::\\<^sub>i I \\<rightarrow>\\<^sub>i I", "by auto"], ["", "lemma pat_num_generic[autoref_op_pat]:\n    \"0 \\<equiv> OP 0 :::\\<^sub>i I\"\n    \"1 \\<equiv> OP 1 :::\\<^sub>i I\"\n    \"numeral x \\<equiv> (OP (numeral x) :::\\<^sub>i I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a \\<equiv> OP (0::'a) :::\\<^sub>i I) &&&\n    (1::'b \\<equiv> OP (1::'b) :::\\<^sub>i I) &&&\n    numeral x \\<equiv> OP (numeral x) :::\\<^sub>i I", "by simp_all"], ["", "lemma [autoref_rules]: \n    assumes \"PRIO_TAG_GEN_ALGO\"\n    shows \"((<), (<)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"((\\<le>), (\\<le>)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"((=), (=)) \\<in> Id\\<rightarrow>Id\\<rightarrow>bool_rel\"\n    and \"(numeral x,OP (numeral x) ::: Id) \\<in> Id\"\n    and \"(uminus,uminus) \\<in> Id \\<rightarrow> Id\"\n    and \"(0,0) \\<in> Id\"\n    and \"(1,1) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((<), (<)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel &&&\n     ((\\<le>), (\\<le>)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel &&&\n     ((=), (=)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel) &&&\n    ((numeral x, OP (numeral x) ::: Id) \\<in> Id &&&\n     (uminus, uminus) \\<in> Id \\<rightarrow> Id) &&&\n    (0::'f, 0::'f) \\<in> Id &&& (1::'g, 1::'g) \\<in> Id", "by auto"], ["", "subsection \"Functional Combinators\""], ["", "lemma [autoref_itype]: \"id ::\\<^sub>i I \\<rightarrow>\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id ::\\<^sub>i I \\<rightarrow>\\<^sub>i I", "by simp"], ["", "lemma autoref_id[autoref_rules]: \"(id,id)\\<in>R\\<rightarrow>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, id) \\<in> R \\<rightarrow> R", "by auto"], ["", "term \"(o)\""], ["", "lemma [autoref_itype]: \"(\\<circ>) ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i (Ic \\<rightarrow>\\<^sub>i Ia) \\<rightarrow>\\<^sub>i Ic \\<rightarrow>\\<^sub>i Ib\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<circ>) ::\\<^sub>i\n    (Ia \\<rightarrow>\\<^sub>i Ib) \\<rightarrow>\\<^sub>i\n    (Ic \\<rightarrow>\\<^sub>i Ia) \\<rightarrow>\\<^sub>i\n    Ic \\<rightarrow>\\<^sub>i Ib", "by simp"], ["", "lemma autoref_comp[autoref_rules]: \n    \"((o), (o)) \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow> (Rc \\<rightarrow> Ra) \\<rightarrow> Rc \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<circ>), (\\<circ>))\n    \\<in> (Ra \\<rightarrow> Rb) \\<rightarrow>\n          (Rc \\<rightarrow> Ra) \\<rightarrow> Rc \\<rightarrow> Rb", "by (auto dest: fun_relD)"], ["", "lemma [autoref_itype]: \"If ::\\<^sub>i i_bool \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If ::\\<^sub>i\n    i_bool \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i I", "by simp"], ["", "lemma autoref_If[autoref_rules]: \"(If,If)\\<in>Id\\<rightarrow>R\\<rightarrow>R\\<rightarrow>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (If, If) \\<in> bool_rel \\<rightarrow> R \\<rightarrow> R \\<rightarrow> R", "by auto"], ["", "lemma autoref_If_cong[autoref_rules]:\n    assumes \"(c',c)\\<in>Id\"\n    assumes \"REMOVE_INTERNAL c \\<Longrightarrow> (t',t)\\<in>R\"\n    assumes \"\\<not> REMOVE_INTERNAL c \\<Longrightarrow> (e',e)\\<in>R\"\n    shows \"(If c' t' e',(OP If ::: Id\\<rightarrow>R\\<rightarrow>R\\<rightarrow>R)$c$t$e)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c' then t' else e',\n     (OP If ::: bool_rel \\<rightarrow> R \\<rightarrow> R \\<rightarrow> R) $\n     c $\n     t $\n     e)\n    \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (c', c) \\<in> bool_rel\n  REMOVE_INTERNAL c \\<Longrightarrow> (t', t) \\<in> R\n  \\<not> REMOVE_INTERNAL c \\<Longrightarrow> (e', e) \\<in> R\n\ngoal (1 subgoal):\n 1. (if c' then t' else e',\n     (OP If ::: bool_rel \\<rightarrow> R \\<rightarrow> R \\<rightarrow> R) $\n     c $\n     t $\n     e)\n    \\<in> R", "by (auto)"], ["", "lemma [autoref_itype]: \"Let ::\\<^sub>i Ix \\<rightarrow>\\<^sub>i (Ix\\<rightarrow>\\<^sub>iIy) \\<rightarrow>\\<^sub>i Iy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let ::\\<^sub>i\n    Ix \\<rightarrow>\\<^sub>i\n    (Ix \\<rightarrow>\\<^sub>i Iy) \\<rightarrow>\\<^sub>i Iy", "by auto"], ["", "lemma autoref_Let: \n    \"(Let,Let)\\<in>Ra \\<rightarrow> (Ra\\<rightarrow>Rr) \\<rightarrow> Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let, Let) \\<in> Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr", "by (auto dest: fun_relD)"], ["", "lemma autoref_Let_cong[autoref_rules]:\n    assumes \"(x',x)\\<in>Ra\"\n    assumes \"\\<And>y y'. REMOVE_INTERNAL (x=y) \\<Longrightarrow> (y',y)\\<in>Ra \\<Longrightarrow> (f' y', f$y)\\<in>Rr\"\n    shows \"(Let x' f',(OP Let ::: Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr)$x$f)\\<in>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let x' f',\n     (OP Let ::: Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr) $\n     x $\n     f)\n    \\<in> Rr", "using assms"], ["proof (prove)\nusing this:\n  (x', x) \\<in> Ra\n  \\<lbrakk>REMOVE_INTERNAL (x = ?y); (?y', ?y) \\<in> Ra\\<rbrakk>\n  \\<Longrightarrow> (f' ?y', f $ ?y) \\<in> Rr\n\ngoal (1 subgoal):\n 1. (Let x' f',\n     (OP Let ::: Ra \\<rightarrow> (Ra \\<rightarrow> Rr) \\<rightarrow> Rr) $\n     x $\n     f)\n    \\<in> Rr", "by (auto)"], ["", "end"], ["", "subsection \"Unit\""], ["", "consts i_unit :: interface"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of unit_rel i_unit]"], ["", "(*lemma [autoref_itype]: \"(a::unit) ::\\<^sub>i i_unit\" by simp*)"], ["", "lemma [autoref_rules]: \"((),())\\<in>unit_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), ()) \\<in> unit_rel", "by simp"], ["", "subsection \"Nat\""], ["", "consts i_nat :: interface"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of nat_rel i_nat]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma pat_num_nat[autoref_op_pat]:\n      \"0::nat \\<equiv> OP 0 :::\\<^sub>i i_nat\"\n      \"1::nat \\<equiv> OP 1 :::\\<^sub>i i_nat\"\n      \"(numeral x)::nat \\<equiv> (OP (numeral x) :::\\<^sub>i i_nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<equiv> OP 0 :::\\<^sub>i i_nat) &&&\n    (1 \\<equiv> OP 1 :::\\<^sub>i i_nat) &&&\n    numeral x \\<equiv> OP (numeral x) :::\\<^sub>i i_nat", "by simp_all"], ["", "lemma autoref_nat[autoref_rules]:\n      \"(0, 0::nat) \\<in> nat_rel\"\n      \"(Suc, Suc) \\<in> nat_rel \\<rightarrow> nat_rel\"\n      \"(1, 1::nat) \\<in> nat_rel\"\n      \"(numeral n::nat,numeral n::nat) \\<in> nat_rel\"\n      \"((<), (<) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((\\<le>), (\\<le>) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((=), (=) ::nat \\<Rightarrow> _) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"\n      \"((+) ::nat\\<Rightarrow>_,(+))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((-) ::nat\\<Rightarrow>_,(-))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((div) ::nat\\<Rightarrow>_,(div))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((*), (*))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\"\n      \"((mod), (mod))\\<in>nat_rel\\<rightarrow>nat_rel\\<rightarrow>nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0, 0) \\<in> nat_rel &&&\n      (Suc, Suc) \\<in> nat_rel \\<rightarrow> nat_rel &&&\n      (1, 1) \\<in> nat_rel) &&&\n     (numeral n, numeral n) \\<in> nat_rel &&&\n     ((<), (<))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel &&&\n     ((\\<le>), (\\<le>))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel) &&&\n    (((=), (=))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel &&&\n     ((+), (+))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n     ((-), (-))\n     \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel) &&&\n    ((div), (div))\n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n    ((*), (*)) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel &&&\n    ((mod), (mod)) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by auto"], ["", "lemma autoref_case_nat[autoref_rules]: \n      \"(case_nat,case_nat)\\<in>Ra \\<rightarrow> (Id \\<rightarrow> Ra) \\<rightarrow> Id \\<rightarrow> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_nat, case_nat)\n    \\<in> Ra \\<rightarrow>\n          (nat_rel \\<rightarrow> Ra) \\<rightarrow> nat_rel \\<rightarrow> Ra", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra; (aa, a'a) \\<in> nat_rel \\<rightarrow> Ra;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case ab of 0 \\<Rightarrow> a\n                          | Suc x \\<Rightarrow> aa x,\n                          case a'b of 0 \\<Rightarrow> a'\n                          | Suc x \\<Rightarrow> a'a x)\n                         \\<in> Ra", "apply (auto split: nat.split dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_rec_nat: \"(rec_nat,rec_nat) \\<in> R \\<rightarrow> (Id \\<rightarrow> R \\<rightarrow> R) \\<rightarrow> Id \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_nat, rec_nat)\n    \\<in> R \\<rightarrow>\n          (nat_rel \\<rightarrow> R \\<rightarrow> R) \\<rightarrow>\n          nat_rel \\<rightarrow> R", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat a aa ab, rec_nat a' a'a a'b) \\<in> R", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat a aa ab, rec_nat a' a'a a'b) \\<in> R", "case (1 s s' f f' n n')"], ["proof (state)\nthis:\n  (s, s') \\<in> R\n  (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat a aa ab, rec_nat a' a'a a'b) \\<in> R", "thus ?case"], ["proof (prove)\nusing this:\n  (s, s') \\<in> R\n  (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (rec_nat s f n, rec_nat s' f' n') \\<in> R", "apply (induct n' arbitrary: n s s')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n s s'.\n       \\<lbrakk>(s, s') \\<in> R;\n        (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (n, 0) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' 0) \\<in> R\n 2. \\<And>n' n s s'.\n       \\<lbrakk>\\<And>n s s'.\n                   \\<lbrakk>(s, s') \\<in> R;\n                    (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n                    (n, n') \\<in> nat_rel\\<rbrakk>\n                   \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' n')\n                                     \\<in> R;\n        (s, s') \\<in> R;\n        (f, f') \\<in> nat_rel \\<rightarrow> R \\<rightarrow> R;\n        (n, Suc n') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_nat s f n, rec_nat s' f' (Suc n')) \\<in> R", "apply (fastforce simp: fun_rel_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_nat s f n, rec_nat s' f' n') \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Int\""], ["", "consts i_int :: interface"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of int_rel i_int]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma pat_num_int[autoref_op_pat]:\n      \"0::int \\<equiv> OP 0 :::\\<^sub>i i_int\"\n      \"1::int \\<equiv> OP 1 :::\\<^sub>i i_int\"\n      \"(numeral x)::int \\<equiv> (OP (numeral x) :::\\<^sub>i i_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<equiv> OP 0 :::\\<^sub>i i_int) &&&\n    (1 \\<equiv> OP 1 :::\\<^sub>i i_int) &&&\n    numeral x \\<equiv> OP (numeral x) :::\\<^sub>i i_int", "by simp_all"], ["", "(*lemma [autoref_itype]:\n      \"((<) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_bool\"\n      \"((\\<le>) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_bool\"\n      \"((=) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_bool\"\n      \"((+) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int\"\n      \"((-) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int\"\n      \"((div) :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int\"\n      \"(uminus :: int \\<Rightarrow> _) ::\\<^sub>i i_int \\<rightarrow>\\<^sub>i i_int\"\n      by auto*)"], ["", "lemma autoref_int[autoref_rules (overloaded)]:\n      \"(0, 0::int) \\<in> int_rel\"\n      \"(1, 1::int) \\<in> int_rel\"\n      \"(numeral n::int,numeral n::int) \\<in> int_rel\"\n      \"((<), (<) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((\\<le>), (\\<le>) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((=), (=) ::int \\<Rightarrow> _) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel\"\n      \"((+) ::int\\<Rightarrow>_,(+))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((-) ::int\\<Rightarrow>_,(-))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((div) ::int\\<Rightarrow>_,(div))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"(uminus,uminus)\\<in>int_rel\\<rightarrow>int_rel\"\n      \"((*), (*))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\"\n      \"((mod), (mod))\\<in>int_rel\\<rightarrow>int_rel\\<rightarrow>int_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0, 0) \\<in> int_rel &&&\n      (1, 1) \\<in> int_rel &&& (numeral n, numeral n) \\<in> int_rel) &&&\n     ((<), (<))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel &&&\n     ((\\<le>), (\\<le>))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel &&&\n     ((=), (=))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> bool_rel) &&&\n    (((+), (+))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n     ((-), (-))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n     ((div), (div))\n     \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel) &&&\n    (uminus, uminus) \\<in> int_rel \\<rightarrow> int_rel &&&\n    ((*), (*)) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel &&&\n    ((mod), (mod)) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel", "by auto"], ["", "end"], ["", "subsection \"Product\""], ["", "consts i_prod :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of prod_rel i_prod]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*\n    lemma [autoref_itype]:\n      \"Pair ::\\<^sub>i Ia \\<rightarrow>\\<^sub>i Ib \\<rightarrow>\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod\"\n      \"case_prod ::\\<^sub>i (Ia \\<rightarrow>\\<^sub>i Ib \\<rightarrow>\\<^sub>i I) \\<rightarrow>\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i I\"\n      \"old.rec_prod ::\\<^sub>i (Ia \\<rightarrow>\\<^sub>i Ib \\<rightarrow>\\<^sub>i I) \\<rightarrow>\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i I\"\n      \"fst ::\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i Ia\"\n      \"snd ::\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i Ib\"\n      \"((=) :: _\\<times>_ \\<Rightarrow> _) ::\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i \\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool\"\n      by auto\n      *)"], ["", "lemma prod_refine[autoref_rules]:\n      \"(Pair,Pair)\\<in>Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel\"\n      \"(case_prod,case_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n      \"(old.rec_prod,old.rec_prod) \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rr\"\n      \"(fst,fst)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Ra\"\n      \"(snd,snd)\\<in>\\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Pair, Pair)\n     \\<in> Ra \\<rightarrow> Rb \\<rightarrow> Ra \\<times>\\<^sub>r Rb &&&\n     (case_prod, case_prod)\n     \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow>\n           Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rr) &&&\n    (old.rec_prod, old.rec_prod)\n    \\<in> (Ra \\<rightarrow> Rb \\<rightarrow> Rr) \\<rightarrow>\n          Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rr &&&\n    (fst, fst) \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow> Ra &&&\n    (snd, snd) \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow> Rb", "by (auto dest: fun_relD split: prod.split \n        simp: prod_rel_def rec_prod_is_case)"], ["", "definition \"prod_eq eqa eqb x1 x2 \\<equiv> \n      case x1 of (a1,b1) \\<Rightarrow> case x2 of (a2,b2) \\<Rightarrow> eqa a1 a2 \\<and> eqb b1 b2\""], ["", "lemma prod_eq_autoref[autoref_rules (overloaded)]:\n      \"\\<lbrakk>GEN_OP eqa (=) (Ra\\<rightarrow>Ra\\<rightarrow>Id); GEN_OP eqb (=) (Rb\\<rightarrow>Rb\\<rightarrow>Id)\\<rbrakk> \n      \\<Longrightarrow> (prod_eq eqa eqb,(=)) \\<in> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> \\<langle>Ra,Rb\\<rangle>prod_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GEN_OP eqa (=) (Ra \\<rightarrow> Ra \\<rightarrow> bool_rel);\n     GEN_OP eqb (=) (Rb \\<rightarrow> Rb \\<rightarrow> bool_rel)\\<rbrakk>\n    \\<Longrightarrow> (prod_eq eqa eqb, (=))\n                      \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow>\n                            Ra \\<times>\\<^sub>r Rb \\<rightarrow> bool_rel", "unfolding prod_eq_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GEN_OP eqa (=) (Ra \\<rightarrow> Ra \\<rightarrow> bool_rel);\n     GEN_OP eqb (=) (Rb \\<rightarrow> Rb \\<rightarrow> bool_rel)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x1 x2.\n                          case x1 of\n                          (a1, b1) \\<Rightarrow>\n                            case x2 of\n                            (a2, b2) \\<Rightarrow>\n                              eqa a1 a2 \\<and> eqb b1 b2,\n                       (=))\n                      \\<in> Ra \\<times>\\<^sub>r Rb \\<rightarrow>\n                            Ra \\<times>\\<^sub>r Rb \\<rightarrow> bool_rel", "by (fastforce dest: fun_relD)"], ["", "lemma prod_eq_expand[autoref_struct_expand]: \"(=) = prod_eq (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = prod_eq (=) (=)", "unfolding prod_eq_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) =\n    (\\<lambda>x1 x2.\n        case x1 of\n        (a1, b1) \\<Rightarrow>\n          case x2 of (a2, b2) \\<Rightarrow> a1 = a2 \\<and> b1 = b2)", "by (auto intro!: ext)"], ["", "end"], ["", "subsection \"Option\""], ["", "consts i_option :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of option_rel i_option]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*\n    lemma [autoref_itype]:\n      \"None ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option\"\n      \"Some ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option\"\n      \"the ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i I\"\n      \"case_option ::\\<^sub>i I \\<rightarrow>\\<^sub>i (Iv\\<rightarrow>\\<^sub>iI) \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i I\"\n      \"rec_option ::\\<^sub>i I \\<rightarrow>\\<^sub>i (Iv\\<rightarrow>\\<^sub>iI) \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i I\"\n      \"((=) :: _ option \\<Rightarrow> _) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool\"\n      by auto\n      *)"], ["", "lemma autoref_opt[autoref_rules]:\n      \"(None,None)\\<in>\\<langle>R\\<rangle>option_rel\"\n      \"(Some,Some)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>option_rel\"\n      \"(case_option,case_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\"\n      \"(rec_option,rec_option)\\<in>Rr\\<rightarrow>(R \\<rightarrow> Rr)\\<rightarrow>\\<langle>R\\<rangle>option_rel \\<rightarrow> Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((None, None) \\<in> \\<langle>R\\<rangle>option_rel &&&\n     (Some, Some) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel) &&&\n    (case_option, case_option)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> Rr &&&\n    (rec_option, rec_option)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> Rr", "by (auto split: option.split \n        simp: option_rel_def case_option_def[symmetric]\n        dest: fun_relD)"], ["", "lemma autoref_the[autoref_rules]:\n      assumes \"SIDE_PRECOND (x\\<noteq>None)\"\n      assumes \"(x',x)\\<in>\\<langle>R\\<rangle>option_rel\"\n      shows \"(the x', (OP the ::: \\<langle>R\\<rangle>option_rel \\<rightarrow> R)$x) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the x', (OP the ::: \\<langle>R\\<rangle>option_rel \\<rightarrow> R) $ x)\n    \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (x \\<noteq> None)\n  (x', x) \\<in> \\<langle>R\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. (the x', (OP the ::: \\<langle>R\\<rangle>option_rel \\<rightarrow> R) $ x)\n    \\<in> R", "by (auto simp: option_rel_def)"], ["", "lemma autoref_the_default[autoref_rules]:\n      \"(the_default, the_default) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_default, the_default)\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> R", "by parametricity"], ["", "definition [simp]: \"is_None a \\<equiv> case a of None \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma pat_isNone[autoref_op_pat]:\n      \"a=None \\<equiv> (OP is_None :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool)$a\"\n      \"None=a \\<equiv> (OP is_None :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool)$a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = None \\<equiv>\n     (OP is_None :::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool) $\n     a) &&&\n    None = a \\<equiv>\n    (OP is_None :::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_option \\<rightarrow>\\<^sub>i i_bool) $\n    a", "by (auto intro!: eq_reflection split: option.splits)"], ["", "lemma autoref_is_None[param,autoref_rules]: \n      \"(is_None,is_None)\\<in>\\<langle>R\\<rangle>option_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_None, is_None)\n    \\<in> \\<langle>R\\<rangle>option_rel \\<rightarrow> bool_rel", "by (auto split: option.splits)"], ["", "lemma fold_is_None: \"x=None \\<longleftrightarrow> is_None x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = None) = is_None x", "by (cases x) auto"], ["", "definition \"option_eq eq v1 v2 \\<equiv> \n      case (v1,v2) of \n        (None,None) \\<Rightarrow> True\n      | (Some x1, Some x2) \\<Rightarrow> eq x1 x2\n      | _ \\<Rightarrow> False\""], ["", "lemma option_eq_autoref[autoref_rules (overloaded)]:\n      \"\\<lbrakk>GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>Id)\\<rbrakk> \n      \\<Longrightarrow> (option_eq eq,(=)) \\<in> \\<langle>R\\<rangle>option_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP eq (=)\n     (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<Longrightarrow>\n    (option_eq eq, (=))\n    \\<in> \\<langle>R\\<rangle>option_rel \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> bool_rel", "unfolding option_eq_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP eq (=)\n     (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<Longrightarrow>\n    (\\<lambda>v1 v2.\n        case (v1, v2) of (None, None) \\<Rightarrow> True\n        | (None, Some a) \\<Rightarrow> False\n        | (Some x1, None) \\<Rightarrow> False\n        | (Some x1, Some x) \\<Rightarrow> eq x1 x,\n     (=))\n    \\<in> \\<langle>R\\<rangle>option_rel \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel \\<rightarrow> bool_rel", "by (auto dest: fun_relD split: option.splits elim!: option_relE)"], ["", "lemma option_eq_expand[autoref_struct_expand]: \n      \"(=) = option_eq (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = option_eq (=)", "by (auto intro!: ext simp: option_eq_def split: option.splits)"], ["", "end"], ["", "subsection \"Sum-Types\""], ["", "consts i_sum :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of sum_rel i_sum]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*lemma [autoref_itype]:\n    \"((=) :: _+_ \\<Rightarrow> _) ::\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum \\<rightarrow>\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum \\<rightarrow>\\<^sub>i i_bool\"\n    \"Inl ::\\<^sub>i Il \\<rightarrow>\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum\"\n    \"Inr ::\\<^sub>i Ir \\<rightarrow>\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum\"\n    \"case_sum ::\\<^sub>i (Il\\<rightarrow>\\<^sub>iI) \\<rightarrow>\\<^sub>i (Ir \\<rightarrow>\\<^sub>i I) \\<rightarrow>\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum \\<rightarrow>\\<^sub>i I\"\n    \"old.rec_sum ::\\<^sub>i (Il\\<rightarrow>\\<^sub>iI) \\<rightarrow>\\<^sub>i (Ir \\<rightarrow>\\<^sub>i I) \\<rightarrow>\\<^sub>i \\<langle>Il,Ir\\<rangle>\\<^sub>ii_sum \\<rightarrow>\\<^sub>i I\"\n    by auto*)"], ["", "lemma autoref_sum[autoref_rules]:\n    \"(Inl,Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n    \"(Inr,Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n    \"(case_sum,case_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\"\n    \"(old.rec_sum,old.rec_sum) \\<in> (Rl \\<rightarrow> R) \\<rightarrow> (Rr \\<rightarrow> R) \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Inl, Inl) \\<in> Rl \\<rightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel &&&\n     (Inr, Inr) \\<in> Rr \\<rightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel) &&&\n    (case_sum, case_sum)\n    \\<in> (Rl \\<rightarrow> R) \\<rightarrow>\n          (Rr \\<rightarrow> R) \\<rightarrow>\n          \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow> R &&&\n    (old.rec_sum, old.rec_sum)\n    \\<in> (Rl \\<rightarrow> R) \\<rightarrow>\n          (Rr \\<rightarrow> R) \\<rightarrow>\n          \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow> R", "by (fastforce split: sum.split dest: fun_relD \n      simp: rec_sum_is_case)+"], ["", "definition \"sum_eq eql eqr s1 s2 \\<equiv> \n    case (s1,s2) of \n      (Inl x1, Inl x2) \\<Rightarrow> eql x1 x2\n    | (Inr x1, Inr x2) \\<Rightarrow> eqr x1 x2\n    | _ \\<Rightarrow> False\""], ["", "lemma sum_eq_autoref[autoref_rules (overloaded)]:\n    \"\\<lbrakk>GEN_OP eql (=) (Rl\\<rightarrow>Rl\\<rightarrow>Id); GEN_OP eqr (=) (Rr\\<rightarrow>Rr\\<rightarrow>Id)\\<rbrakk> \n    \\<Longrightarrow> (sum_eq eql eqr,(=)) \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GEN_OP eql (=) (Rl \\<rightarrow> Rl \\<rightarrow> bool_rel);\n     GEN_OP eqr (=) (Rr \\<rightarrow> Rr \\<rightarrow> bool_rel)\\<rbrakk>\n    \\<Longrightarrow> (sum_eq eql eqr, (=))\n                      \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow>\n                            \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow>\n                            bool_rel", "unfolding sum_eq_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GEN_OP eql (=) (Rl \\<rightarrow> Rl \\<rightarrow> bool_rel);\n     GEN_OP eqr (=) (Rr \\<rightarrow> Rr \\<rightarrow> bool_rel)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>s1 s2.\n                          case (s1, s2) of\n                          (Inl x1, Inl x) \\<Rightarrow> eql x1 x\n                          | (Inl x1, Inr ba) \\<Rightarrow> False\n                          | (Inr x1, Inl a) \\<Rightarrow> False\n                          | (Inr x1, Inr x) \\<Rightarrow> eqr x1 x,\n                       (=))\n                      \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow>\n                            \\<langle>Rl, Rr\\<rangle>sum_rel \\<rightarrow>\n                            bool_rel", "by (fastforce dest: fun_relD elim!: sum_relE)"], ["", "lemma sum_eq_expand[autoref_struct_expand]: \"(=) = sum_eq (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = sum_eq (=) (=)", "by (auto intro!: ext simp: sum_eq_def split: sum.splits)"], ["", "lemmas [autoref_rules] = is_Inl_param is_Inr_param"], ["", "lemma autoref_sum_Projl[autoref_rules]: \n    \"\\<lbrakk>SIDE_PRECOND (is_Inl s); (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n    \\<Longrightarrow> (Sum_Type.sum.projl s', (OP Sum_Type.sum.projl ::: \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> Ra)$s)\\<in>Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SIDE_PRECOND (is_Inl s);\n     (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (projl s',\n                       (OP projl :::\n                        \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> Ra) $\n                       s)\n                      \\<in> Ra", "by simp parametricity"], ["", "lemma autoref_sum_Projr[autoref_rules]: \n    \"\\<lbrakk>SIDE_PRECOND (is_Inr s); (s',s)\\<in>\\<langle>Ra,Rb\\<rangle>sum_rel\\<rbrakk> \n    \\<Longrightarrow> (Sum_Type.sum.projr s', (OP Sum_Type.sum.projr ::: \\<langle>Ra,Rb\\<rangle>sum_rel \\<rightarrow> Rb)$s)\\<in>Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SIDE_PRECOND (is_Inr s);\n     (s', s) \\<in> \\<langle>Ra, Rb\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (projr s',\n                       (OP projr :::\n                        \\<langle>Ra, Rb\\<rangle>sum_rel \\<rightarrow> Rb) $\n                       s)\n                      \\<in> Rb", "by simp parametricity"], ["", "end"], ["", "subsection \"List\""], ["", "consts i_list :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of list_rel i_list]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*\n  term nth\n  lemma [autoref_itype]:\n    \"((=) :: _ list \\<Rightarrow> _) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool\"\n    \"[] ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"(#) ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"(@) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"case_list ::\\<^sub>i Ir \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>i\\<langle>I\\<rangle>\\<^sub>ii_list\\<rightarrow>\\<^sub>iIr) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i Ir\"\n    \"rec_list ::\\<^sub>i Ir \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>i\\<langle>I\\<rangle>\\<^sub>ii_list\\<rightarrow>\\<^sub>iIr\\<rightarrow>\\<^sub>iIr) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i Ir\"\n    \"map ::\\<^sub>i (I1\\<rightarrow>\\<^sub>iI2) \\<rightarrow>\\<^sub>i \\<langle>I1\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I2\\<rangle>\\<^sub>ii_list\"\n    \"foldl ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb\\<rightarrow>\\<^sub>iIa) \\<rightarrow>\\<^sub>i Ia \\<rightarrow>\\<^sub>i \\<langle>Ib\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i Ia\"\n    \"foldr ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i Ib \\<rightarrow>\\<^sub>i Ib\"\n    \"fold ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i Ib \\<rightarrow>\\<^sub>i Ib\"\n    \"take ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"drop ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"length ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_nat\"\n    \"nth ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_nat \\<rightarrow>\\<^sub>i I\"\n    \"hd ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i I\"\n    \"tl ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    \"last ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i I\"\n    \"butlast ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list\"\n    by auto\n    *)"], ["", "lemma autoref_append[autoref_rules]: \n    \"(append, append)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((@), (@))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by (auto simp: list_rel_def list_all2_appendI)"], ["", "lemma refine_list[autoref_rules]:\n    \"(Nil,Nil)\\<in>\\<langle>R\\<rangle>list_rel\"\n    \"(Cons,Cons)\\<in>R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\"\n    \"(case_list,case_list)\\<in>Rr\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>list_rel\\<rightarrow>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], []) \\<in> \\<langle>R\\<rangle>list_rel &&&\n    ((#), (#))\n    \\<in> R \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel &&&\n    (case_list, case_list)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow>\n           \\<langle>R\\<rangle>list_rel \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> Rr", "apply (force dest: fun_relD split: list.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_rec_list[autoref_rules]: \"(rec_list,rec_list) \n    \\<in> Ra \\<rightarrow> (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra) \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list, rec_list)\n    \\<in> Ra \\<rightarrow>\n          (Rb \\<rightarrow>\n           \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n           Ra \\<rightarrow> Ra) \\<rightarrow>\n          \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra", "proof (intro fun_relI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (aa, a'a)\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra;\n        (ab, a'b) \\<in> \\<langle>Rb\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_list a aa ab, rec_list a' a'a a'b) \\<in> Ra", "case prems: (1 a a' f f' l l')"], ["proof (state)\nthis:\n  (a, a') \\<in> Ra\n  (f, f')\n  \\<in> Rb \\<rightarrow>\n        \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (aa, a'a)\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra;\n        (ab, a'b) \\<in> \\<langle>Rb\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_list a aa ab, rec_list a' a'a a'b) \\<in> Ra", "from prems(3)"], ["proof (chain)\npicking this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel", "show ?case"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (rec_list a f l, rec_list a' f' l') \\<in> Ra", "using prems(1,2)"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel\n  (a, a') \\<in> Ra\n  (f, f')\n  \\<in> Rb \\<rightarrow>\n        \\<langle>Rb\\<rangle>list_rel \\<rightarrow> Ra \\<rightarrow> Ra\n\ngoal (1 subgoal):\n 1. (rec_list a f l, rec_list a' f' l') \\<in> Ra", "apply (induct arbitrary: a a')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f [], rec_list a' f' []) \\<in> Ra\n 2. \\<And>x x' l l' a a'.\n       \\<lbrakk>(x, x') \\<in> Rb;\n        (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel;\n        \\<And>a a'.\n           \\<lbrakk>(a, a') \\<in> Ra;\n            (f, f')\n            \\<in> Rb \\<rightarrow>\n                  \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n                  Ra \\<rightarrow> Ra\\<rbrakk>\n           \\<Longrightarrow> (rec_list a f l, rec_list a' f' l') \\<in> Ra;\n        (a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f (x # l), rec_list a' f' (x' # l'))\n                         \\<in> Ra", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' a a'.\n       \\<lbrakk>(x, x') \\<in> Rb;\n        (l, l') \\<in> \\<langle>Rb\\<rangle>list_rel;\n        \\<And>a a'.\n           \\<lbrakk>(a, a') \\<in> Ra;\n            (f, f')\n            \\<in> Rb \\<rightarrow>\n                  \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n                  Ra \\<rightarrow> Ra\\<rbrakk>\n           \\<Longrightarrow> (rec_list a f l, rec_list a' f' l') \\<in> Ra;\n        (a, a') \\<in> Ra;\n        (f, f')\n        \\<in> Rb \\<rightarrow>\n              \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n              Ra \\<rightarrow> Ra\\<rbrakk>\n       \\<Longrightarrow> (rec_list a f (x # l), rec_list a' f' (x' # l'))\n                         \\<in> Ra", "apply (fastforce dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_list a f l, rec_list a' f' l') \\<in> Ra\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma refine_map[autoref_rules]: \n    \"(map,map)\\<in>(R1\\<rightarrow>R2) \\<rightarrow> \\<langle>R1\\<rangle>list_rel \\<rightarrow> \\<langle>R2\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map, map)\n    \\<in> (R1 \\<rightarrow> R2) \\<rightarrow>\n          \\<langle>R1\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R2\\<rangle>list_rel", "using [[autoref_sbias = -1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map, map)\n    \\<in> (R1 \\<rightarrow> R2) \\<rightarrow>\n          \\<langle>R1\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R2\\<rangle>list_rel", "unfolding map_rec[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. rec_list [] (\\<lambda>x _. (#) (f x)),\n     \\<lambda>f. rec_list [] (\\<lambda>x _. (#) (f x)))\n    \\<in> (R1 \\<rightarrow> R2) \\<rightarrow>\n          \\<langle>R1\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R2\\<rangle>list_rel", "by autoref"], ["", "lemma refine_fold[autoref_rules]: \n    \"(fold,fold)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\"\n    \"(foldl,foldl)\\<in>(Rs\\<rightarrow>Re\\<rightarrow>Rs) \\<rightarrow> Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs\"\n    \"(foldr,foldr)\\<in>(Re\\<rightarrow>Rs\\<rightarrow>Rs) \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold, fold)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs &&&\n    (foldl, foldl)\n    \\<in> (Rs \\<rightarrow> Re \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs &&&\n    (foldr, foldr)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs", "unfolding List.fold_def List.foldr_def List.foldl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (xsa f \\<circ>\\<circ> f) x) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (xsa f \\<circ>\\<circ> f) x) uua uu)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs &&&\n    (\\<lambda>uu uua uub.\n        rec_list (\\<lambda>f a. a) (\\<lambda>x xs xsa f a. xsa f (f a x))\n         uub uu uua,\n     \\<lambda>uu uua uub.\n        rec_list (\\<lambda>f a. a) (\\<lambda>x xs xsa f a. xsa f (f a x))\n         uub uu uua)\n    \\<in> (Rs \\<rightarrow> Re \\<rightarrow> Rs) \\<rightarrow>\n          Rs \\<rightarrow> \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs &&&\n    (\\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (f x \\<circ>\\<circ> xsa) f) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>f. id)\n         (\\<lambda>x xs xsa f. (f x \\<circ>\\<circ> xsa) f) uua uu)\n    \\<in> (Re \\<rightarrow> Rs \\<rightarrow> Rs) \\<rightarrow>\n          \\<langle>Re\\<rangle>list_rel \\<rightarrow> Rs \\<rightarrow> Rs", "by (autoref)+"], ["", "schematic_goal autoref_take[autoref_rules]: \"(take,take)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take, take) \\<in> ?R", "unfolding take_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> [] | Suc m \\<Rightarrow> x # xsa m)\n         uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> [] | Suc m \\<Rightarrow> x # xsa m)\n         uua uu)\n    \\<in> ?R", "by autoref"], ["", "schematic_goal autoref_drop[autoref_rules]: \"(drop,drop)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (drop, drop) \\<in> ?R", "unfolding drop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> x # xs | Suc m \\<Rightarrow> xsa m)\n         uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>n. [])\n         (\\<lambda>x xs xsa n.\n             case n of 0 \\<Rightarrow> x # xs | Suc m \\<Rightarrow> xsa m)\n         uua uu)\n    \\<in> ?R", "by autoref"], ["", "schematic_goal autoref_length[autoref_rules]: \n    \"(length,length)\\<in>(?R::(_\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, length) \\<in> ?R", "unfolding size_list_overloaded_def size_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list 0 (\\<lambda>x xa xb. 0 + xb + Suc 0),\n     rec_list 0 (\\<lambda>x xa xb. 0 + xb + Suc 0))\n    \\<in> ?R", "by (autoref)"], ["", "lemma autoref_nth[autoref_rules]: \n    assumes \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\"\n    assumes \"(i,i')\\<in>Id\"\n    assumes \"SIDE_PRECOND (i' < length l')\"\n    shows \"(nth l i,(OP nth ::: \\<langle>R\\<rangle>list_rel \\<rightarrow> Id \\<rightarrow> R)$l'$i')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i,\n     (OP (!) :::\n      \\<langle>R\\<rangle>list_rel \\<rightarrow> nat_rel \\<rightarrow> R) $\n     l' $\n     i')\n    \\<in> R", "unfolding ANNOT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i, OP (!) $ l' $ i') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n  (i, i') \\<in> nat_rel\n  SIDE_PRECOND (i' < length l')\n\ngoal (1 subgoal):\n 1. (l ! i, OP (!) $ l' $ i') \\<in> R", "apply (induct arbitrary: i i')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i i'.\n       \\<lbrakk>(i, i') \\<in> nat_rel;\n        SIDE_PRECOND (i' < length [])\\<rbrakk>\n       \\<Longrightarrow> ([] ! i, OP (!) $ [] $ i') \\<in> R\n 2. \\<And>x x' l l' i i'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        \\<And>i i'.\n           \\<lbrakk>(i, i') \\<in> nat_rel;\n            SIDE_PRECOND (i' < length l')\\<rbrakk>\n           \\<Longrightarrow> (l ! i, OP (!) $ l' $ i') \\<in> R;\n        (i, i') \\<in> nat_rel; SIDE_PRECOND (i' < length (x' # l'))\\<rbrakk>\n       \\<Longrightarrow> ((x # l) ! i, OP (!) $ (x' # l') $ i') \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' i i'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        \\<And>i i'.\n           \\<lbrakk>(i, i') \\<in> nat_rel;\n            SIDE_PRECOND (i' < length l')\\<rbrakk>\n           \\<Longrightarrow> (l ! i, OP (!) $ l' $ i') \\<in> R;\n        (i, i') \\<in> nat_rel; SIDE_PRECOND (i' < length (x' # l'))\\<rbrakk>\n       \\<Longrightarrow> ((x # l) ! i, OP (!) $ (x' # l') $ i') \\<in> R", "apply (case_tac i')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' l l' i i'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        \\<And>i i'.\n           \\<lbrakk>(i, i') \\<in> nat_rel;\n            SIDE_PRECOND (i' < length l')\\<rbrakk>\n           \\<Longrightarrow> (l ! i, OP (!) $ l' $ i') \\<in> R;\n        (i, i') \\<in> nat_rel; SIDE_PRECOND (i' < length (x' # l'));\n        i' = 0\\<rbrakk>\n       \\<Longrightarrow> ((x # l) ! i, OP (!) $ (x' # l') $ i') \\<in> R\n 2. \\<And>x x' l l' i i' nat.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        \\<And>i i'.\n           \\<lbrakk>(i, i') \\<in> nat_rel;\n            SIDE_PRECOND (i' < length l')\\<rbrakk>\n           \\<Longrightarrow> (l ! i, OP (!) $ l' $ i') \\<in> R;\n        (i, i') \\<in> nat_rel; SIDE_PRECOND (i' < length (x' # l'));\n        i' = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ((x # l) ! i, OP (!) $ (x' # l') $ i') \\<in> R", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun list_eq :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n    \"list_eq eq [] [] \\<longleftrightarrow> True\"\n  | \"list_eq eq (a#l) (a'#l') \n       \\<longleftrightarrow> (if eq a a' then list_eq eq l l' else False)\"\n  | \"list_eq _ _ _ \\<longleftrightarrow> False\""], ["", "lemma autoref_list_eq_aux: \"\n    (list_eq,list_eq) \\<in> \n      (R \\<rightarrow> R \\<rightarrow> Id) \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.list_eq, local.list_eq)\n    \\<in> (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "proof (intro fun_relI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, a'b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq a aa ab, local.list_eq a' a'a a'b)\n                         \\<in> bool_rel", "case (1 eq eq' l1 l1' l2 l2')"], ["proof (state)\nthis:\n  (eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\n  (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel\n  (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, a'b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq a aa ab, local.list_eq a' a'a a'b)\n                         \\<in> bool_rel", "thus ?case"], ["proof (prove)\nusing this:\n  (eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\n  (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel\n  (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (local.list_eq eq l1 l2, local.list_eq eq' l1' l2') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(eq, eq') \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n     (l1, l1') \\<in> \\<langle>R\\<rangle>list_rel;\n     (l2, l2') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (local.list_eq eq l1 l2, local.list_eq eq' l1' l2')\n                      \\<in> bool_rel", "apply (induct eq' l1' l2' arbitrary: l1 l2 rule: list_eq.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>eqa l1 l2.\n       \\<lbrakk>(eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2, local.list_eq eqa [] [])\n                         \\<in> bool_rel\n 2. \\<And>eqa a l a' l' l1 l2.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 4. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>eqa a l a' l' l1 l2.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (case_tac l1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>eqa a l a' l' l1 l2.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel; l1 = []\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 2. \\<And>eqa a l a' l' l1 l2 aa list.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 4. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>eqa a l a' l' l1 l2 aa list.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (case_tac l2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>eqa a l a' l' l1 l2 aa list.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel; l1 = aa # list;\n        l2 = []\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 2. \\<And>eqa a l a' l' l1 l2 aa list ab lista.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel; l1 = aa # list;\n        l2 = ab # lista\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 4. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>eqa a l a' l' l1 l2 aa list ab lista.\n       \\<lbrakk>\\<And>l1 l2.\n                   \\<lbrakk>eqa a a';\n                    (eq, eqa)\n                    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n                    (l1, l) \\<in> \\<langle>R\\<rangle>list_rel;\n                    (l2, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (local.list_eq eq l1 l2,\nlocal.list_eq eqa l l')\n                                     \\<in> bool_rel;\n        (eq, eqa) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, a # l) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, a' # l') \\<in> \\<langle>R\\<rangle>list_rel; l1 = aa # list;\n        l2 = ab # lista\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq eqa (a # l) (a' # l'))\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (auto dest: fun_relD) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (case_tac l1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel; l1 = []\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2 a list.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel; l1 = a # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 3. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ v va l1 l2 a list.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, []) \\<in> \\<langle>R\\<rangle>list_rel; l1 = a # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ (v # va) [])\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply (case_tac l2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ v va l1 l2.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel; l2 = []\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel\n 2. \\<And>uu_ v va l1 l2 a list.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        l2 = a # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ v va l1 l2 a list.\n       \\<lbrakk>(eq, uu_) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel;\n        (l1, []) \\<in> \\<langle>R\\<rangle>list_rel;\n        (l2, v # va) \\<in> \\<langle>R\\<rangle>list_rel;\n        l2 = a # list\\<rbrakk>\n       \\<Longrightarrow> (local.list_eq eq l1 l2,\n                          local.list_eq uu_ [] (v # va))\n                         \\<in> bool_rel", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (local.list_eq eq l1 l2, local.list_eq eq' l1' l2') \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_eq_expand[autoref_struct_expand]: \"(=) = (list_eq (=))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = local.list_eq (=)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (x = xa) = local.list_eq (=) x xa", "fix l1 l2 :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (x = xa) = local.list_eq (=) x xa", "show \"(l1 = l2) \\<longleftrightarrow> list_eq (=) l1 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l1 = l2) = local.list_eq (=) l1 l2", "apply (induct \"(=) :: 'a \\<Rightarrow> _\" l1 l2 rule: list_eq.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ([] = []) = local.list_eq (=) [] []\n 2. \\<And>a l a' l'.\n       (a = a' \\<Longrightarrow>\n        (l = l') = local.list_eq (=) l l') \\<Longrightarrow>\n       (a # l = a' # l') = local.list_eq (=) (a # l) (a' # l')\n 3. \\<And>v va. (v # va = []) = local.list_eq (=) (v # va) []\n 4. \\<And>v va. ([] = v # va) = local.list_eq (=) [] (v # va)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (l1 = l2) = local.list_eq (=) l1 l2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_list_eq[autoref_rules (overloaded)]:\n    \"GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>Id) \\<Longrightarrow> (list_eq eq, (=)) \n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP eq (=)\n     (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<Longrightarrow>\n    (local.list_eq eq, (=))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq, (=))\n    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<Longrightarrow>\n    (local.list_eq eq, (=))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "apply (subst list_eq_expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq, (=))\n    \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel \\<Longrightarrow>\n    (local.list_eq eq, local.list_eq (=))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "apply (parametricity add: autoref_list_eq_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_hd[autoref_rules]:\n    \"\\<lbrakk> SIDE_PRECOND (l'\\<noteq>[]); (l,l') \\<in> \\<langle>R\\<rangle>list_rel \\<rbrakk> \\<Longrightarrow>\n      (hd l,(OP hd ::: \\<langle>R\\<rangle>list_rel \\<rightarrow> R)$l') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SIDE_PRECOND (l' \\<noteq> []);\n     (l, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (hd l,\n                       (OP hd :::\n                        \\<langle>R\\<rangle>list_rel \\<rightarrow> R) $\n                       l')\n                      \\<in> R", "apply (simp add: ANNOT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' \\<noteq> [];\n     (l, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (hd l, hd l') \\<in> R", "apply (cases l')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l' \\<noteq> []; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n     l' = []\\<rbrakk>\n    \\<Longrightarrow> (hd l, hd l') \\<in> R\n 2. \\<And>a list.\n       \\<lbrakk>l' \\<noteq> []; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l' = a # list\\<rbrakk>\n       \\<Longrightarrow> (hd l, hd l') \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l' \\<noteq> []; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l' = a # list\\<rbrakk>\n       \\<Longrightarrow> (hd l, hd l') \\<in> R", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>l' \\<noteq> []; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l' = a # list; l = []\\<rbrakk>\n       \\<Longrightarrow> (hd l, hd l') \\<in> R\n 2. \\<And>a list aa lista.\n       \\<lbrakk>l' \\<noteq> []; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l' = a # list; l = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (hd l, hd l') \\<in> R", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_tl[autoref_rules]:\n    \"(tl,tl) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tl, tl)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "unfolding tl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>list.\n        case list of [] \\<Rightarrow> [] | x21 # x22 \\<Rightarrow> x22,\n     \\<lambda>list.\n        case list of [] \\<Rightarrow> [] | x21 # x22 \\<Rightarrow> x22)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by autoref"], ["", "definition [simp]: \"is_Nil a \\<equiv> case a of [] \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma is_Nil_pat[autoref_op_pat]:\n    \"a=[] \\<equiv> (OP is_Nil :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool)$a\"\n    \"[]=a \\<equiv> (OP is_Nil :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool)$a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = [] \\<equiv>\n     (OP is_Nil :::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool) $\n     a) &&&\n    [] = a \\<equiv>\n    (OP is_Nil :::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i i_bool) $\n    a", "by (auto intro!: eq_reflection split: list.splits)"], ["", "lemma autoref_is_Nil[param,autoref_rules]: \n    \"(is_Nil,is_Nil)\\<in>\\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Nil, is_Nil)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> bool_rel", "by (auto split: list.splits)"], ["", "lemma conv_to_is_Nil: \n    \"l=[] \\<longleftrightarrow> is_Nil l\"\n    \"[]=l \\<longleftrightarrow> is_Nil l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = []) = is_Nil l &&& ([] = l) = is_Nil l", "unfolding is_Nil_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = []) =\n    (case l of [] \\<Rightarrow> True | a # list \\<Rightarrow> False) &&&\n    ([] = l) =\n    (case l of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "by (auto split: list.split)"], ["", "lemma autoref_butlast[param, autoref_rules]: \n    \"(butlast,butlast) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (butlast, butlast)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "unfolding butlast_def conv_to_is_Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list [] (\\<lambda>x xs xsa. if is_Nil xs then [] else x # xsa),\n     rec_list [] (\\<lambda>x xs xsa. if is_Nil xs then [] else x # xsa))\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "by parametricity"], ["", "definition [simp]: \"op_list_singleton x \\<equiv> [x]\""], ["", "lemma op_list_singleton_pat[autoref_op_pat]:\n    \"[x] \\<equiv> (OP op_list_singleton :::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list)$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x] \\<equiv>\n    (OP op_list_singleton :::\\<^sub>i\n     I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list) $\n    x", "by simp"], ["", "lemma autoref_list_singleton[autoref_rules]: \n    \"(\\<lambda>a. [a],op_list_singleton) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. [a], op_list_singleton)\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_rel", "by auto"], ["", "definition [simp]: \"op_list_append_elem s x \\<equiv> s@[x]\""], ["", "lemma pat_list_append_elem[autoref_op_pat]: \n    \"s@[x] \\<equiv> (OP op_list_append_elem :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list)$s$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s @ [x] \\<equiv>\n    (OP op_list_append_elem :::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i\n     I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list) $\n    s $\n    x", "by (simp add: relAPP_def)"], ["", "lemma autoref_list_append_elem[autoref_rules]: \n    \"(\\<lambda>s x. s@[x], op_list_append_elem) \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. s @ [x], op_list_append_elem)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_rel", "unfolding op_list_append_elem_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. s @ [x], \\<lambda>s x. s @ [x])\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_rel", "by parametricity"], ["", "declare param_rev[autoref_rules]"], ["", "declare param_all_interval_nat[autoref_rules]"], ["", "lemma [autoref_op_pat]: \n    \"(\\<forall>i<u. P i) \\<equiv> OP List.all_interval_nat P 0 u\"\n    \"(\\<forall>i\\<le>u. P i) \\<equiv> OP List.all_interval_nat P 0 (Suc u)\"\n    \"(\\<forall>i<u. l\\<le>i \\<longrightarrow> P i) \\<equiv> OP List.all_interval_nat P l u\"\n    \"(\\<forall>i\\<le>u. l\\<le>i \\<longrightarrow> P i) \\<equiv> OP List.all_interval_nat P l (Suc u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i<u. P i \\<equiv> OP List.all_interval_nat P 0 u) &&&\n     \\<forall>i\\<le>u. P i \\<equiv>\n     OP List.all_interval_nat P 0 (Suc u)) &&&\n    (\\<forall>i<u. l \\<le> i \\<longrightarrow> P i \\<equiv>\n     OP List.all_interval_nat P l u) &&&\n    \\<forall>i\\<le>u. l \\<le> i \\<longrightarrow> P i \\<equiv>\n    OP List.all_interval_nat P l (Suc u)", "by (auto intro!: eq_reflection simp: List.all_interval_nat_def)"], ["", "lemmas [autoref_rules] = param_dropWhile param_takeWhile"], ["", "end"], ["", "subsection \"Examples\""], ["", "text \\<open>Be careful to make the concrete type a schematic type variable.\n  The default behaviour of \\<open>schematic_lemma\\<close> makes it a fixed variable,\n  that will not unify with the infered term!\\<close>"], ["", "schematic_goal \n  \"(?f::?'c,[1,2,3]@[4::nat])\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, [1, 2, 3] @ [4]) \\<in> ?R", "by autoref"], ["", "schematic_goal \n  \"(?f::?'c,[1::nat,\n    2,3,4,5,6,7,8,9,0,1,43,5,5,435,5,1,5,6,5,6,5,63,56\n  ]\n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 43, 5, 5, 435, 5, 1, 5, 6, 5, 6, 5,\n      63, 56])\n    \\<in> ?R", "apply (autoref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  \"(?f::?'c,[1,2,3] = [])\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, [1::'a, 2::'a, 3::'a] = []) \\<in> ?R", "by autoref"], ["", "text \\<open>\n  When specifying custom refinement rules on the fly, be careful with\n  the type-inference between \\<open>notes\\<close> and \\<open>shows\\<close>. It's\n  too easy to ,,decouple'' the type \\<open>'a\\<close> in the autoref-rule and\n  the actual goal, as shown below!\n\\<close>"], ["", "schematic_goal \n  notes [autoref_rules] = IdI[where 'a=\"'a\"]\n  notes [autoref_itype] = itypeI[where 't=\"'a::numeral\" and I=i_std]\n  shows \"(?f::?'c, hd [a,b,c::'a::numeral])\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, hd [a, b, c]) \\<in> ?R", "txt \\<open>The autoref-rule is bound with type \\<open>'a::typ\\<close>, while\n    the goal statement has \\<open>'a::numeral\\<close>!\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, hd [a, b, c]) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "txt \\<open>We get an unsolved goal, as it finds no rule to translate \n    \\<open>a\\<close>\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "oops"], ["", "text \\<open>Here comes the correct version. Note the duplicate sort annotation\n  of type \\<open>'a\\<close>:\\<close>"], ["", "schematic_goal \n  notes [autoref_rules_raw] = IdI[where 'a=\"'a::numeral\"]\n  notes [autoref_itype] = itypeI[where 't=\"'a::numeral\" and I=i_std]\n  shows \"(?f::?'c, hd [a,b,c::'a::numeral])\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, hd [a, b, c]) \\<in> ?R", "by (autoref)"], ["", "text \\<open>Special cases of equality: Note that we do not require equality\n  on the element type!\\<close>"], ["", "schematic_goal \n  (*notes [autoref_itype] = itypeI[of a \"\\<langle>I\\<rangle>\\<^sub>ii_option\"]*)\n  assumes [autoref_rules]: \"(ai,a)\\<in>\\<langle>R\\<rangle>option_rel\"\n  shows \"(?f::?'c, a = None)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, a = None) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  (*notes [autoref_itype] = itypeI[of a \"\\<langle>I\\<rangle>\\<^sub>ii_list\"]*)\n  assumes [autoref_rules]: \"(ai,a)\\<in>\\<langle>R\\<rangle>list_rel\"  \n  shows \"(?f::?'c, [] = a)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, [] = a) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  shows \"(?f::?'c, [1,2] = [2,3::nat])\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, [1, 2] = [2, 3]) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}