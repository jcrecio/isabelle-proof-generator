{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Tool/Autoref_Tagging.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma ABS_beta: \"(\\<lambda>'x. f x)$x \\<equiv> f x\"", "lemma ABS_eta: \"\\<lambda>'x. (f$x) \\<equiv> f\"", "lemma rel_ANNOT_eq: \"t \\<equiv> t:::R\""], "translations": [["", "lemma ABS_beta: \"(\\<lambda>'x. f x)$x \\<equiv> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>'x. f x) $ x \\<equiv> f x", "by simp"], ["", "lemma ABS_eta: \"\\<lambda>'x. (f$x) \\<equiv> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>'x. f $ x \\<equiv> f", "by simp"], ["", "text \\<open>This tag is used to highlight failures during operation \n  identification\\<close>"], ["", "definition \"ID_FAIL x \\<equiv> x\""], ["", "notation (output) ID_FAIL (\"FAIL *** _ ***\")"], ["", "text \\<open>Relator annotation\\<close>"], ["", "consts rel_annot :: \"('c\\<times>'a) set \\<Rightarrow> annot\""], ["", "abbreviation rel_ANNOT :: \"'a \\<Rightarrow> ('c \\<times> 'a) set \\<Rightarrow> 'a\" (infix \":::\" 10)\n  where \"t:::R \\<equiv> ANNOT t (rel_annot R)\""], ["", "lemma rel_ANNOT_eq: \"t \\<equiv> t:::R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<equiv> t ::: R", "by simp"], ["", "text \\<open>Indirect annotation\\<close>"], ["", "typedecl rel_name"], ["", "consts ind_annot :: \"rel_name \\<Rightarrow> annot\""], ["", "abbreviation ind_ANNOT :: \"'a \\<Rightarrow> rel_name \\<Rightarrow> 'a\" (infix \"::#\" 10)\n  where \"t::#s \\<equiv> ANNOT t (ind_annot s)\""], ["", "ML \\<open>\n  signature AUTOREF_TAGGING = sig\n    val term_of_tagged: term -> term\n    val is_valid_tagged: term -> bool\n\n    val mk_APP: term -> term -> term\n    val mk_OP: term -> term\n    val lambda': string * typ -> term -> term\n\n    val list_APP: term * term list -> term\n    val strip_app: term -> term * term list\n\n    val untag_conv: Proof.context -> conv\n\n    val mk_APP_conv: conv\n    val mk_OP_conv: conv\n    val mk_ABS_conv: Proof.context -> conv\n    val mk_ANNOT_conv: cterm -> conv\n    val mk_rel_ANNOT_conv: Proof.context -> cterm -> conv\n\n    val ABS_beta_conv: Proof.context -> conv\n\n    val rhs_conv: (Proof.context -> conv) -> Proof.context -> conv\n  end\n\n\n  structure Autoref_Tagging :AUTOREF_TAGGING = struct\n    fun term_of_tagged (Free v) = Free v\n      | term_of_tagged (Var v) = Var v\n      | term_of_tagged (Bound i) = Bound i\n      | term_of_tagged @{mpat \"OP ?t\"} = t\n      | term_of_tagged @{mpat \"ANNOT ?t _\"} = term_of_tagged t\n      | term_of_tagged @{mpat \"?f$?x\"} = term_of_tagged f $ term_of_tagged x\n      | term_of_tagged @{mpat \"PROTECT (\\<lambda>x. PROTECT ?t)\"} \n        = Abs (x,x_T,term_of_tagged t)\n      | term_of_tagged @{mpat (typs) \"PROTECT (PROTECT::?'v_T\\<Rightarrow>_)\"} \n        = Abs (\"x\",T,Bound 0)\n      | term_of_tagged t = raise TERM (\"term_of_tagged\",[t])\n\n    fun is_valid_tagged (Free _) = true\n      | is_valid_tagged (Var _) = true\n      | is_valid_tagged (Bound _) = true\n      | is_valid_tagged @{mpat \"OP _\"} = true\n      | is_valid_tagged @{mpat \"ANNOT ?t _\"} = is_valid_tagged t\n      | is_valid_tagged @{mpat \"?f$?x\"} \n        = is_valid_tagged f andalso is_valid_tagged x\n      | is_valid_tagged @{mpat \"PROTECT (\\<lambda>_. PROTECT ?t)\"} = is_valid_tagged t\n      | is_valid_tagged @{mpat \"PROTECT PROTECT\"} = true\n      | is_valid_tagged _ = false\n\n    fun mk_APP f x = let\n      val fT = fastype_of f\n      val xT = fastype_of x\n      val rT = range_type fT\n    in\n      Const (@{const_name APP},fT --> xT --> rT)$f$x\n    end;\n\n    fun mk_OP x = let \n      val T = fastype_of x \n    in \n      Const(@{const_name OP},T-->T)$x\n    end\n\n    fun lambda' (name,T) t = let\n      val tT = fastype_of t\n      val t' = Const (@{const_name PROTECT},tT --> tT)$\n        abstract_over (Free (name,T), t)\n      val t' = \n        Const (@{const_name PROTECT},(T --> tT) --> T --> tT)$Abs (name,T,t')\n    in\n      t'\n    end\n\n    val list_APP = Library.foldl (uncurry mk_APP)\n\n    (* f$x1$...$xn goes to (f,[x1,...,xn]*)\n    fun strip_app t = let\n      fun strip_app_aux @{mpat \"?f$?x\"} args = strip_app_aux f (x::args)\n        | strip_app_aux t args = (t,args)\n    in strip_app_aux t [] end\n      \n    fun untag_conv ctxt = Raw_Simplifier.rewrite ctxt\n      true (Autoref_Tag_Defs.get ctxt)\n\n    fun ABS_beta_conv ctxt = Raw_Simplifier.rewrite ctxt\n      true @{thms ABS_beta}\n  \n    val mk_PROTECT_conv = Conv.rewr_conv @{thm PROTECT_def[symmetric]}\n    val mk_APP_conv = Conv.rewr_conv @{thm APP_def[symmetric]}\n    val mk_OP_conv = Conv.rewr_conv @{thm OP_def[symmetric]}\n    fun mk_ABS_conv ctxt = Conv.abs_conv (K mk_PROTECT_conv) ctxt\n      then_conv mk_PROTECT_conv\n\n    fun mk_ANNOT_conv a ct = let\n      val Tt = Thm.ctyp_of_cterm ct\n\n      val thm = Thm.instantiate' [SOME Tt] [SOME ct,SOME a] \n        @{thm ANNOT_def[symmetric]}\n    in\n      thm\n    end\n\n    fun mk_rel_ANNOT_conv ctxt a ct = let\n      val T = Thm.typ_of_cterm a\n      val (Tc,Ta) = HOLogic.dest_setT T \n        |> HOLogic.dest_prodT \n        |> apply2 (Thm.ctyp_of ctxt)\n      val thm = Thm.instantiate' [SOME Ta, SOME Tc] [SOME ct,SOME a] \n        @{thm rel_ANNOT_eq}\n    in\n      thm\n    end\n\n    (* Convert right hand side of refinement statement *)\n    fun rhs_conv conv ctxt ct = let \n      open Conv Refine_Util \n    in\n      case Logic.strip_imp_concl (Thm.term_of ct) of\n        @{mpat \"Trueprop ((_,_)\\<in>_)\"} =>\n          HOL_concl_conv (fn ctxt => (arg1_conv (arg_conv (conv ctxt)))) ctxt ct\n      | _ => raise CTERM (\"rhs_conv\",[ct])\n    end\n  end\n\n\\<close>"], ["", "ML_val \\<open>\n  Autoref_Tagging.mk_ANNOT_conv @{cterm \"bar::annot\"} @{cterm \"foo::'a::type\"};\n\\<close>"], ["", "ML_val \\<open>\n  Autoref_Tagging.mk_rel_ANNOT_conv @{context}\n    @{cterm \"bar::('c\\<times>'a) set\"} @{cterm \"foo::'a::type\"}\n\\<close>"], ["", "end"]]}