{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Tool/Autoref_Id_Ops.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma ID_abs: \\<comment> \\<open>Tag abs first\\<close>\n  \"\\<lbrakk> \\<And>x. ID_OP x x I1 \\<Longrightarrow> ID_OP (f x) (f' x) I2 \\<rbrakk> \n  \\<Longrightarrow> ID_OP (\\<lambda>'x. f x) (\\<lambda>'x. f' x) (I1\\<rightarrow>\\<^sub>iI2)\"", "lemma ID_app: \\<comment> \\<open>Tag app first\\<close>\n  \"\\<lbrakk> INDEP I1; ID_OP x x' I1; ID_OP f f' (I1\\<rightarrow>\\<^sub>iI2) \\<rbrakk> \n  \\<Longrightarrow> ID_OP (f$x) (f'$x') I2\"", "lemma ID_const: \\<comment> \\<open>Only if c is constant or free variable\\<close>\n  \"\\<lbrakk> c ::\\<^sub>i I \\<rbrakk> \\<Longrightarrow> ID_OP c (OP c :::\\<^sub>i I) I\"", "lemma ID_const_any: \\<comment> \\<open>Only if no typing for constant exists\\<close>\n  \"ID_OP c (OP (ID_TAG c) :::\\<^sub>i I) I\"", "lemma ID_const_check_known: \n  \"\\<lbrakk> c ::\\<^sub>i I' \\<rbrakk> \\<Longrightarrow> ID_OP c c I\"", "lemma ID_tagged_OP: \\<comment> \\<open>Try first\\<close>\n  \"ID_OP (OP f :::\\<^sub>i I) (OP f :::\\<^sub>i I) I\"", "lemma ID_is_tagged_OP: \"ID_OP (OP c) t' I \\<Longrightarrow> ID_OP (OP c) t' I\"", "lemma ID_tagged_OP_no_annot:\n  \"c ::\\<^sub>i I \\<Longrightarrow> ID_OP (OP c) (OP c :::\\<^sub>i I) I\"", "lemmas ID_tagged = ID_tagged_OP ID_abs ID_app", "lemma ID_annotated: \\<comment> \\<open>Try second\\<close>\n  \"ID_OP t t' I \\<Longrightarrow> ID_OP (t :::\\<^sub>i I) t' I\"\n  \"ID_OP t t' I \\<Longrightarrow> ID_OP (ANNOT t A) (ANNOT t' A) I\"", "lemma ID_init:\n  assumes \"ID_OP a a' I\"\n  assumes \"(c,a')\\<in>R\"\n  shows \"(c,a)\\<in>R\"", "lemma itypeI: \"(c::'t) ::\\<^sub>i I\"", "lemma REL_INDIRECT: \"#name=R\"", "lemma CNV_ANNOT:\n  \"\\<And>f f' a a'. \\<lbrakk> CNV_ANNOT a a' Ra; CNV_ANNOT f f' (Ra\\<rightarrow>Rr) \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (f$a) (f'$a') (Rr)\"\n  \"\\<And>f f'. \\<lbrakk> \\<And>x. CNV_ANNOT x x Ra \\<Longrightarrow> CNV_ANNOT (f x) (f' x) Rr \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (\\<lambda>'x. f x) (\\<lambda>'x. f' x) (Ra\\<rightarrow>Rr)\"\n  \"\\<And>f f I R. \\<lbrakk>undefined (''Id tag not yet supported'',f)\\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (OP (ID_TAG f) :::\\<^sub>i I) f R\"\n  \"\\<And>f I R. \\<lbrakk> INDEP R; REL_OF_INTF I R \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (OP f :::\\<^sub>i I) (OP f ::: R) R\"\n  \"\\<And>t t' R. CNV_ANNOT t t' R \\<Longrightarrow> CNV_ANNOT (t ::: R) t' R\"\n  \"\\<And>t t' name R. \\<lbrakk> #name=R; CNV_ANNOT t t' R \\<rbrakk> \\<Longrightarrow> CNV_ANNOT (t ::#name) t' R\"", "lemma ROI_P_app: \\<comment> \\<open>Only if interface is really application\\<close>\n  \"REL_OF_INTF_P I R \\<Longrightarrow> REL_OF_INTF I R\"", "lemma ROI_app: \\<comment> \\<open>Only if interface is really application\\<close>\n  \"\\<lbrakk> REL_OF_INTF I R; REL_OF_INTF_P J S \\<rbrakk> \\<Longrightarrow> REL_OF_INTF_P (\\<langle>I\\<rangle>\\<^sub>iJ) (\\<langle>R\\<rangle>S)\"", "lemma ROI_i_of_rel:\n  \"REL_OF_INTF_P (i_of_rel S) S\"\n  \"REL_OF_INTF (i_of_rel R) R\"", "lemma ROI_const:\n  \"REL_OF_INTF_P J S\"\n  \"REL_OF_INTF I R\"", "lemma ROI_init:\n  assumes \"CNV_ANNOT a a' R\"\n  assumes \"(c,a')\\<in>R\"\n  shows \"(c,a)\\<in>R\"", "lemma REL_OF_INTF_I: \"REL_OF_INTF I R\""], "translations": [["", "lemma ID_abs: \\<comment> \\<open>Tag abs first\\<close>\n  \"\\<lbrakk> \\<And>x. ID_OP x x I1 \\<Longrightarrow> ID_OP (f x) (f' x) I2 \\<rbrakk> \n  \\<Longrightarrow> ID_OP (\\<lambda>'x. f x) (\\<lambda>'x. f' x) (I1\\<rightarrow>\\<^sub>iI2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        ID_OP x x I1 \\<Longrightarrow>\n        ID_OP (f x) (f' x) I2) \\<Longrightarrow>\n    ID_OP (\\<lambda>'x. f x) (\\<lambda>'x. f' x)\n     (I1 \\<rightarrow>\\<^sub>i I2)", "by simp"], ["", "lemma ID_app: \\<comment> \\<open>Tag app first\\<close>\n  \"\\<lbrakk> INDEP I1; ID_OP x x' I1; ID_OP f f' (I1\\<rightarrow>\\<^sub>iI2) \\<rbrakk> \n  \\<Longrightarrow> ID_OP (f$x) (f'$x') I2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>INDEP I1; ID_OP x x' I1;\n     ID_OP f f' (I1 \\<rightarrow>\\<^sub>i I2)\\<rbrakk>\n    \\<Longrightarrow> ID_OP (f $ x) (f' $ x') I2", "by simp"], ["", "lemma ID_const: \\<comment> \\<open>Only if c is constant or free variable\\<close>\n  \"\\<lbrakk> c ::\\<^sub>i I \\<rbrakk> \\<Longrightarrow> ID_OP c (OP c :::\\<^sub>i I) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I \\<Longrightarrow> ID_OP c (OP c :::\\<^sub>i I) I", "by simp"], ["", "definition [simp]: \"ID_TAG x \\<equiv> x\""], ["", "lemma ID_const_any: \\<comment> \\<open>Only if no typing for constant exists\\<close>\n  \"ID_OP c (OP (ID_TAG c) :::\\<^sub>i I) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID_OP c (OP (ID_TAG c) :::\\<^sub>i I) I", "by simp"], ["", "lemma ID_const_check_known: \n  \"\\<lbrakk> c ::\\<^sub>i I' \\<rbrakk> \\<Longrightarrow> ID_OP c c I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I' \\<Longrightarrow> ID_OP c c I", "by simp"], ["", "lemma ID_tagged_OP: \\<comment> \\<open>Try first\\<close>\n  \"ID_OP (OP f :::\\<^sub>i I) (OP f :::\\<^sub>i I) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID_OP (OP f :::\\<^sub>i I) (OP f :::\\<^sub>i I) I", "by simp"], ["", "lemma ID_is_tagged_OP: \"ID_OP (OP c) t' I \\<Longrightarrow> ID_OP (OP c) t' I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID_OP (OP c) t' I \\<Longrightarrow> ID_OP (OP c) t' I", "."], ["", "lemma ID_tagged_OP_no_annot:\n  \"c ::\\<^sub>i I \\<Longrightarrow> ID_OP (OP c) (OP c :::\\<^sub>i I) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I \\<Longrightarrow> ID_OP (OP c) (OP c :::\\<^sub>i I) I", "by simp"], ["", "lemmas ID_tagged = ID_tagged_OP ID_abs ID_app"], ["", "lemma ID_annotated: \\<comment> \\<open>Try second\\<close>\n  \"ID_OP t t' I \\<Longrightarrow> ID_OP (t :::\\<^sub>i I) t' I\"\n  \"ID_OP t t' I \\<Longrightarrow> ID_OP (ANNOT t A) (ANNOT t' A) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ID_OP t t' I \\<Longrightarrow> ID_OP (t :::\\<^sub>i I) t' I) &&&\n    (ID_OP t t' I \\<Longrightarrow> ID_OP (ANNOT t A) (ANNOT t' A) I)", "by simp_all"], ["", "lemma ID_init:\n  assumes \"ID_OP a a' I\"\n  assumes \"(c,a')\\<in>R\"\n  shows \"(c,a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  ID_OP a a' I\n  (c, a') \\<in> R\n\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "by auto"], ["", "lemma itypeI: \"(c::'t) ::\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I", "by simp"], ["", "consts depth_limit_dummy :: 'a"], ["", "notation (output) depth_limit_dummy (\"\\<dots>\")"], ["", "ML \\<open>\n  fun limit_depth _ (t as Const _) = t\n    | limit_depth _ (t as Var _) = t\n    | limit_depth _ (t as Free _) = t\n    | limit_depth _ (t as Bound _) = t\n    | limit_depth 0 t = Const (@{const_name depth_limit_dummy},fastype_of t)\n    | limit_depth i (t as _$_) = let\n        val (f,args) = strip_comb t\n        val f = limit_depth (i - 1) f\n        val args = map (limit_depth (i - 1)) args\n      in \n        list_comb (f,args)\n      end\n    | limit_depth i (Abs (x,T,t)) = Abs (x,T,limit_depth (i - 1) t)\n\n  fun depth_of (t as _$_) = let\n        val (f,args) = strip_comb t\n      in \n        Integer.max (depth_of f) (fold (Integer.max o depth_of) args 0) + 1\n      end\n    | depth_of (Abs (_,_,t)) = depth_of t + 1\n    | depth_of _ = 0\n\n  val depth_of_lhs = depth_of o Thm.term_of o Thm.lhs_of\n  val depth_of_rhs = depth_of o Thm.term_of o Thm.rhs_of\n\n  fun pretty_rewrite ctxt thm rthm = let\n    val lhsd = depth_of_lhs thm\n    val t = Thm.lhs_of rthm |> Thm.term_of |> limit_depth lhsd\n\n    val rhsd = depth_of_rhs thm\n    val t' = Thm.rhs_of rthm |> Thm.term_of |> limit_depth rhsd\n  in\n    Pretty.block [\n      Syntax.pretty_term ctxt t, \n      Pretty.brk 1, Pretty.str \"->\", Pretty.brk 1,\n      Syntax.pretty_term ctxt t'\n    ]\n  end\n\n\n\\<close>"], ["", "ML_val \\<open>\n  depth_of @{term \"f [1] [2] []\"};\n\n  limit_depth 2 @{term \"[1,2,3,4,5,6,7]\"}\n  |> Thm.cterm_of @{context}\n\n\\<close>"], ["", "ML \\<open>\n  fun index_rewr_thms thms = let\n    fun lhs thm = case Thm.concl_of thm of\n      @{mpat \"?lhs == _\"} => [lhs]\n    | _ => []\n\n    val net = Item_Net.init Thm.eq_thm_prop lhs\n    val net = fold_rev Item_Net.update thms net\n  in\n    net\n  end\n\n  fun net_rewr_tac net get_pat frame_conv ctxt = IF_EXGOAL (\n    fn i => fn st => let\n      val g = Logic.concl_of_goal (Thm.prop_of st) i |> get_pat\n      val thms = Item_Net.retrieve net g\n      val cnv = map \n        (fn thm => CONVERSION (frame_conv (Conv.rewr_conv thm) ctxt)) thms\n      |> APPEND_LIST'\n    in\n      cnv i st\n    end\n  )\n\n\\<close>"], ["", "ML \\<open>\n  signature AUTOREF_ID_OPS = sig\n    val id_tac: Proof.context -> tactic'\n\n    val id_phase: Autoref_Phases.phase\n\n    val mk_const_intf: term -> term -> term\n    val mk_const_intf_thm: Proof.context -> term -> term -> thm\n\n    val dest_const_intf: term -> term * term\n    val dest_const_intf_thm: thm -> term * term\n\n    val cfg_trace_intf_unif: bool Config.T\n    val cfg_trace_failed_id: bool Config.T\n    val cfg_ss_id_op: bool Config.T\n    val cfg_trace_patterns: bool Config.T\n    val cfg_use_id_tags: bool Config.T\n    val cfg_trace_id_tags: bool Config.T\n\n    val typ_thms_of_seq: Proof.context -> term -> thm Seq.seq\n    val has_typ_thms: Proof.context -> term -> bool\n\n    val decl_derived_typing: bool -> term -> term \n      -> Context.generic -> Context.generic\n\n    val setup: theory -> theory\n  end\n  \n\n  structure Autoref_Id_Ops :AUTOREF_ID_OPS = struct\n    open Refine_Util Autoref_Tagging\n\n\n    fun mk_const_intf c I = let\n      val Tc = fastype_of c\n      val T = Tc --> @{typ interface} --> @{typ bool}\n    in \n      Const (@{const_name CONST_INTF},T)$c$I\n    end\n\n    fun mk_const_intf_thm ctxt f I = let\n      val fT = fastype_of f |> Thm.ctyp_of ctxt\n      val f = Thm.cterm_of ctxt f\n      val I = Thm.cterm_of ctxt I\n      val thm = Thm.instantiate' [SOME fT] [SOME f, SOME I] @{thm itypeI}\n    in\n      thm\n    end\n\n    fun dest_const_intf @{mpat \"?c::\\<^sub>i?I\"} = (c,I)\n      | dest_const_intf t = raise TERM (\"dest_const_intf\",[t])\n\n    val dest_const_intf_thm = Thm.concl_of \n      #> HOLogic.dest_Trueprop \n      #> dest_const_intf\n\n    fun LHS_COND' P = CONCL_COND'\n      (fn @{mpat \"Trueprop (ID_OP ?lhs _ _)\"} => P lhs | _ => false)\n    \n    local open Conv in\n      fun id_op_lhs_conv cnv ct = case Thm.term_of ct of\n        @{mpat \"ID_OP _ _ _\"} => (fun_conv (fun_conv (arg_conv cnv))) ct\n      | _ => raise CTERM (\"id_op_lhs_conv\",[ct])\n    end\n\n    structure intf_types = Named_Thms (\n      val name = @{binding autoref_itype}\n      val description = \"Interface type declaration\"\n    )\n\n    structure op_patterns = Named_Thms (\n      val name = @{binding autoref_op_pat}\n      val description = \"Operation patterns\"\n    )\n\n    structure op_patterns_def = Named_Thms (\n      val name = @{binding autoref_op_pat_def}\n      val description = \"Definitive operation patterns\"\n    )\n\n    val cfg_trace_intf_unif = \n      Attrib.setup_config_bool @{binding autoref_trace_intf_unif} (K false)\n\n    val cfg_trace_failed_id = \n      Attrib.setup_config_bool @{binding autoref_trace_failed_id} (K false)\n\n    val cfg_ss_id_op = \n      Attrib.setup_config_bool @{binding autoref_ss_id_op} (K false)\n\n    val cfg_trace_patterns = \n      Attrib.setup_config_bool @{binding autoref_trace_pat} (K false)\n\n    val cfg_use_id_tags = \n      Attrib.setup_config_bool @{binding autoref_use_id_tags} (K false)\n\n    val cfg_trace_id_tags = \n      Attrib.setup_config_bool @{binding autoref_trace_id_tags} (K false)\n\n    fun get_typ_net ctxt = let\n      val thy = Proof_Context.theory_of ctxt\n      val typ_net = intf_types.get ctxt\n        |> Refine_Util.subsume_sort Thm.concl_of thy\n        |> Tactic.build_net\n    in typ_net end\n\n    fun typ_thms_of_seq' ctxt typ_net c = let\n      val idx = Term.maxidx_of_term c + 1\n      val typ_thms = mk_const_intf c (Var ((\"I\",idx),@{typ interface}))\n        |> HOLogic.mk_Trueprop\n        |> Thm.cterm_of ctxt\n        |> Goal.init\n        |> resolve_from_net_tac ctxt typ_net 1\n        |> Seq.map Goal.conclude\n    in typ_thms end\n\n    fun typ_thms_of_seq ctxt = typ_thms_of_seq' ctxt (get_typ_net ctxt)\n\n    fun has_typ_thms' thy typ_net = \n      typ_thms_of_seq' thy typ_net #> Seq.pull #> is_some\n    fun has_typ_thms ctxt = has_typ_thms' ctxt (get_typ_net ctxt)\n  \n    fun id_tac ctxt = let\n      val thy = Proof_Context.theory_of ctxt\n\n      val typ_net = get_typ_net ctxt\n      val typ_thms_seq_of = typ_thms_of_seq' ctxt typ_net\n      val typ_thms_of = typ_thms_seq_of #> Seq.list_of\n\n      fun pretty_typ_thms l = \n        l\n        |> map (Thm.pretty_thm ctxt)\n        |> Pretty.fbreaks |> Pretty.block\n\n\n      val tr_iu = \n        if Config.get ctxt cfg_trace_intf_unif then\n          fn i => fn st => ((\n            case Logic.concl_of_goal (Thm.prop_of st) i of\n              (t as @{mpat \"Trueprop (?c::\\<^sub>i_)\"}) => ( case typ_thms_of c of\n                [] => ()\n              | tts => Pretty.block [\n                  Pretty.block [\n                    Pretty.str \"Interface unification failed:\",\n                    Pretty.brk 1,\n                    Syntax.pretty_term ctxt t\n                  ], \n                  Pretty.fbrk,\n                  Pretty.str \"  \",\n                  Pretty.block [\n                    Pretty.str \"Candidates: \", \n                    Pretty.fbrk,\n                    pretty_typ_thms tts\n                  ]\n                ]\n                |> Pretty.string_of |> tracing\n              )\n            | _ => ()\n          ); Seq.empty)\n        else K no_tac\n\n      val id_typ = \n        resolve_from_net_tac ctxt typ_net\n        ORELSE' tr_iu\n\n      val pat_net = op_patterns.get ctxt \n        |> Refine_Util.subsume_sort (Thm.concl_of #> Logic.dest_equals #> #1) thy\n        |> index_rewr_thms\n\n      val def_pat_net = op_patterns_def.get ctxt\n        |> Refine_Util.subsume_sort (Thm.concl_of #> Logic.dest_equals #> #1) thy\n        |> index_rewr_thms\n\n      val id_abs = CONVERSION (HOL_concl_conv \n        (fn ctxt => id_op_lhs_conv (mk_ABS_conv ctxt)) ctxt)\n        THEN' resolve_tac ctxt @{thms ID_abs}\n      val id_app = CONVERSION (HOL_concl_conv \n        (fn _ => id_op_lhs_conv (mk_APP_conv)) ctxt)\n        THEN' resolve_tac ctxt @{thms ID_app}\n\n      val id_tag_tac = let\n        val trace = Config.get ctxt cfg_trace_id_tags\n      in \n        if trace then IF_EXGOAL (fn i => fn st => let\n            fun tr_tac _ st' = let\n              val goal = Logic.get_goal (Thm.prop_of st) i\n              val concl = Logic.concl_of_goal (Thm.prop_of st) i\n              val _ = case concl of\n                  @{mpat \"Trueprop (ID_OP ?lhs _ _)\"} =>\n                    tracing (\"ID_TAG: \" ^ @{make_string} lhs) \n                | _ => tracing \"ID_TAG: LHS???\"\n\n              val _ = Pretty.block [\n                Pretty.str \"ID_TAG: \", Pretty.brk 1,\n                Syntax.pretty_term ctxt goal\n              ] |> Pretty.string_of |> tracing\n            in \n              Seq.single st'\n            end\n          in\n            (resolve_tac ctxt @{thms ID_const_any} THEN' tr_tac) i st\n          end) \n        else\n          resolve_tac ctxt @{thms ID_const_any}\n\n      end\n\n      val id_const = \n        LHS_COND' (fn t => is_Const t orelse is_Free t)\n        THEN' (\n          (resolve_tac ctxt @{thms ID_const} THEN' id_typ) (* Try to find type *)\n          ORELSE' (\n            if Config.get ctxt cfg_use_id_tags then\n              CAN' (resolve_tac ctxt @{thms ID_const_check_known} THEN' id_typ)\n              THEN_ELSE' (\n                K no_tac,\n                id_tag_tac\n              )\n            else K no_tac\n          )\n        )\n  \n      val id_tagged = resolve_tac ctxt @{thms ID_tagged}\n\n      val id_annotated = resolve_tac ctxt @{thms ID_annotated}\n\n      (*\n      val traced_rewr_conv = if Config.get ctxt cfg_trace_patterns then\n        fn ctxt => fn thm => fn ct => let\n          val rthm = Conv.rewr_conv thm ct\n          val _ = Pretty.block [\n            Pretty.str \"Trying (-pat:)\", Pretty.brk 1, \n            pretty_rewrite ctxt thm rthm\n          ] |> Pretty.string_of |> tracing\n        in\n          rthm\n        end\n      else\n        K Conv.rewr_conv\n      *)\n\n      fun get_rewr_pat @{mpat \"Trueprop (ID_OP ?lhs _ _)\"} = lhs\n        | get_rewr_pat t = t\n      \n      fun rewr_frame_conv conv = HOL_concl_conv (fn _ => id_op_lhs_conv conv)\n\n      val def_id_pat = \n        DETERM o net_rewr_tac def_pat_net get_rewr_pat rewr_frame_conv ctxt\n  \n      val id_pat = \n        net_rewr_tac pat_net get_rewr_pat rewr_frame_conv ctxt\n  \n      val id_dflt = FIRST' [id_app,id_const,id_abs]\n    \n      val id_fail = if Config.get ctxt cfg_trace_failed_id then\n        IF_EXGOAL (fn i => fn st => \n          let \n            val pat = Logic.concl_of_goal (Thm.prop_of st) i\n                  |> get_rewr_pat\n            val _ = Pretty.block [ \n                Pretty.str \"Failed to identify: \",\n                Syntax.pretty_term ctxt pat\n              ]\n            |> Pretty.string_of |> tracing\n          in\n            Seq.empty\n          end\n        ) \n      else K no_tac\n\n      val ss = Config.get ctxt cfg_ss_id_op\n      val step_tac = \n        FIRST' [\n          assume_tac ctxt,\n          id_tagged,\n          resolve_tac ctxt @{thms ID_is_tagged_OP} THEN_ELSE' (\n            resolve_tac ctxt @{thms ID_tagged_OP_no_annot} THEN' id_typ,\n            FIRST' [\n              Indep_Vars.indep_tac ctxt,\n              id_annotated,\n              def_id_pat,\n              id_pat APPEND' id_dflt,\n              id_fail\n            ]\n          )\n        ] \n\n      fun rec_tac i st = (\n        step_tac THEN_ALL_NEW_FWD (if ss then K all_tac else rec_tac)\n      ) i st\n\n    in\n      rec_tac\n    end\n\n    fun id_analyze _ i j _ = (i = j)\n    fun id_pretty_failure _ i j _ = \n      if i = j then\n        Pretty.str \"No failure\"\n      else \n        Pretty.str \"Interface typing error. Enable tracing for more information\"\n\n\n    val id_phase = {\n      init = I,\n      tac = (fn ctxt => Seq.INTERVAL (resolve_tac ctxt @{thms ID_init} THEN' id_tac ctxt)),\n      analyze = id_analyze,\n      pretty_failure = id_pretty_failure\n    }\n\n\n    fun decl_derived_typing overl c I context = let\n      val ctxt = Context.proof_of context\n\n      val typ_thms = intf_types.get ctxt \n        (* TODO: Use net cached in ctxt here! *)\n\n      val thm = mk_const_intf_thm ctxt c I\n\n      val st = Thm.cprop_of thm |> Goal.init\n      val has_t = SOLVED' (match_tac ctxt typ_thms) 1 st |> Seq.pull |> is_some\n    in\n      if has_t then context\n      else (\n        not overl andalso has_typ_thms ctxt c andalso (warning (\n          Pretty.block [\n            Pretty.str \"Adding overloaded interface type to constant:\",\n            Pretty.brk 1,\n            Thm.pretty_thm ctxt thm\n          ] |> Pretty.string_of\n        ); true);\n        intf_types.add_thm thm context \n      )\n    end\n\n    val setup = I\n      #> intf_types.setup\n      #> op_patterns.setup\n      #> op_patterns_def.setup\n\n  end\n\n\n\\<close>"], ["", "setup Autoref_Id_Ops.setup"], ["", "definition IND_FACT :: \"rel_name \\<Rightarrow> ('c \\<times> 'a) set \\<Rightarrow> bool\" (\"#_=_\" 10)\n  where [simp]: \"#name=R \\<equiv> True\""], ["", "lemma REL_INDIRECT: \"#name=R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #name=R", "by simp"], ["", "definition CNV_ANNOT :: \"'a \\<Rightarrow> 'a \\<Rightarrow> (_\\<times>'a) set \\<Rightarrow> bool\"\n  where [simp]: \"CNV_ANNOT t t' R \\<equiv> t=t'\""], ["", "definition REL_OF_INTF :: \"interface \\<Rightarrow> ('c\\<times>'a) set \\<Rightarrow> bool\" \n  where [simp]: \"REL_OF_INTF I R \\<equiv> True\""], ["", "definition \n  [simp]: \"REL_OF_INTF_P I R \\<equiv> True\" \\<comment> \\<open>Version to resolve relator arguments\\<close>"], ["", "lemma CNV_ANNOT:\n  \"\\<And>f f' a a'. \\<lbrakk> CNV_ANNOT a a' Ra; CNV_ANNOT f f' (Ra\\<rightarrow>Rr) \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (f$a) (f'$a') (Rr)\"\n  \"\\<And>f f'. \\<lbrakk> \\<And>x. CNV_ANNOT x x Ra \\<Longrightarrow> CNV_ANNOT (f x) (f' x) Rr \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (\\<lambda>'x. f x) (\\<lambda>'x. f' x) (Ra\\<rightarrow>Rr)\"\n  \"\\<And>f f I R. \\<lbrakk>undefined (''Id tag not yet supported'',f)\\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (OP (ID_TAG f) :::\\<^sub>i I) f R\"\n  \"\\<And>f I R. \\<lbrakk> INDEP R; REL_OF_INTF I R \\<rbrakk> \n    \\<Longrightarrow> CNV_ANNOT (OP f :::\\<^sub>i I) (OP f ::: R) R\"\n  \"\\<And>t t' R. CNV_ANNOT t t' R \\<Longrightarrow> CNV_ANNOT (t ::: R) t' R\"\n  \"\\<And>t t' name R. \\<lbrakk> #name=R; CNV_ANNOT t t' R \\<rbrakk> \\<Longrightarrow> CNV_ANNOT (t ::#name) t' R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>f f' a a'.\n         \\<lbrakk>CNV_ANNOT a a' Ra;\n          CNV_ANNOT f f' (Ra \\<rightarrow> Rr)\\<rbrakk>\n         \\<Longrightarrow> CNV_ANNOT (f $ a) (f' $ a') Rr) &&&\n     (\\<And>f f'.\n         (\\<And>x.\n             CNV_ANNOT x x Ra \\<Longrightarrow>\n             CNV_ANNOT (f x) (f' x) Rr) \\<Longrightarrow>\n         CNV_ANNOT (\\<lambda>'x. f x) (\\<lambda>'x. f' x)\n          (Ra \\<rightarrow> Rr)) &&&\n     (\\<And>f fa I R.\n         undefined (''Id tag not yet supported'', fa) \\<Longrightarrow>\n         CNV_ANNOT (OP (ID_TAG fa) :::\\<^sub>i I) fa R)) &&&\n    (\\<And>f I R.\n        \\<lbrakk>INDEP R; REL_OF_INTF I R\\<rbrakk>\n        \\<Longrightarrow> CNV_ANNOT (OP f :::\\<^sub>i I) (OP f ::: R) R) &&&\n    (\\<And>t t' R.\n        CNV_ANNOT t t' R \\<Longrightarrow> CNV_ANNOT (t ::: R) t' R) &&&\n    (\\<And>t t' name R.\n        \\<lbrakk>#name=R; CNV_ANNOT t t' R\\<rbrakk>\n        \\<Longrightarrow> CNV_ANNOT (t ::# name) t' R)", "by simp_all"], ["", "consts i_of_rel :: \"'a \\<Rightarrow> 'b\""], ["", "lemma ROI_P_app: \\<comment> \\<open>Only if interface is really application\\<close>\n  \"REL_OF_INTF_P I R \\<Longrightarrow> REL_OF_INTF I R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_OF_INTF_P I R \\<Longrightarrow> REL_OF_INTF I R", "by auto"], ["", "lemma ROI_app: \\<comment> \\<open>Only if interface is really application\\<close>\n  \"\\<lbrakk> REL_OF_INTF I R; REL_OF_INTF_P J S \\<rbrakk> \\<Longrightarrow> REL_OF_INTF_P (\\<langle>I\\<rangle>\\<^sub>iJ) (\\<langle>R\\<rangle>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>REL_OF_INTF I R; REL_OF_INTF_P J S\\<rbrakk>\n    \\<Longrightarrow> REL_OF_INTF_P (\\<langle>I\\<rangle>\\<^sub>iJ)\n                       (\\<langle>R\\<rangle>S)", "by auto"], ["", "lemma ROI_i_of_rel:\n  \"REL_OF_INTF_P (i_of_rel S) S\"\n  \"REL_OF_INTF (i_of_rel R) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_OF_INTF_P (i_of_rel S) S &&& REL_OF_INTF (i_of_rel R) R", "by auto"], ["", "lemma ROI_const:\n  \"REL_OF_INTF_P J S\"\n  \"REL_OF_INTF I R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_OF_INTF_P J S &&& REL_OF_INTF I R", "by auto"], ["", "lemma ROI_init:\n  assumes \"CNV_ANNOT a a' R\"\n  assumes \"(c,a')\\<in>R\"\n  shows \"(c,a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  CNV_ANNOT a a' R\n  (c, a') \\<in> R\n\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "by simp"], ["", "lemma REL_OF_INTF_I: \"REL_OF_INTF I R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_OF_INTF I R", "by simp"], ["", "ML \\<open>\nsignature AUTOREF_REL_INF = sig\n  val roi_tac: Proof.context -> tactic'\n  val roi_step_tac: Proof.context -> tactic'\n  val roi_phase: Autoref_Phases.phase\n  val cfg_sbias: int Config.T\n\n  val setup: theory -> theory\nend\n\nstructure Autoref_Rel_Inf :AUTOREF_REL_INF = struct\n\n  val cfg_sbias = \n    Attrib.setup_config_int @{binding autoref_sbias} (K 100)\n\n\n  structure rel_indirect = Named_Thms (\n    val name = @{binding autoref_rel_indirect}\n    val description = \"Indirect relator bindings\"\n  )\n\n  fun rel_of_intf_thm ctxt I = let\n    fun \n      roi (Free (n,_)) ctxt = let \n        val (Rn,ctxt) = yield_singleton Variable.variant_fixes (\"R_\" ^ n) ctxt\n      in (Free (Rn,dummyT),ctxt) end\n    | roi (Const (n,_)) ctxt = let \n        val n = Long_Name.base_name n\n        val (Rn,ctxt) = yield_singleton Variable.variant_fixes (\"R_\" ^ n) ctxt\n      in (Free (Rn,dummyT),ctxt) end\n    | roi @{mpat \"\\<langle>?Ia\\<rangle>\\<^sub>i?Ib\"} ctxt = let\n        val (Ra,ctxt) = roi Ia ctxt\n        val (Rb,ctxt) = roi Ib ctxt\n      in \n        (Const (@{const_name relAPP},dummyT)$Rb$Ra,ctxt)\n      end\n    | roi @{mpat \"i_of_rel ?R\"} ctxt = (R,ctxt)\n    | roi t _ = raise TERM (\"rel_of_intf: Unexpected interface\", [t])\n\n    val orig_ctxt = ctxt\n    val (I,ctxt) = yield_singleton (Variable.import_terms true) I ctxt\n    val (R,ctxt) = roi I ctxt\n    val res = Const (@{const_name REL_OF_INTF},dummyT)$I$R\n    val res = Syntax.check_term ctxt res\n    val res = singleton (Variable.export_terms ctxt orig_ctxt) res\n      |> HOLogic.mk_Trueprop\n      |> Thm.cterm_of ctxt\n\n    val thm = Goal.prove_internal ctxt [] res (fn _ => resolve_tac ctxt @{thms REL_OF_INTF_I} 1)\n  in thm end\n\n\n  fun roi_step_tac ctxt = let\n    val ind_net = rel_indirect.get ctxt |> Tactic.build_net\n  in\n    IF_EXGOAL (\n      assume_tac ctxt\n      ORELSE'\n      Indep_Vars.indep_tac ctxt\n      ORELSE' resolve_from_net_tac ctxt ind_net\n      ORELSE'\n      (fn i => fn st => \n        case Logic.concl_of_goal (Thm.prop_of st) i of\n          @{mpat \"Trueprop (CNV_ANNOT _ _ _)\"} => \n            resolve_tac ctxt @{thms CNV_ANNOT} i st\n        | @{mpat \"Trueprop (REL_OF_INTF ?I _)\"} => \n            resolve_tac ctxt [rel_of_intf_thm ctxt I] i st\n        | _ => Seq.empty\n      \n\n      (*\n        | @{mpat \"Trueprop (REL_OF_INTF (\\<langle>_\\<rangle>\\<^sub>i_) _)\"} => \n            rtac @{thm ROI_P_app} i st\n        | @{mpat \"Trueprop (REL_OF_INTF_P (\\<langle>_\\<rangle>\\<^sub>i_) _)\"} => \n            rtac @{thm ROI_app} i st\n        | @{mpat \"Trueprop (REL_OF_INTF_P (i_of_rel _) _)\"} => \n            resolve_tac ctxt @{thms ROI_i_of_rel} i st\n        | @{mpat \"Trueprop (REL_OF_INTF (i_of_rel _) _)\"} => \n            resolve_tac ctxt @{thms ROI_i_of_rel} i st\n        | _ => resolve_tac ctxt @{thms ROI_const} i st\n      *)\n      )\n    )\n  end\n\n  fun roi_tac ctxt = \n    REPEAT_ALL_NEW_FWD (DETERM o roi_step_tac ctxt)\n\n  fun roi_analyze _ i j _ = (i = j)\n  fun roi_pretty_failure _ i j _ = \n    if i = j then\n      Pretty.str \"No failure\"\n    else \n      Pretty.str \"Relator inference error\"\n\n  val roi_phase = {\n    init = I,\n    tac = (fn ctxt => Seq.INTERVAL (resolve_tac ctxt @{thms ROI_init} THEN' roi_tac ctxt)),\n    analyze = roi_analyze,\n    pretty_failure = roi_pretty_failure\n  }\n\n  val setup = rel_indirect.setup\n\nend\n\\<close>"], ["", "setup Autoref_Rel_Inf.setup"], ["", "end"]]}