{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Lib/Select_Solve.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma retrofit_with_prems:\n  fixes P Q R TAG :: \"prop\"\n  assumes 1: \"PROP P ==> PROP Q\" (* Original goal state *)\n  assumes 2: \"PROP R ==> PROP TAG &&& PROP P\" (* Result of first subgoal *)\n  shows \"PROP R ==> PROP Q\"", "lemma retrofit_no_prems:\n  fixes P Q TAG :: \"prop\"\n  assumes 1: \"PROP P ==> PROP Q\" (* Original goal state *)\n  assumes 2: \"PROP TAG &&& PROP P\" (* Result of first subgoal *)\n  shows \"PROP Q\""], "translations": [["", "lemma retrofit_with_prems:\n  fixes P Q R TAG :: \"prop\"\n  assumes 1: \"PROP P ==> PROP Q\" (* Original goal state *)\n  assumes 2: \"PROP R ==> PROP TAG &&& PROP P\" (* Result of first subgoal *)\n  shows \"PROP R ==> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP R \\<Longrightarrow> PROP Q", "(* New goal state with &&&*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP R \\<Longrightarrow> PROP Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. PROP R \\<Longrightarrow> PROP Q", "assume \"PROP R\""], ["proof (state)\nthis:\n  PROP R\n\ngoal (1 subgoal):\n 1. PROP R \\<Longrightarrow> PROP Q", "from this[THEN 2, THEN conjunctionD2]"], ["proof (chain)\npicking this:\n  PROP P", "have \"PROP P\""], ["proof (prove)\nusing this:\n  PROP P\n\ngoal (1 subgoal):\n 1. PROP P", "."], ["proof (state)\nthis:\n  PROP P\n\ngoal (1 subgoal):\n 1. PROP R \\<Longrightarrow> PROP Q", "with 1"], ["proof (chain)\npicking this:\n  PROP P \\<Longrightarrow> PROP Q\n  PROP P", "show \"PROP Q\""], ["proof (prove)\nusing this:\n  PROP P \\<Longrightarrow> PROP Q\n  PROP P\n\ngoal (1 subgoal):\n 1. PROP Q", "."], ["proof (state)\nthis:\n  PROP Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma retrofit_no_prems:\n  fixes P Q TAG :: \"prop\"\n  assumes 1: \"PROP P ==> PROP Q\" (* Original goal state *)\n  assumes 2: \"PROP TAG &&& PROP P\" (* Result of first subgoal *)\n  shows \"PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP Q", "(* New goal state *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. PROP Q", "from 2"], ["proof (chain)\npicking this:\n  PROP TAG &&& PROP P", "have \"PROP P\""], ["proof (prove)\nusing this:\n  PROP TAG &&& PROP P\n\ngoal (1 subgoal):\n 1. PROP P", "by (rule conjunctionD2)"], ["proof (state)\nthis:\n  PROP P\n\ngoal (1 subgoal):\n 1. PROP Q", "thus \"PROP Q\""], ["proof (prove)\nusing this:\n  PROP P\n\ngoal (1 subgoal):\n 1. PROP Q", "by (rule 1)"], ["proof (state)\nthis:\n  PROP Q\n\ngoal:\nNo subgoals!", "qed"], ["", "consts NO_TAG :: \"prop\""], ["", "ML \\<open>\nsignature SELECT_SOLVE = sig\n  val PREFER_SOLVED: tactic -> tactic\n  val IF_SUBGOAL_SOLVED: tactic -> tactic -> tactic -> tactic\n  val TRY_SOLVE_FWD: int -> tactic -> tactic\n  val SELECT_FIRST: Proof.context -> tactic -> tactic\n  val AS_FIRSTGOAL: tactic -> tactic'\n  val REPEAT_SOLVE_FWD_SELECT: Proof.context -> int -> tactic' -> tactic' \nend\n\nstructure Select_Solve :SELECT_SOLVE = struct\n  fun PREFER_SOLVED tac st = let\n    val n = Thm.nprems_of st\n    val res = tac st\n    (*val res' = Seq.append \n      (Seq.filter (has_fewer_prems n) res)\n      (Seq.filter (not o has_fewer_prems n) res)*)\n\n    val res' = Seq.filter (has_fewer_prems n) res\n  in\n    res'\n  end\n\n  fun IF_SUBGOAL_SOLVED tac1 then_tac else_tac st = let\n    val n = Thm.nprems_of st\n  in\n    (tac1 THEN COND (has_fewer_prems n) then_tac else_tac) st\n  end\n\n  fun TRY_SOLVE_FWD i tac st = \n    if i <= 0 then \n      Seq.single st \n    else\n      IF_UNSOLVED (\n        IF_SUBGOAL_SOLVED tac (TRY_SOLVE_FWD (i-1) tac) all_tac\n      ) st\n\n  fun TRY_SOLVE_ALL_NEW_FWD tac1 tac2 tac3 st = let\n    val n = Thm.nprems_of st\n  in \n    (\n      tac1 THEN_ELSE \n        ( fn st' => let val n' = Thm.nprems_of st' in TRY_SOLVE_FWD (n' - n + 1) tac2 st' end,\n          tac3)\n    ) st \n  end\n\n\n  fun SELECT_FIRST ctxt tac st = if Thm.nprems_of st < 2 then tac st\n  else let\n    (*val _ = print_tac \"Focusing\" st*)\n\n    (* Extract first subgoal *)\n    val (P,Q) = Thm.dest_implies (Thm.cprop_of st)\n\n    (*val _ = \"Extracted: \" ^ @{make_string} P |> tracing*)\n\n    (* Prepare tag *)\n    local \n      fun intr_bal [] = @{thm \\<open>TERM NO_TAG\\<close>}\n        | intr_bal l = Conjunction.intr_balanced l\n\n      val t = Thm.term_of P \n\n      val vars = Term.add_vars t []\n      val tvars = Term.add_tvars t []\n      val vtvars = fold (Term.add_tvarsT o #2) vars []\n      val tvars = subtract (op =) vtvars tvars\n\n      val tvars_tag = tvars\n        |> map (Drule.mk_term o Thm.cterm_of ctxt o Logic.mk_type o TVar)\n        |> intr_bal\n\n      val vars_tag = vars\n        |> map (Drule.mk_term o Thm.cterm_of ctxt o Var)\n        |> intr_bal\n    in\n      val tag_thm = Conjunction.intr tvars_tag vars_tag\n    end\n\n    val TAG = Thm.cprop_of tag_thm\n\n    (* Prepare new proof state *)\n    val st' = Conjunction.mk_conjunction (TAG, P)\n      |> Goal.init\n      |> Conjunction.curry_balanced 2\n      |> Thm.elim_implies tag_thm\n\n    (*val _ = \"New proof state: \" ^ @{make_string} st' |> tracing*)\n\n    (*val _ = print_tac \"New state\" st'*)\n\n    (* Apply proof *)\n    val seq = tac st'\n\n    fun elim_implies thA thAB = \n      case try Thm.dest_implies (Thm.cprop_of thAB) of \n        SOME (A,_) => (\n          A aconvc Thm.cprop_of thA\n            orelse (\n              (*tracing (@{make_string} (term_of A));\n              tracing (@{make_string} (prop_of thA));*)\n              raise CTERM (\"implies_elim: No aconv\",[A,Thm.cprop_of thA])\n            );\n          Thm.elim_implies thA thAB\n        )\n    | _ => raise THM (\"implies_elim: No impl\",0,[thAB,thA])\n\n    fun retrofit st' = let\n      val st' = Drule.incr_indexes st st'\n      val n = Thm.nprems_of st'\n      val thm = Conjunction.uncurry_balanced n st'\n        |> Goal.conclude\n        |> Conv.fconv_rule (Thm.beta_conversion true)\n      (*val _ = \"Proved: \" ^ @{make_string} thm |> tracing*)\n    in\n      if n=0 then \n        let\n          val (TAG',_) = Conjunction.dest_conjunction (Thm.cprop_of thm)\n          val inst = Thm.match (TAG, TAG')\n          val st = Thm.instantiate inst st \n            |> Conv.fconv_rule (Thm.beta_conversion true)\n          val P = Thm.instantiate_cterm inst P\n          val Q = Thm.instantiate_cterm inst Q\n        in\n          @{thm retrofit_no_prems}\n          |> Thm.instantiate' [] [SOME P, SOME Q, SOME TAG'] \n          |> Conv.fconv_rule (Thm.beta_conversion true)\n          |> elim_implies st\n          |> elim_implies thm\n        end\n      else \n        let\n          val (R,TP') = Thm.dest_implies (Thm.cprop_of thm)\n          val (TAG',_) = Conjunction.dest_conjunction TP'\n          val inst = Thm.match (TAG, TAG')\n          val st = Thm.instantiate inst st\n            |> Conv.fconv_rule (Thm.beta_conversion true)\n          val P = Thm.instantiate_cterm inst P\n          val Q = Thm.instantiate_cterm inst Q\n        in \n          @{thm retrofit_with_prems}\n          |> Thm.instantiate' [] [SOME P, SOME Q, SOME R, SOME TAG']\n          |> Conv.fconv_rule (Thm.beta_conversion true)\n          |> elim_implies st\n          |> elim_implies thm\n          |> Conjunction.curry_balanced n\n        end\n    end\n\n  in\n    Seq.map retrofit seq\n  end\n\n  fun AS_FIRSTGOAL tac i st = \n    if i <= Thm.nprems_of st then\n      (PRIMITIVE (Thm.permute_prems 0 (i-1)) \n      THEN tac \n      THEN PRIMITIVE (Thm.permute_prems 0 (1-i))) st\n    else Seq.empty\n\n  fun REPEAT_SOLVE_FWD_SELECT ctxt bias tac = let\n    fun BIASED_SELECT tac st = \n      if Thm.nprems_of st < 2 then tac st\n      else let\n        val s = Drule.size_of_thm st\n        (*val _ = if s>100 then string_of_int s |> tracing else ()*)\n      in\n        if s < bias then \n          tac st \n        else let\n          val s1 = Logic.dest_implies (Thm.prop_of st) |> #1 |> size_of_term\n        in\n          if 5 * s1 < 2 * s then\n            SELECT_FIRST ctxt tac st\n          else tac st\n        end\n      end\n\n\n    fun sg_rec st = IF_UNSOLVED (BIASED_SELECT (\n        PREFER_SOLVED (\n          TRY_SOLVE_ALL_NEW_FWD (tac 1) sg_rec all_tac\n        )\n      )) st\n\n  in\n    AS_FIRSTGOAL sg_rec\n  end\nend\n\n\\<close>"], ["", "end"]]}