{"file_name": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement/Parametricity/Relators.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Automatic_Refinement", "problem_names": ["lemma fun_rel_def[refine_rel_defs]: \n  \"A\\<rightarrow>B \\<equiv> { (f,f'). \\<forall>(a,a')\\<in>A. (f a, f' a')\\<in>B }\"", "lemma fun_relI[intro!]: \"\\<lbrakk>\\<And>a a'. (a,a')\\<in>A \\<Longrightarrow> (f a,f' a')\\<in>B\\<rbrakk> \\<Longrightarrow> (f,f')\\<in>A\\<rightarrow>B\"", "lemma fun_relD: \n  shows \" ((f,f')\\<in>(A\\<rightarrow>B)) \\<Longrightarrow> \n  (\\<And>x x'. \\<lbrakk> (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x, f' x')\\<in>B)\"", "lemma fun_relD1:\n  assumes \"(f,f')\\<in>Ra\\<rightarrow>Rr\"\n  assumes \"f x = r\"\n  shows \"\\<forall>x'. (x,x')\\<in>Ra \\<longrightarrow> (r,f' x')\\<in>Rr\"", "lemma fun_relD2:\n  assumes \"(f,f')\\<in>Ra\\<rightarrow>Rr\"\n  assumes \"f' x' = r'\"\n  shows \"\\<forall>x. (x,x')\\<in>Ra \\<longrightarrow> (f x,r')\\<in>Rr\"", "lemma fun_relE1:\n  assumes \"(f,f')\\<in>Id \\<rightarrow> Rv\"\n  assumes \"t' = f' x\"\n  shows \"(f x,t')\\<in>Rv\"", "lemma fun_relE2:\n  assumes \"(f,f')\\<in>Id \\<rightarrow> Rv\"\n  assumes \"t = f x\"\n  shows \"(t,f' x)\\<in>Rv\"", "lemma prod_rel_def[refine_rel_defs]: \n  \"(\\<langle>R1,R2\\<rangle>prod_rel) \\<equiv> { ((a,b),(a',b')) . (a,a')\\<in>R1 \\<and> (b,b')\\<in>R2 }\"", "lemma prod_relI: \"\\<lbrakk>(a,a')\\<in>R1; (b,b')\\<in>R2\\<rbrakk> \\<Longrightarrow> ((a,b),(a',b'))\\<in>\\<langle>R1,R2\\<rangle>prod_rel\"", "lemma prod_relE: \n  assumes \"(p,p')\\<in>\\<langle>R1,R2\\<rangle>prod_rel\"\n  obtains a b a' b' where \"p=(a,b)\" and \"p'=(a',b')\" \n  and \"(a,a')\\<in>R1\" and \"(b,b')\\<in>R2\"", "lemma prod_rel_simp[simp]: \n  \"((a,b),(a',b'))\\<in>\\<langle>R1,R2\\<rangle>prod_rel \\<longleftrightarrow> (a,a')\\<in>R1 \\<and> (b,b')\\<in>R2\"", "lemma in_Domain_prod_rel_iff[iff]: \"(a,b)\\<in>Domain (A\\<times>\\<^sub>rB) \\<longleftrightarrow> a\\<in>Domain A \\<and> b\\<in>Domain B\"", "lemma prod_rel_comp: \"(A \\<times>\\<^sub>r B) O (C \\<times>\\<^sub>r D) = (A O C) \\<times>\\<^sub>r (B O D)\"", "lemma option_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>option_rel \\<equiv> { (Some a,Some a') | a a'. (a,a')\\<in>R } \\<union> {(None,None)}\"", "lemma option_relI:\n  \"(None,None)\\<in>\\<langle>R\\<rangle> option_rel\"\n  \"\\<lbrakk> (a,a')\\<in>R \\<rbrakk> \\<Longrightarrow> (Some a, Some a')\\<in>\\<langle>R\\<rangle>option_rel\"", "lemma option_relE:\n  assumes \"(x,x')\\<in>\\<langle>R\\<rangle>option_rel\"\n  obtains \"x=None\" and \"x'=None\"\n  | a a' where \"x=Some a\" and \"x'=Some a'\" and \"(a,a')\\<in>R\"", "lemma option_rel_simp[simp]:\n  \"(None,a)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> a=None\"\n  \"(c,None)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> c=None\"\n  \"(Some x,Some y)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> (x,y)\\<in>R\"", "lemma sum_rel_def[refine_rel_defs]: \n  \"\\<langle>Rl,Rr\\<rangle>sum_rel \\<equiv> \n     { (Inl a, Inl a') | a a'. (a,a')\\<in>Rl } \\<union>\n     { (Inr a, Inr a') | a a'. (a,a')\\<in>Rr }\"", "lemma sum_rel_simp[simp]:\n  \"\\<And>a a'. (Inl a, Inl a') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<longleftrightarrow> (a,a')\\<in>Rl\"\n  \"\\<And>a a'. (Inr a, Inr a') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<longleftrightarrow> (a,a')\\<in>Rr\"\n  \"\\<And>a a'. (Inl a, Inr a') \\<notin> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"\\<And>a a'. (Inr a, Inl a') \\<notin> \\<langle>Rl,Rr\\<rangle>sum_rel\"", "lemma sum_relI: \n  \"(l,l')\\<in>Rl \\<Longrightarrow> (Inl l, Inl l') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(r,r')\\<in>Rr \\<Longrightarrow> (Inr r, Inr r') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel\"", "lemma sum_relE:\n  assumes \"(x,x')\\<in>\\<langle>Rl,Rr\\<rangle>sum_rel\"\n  obtains \n    l l' where \"x=Inl l\" and \"x'=Inl l'\" and \"(l,l')\\<in>Rl\"\n  | r r' where \"x=Inr r\" and \"x'=Inr r'\" and \"(r,r')\\<in>Rr\"", "lemma list_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>list_rel \\<equiv> {(l,l'). list_all2 (\\<lambda>x x'. (x,x')\\<in>R) l l'}\"", "lemma list_rel_induct[induct set,consumes 1, case_names Nil Cons]:\n  assumes \"(l,l')\\<in>\\<langle>R\\<rangle> list_rel\"\n  assumes \"P [] []\"\n  assumes \"\\<And>x x' l l'. \\<lbrakk> (x,x')\\<in>R; (l,l')\\<in>\\<langle>R\\<rangle>list_rel; P l l' \\<rbrakk> \n    \\<Longrightarrow> P (x#l) (x'#l')\"\n  shows \"P l l'\"", "lemma list_rel_eq_listrel: \"list_rel = listrel\"", "lemma list_relI: \n  \"([],[])\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"\\<lbrakk> (x,x')\\<in>R; (l,l')\\<in>\\<langle>R\\<rangle>list_rel \\<rbrakk> \\<Longrightarrow> (x#l,x'#l')\\<in>\\<langle>R\\<rangle>list_rel\"", "lemma list_rel_simp[simp]:\n  \"([],l')\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> l'=[]\"\n  \"(l,[])\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> l=[]\"\n  \"([],[])\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"(x#l,x'#l')\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (x,x')\\<in>R \\<and> (l,l')\\<in>\\<langle>R\\<rangle>list_rel\"", "lemma list_relE1:\n  assumes \"(l,[])\\<in>\\<langle>R\\<rangle>list_rel\" obtains \"l=[]\"", "lemma list_relE2:\n  assumes \"([],l)\\<in>\\<langle>R\\<rangle>list_rel\" obtains \"l=[]\"", "lemma list_relE3:\n  assumes \"(x#xs,l')\\<in>\\<langle>R\\<rangle>list_rel\" obtains x' xs' where \n  \"l'=x'#xs'\" and \"(x,x')\\<in>R\" and \"(xs,xs')\\<in>\\<langle>R\\<rangle>list_rel\"", "lemma list_relE4:\n  assumes \"(l,x'#xs')\\<in>\\<langle>R\\<rangle>list_rel\" obtains x xs where \n  \"l=x#xs\" and \"(x,x')\\<in>R\" and \"(xs,xs')\\<in>\\<langle>R\\<rangle>list_rel\"", "lemmas list_relE = list_relE1 list_relE2 list_relE3 list_relE4", "lemma list_rel_imp_same_length: \n    \"(l, l') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> length l = length l'\"", "lemma list_rel_split_right_iff: \n  \"(x#xs,l)\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (\\<exists>y ys. l=y#ys \\<and> (x,y)\\<in>R \\<and> (xs,ys)\\<in>\\<langle>R\\<rangle>list_rel)\"", "lemma list_rel_split_left_iff: \n  \"(l,y#ys)\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (\\<exists>x xs. l=x#xs \\<and> (x,y)\\<in>R \\<and> (xs,ys)\\<in>\\<langle>R\\<rangle>list_rel)\"", "lemma set_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>set_rel \\<equiv> {(A,B). (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x,y)\\<in>R) \\<and> (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x,y)\\<in>R)}\"", "lemma set_rel_alt: \"\\<langle>R\\<rangle>set_rel = {(A,B). A \\<subseteq> R\\<inverse>``B \\<and> B \\<subseteq> R``A}\"", "lemma set_relI[intro?]:\n  assumes \"\\<And>x. x\\<in>A \\<Longrightarrow> \\<exists>y\\<in>B. (x,y)\\<in>R\"\n  assumes \"\\<And>y. y\\<in>B \\<Longrightarrow> \\<exists>x\\<in>A. (x,y)\\<in>R\"\n  shows \"(A,B)\\<in>\\<langle>R\\<rangle>set_rel\"", "lemma old_set_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>old_set_rel \\<equiv> {(S,S'). S'=R``S \\<and> S\\<subseteq>Domain R}\"", "lemma old_set_rel_sv_eq: \"single_valued R \\<Longrightarrow> \\<langle>R\\<rangle>old_set_rel = \\<langle>R\\<rangle>set_rel\"", "lemma set_rel_simp[simp]: \n  \"({},{})\\<in>\\<langle>R\\<rangle>set_rel\"", "lemma set_rel_empty_iff[simp]: \n  \"({},y)\\<in>\\<langle>A\\<rangle>set_rel \\<longleftrightarrow> y={}\" \n  \"(x,{})\\<in>\\<langle>A\\<rangle>set_rel \\<longleftrightarrow> x={}\"", "lemma set_relD1: \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> x\\<in>s \\<Longrightarrow> \\<exists>x'\\<in>s'. (x,x')\\<in>R\"", "lemma set_relD2: \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> x'\\<in>s' \\<Longrightarrow> \\<exists>x\\<in>s. (x,x')\\<in>R\"", "lemma set_relE1[consumes 2]: \n  assumes \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\" \"x\\<in>s\"\n  obtains x' where \"x'\\<in>s'\" \"(x,x')\\<in>R\"", "lemma set_relE2[consumes 2]: \n  assumes \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\" \"x'\\<in>s'\"\n  obtains x where \"x\\<in>s\" \"(x,x')\\<in>R\"", "lemma relprop_triggers: \n  \"\\<And>R. single_valued R \\<Longrightarrow> single_valued R\" \n  \"\\<And>R. R=Id \\<Longrightarrow> R=Id\"\n  \"\\<And>R. R=Id \\<Longrightarrow> Id=R\"\n  \"\\<And>R. Range R = UNIV \\<Longrightarrow> Range R = UNIV\"\n  \"\\<And>R. Range R = UNIV \\<Longrightarrow> UNIV = Range R\"\n  \"\\<And>R R'. R\\<subseteq>R' \\<Longrightarrow> R\\<subseteq>R'\"", "lemma \n  relprop_id_orient[relator_props]: \"R=Id \\<Longrightarrow> Id=R\" and\n  relprop_eq_refl[solve_relator_props]: \"t = t\"", "lemma \n  relprop_UNIV_orient[relator_props]: \"R=UNIV \\<Longrightarrow> UNIV=R\"", "lemmas [relator_props] = \n  single_valued_Id\n  subset_refl\n  refl", "lemma eq_UNIV_iff: \"S=UNIV \\<longleftrightarrow> (\\<forall>x. x\\<in>S)\"", "lemma fun_rel_sv[relator_props]: \n  assumes RAN: \"Range Ra = UNIV\" \n  assumes SV: \"single_valued Rv\"\n  shows \"single_valued (Ra \\<rightarrow> Rv)\"", "lemmas [relator_props] = Range_Id", "lemma fun_rel_id[relator_props]: \"\\<lbrakk>R1=Id; R2=Id\\<rbrakk> \\<Longrightarrow> R1 \\<rightarrow> R2 = Id\"", "lemma fun_rel_id_simp[simp]: \"Id\\<rightarrow>Id = Id\"", "lemma fun_rel_comp_dist[relator_props]: \n  \"(R1\\<rightarrow>R2) O (R3\\<rightarrow>R4) \\<subseteq> ((R1 O R3) \\<rightarrow> (R2 O R4))\"", "lemma fun_rel_mono[relator_props]: \"\\<lbrakk> R1\\<subseteq>R2; R3\\<subseteq>R4 \\<rbrakk> \\<Longrightarrow> R2\\<rightarrow>R3 \\<subseteq> R1\\<rightarrow>R4\"", "lemma prod_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued R1; single_valued R2\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R1,R2\\<rangle>prod_rel)\"", "lemma prod_rel_id[relator_props]: \"\\<lbrakk>R1=Id; R2=Id\\<rbrakk> \\<Longrightarrow> \\<langle>R1,R2\\<rangle>prod_rel = Id\"", "lemma prod_rel_id_simp[simp]: \"\\<langle>Id,Id\\<rangle>prod_rel = Id\"", "lemma prod_rel_mono[relator_props]: \n\"\\<lbrakk> R2\\<subseteq>R1; R3\\<subseteq>R4 \\<rbrakk> \\<Longrightarrow> \\<langle>R2,R3\\<rangle>prod_rel \\<subseteq> \\<langle>R1,R4\\<rangle>prod_rel\"", "lemma prod_rel_range[relator_props]: \"\\<lbrakk>Range Ra=UNIV; Range Rb=UNIV\\<rbrakk> \n  \\<Longrightarrow> Range (\\<langle>Ra,Rb\\<rangle>prod_rel) = UNIV\"", "lemma option_rel_sv[relator_props]:\n  \"\\<lbrakk>single_valued R\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>option_rel)\"", "lemma option_rel_id[relator_props]: \n  \"R=Id \\<Longrightarrow> \\<langle>R\\<rangle>option_rel = Id\"", "lemma option_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>option_rel = Id\"", "lemma option_rel_mono[relator_props]: \"R\\<subseteq>R' \\<Longrightarrow> \\<langle>R\\<rangle>option_rel \\<subseteq> \\<langle>R'\\<rangle>option_rel\"", "lemma option_rel_range: \"Range R = UNIV \\<Longrightarrow> Range (\\<langle>R\\<rangle>option_rel) = UNIV\"", "lemma option_rel_inter[simp]: \"\\<langle>R1 \\<inter> R2\\<rangle>option_rel = \\<langle>R1\\<rangle>option_rel \\<inter> \\<langle>R2\\<rangle>option_rel\"", "lemma option_rel_constraint[simp]: \n  \"(x,x)\\<in>\\<langle>UNIV\\<times>C\\<rangle>option_rel \\<longleftrightarrow> (\\<forall>v. x=Some v \\<longrightarrow> v\\<in>C)\"", "lemma sum_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rr\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rl,Rr\\<rangle>sum_rel)\"", "lemma sum_rel_id[relator_props]: \"\\<lbrakk>Rl=Id; Rr=Id\\<rbrakk> \\<Longrightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel = Id\"", "lemma sum_rel_id_simp[simp]: \"\\<langle>Id,Id\\<rangle>sum_rel = Id\"", "lemma sum_rel_mono[relator_props]:\n  \"\\<lbrakk> Rl\\<subseteq>Rl'; Rr\\<subseteq>Rr' \\<rbrakk> \\<Longrightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<subseteq> \\<langle>Rl',Rr'\\<rangle>sum_rel\"", "lemma sum_rel_range[relator_props]:\n  \"\\<lbrakk> Range Rl=UNIV; Range Rr=UNIV \\<rbrakk> \\<Longrightarrow> Range (\\<langle>Rl,Rr\\<rangle>sum_rel) = UNIV\"", "lemma list_rel_sv_iff: \n  \"single_valued (\\<langle>R\\<rangle>list_rel) \\<longleftrightarrow> single_valued R\"", "lemma list_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>list_rel)\"", "lemma list_rel_id[relator_props]: \"\\<lbrakk>R=Id\\<rbrakk> \\<Longrightarrow> \\<langle>R\\<rangle>list_rel = Id\"", "lemma list_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>list_rel = Id\"", "lemma list_rel_mono[relator_props]: \n  assumes A: \"R\\<subseteq>R'\" \n  shows \"\\<langle>R\\<rangle>list_rel \\<subseteq> \\<langle>R'\\<rangle>list_rel\"", "lemma list_rel_range[relator_props]:\n  assumes A: \"Range R = UNIV\"\n  shows \"Range (\\<langle>R\\<rangle>list_rel) = UNIV\"", "lemma bijective_imp_sv:  \n  \"bijective R \\<Longrightarrow> single_valued R\"\n  \"bijective R \\<Longrightarrow> single_valued (R\\<inverse>)\"", "lemma set_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>set_rel)\"", "lemma set_rel_id[relator_props]: \"R=Id \\<Longrightarrow> \\<langle>R\\<rangle>set_rel = Id\"", "lemma set_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>set_rel = Id\"", "lemma set_rel_csv[relator_props]:\n  \"\\<lbrakk> single_valued (R\\<inverse>) \\<rbrakk> \n  \\<Longrightarrow> single_valued ((\\<langle>R\\<rangle>set_rel)\\<inverse>)\"", "lemmas br_def[refine_rel_defs] = build_rel_def", "lemma in_br_conv: \"(c,a)\\<in>br \\<alpha> I \\<longleftrightarrow> a=\\<alpha> c \\<and> I c\"", "lemma brI[intro?]: \"\\<lbrakk> a=\\<alpha> c; I c \\<rbrakk> \\<Longrightarrow> (c,a)\\<in>br \\<alpha> I\"", "lemma br_id[simp]: \"br id (\\<lambda>_. True) = Id\"", "lemma br_chain: \n  \"(build_rel \\<beta> J) O (build_rel \\<alpha> I) = build_rel (\\<alpha>\\<circ>\\<beta>) (\\<lambda>s. J s \\<and> I (\\<beta> s))\"", "lemma br_sv[simp, intro!,relator_props]: \"single_valued (br \\<alpha> I)\"", "lemma converse_br_sv_iff[simp]: \n  \"single_valued (converse (br \\<alpha> I)) \\<longleftrightarrow> inj_on \\<alpha> (Collect I)\"", "lemmas [relator_props] = single_valued_relcomp", "lemma br_comp_alt: \"br \\<alpha> I O R = { (c,a) . I c \\<and> (\\<alpha> c,a)\\<in>R }\"", "lemma br_comp_alt': \n  \"{(c,a) . a=\\<alpha> c \\<and> I c} O R = { (c,a) . I c \\<and> (\\<alpha> c,a)\\<in>R }\"", "lemma single_valued_as_brE:\n  assumes \"single_valued R\"\n  obtains \\<alpha> invar where \"R=br \\<alpha> invar\"", "lemma sv_add_invar: \n  \"single_valued R \\<Longrightarrow> single_valued {(c, a). (c, a) \\<in> R \\<and> I c}\"", "lemma br_Image_conv[simp]: \"br \\<alpha> I `` S = {\\<alpha> x | x. x\\<in>S \\<and> I x}\"", "lemma rel_cong: \"(f,g)\\<in>Id \\<Longrightarrow> (x,y)\\<in>Id \\<Longrightarrow> (f x, g y)\\<in>Id\"", "lemma rel_fun_cong: \"(f,g)\\<in>Id \\<Longrightarrow> (f x, g x)\\<in>Id\"", "lemma rel_arg_cong: \"(x,y)\\<in>Id \\<Longrightarrow> (f x, f y)\\<in>Id\"", "lemma rel2pD: \"\\<lbrakk>rel2p R a b\\<rbrakk> \\<Longrightarrow> (a,b)\\<in>R\"", "lemma p2relD: \"\\<lbrakk>(a,b) \\<in> p2rel R\\<rbrakk> \\<Longrightarrow> R a b\"", "lemma rel2p_inv[simp]:\n  \"rel2p (p2rel P) = P\"\n  \"p2rel (rel2p R) = R\"", "lemma rel2p_dflt[rel2p]:\n  \"rel2p Id = (=)\"\n  \"rel2p (A\\<rightarrow>B) = rel_fun (rel2p A) (rel2p B)\"\n  \"rel2p (A\\<times>\\<^sub>rB) = rel_prod (rel2p A) (rel2p B)\"\n  \"rel2p (\\<langle>A,B\\<rangle>sum_rel) = rel_sum (rel2p A) (rel2p B)\"\n  \"rel2p (\\<langle>A\\<rangle>option_rel) = rel_option (rel2p A)\"\n  \"rel2p (\\<langle>A\\<rangle>list_rel) = list_all2 (rel2p A)\"", "lemma p2rel_dflt[p2rel]: \n  \"p2rel (=) = Id\"\n  \"p2rel (rel_fun A B) = p2rel A \\<rightarrow> p2rel B\"\n  \"p2rel (rel_prod A B) = p2rel A \\<times>\\<^sub>r p2rel B\"\n  \"p2rel (rel_sum A B) = \\<langle>p2rel A, p2rel B\\<rangle>sum_rel\"\n  \"p2rel (rel_option A) = \\<langle>p2rel A\\<rangle>option_rel\"\n  \"p2rel (list_all2 A) = \\<langle>p2rel A\\<rangle>list_rel\"", "lemma [rel2p]: \"rel2p (\\<langle>A\\<rangle>set_rel) = rel_set (rel2p A)\"", "lemma [p2rel]: \"left_unique A \\<Longrightarrow> p2rel (rel_set A) = (\\<langle>p2rel A\\<rangle>set_rel)\"", "lemma rel2p_comp: \"rel2p A OO rel2p B = rel2p (A O B)\"", "lemma rel2p_inj[simp]: \"rel2p A = rel2p B \\<longleftrightarrow> A=B\"", "lemma list_rel_compp: \"\\<langle>A O B\\<rangle>list_rel = \\<langle>A\\<rangle>list_rel O \\<langle>B\\<rangle>list_rel\"", "lemma option_rel_compp: \"\\<langle>A O B\\<rangle>option_rel = \\<langle>A\\<rangle>option_rel O \\<langle>B\\<rangle>option_rel\"", "lemma prod_rel_compp: \"\\<langle>A O B, C O D\\<rangle>prod_rel = \\<langle>A,C\\<rangle>prod_rel O \\<langle>B,D\\<rangle>prod_rel\"", "lemma sum_rel_compp: \"\\<langle>A O B, C O D\\<rangle>sum_rel = \\<langle>A,C\\<rangle>sum_rel O \\<langle>B,D\\<rangle>sum_rel\"", "lemma set_rel_compp: \"\\<langle>A O B\\<rangle>set_rel = \\<langle>A\\<rangle>set_rel O \\<langle>B\\<rangle>set_rel\"", "lemma map_in_list_rel_conv: \n  shows \"(l, map \\<alpha> l) \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<longleftrightarrow> (\\<forall>x\\<in>set l. I x)\"", "lemma br_set_rel_alt: \"(s',s)\\<in>\\<langle>br \\<alpha> I\\<rangle>set_rel \\<longleftrightarrow> (s=\\<alpha>`s' \\<and> (\\<forall>x\\<in>s'. I x))\"", "lemma finite_Image_sv: \"single_valued R \\<Longrightarrow> finite s \\<Longrightarrow> finite (R``s)\"", "lemma finite_set_rel_transfer: \"\\<lbrakk>(s,s')\\<in>\\<langle>R\\<rangle>set_rel; single_valued R; finite s\\<rbrakk> \\<Longrightarrow> finite s'\"", "lemma finite_set_rel_transfer_back: \"\\<lbrakk>(s,s')\\<in>\\<langle>R\\<rangle>set_rel; single_valued (R\\<inverse>); finite s'\\<rbrakk> \\<Longrightarrow> finite s\""], "translations": [["", "lemma fun_rel_def[refine_rel_defs]: \n  \"A\\<rightarrow>B \\<equiv> { (f,f'). \\<forall>(a,a')\\<in>A. (f a, f' a')\\<in>B }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<rightarrow> B \\<equiv>\n    {(f, f'). \\<forall>(a, a')\\<in>A. (f a, f' a') \\<in> B}", "by (simp add: relAPP_def fun_rel_def_internal)"], ["", "lemma fun_relI[intro!]: \"\\<lbrakk>\\<And>a a'. (a,a')\\<in>A \\<Longrightarrow> (f a,f' a')\\<in>B\\<rbrakk> \\<Longrightarrow> (f,f')\\<in>A\\<rightarrow>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a a'.\n        (a, a') \\<in> A \\<Longrightarrow>\n        (f a, f' a') \\<in> B) \\<Longrightarrow>\n    (f, f') \\<in> A \\<rightarrow> B", "by (auto simp: fun_rel_def)"], ["", "lemma fun_relD: \n  shows \" ((f,f')\\<in>(A\\<rightarrow>B)) \\<Longrightarrow> \n  (\\<And>x x'. \\<lbrakk> (x,x')\\<in>A \\<rbrakk> \\<Longrightarrow> (f x, f' x')\\<in>B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, f') \\<in> A \\<rightarrow> B \\<Longrightarrow>\n    (\\<And>x x'. (x, x') \\<in> A \\<Longrightarrow> (f x, f' x') \\<in> B)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (f x, f' x') \\<in> ?A x x'\n 2. \\<And>x x'.\n       \\<lbrakk>(f, f') \\<in> A \\<rightarrow> B; (x, x') \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ?A x x' \\<subseteq> B", "by (auto simp: fun_rel_def)"], ["", "lemma fun_relD1:\n  assumes \"(f,f')\\<in>Ra\\<rightarrow>Rr\"\n  assumes \"f x = r\"\n  shows \"\\<forall>x'. (x,x')\\<in>Ra \\<longrightarrow> (r,f' x')\\<in>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x'. (x, x') \\<in> Ra \\<longrightarrow> (r, f' x') \\<in> Rr", "using assms"], ["proof (prove)\nusing this:\n  (f, f') \\<in> Ra \\<rightarrow> Rr\n  f x = r\n\ngoal (1 subgoal):\n 1. \\<forall>x'. (x, x') \\<in> Ra \\<longrightarrow> (r, f' x') \\<in> Rr", "by (auto simp: fun_rel_def)"], ["", "lemma fun_relD2:\n  assumes \"(f,f')\\<in>Ra\\<rightarrow>Rr\"\n  assumes \"f' x' = r'\"\n  shows \"\\<forall>x. (x,x')\\<in>Ra \\<longrightarrow> (f x,r')\\<in>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x') \\<in> Ra \\<longrightarrow> (f x, r') \\<in> Rr", "using assms"], ["proof (prove)\nusing this:\n  (f, f') \\<in> Ra \\<rightarrow> Rr\n  f' x' = r'\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x') \\<in> Ra \\<longrightarrow> (f x, r') \\<in> Rr", "by (auto simp: fun_rel_def)"], ["", "lemma fun_relE1:\n  assumes \"(f,f')\\<in>Id \\<rightarrow> Rv\"\n  assumes \"t' = f' x\"\n  shows \"(f x,t')\\<in>Rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x, t') \\<in> Rv", "using assms"], ["proof (prove)\nusing this:\n  (f, f') \\<in> Id \\<rightarrow> Rv\n  t' = f' x\n\ngoal (1 subgoal):\n 1. (f x, t') \\<in> Rv", "by (auto elim: fun_relD)"], ["", "lemma fun_relE2:\n  assumes \"(f,f')\\<in>Id \\<rightarrow> Rv\"\n  assumes \"t = f x\"\n  shows \"(t,f' x)\\<in>Rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, f' x) \\<in> Rv", "using assms"], ["proof (prove)\nusing this:\n  (f, f') \\<in> Id \\<rightarrow> Rv\n  t = f x\n\ngoal (1 subgoal):\n 1. (t, f' x) \\<in> Rv", "by (auto elim: fun_relD)"], ["", "subsubsection \\<open>Terminal Types\\<close>"], ["", "abbreviation unit_rel :: \"(unit\\<times>unit) set\" where \"unit_rel == Id\""], ["", "abbreviation \"nat_rel \\<equiv> Id::(nat\\<times>_) set\""], ["", "abbreviation \"int_rel \\<equiv> Id::(int\\<times>_) set\""], ["", "abbreviation \"bool_rel \\<equiv> Id::(bool\\<times>_) set\""], ["", "subsubsection \\<open>Product\\<close>"], ["", "definition prod_rel where\n  prod_rel_def_internal: \"prod_rel R1 R2 \n    \\<equiv> { ((a,b),(a',b')) . (a,a')\\<in>R1 \\<and> (b,b')\\<in>R2 }\""], ["", "abbreviation prod_rel_syn (infixr \"\\<times>\\<^sub>r\" 70) where \"a\\<times>\\<^sub>rb \\<equiv> \\<langle>a,b\\<rangle>prod_rel\""], ["", "lemma prod_rel_def[refine_rel_defs]: \n  \"(\\<langle>R1,R2\\<rangle>prod_rel) \\<equiv> { ((a,b),(a',b')) . (a,a')\\<in>R1 \\<and> (b,b')\\<in>R2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 \\<times>\\<^sub>r R2 \\<equiv>\n    {((a, b), a', b'). (a, a') \\<in> R1 \\<and> (b, b') \\<in> R2}", "by (simp add: prod_rel_def_internal relAPP_def)"], ["", "lemma prod_relI: \"\\<lbrakk>(a,a')\\<in>R1; (b,b')\\<in>R2\\<rbrakk> \\<Longrightarrow> ((a,b),(a',b'))\\<in>\\<langle>R1,R2\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> R1; (b, b') \\<in> R2\\<rbrakk>\n    \\<Longrightarrow> ((a, b), a', b') \\<in> R1 \\<times>\\<^sub>r R2", "by (auto simp: prod_rel_def)"], ["", "lemma prod_relE: \n  assumes \"(p,p')\\<in>\\<langle>R1,R2\\<rangle>prod_rel\"\n  obtains a b a' b' where \"p=(a,b)\" and \"p'=(a',b')\" \n  and \"(a,a')\\<in>R1\" and \"(b,b')\\<in>R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b a' b'.\n        \\<lbrakk>p = (a, b); p' = (a', b'); (a, a') \\<in> R1;\n         (b, b') \\<in> R2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (p, p') \\<in> R1 \\<times>\\<^sub>r R2\n\ngoal (1 subgoal):\n 1. (\\<And>a b a' b'.\n        \\<lbrakk>p = (a, b); p' = (a', b'); (a, a') \\<in> R1;\n         (b, b') \\<in> R2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: prod_rel_def)"], ["", "lemma prod_rel_simp[simp]: \n  \"((a,b),(a',b'))\\<in>\\<langle>R1,R2\\<rangle>prod_rel \\<longleftrightarrow> (a,a')\\<in>R1 \\<and> (b,b')\\<in>R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a, b), a', b') \\<in> R1 \\<times>\\<^sub>r R2) =\n    ((a, a') \\<in> R1 \\<and> (b, b') \\<in> R2)", "by (auto intro: prod_relI elim: prod_relE)"], ["", "lemma in_Domain_prod_rel_iff[iff]: \"(a,b)\\<in>Domain (A\\<times>\\<^sub>rB) \\<longleftrightarrow> a\\<in>Domain A \\<and> b\\<in>Domain B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> Domain (A \\<times>\\<^sub>r B)) =\n    (a \\<in> Domain A \\<and> b \\<in> Domain B)", "by (auto simp: prod_rel_def)"], ["", "lemma prod_rel_comp: \"(A \\<times>\\<^sub>r B) O (C \\<times>\\<^sub>r D) = (A O C) \\<times>\\<^sub>r (B O D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<times>\\<^sub>r B) O (C \\<times>\\<^sub>r D) =\n    A O C \\<times>\\<^sub>r B O D", "unfolding prod_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((a, b), a', b'). (a, a') \\<in> A \\<and> (b, b') \\<in> B} O\n    {((a, b), a', b'). (a, a') \\<in> C \\<and> (b, b') \\<in> D} =\n    {((a, b), a', b'). (a, a') \\<in> A O C \\<and> (b, b') \\<in> B O D}", "by auto"], ["", "subsubsection \\<open>Option\\<close>"], ["", "definition option_rel where\n  option_rel_def_internal:\n  \"option_rel R \\<equiv> { (Some a,Some a') | a a'. (a,a')\\<in>R } \\<union> {(None,None)}\""], ["", "lemma option_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>option_rel \\<equiv> { (Some a,Some a') | a a'. (a,a')\\<in>R } \\<union> {(None,None)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>option_rel \\<equiv>\n    {(Some a, Some a') |a a'. (a, a') \\<in> R} \\<union> {(None, None)}", "by (simp add: option_rel_def_internal relAPP_def)"], ["", "lemma option_relI:\n  \"(None,None)\\<in>\\<langle>R\\<rangle> option_rel\"\n  \"\\<lbrakk> (a,a')\\<in>R \\<rbrakk> \\<Longrightarrow> (Some a, Some a')\\<in>\\<langle>R\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None, None) \\<in> \\<langle>R\\<rangle>option_rel &&&\n    ((a, a') \\<in> R \\<Longrightarrow>\n     (Some a, Some a') \\<in> \\<langle>R\\<rangle>option_rel)", "by (auto simp: option_rel_def)"], ["", "lemma option_relE:\n  assumes \"(x,x')\\<in>\\<langle>R\\<rangle>option_rel\"\n  obtains \"x=None\" and \"x'=None\"\n  | a a' where \"x=Some a\" and \"x'=Some a'\" and \"(a,a')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = None; x' = None\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>a a'.\n        \\<lbrakk>x = Some a; x' = Some a'; (a, a') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> \\<langle>R\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = None; x' = None\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>a a'.\n        \\<lbrakk>x = Some a; x' = Some a'; (a, a') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: option_rel_def)"], ["", "lemma option_rel_simp[simp]:\n  \"(None,a)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> a=None\"\n  \"(c,None)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> c=None\"\n  \"(Some x,Some y)\\<in>\\<langle>R\\<rangle>option_rel \\<longleftrightarrow> (x,y)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((None, a) \\<in> \\<langle>R\\<rangle>option_rel) = (a = None) &&&\n    ((c, None) \\<in> \\<langle>R\\<rangle>option_rel) = (c = None) &&&\n    ((Some x, Some y) \\<in> \\<langle>R\\<rangle>option_rel) =\n    ((x, y) \\<in> R)", "by (auto intro: option_relI elim: option_relE)"], ["", "subsubsection \\<open>Sum\\<close>"], ["", "definition sum_rel where sum_rel_def_internal: \n  \"sum_rel Rl Rr \n   \\<equiv> { (Inl a, Inl a') | a a'. (a,a')\\<in>Rl } \\<union>\n     { (Inr a, Inr a') | a a'. (a,a')\\<in>Rr }\""], ["", "lemma sum_rel_def[refine_rel_defs]: \n  \"\\<langle>Rl,Rr\\<rangle>sum_rel \\<equiv> \n     { (Inl a, Inl a') | a a'. (a,a')\\<in>Rl } \\<union>\n     { (Inr a, Inr a') | a a'. (a,a')\\<in>Rr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rl, Rr\\<rangle>sum_rel \\<equiv>\n    {(Inl a, Inl a') |a a'. (a, a') \\<in> Rl} \\<union>\n    {(Inr a, Inr a') |a a'. (a, a') \\<in> Rr}", "by (simp add: sum_rel_def_internal relAPP_def)"], ["", "lemma sum_rel_simp[simp]:\n  \"\\<And>a a'. (Inl a, Inl a') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<longleftrightarrow> (a,a')\\<in>Rl\"\n  \"\\<And>a a'. (Inr a, Inr a') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel \\<longleftrightarrow> (a,a')\\<in>Rr\"\n  \"\\<And>a a'. (Inl a, Inr a') \\<notin> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"\\<And>a a'. (Inr a, Inl a') \\<notin> \\<langle>Rl,Rr\\<rangle>sum_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>a a'.\n         ((Inl a, Inl a') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel) =\n         ((a, a') \\<in> Rl)) &&&\n     (\\<And>a a'.\n         ((Inr a, Inr a') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel) =\n         ((a, a') \\<in> Rr))) &&&\n    (\\<And>a a'.\n        (Inl a, Inr a') \\<notin> \\<langle>Rl, Rr\\<rangle>sum_rel) &&&\n    (\\<And>a a'. (Inr a, Inl a') \\<notin> \\<langle>Rl, Rr\\<rangle>sum_rel)", "unfolding sum_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>a a'.\n         ((Inl a, Inl a')\n          \\<in> {(Inl a, Inl a') |a a'. (a, a') \\<in> Rl} \\<union>\n                {(Inr a, Inr a') |a a'. (a, a') \\<in> Rr}) =\n         ((a, a') \\<in> Rl)) &&&\n     (\\<And>a a'.\n         ((Inr a, Inr a')\n          \\<in> {(Inl a, Inl a') |a a'. (a, a') \\<in> Rl} \\<union>\n                {(Inr a, Inr a') |a a'. (a, a') \\<in> Rr}) =\n         ((a, a') \\<in> Rr))) &&&\n    (\\<And>a a'.\n        (Inl a, Inr a')\n        \\<notin> {(Inl a, Inl a') |a a'. (a, a') \\<in> Rl} \\<union>\n                 {(Inr a, Inr a') |a a'. (a, a') \\<in> Rr}) &&&\n    (\\<And>a a'.\n        (Inr a, Inl a')\n        \\<notin> {(Inl a, Inl a') |a a'. (a, a') \\<in> Rl} \\<union>\n                 {(Inr a, Inr a') |a a'. (a, a') \\<in> Rr})", "by auto"], ["", "lemma sum_relI: \n  \"(l,l')\\<in>Rl \\<Longrightarrow> (Inl l, Inl l') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel\"\n  \"(r,r')\\<in>Rr \\<Longrightarrow> (Inr r, Inr r') \\<in> \\<langle>Rl,Rr\\<rangle>sum_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, l') \\<in> Rl \\<Longrightarrow>\n     (Inl l, Inl l') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel) &&&\n    ((r, r') \\<in> Rr \\<Longrightarrow>\n     (Inr r, Inr r') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel)", "by simp_all"], ["", "lemma sum_relE:\n  assumes \"(x,x')\\<in>\\<langle>Rl,Rr\\<rangle>sum_rel\"\n  obtains \n    l l' where \"x=Inl l\" and \"x'=Inl l'\" and \"(l,l')\\<in>Rl\"\n  | r r' where \"x=Inr r\" and \"x'=Inr r'\" and \"(r,r')\\<in>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l l'.\n                \\<lbrakk>x = Inl l; x' = Inl l'; (l, l') \\<in> Rl\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>r r'.\n        \\<lbrakk>x = Inr r; x' = Inr r'; (r, r') \\<in> Rr\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> \\<langle>Rl, Rr\\<rangle>sum_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l l'.\n                \\<lbrakk>x = Inl l; x' = Inl l'; (l, l') \\<in> Rl\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>r r'.\n        \\<lbrakk>x = Inr r; x' = Inr r'; (r, r') \\<in> Rr\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: sum_rel_def)"], ["", "subsubsection \\<open>Lists\\<close>"], ["", "definition list_rel where list_rel_def_internal:\n  \"list_rel R \\<equiv> {(l,l'). list_all2 (\\<lambda>x x'. (x,x')\\<in>R) l l'}\""], ["", "lemma list_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>list_rel \\<equiv> {(l,l'). list_all2 (\\<lambda>x x'. (x,x')\\<in>R) l l'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>list_rel \\<equiv>\n    {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'}", "by (simp add: list_rel_def_internal relAPP_def)"], ["", "lemma list_rel_induct[induct set,consumes 1, case_names Nil Cons]:\n  assumes \"(l,l')\\<in>\\<langle>R\\<rangle> list_rel\"\n  assumes \"P [] []\"\n  assumes \"\\<And>x x' l l'. \\<lbrakk> (x,x')\\<in>R; (l,l')\\<in>\\<langle>R\\<rangle>list_rel; P l l' \\<rbrakk> \n    \\<Longrightarrow> P (x#l) (x'#l')\"\n  shows \"P l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l l'", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n  P [] []\n  \\<lbrakk>(?x, ?x') \\<in> R; (?l, ?l') \\<in> \\<langle>R\\<rangle>list_rel;\n   P ?l ?l'\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?l) (?x' # ?l')\n\ngoal (1 subgoal):\n 1. P l l'", "unfolding list_rel_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'}\n  P [] []\n  \\<lbrakk>(?x, ?x') \\<in> R;\n   (?l, ?l')\n   \\<in> {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'};\n   P ?l ?l'\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?l) (?x' # ?l')\n\ngoal (1 subgoal):\n 1. P l l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'; P [] [];\n     \\<And>x x' l l'.\n        \\<lbrakk>(x, x') \\<in> R;\n         list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'; P l l'\\<rbrakk>\n        \\<Longrightarrow> P (x # l) (x' # l')\\<rbrakk>\n    \\<Longrightarrow> P l l'", "by (rule list_all2_induct)"], ["", "lemma list_rel_eq_listrel: \"list_rel = listrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_rel = listrel", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. list_rel x = listrel x", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b) \\<in> list_rel x \\<Longrightarrow> (a, b) \\<in> listrel x\n 2. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b) \\<in> list_rel x \\<Longrightarrow> (a, b) \\<in> listrel x\n 2. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "case (1 x a b)"], ["proof (state)\nthis:\n  (a, b) \\<in> list_rel x\n\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b) \\<in> list_rel x \\<Longrightarrow> (a, b) \\<in> listrel x\n 2. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "thus ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> list_rel x\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> listrel x", "unfolding list_rel_def_internal"], ["proof (prove)\nusing this:\n  (a, b) \\<in> {(l, l'). list_all2 (\\<lambda>xa x'. (xa, x') \\<in> x) l l'}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> listrel x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>xa x'. (xa, x') \\<in> x) a b \\<Longrightarrow>\n    (a, b) \\<in> listrel x", "apply (induct a b rule: list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([], []) \\<in> listrel x\n 2. \\<And>xa x' ls ls'.\n       \\<lbrakk>(xa, x') \\<in> x;\n        list_all2 (\\<lambda>xa x'. (xa, x') \\<in> x) ls ls';\n        (ls, ls') \\<in> listrel x\\<rbrakk>\n       \\<Longrightarrow> (xa # ls, x' # ls') \\<in> listrel x", "apply (auto intro: listrel.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a, b) \\<in> listrel x\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "case 2"], ["proof (state)\nthis:\n  (a_, b_) \\<in> listrel x_\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> listrel x \\<Longrightarrow> (a, b) \\<in> list_rel x", "thus ?case"], ["proof (prove)\nusing this:\n  (a_, b_) \\<in> listrel x_\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> list_rel x_", "apply (induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([], []) \\<in> list_rel x_\n 2. \\<And>xa y xs ys.\n       \\<lbrakk>(xa, y) \\<in> x_; (xs, ys) \\<in> listrel x_;\n        (xs, ys) \\<in> list_rel x_\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, y # ys) \\<in> list_rel x_", "apply (auto simp: list_rel_def_internal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a_, b_) \\<in> list_rel x_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_relI: \n  \"([],[])\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"\\<lbrakk> (x,x')\\<in>R; (l,l')\\<in>\\<langle>R\\<rangle>list_rel \\<rbrakk> \\<Longrightarrow> (x#l,x'#l')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], []) \\<in> \\<langle>R\\<rangle>list_rel &&&\n    (\\<lbrakk>(x, x') \\<in> R;\n      (l, l') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n     \\<Longrightarrow> (x # l, x' # l') \\<in> \\<langle>R\\<rangle>list_rel)", "by (auto simp: list_rel_def)"], ["", "lemma list_rel_simp[simp]:\n  \"([],l')\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> l'=[]\"\n  \"(l,[])\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> l=[]\"\n  \"([],[])\\<in>\\<langle>R\\<rangle>list_rel\"\n  \"(x#l,x'#l')\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (x,x')\\<in>R \\<and> (l,l')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((([], l') \\<in> \\<langle>R\\<rangle>list_rel) = (l' = []) &&&\n     ((l, []) \\<in> \\<langle>R\\<rangle>list_rel) = (l = [])) &&&\n    ([], []) \\<in> \\<langle>R\\<rangle>list_rel &&&\n    ((x # l, x' # l') \\<in> \\<langle>R\\<rangle>list_rel) =\n    ((x, x') \\<in> R \\<and> (l, l') \\<in> \\<langle>R\\<rangle>list_rel)", "by (auto simp: list_rel_def)"], ["", "lemma list_relE1:\n  assumes \"(l,[])\\<in>\\<langle>R\\<rangle>list_rel\" obtains \"l=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = [] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (l, []) \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (l = [] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["", "lemma list_relE2:\n  assumes \"([],l)\\<in>\\<langle>R\\<rangle>list_rel\" obtains \"l=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = [] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  ([], l) \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (l = [] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["", "lemma list_relE3:\n  assumes \"(x#xs,l')\\<in>\\<langle>R\\<rangle>list_rel\" obtains x' xs' where \n  \"l'=x'#xs'\" and \"(x,x')\\<in>R\" and \"(xs,xs')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' xs'.\n        \\<lbrakk>l' = x' # xs'; (x, x') \\<in> R;\n         (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (x # xs, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>x' xs'.\n        \\<lbrakk>l' = x' # xs'; (x, x') \\<in> R;\n         (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases l')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'.\n                \\<lbrakk>l' = x' # xs'; (x, x') \\<in> R;\n                 (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (x # xs, l') \\<in> \\<langle>R\\<rangle>list_rel; l' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'.\n                   \\<lbrakk>l' = x' # xs'; (x, x') \\<in> R;\n                    (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (x # xs, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l' = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_relE4:\n  assumes \"(l,x'#xs')\\<in>\\<langle>R\\<rangle>list_rel\" obtains x xs where \n  \"l=x#xs\" and \"(x,x')\\<in>R\" and \"(xs,xs')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>l = x # xs; (x, x') \\<in> R;\n         (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (l, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>l = x # xs; (x, x') \\<in> R;\n         (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>l = x # xs; (x, x') \\<in> R;\n                 (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (l, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel; l = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x xs.\n                   \\<lbrakk>l = x # xs; (x, x') \\<in> R;\n                    (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (l, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel;\n        l = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas list_relE = list_relE1 list_relE2 list_relE3 list_relE4"], ["", "lemma list_rel_imp_same_length: \n    \"(l, l') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> length l = length l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, l') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n    length l = length l'", "unfolding list_rel_eq_listrel relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, l') \\<in> listrel R \\<Longrightarrow> length l = length l'", "by (rule listrel_eq_len)"], ["", "lemma list_rel_split_right_iff: \n  \"(x#xs,l)\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (\\<exists>y ys. l=y#ys \\<and> (x,y)\\<in>R \\<and> (xs,ys)\\<in>\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x # xs, l) \\<in> \\<langle>R\\<rangle>list_rel) =\n    (\\<exists>y ys.\n        l = y # ys \\<and>\n        (x, y) \\<in> R \\<and> (xs, ys) \\<in> \\<langle>R\\<rangle>list_rel)", "by (cases l) auto"], ["", "lemma list_rel_split_left_iff: \n  \"(l,y#ys)\\<in>\\<langle>R\\<rangle>list_rel \\<longleftrightarrow> (\\<exists>x xs. l=x#xs \\<and> (x,y)\\<in>R \\<and> (xs,ys)\\<in>\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, y # ys) \\<in> \\<langle>R\\<rangle>list_rel) =\n    (\\<exists>x xs.\n        l = x # xs \\<and>\n        (x, y) \\<in> R \\<and> (xs, ys) \\<in> \\<langle>R\\<rangle>list_rel)", "by (cases l) auto"], ["", "subsubsection \\<open>Sets\\<close>"], ["", "text \\<open>Pointwise refinement: The abstract set is the image of\n  the concrete set, and the concrete set only contains elements that\n  have an abstract counterpart\\<close>"], ["", "definition set_rel where\n  set_rel_def_internal: \n    \"set_rel R \\<equiv> {(A,B). (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x,y)\\<in>R) \\<and> (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x,y)\\<in>R)}\""], ["", "term set_rel"], ["", "lemma set_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>set_rel \\<equiv> {(A,B). (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x,y)\\<in>R) \\<and> (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x,y)\\<in>R)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>set_rel \\<equiv>\n    {(A, B).\n     (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n     (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}", "by (simp add: set_rel_def_internal relAPP_def)"], ["", "lemma set_rel_alt: \"\\<langle>R\\<rangle>set_rel = {(A,B). A \\<subseteq> R\\<inverse>``B \\<and> B \\<subseteq> R``A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>set_rel =\n    {(A, B). A \\<subseteq> R\\<inverse> `` B \\<and> B \\<subseteq> R `` A}", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(A, B).\n     (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n     (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)} =\n    {(A, B). A \\<subseteq> R\\<inverse> `` B \\<and> B \\<subseteq> R `` A}", "by auto"], ["", "lemma set_relI[intro?]:\n  assumes \"\\<And>x. x\\<in>A \\<Longrightarrow> \\<exists>y\\<in>B. (x,y)\\<in>R\"\n  assumes \"\\<And>y. y\\<in>B \\<Longrightarrow> \\<exists>x\\<in>A. (x,y)\\<in>R\"\n  shows \"(A,B)\\<in>\\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, B) \\<in> \\<langle>R\\<rangle>set_rel", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>B. (?x, y) \\<in> R\n  ?y \\<in> B \\<Longrightarrow> \\<exists>x\\<in>A. (x, ?y) \\<in> R\n\ngoal (1 subgoal):\n 1. (A, B) \\<in> \\<langle>R\\<rangle>set_rel", "unfolding set_rel_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>B. (?x, y) \\<in> R\n  ?y \\<in> B \\<Longrightarrow> \\<exists>x\\<in>A. (x, ?y) \\<in> R\n\ngoal (1 subgoal):\n 1. (A, B)\n    \\<in> {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}", "by blast"], ["", "text \\<open>Original definition of \\<open>set_rel\\<close> in refinement framework. \n  Abandoned in favour of more symmetric definition above: \\<close>"], ["", "definition old_set_rel where old_set_rel_def_internal: \n  \"old_set_rel R \\<equiv> {(S,S'). S'=R``S \\<and> S\\<subseteq>Domain R}\""], ["", "lemma old_set_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>old_set_rel \\<equiv> {(S,S'). S'=R``S \\<and> S\\<subseteq>Domain R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>old_set_rel \\<equiv>\n    {(S, S'). S' = R `` S \\<and> S \\<subseteq> Domain R}", "by (simp add: old_set_rel_def_internal relAPP_def)"], ["", "text \\<open>Old definition coincides with new definition for single-valued \n  element relations. This is probably the reason why the old definition worked \n  for most applications.\\<close>"], ["", "lemma old_set_rel_sv_eq: \"single_valued R \\<Longrightarrow> \\<langle>R\\<rangle>old_set_rel = \\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    \\<langle>R\\<rangle>old_set_rel = \\<langle>R\\<rangle>set_rel", "unfolding set_rel_def old_set_rel_def single_valued_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> R \\<longrightarrow>\n       (\\<forall>z.\n           (x, z) \\<in> R \\<longrightarrow> y = z) \\<Longrightarrow>\n    {(S, S'). S' = R `` S \\<and> S \\<subseteq> Domain R} =\n    {(A, B).\n     (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n     (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}", "by blast"], ["", "lemma set_rel_simp[simp]: \n  \"({},{})\\<in>\\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({}, {}) \\<in> \\<langle>R\\<rangle>set_rel", "by (auto simp: set_rel_def)"], ["", "lemma set_rel_empty_iff[simp]: \n  \"({},y)\\<in>\\<langle>A\\<rangle>set_rel \\<longleftrightarrow> y={}\" \n  \"(x,{})\\<in>\\<langle>A\\<rangle>set_rel \\<longleftrightarrow> x={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({}, y) \\<in> \\<langle>A\\<rangle>set_rel) = (y = {}) &&&\n    ((x, {}) \\<in> \\<langle>A\\<rangle>set_rel) = (x = {})", "by (auto simp: set_rel_def; fastforce)+"], ["", "lemma set_relD1: \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> x\\<in>s \\<Longrightarrow> \\<exists>x'\\<in>s'. (x,x')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> \\<langle>R\\<rangle>set_rel; x \\<in> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>s'. (x, x') \\<in> R", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> {(A, B).\n                    (\\<forall>x\\<in>A.\n                        \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                    (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)};\n     x \\<in> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>s'. (x, x') \\<in> R", "by blast"], ["", "lemma set_relD2: \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> x'\\<in>s' \\<Longrightarrow> \\<exists>x\\<in>s. (x,x')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> \\<langle>R\\<rangle>set_rel; x' \\<in> s'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>s. (x, x') \\<in> R", "unfolding set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> {(A, B).\n                    (\\<forall>x\\<in>A.\n                        \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                    (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)};\n     x' \\<in> s'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>s. (x, x') \\<in> R", "by blast"], ["", "lemma set_relE1[consumes 2]: \n  assumes \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\" \"x\\<in>s\"\n  obtains x' where \"x'\\<in>s'\" \"(x,x')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> s'; (x, x') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_relD1[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>s'. (x, x') \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> s'; (x, x') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["", "lemma set_relE2[consumes 2]: \n  assumes \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\" \"x'\\<in>s'\"\n  obtains x where \"x\\<in>s\" \"(x,x')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> s; (x, x') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_relD2[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>s. (x, x') \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> s; (x, x') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["", "subsection \\<open>Automation\\<close>"], ["", "subsubsection \\<open>A solver for relator properties\\<close>"], ["", "lemma relprop_triggers: \n  \"\\<And>R. single_valued R \\<Longrightarrow> single_valued R\" \n  \"\\<And>R. R=Id \\<Longrightarrow> R=Id\"\n  \"\\<And>R. R=Id \\<Longrightarrow> Id=R\"\n  \"\\<And>R. Range R = UNIV \\<Longrightarrow> Range R = UNIV\"\n  \"\\<And>R. Range R = UNIV \\<Longrightarrow> UNIV = Range R\"\n  \"\\<And>R R'. R\\<subseteq>R' \\<Longrightarrow> R\\<subseteq>R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>R. single_valued R \\<Longrightarrow> single_valued R) &&&\n     (\\<And>R. R = Id \\<Longrightarrow> R = Id) &&&\n     (\\<And>R. R = Id \\<Longrightarrow> Id = R)) &&&\n    (\\<And>R. Range R = UNIV \\<Longrightarrow> Range R = UNIV) &&&\n    (\\<And>R. Range R = UNIV \\<Longrightarrow> UNIV = Range R) &&&\n    (\\<And>R R'. R \\<subseteq> R' \\<Longrightarrow> R \\<subseteq> R')", "by auto"], ["", "ML \\<open>\n  structure relator_props = Named_Thms (\n    val name = @{binding relator_props}\n    val description = \"Additional relator properties\"\n  )\n\n  structure solve_relator_props = Named_Thms (\n    val name = @{binding solve_relator_props}\n    val description = \"Relator properties that solve goal\"\n  )\n\n\\<close>"], ["", "setup relator_props.setup"], ["", "setup solve_relator_props.setup"], ["", "declaration \\<open>\n  Tagged_Solver.declare_solver \n    @{thms relprop_triggers} \n    @{binding relator_props_solver}\n    \"Additional relator properties solver\"\n    (fn ctxt => (REPEAT_ALL_NEW (CHANGED o (\n      match_tac ctxt (solve_relator_props.get ctxt) ORELSE'\n      match_tac ctxt (relator_props.get ctxt)\n    ))))\n\\<close>"], ["", "declaration \\<open>\n  Tagged_Solver.declare_solver \n    []\n    @{binding force_relator_props_solver}\n    \"Additional relator properties solver (instantiate schematics)\"\n    (fn ctxt => (REPEAT_ALL_NEW (CHANGED o (\n      resolve_tac ctxt (solve_relator_props.get ctxt) ORELSE'\n      match_tac ctxt (relator_props.get ctxt)\n    ))))\n\\<close>"], ["", "lemma \n  relprop_id_orient[relator_props]: \"R=Id \\<Longrightarrow> Id=R\" and\n  relprop_eq_refl[solve_relator_props]: \"t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R = Id \\<Longrightarrow> Id = R) &&& t = t", "by auto"], ["", "lemma \n  relprop_UNIV_orient[relator_props]: \"R=UNIV \\<Longrightarrow> UNIV=R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = UNIV \\<Longrightarrow> UNIV = R", "by auto"], ["", "subsubsection \\<open>ML-Level utilities\\<close>"], ["", "ML \\<open>\n  signature RELATORS = sig\n    val mk_relT: typ * typ -> typ\n    val dest_relT: typ -> typ * typ\n\n    val mk_relAPP: term -> term -> term\n    val list_relAPP: term list -> term -> term\n    val strip_relAPP: term -> term list * term \n    val mk_fun_rel: term -> term -> term\n\n    val list_rel: term list -> term -> term\n\n    val rel_absT: term -> typ\n    val rel_concT: term -> typ\n\n    val mk_prodrel: term * term -> term\n    val is_prodrel: term -> bool\n    val dest_prodrel: term -> term * term\n\n    val strip_prodrel_left: term -> term list\n    val list_prodrel_left: term list -> term\n\n\n    val declare_natural_relator: \n      (string*string) -> Context.generic -> Context.generic\n    val remove_natural_relator: string -> Context.generic -> Context.generic\n    val natural_relator_of: Proof.context -> string -> string option\n\n    val mk_natural_relator: Proof.context -> term list -> string -> term option\n\n    val setup: theory -> theory\n  end\n\n  structure Relators :RELATORS = struct\n    val mk_relT = HOLogic.mk_prodT #> HOLogic.mk_setT\n\n    fun dest_relT (Type (@{type_name set},[Type (@{type_name prod},[cT,aT])])) \n      = (cT,aT)\n      | dest_relT ty = raise TYPE (\"dest_relT\",[ty],[])\n\n    fun mk_relAPP x f = let\n      val xT = fastype_of x\n      val fT = fastype_of f\n      val rT = range_type fT\n    in \n      Const (@{const_name relAPP},fT-->xT-->rT)$f$x\n    end\n\n    val list_relAPP = fold mk_relAPP\n\n    fun strip_relAPP R = let\n      fun aux @{mpat \"\\<langle>?R\\<rangle>?S\"} l = aux S (R::l)\n        | aux R l = (l,R)\n    in aux R [] end\n\n    val rel_absT = fastype_of #> HOLogic.dest_setT #> HOLogic.dest_prodT #> snd\n    val rel_concT = fastype_of #> HOLogic.dest_setT #> HOLogic.dest_prodT #> fst\n\n    fun mk_fun_rel r1 r2 = let\n      val (r1T,r2T) = (fastype_of r1,fastype_of r2)\n      val (c1T,a1T) = dest_relT r1T\n      val (c2T,a2T) = dest_relT r2T\n      val (cT,aT) = (c1T --> c2T, a1T --> a2T)\n      val rT = mk_relT (cT,aT)\n    in \n      list_relAPP [r1,r2] (Const (@{const_name fun_rel},r1T-->r2T-->rT))\n    end\n\n    val list_rel = fold_rev mk_fun_rel\n\n    fun mk_prodrel (A,B) = @{mk_term \"?A \\<times>\\<^sub>r ?B\"}\n    fun is_prodrel @{mpat \"_ \\<times>\\<^sub>r _\"} = true | is_prodrel _ = false\n    fun dest_prodrel @{mpat \"?A \\<times>\\<^sub>r ?B\"} = (A,B) | dest_prodrel t = raise TERM(\"dest_prodrel\",[t])\n\n    fun strip_prodrel_left @{mpat \"?A \\<times>\\<^sub>r ?B\"} = strip_prodrel_left A @ [B]\n      | strip_prodrel_left @{mpat (typs) \"unit_rel\"} = []\n      | strip_prodrel_left R = [R]\n\n    val list_prodrel_left = Refine_Util.list_binop_left @{term unit_rel} mk_prodrel\n\n    structure natural_relators = Generic_Data (\n      type T = string Symtab.table\n      val empty = Symtab.empty\n      val extend = I\n      val merge = Symtab.join (fn _ => fn (_,cn) => cn)\n    )\n\n    fun declare_natural_relator tcp =\n      natural_relators.map (Symtab.update tcp)\n\n    fun remove_natural_relator tname =\n      natural_relators.map (Symtab.delete_safe tname)\n\n    fun natural_relator_of ctxt =\n      Symtab.lookup (natural_relators.get (Context.Proof ctxt))\n\n    (* [R1,\\<dots>,Rn] T is mapped to \\<langle>R1,\\<dots>,Rn\\<rangle> Trel *)\n    fun mk_natural_relator ctxt args Tname = \n      case natural_relator_of ctxt Tname of\n        NONE => NONE\n      | SOME Cname => SOME let\n          val argsT = map fastype_of args\n          val (cTs, aTs) = map dest_relT argsT |> split_list\n          val aT = Type (Tname,aTs)\n          val cT = Type (Tname,cTs)\n          val rT = mk_relT (cT,aT)\n        in\n          list_relAPP args (Const (Cname,argsT--->rT))\n        end\n\n    fun \n      natural_relator_from_term (t as Const (name,T)) = let\n        fun err msg = raise TERM (msg,[t])\n  \n        val (argTs,bodyT) = strip_type T\n        val (conTs,absTs) = argTs |> map (HOLogic.dest_setT #> HOLogic.dest_prodT) |> split_list\n        val (bconT,babsT) = bodyT |> HOLogic.dest_setT |> HOLogic.dest_prodT\n        val (Tcon,bconTs) = dest_Type bconT\n        val (Tcon',babsTs) = dest_Type babsT\n  \n        val _ = Tcon = Tcon' orelse err \"Type constructors do not match\"\n        val _ = conTs = bconTs orelse err \"Concrete types do not match\"\n        val _ = absTs = babsTs orelse err \"Abstract types do not match\"\n\n      in \n        (Tcon,name)\n      end\n    | natural_relator_from_term t = \n        raise TERM (\"Expected constant\",[t]) (* TODO: Localize this! *)\n\n    local\n      fun decl_natrel_aux t context = let\n        fun warn msg = let\n          val tP = \n            Context.cases Syntax.pretty_term_global Syntax.pretty_term \n              context t\n          val m = Pretty.block [\n            Pretty.str \"Ignoring invalid natural_relator declaration:\",\n            Pretty.brk 1,\n            Pretty.str msg,\n            Pretty.brk 1,\n            tP\n          ] |> Pretty.string_of\n          val _ = warning m\n        in context end \n      in\n        declare_natural_relator (natural_relator_from_term t) context\n        handle \n          TERM (msg,_) => warn msg\n        | exn => if Exn.is_interrupt exn then Exn.reraise exn else warn \"\"\n      end\n    in\n      val natural_relator_attr = Scan.repeat1 Args.term >> (fn ts => \n        Thm.declaration_attribute ( fn _ => fold decl_natrel_aux ts)\n      )\n    end\n  \n\n    val setup = I\n      #> Attrib.setup \n        @{binding natural_relator} natural_relator_attr \"Declare natural relator\"\n\n  end\n\\<close>"], ["", "setup Relators.setup"], ["", "subsection \\<open>Setup\\<close>"], ["", "subsubsection \"Natural Relators\""], ["", "declare [[natural_relator \n  unit_rel int_rel nat_rel bool_rel\n  fun_rel prod_rel option_rel sum_rel list_rel\n  ]]"], ["", "(*declaration {* let open Relators in \n  fn _ =>\n     declare_natural_relator (@{type_name unit},@{const_name unit_rel})\n  #> declare_natural_relator (@{type_name fun},@{const_name fun_rel})\n  #> declare_natural_relator (@{type_name prod},@{const_name prod_rel})\n  #> declare_natural_relator (@{type_name option},@{const_name option_rel})\n  #> declare_natural_relator (@{type_name sum},@{const_name sum_rel})\n  #> declare_natural_relator (@{type_name list},@{const_name list_rel})\n  \nend\n*}*)"], ["", "ML_val \\<open>\n  Relators.mk_natural_relator \n    @{context} \n    [@{term \"Ra::('c\\<times>'a) set\"},@{term \"\\<langle>Rb\\<rangle>option_rel\"}] \n    @{type_name prod}\n  |> the\n  |> Thm.cterm_of @{context}\n;\n  Relators.mk_fun_rel @{term \"\\<langle>Id\\<rangle>option_rel\"} @{term \"\\<langle>Id\\<rangle>list_rel\"}\n  |> Thm.cterm_of @{context}\n\\<close>"], ["", "subsubsection \"Additional Properties\""], ["", "lemmas [relator_props] = \n  single_valued_Id\n  subset_refl\n  refl"], ["", "(* TODO: Move *)"], ["", "lemma eq_UNIV_iff: \"S=UNIV \\<longleftrightarrow> (\\<forall>x. x\\<in>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S = UNIV) = (\\<forall>x. x \\<in> S)", "by auto"], ["", "lemma fun_rel_sv[relator_props]: \n  assumes RAN: \"Range Ra = UNIV\" \n  assumes SV: \"single_valued Rv\"\n  shows \"single_valued (Ra \\<rightarrow> Rv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (Ra \\<rightarrow> Rv)", "proof (intro single_valuedI ext impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "fix f g h x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "assume R1: \"(f,g)\\<in>Ra\\<rightarrow>Rv\"\n  and R2: \"(f,h)\\<in>Ra\\<rightarrow>Rv\""], ["proof (state)\nthis:\n  (f, g) \\<in> Ra \\<rightarrow> Rv\n  (f, h) \\<in> Ra \\<rightarrow> Rv\n\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "from RAN"], ["proof (chain)\npicking this:\n  Range Ra = UNIV", "obtain x where AR: \"(x,x')\\<in>Ra\""], ["proof (prove)\nusing this:\n  Range Ra = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x. (x, x') \\<in> Ra \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, x') \\<in> Ra\n\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "from fun_relD[OF R1 AR]"], ["proof (chain)\npicking this:\n  (f x, g x') \\<in> Rv", "have \"(f x,g x') \\<in> Rv\""], ["proof (prove)\nusing this:\n  (f x, g x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. (f x, g x') \\<in> Rv", "."], ["proof (state)\nthis:\n  (f x, g x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "moreover"], ["proof (state)\nthis:\n  (f x, g x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "from fun_relD[OF R2 AR]"], ["proof (chain)\npicking this:\n  (f x, h x') \\<in> Rv", "have \"(f x,h x') \\<in> Rv\""], ["proof (prove)\nusing this:\n  (f x, h x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. (f x, h x') \\<in> Rv", "."], ["proof (state)\nthis:\n  (f x, h x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>x y z xa.\n       \\<lbrakk>(x, y) \\<in> Ra \\<rightarrow> Rv;\n        (x, z) \\<in> Ra \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> y xa = z xa", "ultimately"], ["proof (chain)\npicking this:\n  (f x, g x') \\<in> Rv\n  (f x, h x') \\<in> Rv", "show \"g x' = h x'\""], ["proof (prove)\nusing this:\n  (f x, g x') \\<in> Rv\n  (f x, h x') \\<in> Rv\n\ngoal (1 subgoal):\n 1. g x' = h x'", "using SV"], ["proof (prove)\nusing this:\n  (f x, g x') \\<in> Rv\n  (f x, h x') \\<in> Rv\n  single_valued Rv\n\ngoal (1 subgoal):\n 1. g x' = h x'", "by (auto dest: single_valuedD)"], ["proof (state)\nthis:\n  g x' = h x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [relator_props] = Range_Id"], ["", "lemma fun_rel_id[relator_props]: \"\\<lbrakk>R1=Id; R2=Id\\<rbrakk> \\<Longrightarrow> R1 \\<rightarrow> R2 = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 = Id; R2 = Id\\<rbrakk>\n    \\<Longrightarrow> R1 \\<rightarrow> R2 = Id", "by (auto simp: fun_rel_def)"], ["", "lemma fun_rel_id_simp[simp]: \"Id\\<rightarrow>Id = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<rightarrow> Id = Id", "by tagged_solver"], ["", "lemma fun_rel_comp_dist[relator_props]: \n  \"(R1\\<rightarrow>R2) O (R3\\<rightarrow>R4) \\<subseteq> ((R1 O R3) \\<rightarrow> (R2 O R4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R1 \\<rightarrow> R2) O (R3 \\<rightarrow> R4)\n    \\<subseteq> R1 O R3 \\<rightarrow> R2 O R4", "by (auto simp: fun_rel_def)"], ["", "lemma fun_rel_mono[relator_props]: \"\\<lbrakk> R1\\<subseteq>R2; R3\\<subseteq>R4 \\<rbrakk> \\<Longrightarrow> R2\\<rightarrow>R3 \\<subseteq> R1\\<rightarrow>R4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 \\<subseteq> R2; R3 \\<subseteq> R4\\<rbrakk>\n    \\<Longrightarrow> R2 \\<rightarrow> R3 \\<subseteq> R1 \\<rightarrow> R4", "by (force simp: fun_rel_def)"], ["", "lemma prod_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued R1; single_valued R2\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R1,R2\\<rangle>prod_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R1; single_valued R2\\<rbrakk>\n    \\<Longrightarrow> single_valued (R1 \\<times>\\<^sub>r R2)", "by (auto intro: single_valuedI dest: single_valuedD simp: prod_rel_def)"], ["", "lemma prod_rel_id[relator_props]: \"\\<lbrakk>R1=Id; R2=Id\\<rbrakk> \\<Longrightarrow> \\<langle>R1,R2\\<rangle>prod_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 = Id; R2 = Id\\<rbrakk>\n    \\<Longrightarrow> R1 \\<times>\\<^sub>r R2 = Id", "by (auto simp: prod_rel_def)"], ["", "lemma prod_rel_id_simp[simp]: \"\\<langle>Id,Id\\<rangle>prod_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<times>\\<^sub>r Id = Id", "by tagged_solver"], ["", "lemma prod_rel_mono[relator_props]: \n\"\\<lbrakk> R2\\<subseteq>R1; R3\\<subseteq>R4 \\<rbrakk> \\<Longrightarrow> \\<langle>R2,R3\\<rangle>prod_rel \\<subseteq> \\<langle>R1,R4\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R2 \\<subseteq> R1; R3 \\<subseteq> R4\\<rbrakk>\n    \\<Longrightarrow> R2 \\<times>\\<^sub>r R3\n                      \\<subseteq> R1 \\<times>\\<^sub>r R4", "by (auto simp: prod_rel_def)"], ["", "lemma prod_rel_range[relator_props]: \"\\<lbrakk>Range Ra=UNIV; Range Rb=UNIV\\<rbrakk> \n  \\<Longrightarrow> Range (\\<langle>Ra,Rb\\<rangle>prod_rel) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Ra = UNIV; Range Rb = UNIV\\<rbrakk>\n    \\<Longrightarrow> Range (Ra \\<times>\\<^sub>r Rb) = UNIV", "apply (auto simp: prod_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>Range Ra = UNIV; Range Rb = UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa. (aa, a) \\<in> Ra\n 2. \\<And>b.\n       \\<lbrakk>Range Ra = UNIV; Range Rb = UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba. (ba, b) \\<in> Rb", "by (metis Range_iff UNIV_I)+"], ["", "lemma option_rel_sv[relator_props]:\n  \"\\<lbrakk>single_valued R\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>option_rel)", "by (auto intro: single_valuedI dest: single_valuedD simp: option_rel_def)"], ["", "lemma option_rel_id[relator_props]: \n  \"R=Id \\<Longrightarrow> \\<langle>R\\<rangle>option_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> \\<langle>R\\<rangle>option_rel = Id", "by (auto simp: option_rel_def)"], ["", "lemma option_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>option_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>option_rel = Id", "by tagged_solver"], ["", "lemma option_rel_mono[relator_props]: \"R\\<subseteq>R' \\<Longrightarrow> \\<langle>R\\<rangle>option_rel \\<subseteq> \\<langle>R'\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> R' \\<Longrightarrow>\n    \\<langle>R\\<rangle>option_rel \\<subseteq> \\<langle>R'\\<rangle>option_rel", "by (auto simp: option_rel_def)"], ["", "lemma option_rel_range: \"Range R = UNIV \\<Longrightarrow> Range (\\<langle>R\\<rangle>option_rel) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range R = UNIV \\<Longrightarrow>\n    Range (\\<langle>R\\<rangle>option_rel) = UNIV", "apply (auto simp: option_rel_def Range_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Range R = UNIV;\n        \\<forall>a a'.\n           x = Some a' \\<longrightarrow> (a, a') \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> x = None", "by (metis Range_iff UNIV_I option.exhaust)"], ["", "lemma option_rel_inter[simp]: \"\\<langle>R1 \\<inter> R2\\<rangle>option_rel = \\<langle>R1\\<rangle>option_rel \\<inter> \\<langle>R2\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R1 \\<inter> R2\\<rangle>option_rel =\n    \\<langle>R1\\<rangle>option_rel \\<inter> \\<langle>R2\\<rangle>option_rel", "by (auto simp: option_rel_def)"], ["", "lemma option_rel_constraint[simp]: \n  \"(x,x)\\<in>\\<langle>UNIV\\<times>C\\<rangle>option_rel \\<longleftrightarrow> (\\<forall>v. x=Some v \\<longrightarrow> v\\<in>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, x) \\<in> \\<langle>UNIV \\<times> C\\<rangle>option_rel) =\n    (\\<forall>v. x = Some v \\<longrightarrow> v \\<in> C)", "by (auto simp: option_rel_def)"], ["", "lemma sum_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rr\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rl,Rr\\<rangle>sum_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rl; single_valued Rr\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rl, Rr\\<rangle>sum_rel)", "by (auto intro: single_valuedI dest: single_valuedD simp: sum_rel_def)"], ["", "lemma sum_rel_id[relator_props]: \"\\<lbrakk>Rl=Id; Rr=Id\\<rbrakk> \\<Longrightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rl = Id; Rr = Id\\<rbrakk>\n    \\<Longrightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel = Id", "apply (auto elim: sum_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>Rl = Id; Rr = Id\\<rbrakk>\n       \\<Longrightarrow> (b, b) \\<in> \\<langle>Id, Id\\<rangle>sum_rel", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a.\n       \\<lbrakk>Rl = Id; Rr = Id; b = Inl a\\<rbrakk>\n       \\<Longrightarrow> (b, b) \\<in> \\<langle>Id, Id\\<rangle>sum_rel\n 2. \\<And>b ba.\n       \\<lbrakk>Rl = Id; Rr = Id; b = Inr ba\\<rbrakk>\n       \\<Longrightarrow> (b, b) \\<in> \\<langle>Id, Id\\<rangle>sum_rel", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_rel_id_simp[simp]: \"\\<langle>Id,Id\\<rangle>sum_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>sum_rel = Id", "by tagged_solver"], ["", "lemma sum_rel_mono[relator_props]:\n  \"\\<lbrakk> Rl\\<subseteq>Rl'; Rr\\<subseteq>Rr' \\<rbrakk> \\<Longrightarrow> \\<langle>Rl,Rr\\<rangle>sum_rel \\<subseteq> \\<langle>Rl',Rr'\\<rangle>sum_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rl \\<subseteq> Rl'; Rr \\<subseteq> Rr'\\<rbrakk>\n    \\<Longrightarrow> \\<langle>Rl, Rr\\<rangle>sum_rel\n                      \\<subseteq> \\<langle>Rl', Rr'\\<rangle>sum_rel", "by (auto simp: sum_rel_def)"], ["", "lemma sum_rel_range[relator_props]:\n  \"\\<lbrakk> Range Rl=UNIV; Range Rr=UNIV \\<rbrakk> \\<Longrightarrow> Range (\\<langle>Rl,Rr\\<rangle>sum_rel) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rl = UNIV; Range Rr = UNIV\\<rbrakk>\n    \\<Longrightarrow> Range (\\<langle>Rl, Rr\\<rangle>sum_rel) = UNIV", "apply (auto simp: sum_rel_def Range_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Range Rl = UNIV; Range Rr = UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>a.\n                                y = Inl a \\<and>\n                                (\\<exists>a'.\n                                    x = Inl a' \\<and>\n                                    (a, a') \\<in> Rl)) \\<or>\n                            (\\<exists>a.\n                                y = Inr a \\<and>\n                                (\\<exists>a'.\n                                    x = Inr a' \\<and> (a, a') \\<in> Rr))", "by (metis Range_iff UNIV_I sumE)"], ["", "lemma list_rel_sv_iff: \n  \"single_valued (\\<langle>R\\<rangle>list_rel) \\<longleftrightarrow> single_valued R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>R\\<rangle>list_rel) = single_valued R", "apply (intro iffI[rotated] single_valuedI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R; (x, y) \\<in> \\<langle>R\\<rangle>list_rel;\n        (x, z) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp simp: list_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume SV: \"single_valued R\""], ["proof (state)\nthis:\n  single_valued R\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y\" and\n    \"list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\""], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "thus \"y=z\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x y\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> R) x z\n\ngoal (1 subgoal):\n 1. y = z", "apply (induct arbitrary: z rule: list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) [] z \\<Longrightarrow>\n       [] = z\n 2. \\<And>x x' ls ls' z.\n       \\<lbrakk>(x, x') \\<in> R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls ls';\n        \\<And>z.\n           list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls z \\<Longrightarrow>\n           ls' = z;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) (x # ls) z\\<rbrakk>\n       \\<Longrightarrow> x' # ls' = z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls' z.\n       \\<lbrakk>(x, x') \\<in> R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls ls';\n        \\<And>z.\n           list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls z \\<Longrightarrow>\n           ls' = z;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) (x # ls) z\\<rbrakk>\n       \\<Longrightarrow> x' # ls' = z", "apply (case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' ls ls' z.\n       \\<lbrakk>(x, x') \\<in> R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls ls';\n        \\<And>z.\n           list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls z \\<Longrightarrow>\n           ls' = z;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) (x # ls) z;\n        z = []\\<rbrakk>\n       \\<Longrightarrow> x' # ls' = z\n 2. \\<And>x x' ls ls' z a list.\n       \\<lbrakk>(x, x') \\<in> R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls ls';\n        \\<And>z.\n           list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls z \\<Longrightarrow>\n           ls' = z;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) (x # ls) z;\n        z = a # list\\<rbrakk>\n       \\<Longrightarrow> x' # ls' = z", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls' z a list.\n       \\<lbrakk>(x, x') \\<in> R;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls ls';\n        \\<And>z.\n           list_all2 (\\<lambda>x x'. (x, x') \\<in> R) ls z \\<Longrightarrow>\n           ls' = z;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> R) (x # ls) z;\n        z = a # list\\<rbrakk>\n       \\<Longrightarrow> x' # ls' = z", "apply (force intro: single_valuedD[OF SV])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume SV: \"single_valued (\\<langle>R\\<rangle>list_rel)\""], ["proof (state)\nthis:\n  single_valued (\\<langle>R\\<rangle>list_rel)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"(x,y)\\<in>R\" \"(x,z)\\<in>R\""], ["proof (state)\nthis:\n  (x, y) \\<in> R\n  (x, z) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "hence \"([x],[y])\\<in>\\<langle>R\\<rangle>list_rel\" and \"([x],[z])\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\n  (x, z) \\<in> R\n\ngoal (1 subgoal):\n 1. ([x], [y]) \\<in> \\<langle>R\\<rangle>list_rel &&&\n    ([x], [z]) \\<in> \\<langle>R\\<rangle>list_rel", "by (auto simp: list_rel_def)"], ["proof (state)\nthis:\n  ([x], [y]) \\<in> \\<langle>R\\<rangle>list_rel\n  ([x], [z]) \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued (\\<langle>R\\<rangle>list_rel); (x, y) \\<in> R;\n        (x, z) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> y = z", "with single_valuedD[OF SV]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> \\<langle>R\\<rangle>list_rel;\n   (?x, ?z) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n  ([x], [y]) \\<in> \\<langle>R\\<rangle>list_rel\n  ([x], [z]) \\<in> \\<langle>R\\<rangle>list_rel", "show \"y=z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> \\<langle>R\\<rangle>list_rel;\n   (?x, ?z) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n  ([x], [y]) \\<in> \\<langle>R\\<rangle>list_rel\n  ([x], [z]) \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. y = z", "by blast"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>list_rel)", "by (simp add: list_rel_sv_iff)"], ["", "lemma list_rel_id[relator_props]: \"\\<lbrakk>R=Id\\<rbrakk> \\<Longrightarrow> \\<langle>R\\<rangle>list_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> \\<langle>R\\<rangle>list_rel = Id", "by (auto simp add: list_rel_def list_all2_eq[symmetric])"], ["", "lemma list_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>list_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>list_rel = Id", "by tagged_solver"], ["", "lemma list_rel_mono[relator_props]: \n  assumes A: \"R\\<subseteq>R'\" \n  shows \"\\<langle>R\\<rangle>list_rel \\<subseteq> \\<langle>R'\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>list_rel \\<subseteq> \\<langle>R'\\<rangle>list_rel", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       (a, b) \\<in> \\<langle>R'\\<rangle>list_rel", "fix l l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       (a, b) \\<in> \\<langle>R'\\<rangle>list_rel", "assume \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       (a, b) \\<in> \\<langle>R'\\<rangle>list_rel", "thus \"(l,l')\\<in>\\<langle>R'\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (l, l') \\<in> \\<langle>R'\\<rangle>list_rel", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([], []) \\<in> \\<langle>R'\\<rangle>list_rel\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        (l, l') \\<in> \\<langle>R'\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x # l, x' # l') \\<in> \\<langle>R'\\<rangle>list_rel", "using A"], ["proof (prove)\nusing this:\n  R \\<subseteq> R'\n\ngoal (2 subgoals):\n 1. ([], []) \\<in> \\<langle>R'\\<rangle>list_rel\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        (l, l') \\<in> \\<langle>R'\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x # l, x' # l') \\<in> \\<langle>R'\\<rangle>list_rel", "by auto"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>R'\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_rel_range[relator_props]:\n  assumes A: \"Range R = UNIV\"\n  shows \"Range (\\<langle>R\\<rangle>list_rel) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (\\<langle>R\\<rangle>list_rel) = UNIV", "proof (clarsimp simp: eq_UNIV_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Range (\\<langle>R\\<rangle>list_rel)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Range (\\<langle>R\\<rangle>list_rel)", "show \"l\\<in>Range (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> Range (\\<langle>R\\<rangle>list_rel)", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<in> Range (\\<langle>R\\<rangle>list_rel)\n 2. \\<And>a l.\n       l \\<in> Range (\\<langle>R\\<rangle>list_rel) \\<Longrightarrow>\n       a # l \\<in> Range (\\<langle>R\\<rangle>list_rel)", "using A[unfolded eq_UNIV_iff]"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> Range R\n\ngoal (2 subgoals):\n 1. [] \\<in> Range (\\<langle>R\\<rangle>list_rel)\n 2. \\<And>a l.\n       l \\<in> Range (\\<langle>R\\<rangle>list_rel) \\<Longrightarrow>\n       a # l \\<in> Range (\\<langle>R\\<rangle>list_rel)", "by (auto simp: Range_iff intro: list_relI)"], ["proof (state)\nthis:\n  l \\<in> Range (\\<langle>R\\<rangle>list_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bijective_imp_sv:  \n  \"bijective R \\<Longrightarrow> single_valued R\"\n  \"bijective R \\<Longrightarrow> single_valued (R\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bijective R \\<Longrightarrow> single_valued R) &&&\n    (bijective R \\<Longrightarrow> single_valued (R\\<inverse>))", "by (simp_all add: bijective_alt)"], ["", "(* TODO: Move *)"], ["", "declare bijective_Id[relator_props]"], ["", "declare bijective_Empty[relator_props]"], ["", "text \\<open>Pointwise refinement for set types:\\<close>"], ["", "lemma set_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>set_rel)", "unfolding single_valued_def set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> R \\<longrightarrow>\n       (\\<forall>z.\n           (x, z) \\<in> R \\<longrightarrow> y = z) \\<Longrightarrow>\n    \\<forall>x y.\n       (x, y)\n       \\<in> {(A, B).\n              (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n              (\\<forall>y\\<in>B.\n                  \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<longrightarrow>\n       (\\<forall>z.\n           (x, z)\n           \\<in> {(A, B).\n                  (\\<forall>x\\<in>A.\n                      \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                  (\\<forall>y\\<in>B.\n                      \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<longrightarrow>\n           y = z)", "by blast"], ["", "lemma set_rel_id[relator_props]: \"R=Id \\<Longrightarrow> \\<langle>R\\<rangle>set_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> \\<langle>R\\<rangle>set_rel = Id", "by (auto simp add: set_rel_def)"], ["", "lemma set_rel_id_simp[simp]: \"\\<langle>Id\\<rangle>set_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>set_rel = Id", "by tagged_solver"], ["", "lemma set_rel_csv[relator_props]:\n  \"\\<lbrakk> single_valued (R\\<inverse>) \\<rbrakk> \n  \\<Longrightarrow> single_valued ((\\<langle>R\\<rangle>set_rel)\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (R\\<inverse>) \\<Longrightarrow>\n    single_valued ((\\<langle>R\\<rangle>set_rel)\\<inverse>)", "unfolding single_valued_def set_rel_def converse_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (y, x) \\<in> R \\<longrightarrow>\n       (\\<forall>z.\n           (z, x) \\<in> R \\<longrightarrow> y = z) \\<Longrightarrow>\n    \\<forall>x y.\n       (y, x)\n       \\<in> {(A, B).\n              (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n              (\\<forall>y\\<in>B.\n                  \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<longrightarrow>\n       (\\<forall>z.\n           (z, x)\n           \\<in> {(A, B).\n                  (\\<forall>x\\<in>A.\n                      \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n                  (\\<forall>y\\<in>B.\n                      \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<longrightarrow>\n           y = z)", "by fast"], ["", "subsection \\<open>Invariant and Abstraction\\<close>"], ["", "text \\<open>\n  Quite often, a relation can be described as combination of an\n  abstraction function and an invariant, such that the invariant describes valid\n  values on the concrete domain, and the abstraction function maps valid \n  concrete values to its corresponding abstract value.\n\\<close>"], ["", "definition build_rel where \n  \"build_rel \\<alpha> I \\<equiv> {(c,a) . a=\\<alpha> c \\<and> I c}\""], ["", "abbreviation \"br\\<equiv>build_rel\""], ["", "lemmas br_def[refine_rel_defs] = build_rel_def"], ["", "lemma in_br_conv: \"(c,a)\\<in>br \\<alpha> I \\<longleftrightarrow> a=\\<alpha> c \\<and> I c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, a) \\<in> br \\<alpha> I) = (a = \\<alpha> c \\<and> I c)", "by (auto simp: br_def)"], ["", "lemma brI[intro?]: \"\\<lbrakk> a=\\<alpha> c; I c \\<rbrakk> \\<Longrightarrow> (c,a)\\<in>br \\<alpha> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = \\<alpha> c; I c\\<rbrakk>\n    \\<Longrightarrow> (c, a) \\<in> br \\<alpha> I", "by (simp add: br_def)"], ["", "lemma br_id[simp]: \"br id (\\<lambda>_. True) = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br id (\\<lambda>_. True) = Id", "unfolding build_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(c, a). a = id c \\<and> True} = Id", "by auto"], ["", "lemma br_chain: \n  \"(build_rel \\<beta> J) O (build_rel \\<alpha> I) = build_rel (\\<alpha>\\<circ>\\<beta>) (\\<lambda>s. J s \\<and> I (\\<beta> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br \\<beta> J O br \\<alpha> I =\n    br (\\<alpha> \\<circ> \\<beta>) (\\<lambda>s. J s \\<and> I (\\<beta> s))", "unfolding build_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(c, a). a = \\<beta> c \\<and> J c} O\n    {(c, a). a = \\<alpha> c \\<and> I c} =\n    {(c, a).\n     a = (\\<alpha> \\<circ> \\<beta>) c \\<and> J c \\<and> I (\\<beta> c)}", "by auto"], ["", "lemma br_sv[simp, intro!,relator_props]: \"single_valued (br \\<alpha> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br \\<alpha> I)", "unfolding build_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued {(c, a). a = \\<alpha> c \\<and> I c}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> {(c, a). a = \\<alpha> c \\<and> I c};\n        (x, z) \\<in> {(c, a). a = \\<alpha> c \\<and> I c}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma converse_br_sv_iff[simp]: \n  \"single_valued (converse (br \\<alpha> I)) \\<longleftrightarrow> inj_on \\<alpha> (Collect I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued ((br \\<alpha> I)\\<inverse>) = inj_on \\<alpha> (Collect I)", "by (auto intro!: inj_onI single_valuedI dest: single_valuedD inj_onD\n    simp: br_def) []"], ["", "lemmas [relator_props] = single_valued_relcomp"], ["", "lemma br_comp_alt: \"br \\<alpha> I O R = { (c,a) . I c \\<and> (\\<alpha> c,a)\\<in>R }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br \\<alpha> I O R = {(c, a). I c \\<and> (\\<alpha> c, a) \\<in> R}", "by (auto simp add: br_def)"], ["", "lemma br_comp_alt': \n  \"{(c,a) . a=\\<alpha> c \\<and> I c} O R = { (c,a) . I c \\<and> (\\<alpha> c,a)\\<in>R }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(c, a). a = \\<alpha> c \\<and> I c} O R =\n    {(c, a). I c \\<and> (\\<alpha> c, a) \\<in> R}", "by auto"], ["", "lemma single_valued_as_brE:\n  assumes \"single_valued R\"\n  obtains \\<alpha> invar where \"R=br \\<alpha> invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> invar.\n        R = br \\<alpha> invar \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule that[of \"\\<lambda>x. THE y. (x,y)\\<in>R\" \"\\<lambda>x. x\\<in>Domain R\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> invar.\n        R = br \\<alpha> invar \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R =\n    br (\\<lambda>x. THE y. (x, y) \\<in> R) (\\<lambda>x. x \\<in> Domain R)", "using assms"], ["proof (prove)\nusing this:\n  single_valued R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> invar.\n        R = br \\<alpha> invar \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R =\n    br (\\<lambda>x. THE y. (x, y) \\<in> R) (\\<lambda>x. x \\<in> Domain R)", "unfolding br_def"], ["proof (prove)\nusing this:\n  single_valued R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> invar.\n        R = {(c, a). a = \\<alpha> c \\<and> invar c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    R = {(c, a). a = (THE y. (c, y) \\<in> R) \\<and> c \\<in> Domain R}", "by (auto dest: single_valuedD \n    intro: the_equality[symmetric] theI)"], ["", "lemma sv_add_invar: \n  \"single_valued R \\<Longrightarrow> single_valued {(c, a). (c, a) \\<in> R \\<and> I c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued {(c, a). (c, a) \\<in> R \\<and> I c}", "by (auto dest: single_valuedD intro: single_valuedI)"], ["", "lemma br_Image_conv[simp]: \"br \\<alpha> I `` S = {\\<alpha> x | x. x\\<in>S \\<and> I x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br \\<alpha> I `` S = {\\<alpha> x |x. x \\<in> S \\<and> I x}", "by (auto simp: br_def)"], ["", "subsection \\<open>Miscellanneous\\<close>"], ["", "lemma rel_cong: \"(f,g)\\<in>Id \\<Longrightarrow> (x,y)\\<in>Id \\<Longrightarrow> (f x, g y)\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> Id; (x, y) \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> Id", "by simp"], ["", "lemma rel_fun_cong: \"(f,g)\\<in>Id \\<Longrightarrow> (f x, g x)\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> Id \\<Longrightarrow> (f x, g x) \\<in> Id", "by simp"], ["", "lemma rel_arg_cong: \"(x,y)\\<in>Id \\<Longrightarrow> (f x, f y)\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Id \\<Longrightarrow> (f x, f y) \\<in> Id", "by simp"], ["", "subsection \\<open>Conversion between Predicate and Set Based Relators\\<close>"], ["", "text \\<open>\n  Autoref uses set-based relators of type @{typ \\<open>('a\\<times>'b) set\\<close>}, while the \n  transfer and lifting package of Isabelle/HOL uses predicate based relators\n  of type @{typ \\<open>'a \\<Rightarrow> 'b \\<Rightarrow> bool\\<close>}. This section defines some utilities \n  to convert between the two.\n\\<close>"], ["", "definition \"rel2p R x y \\<equiv> (x,y)\\<in>R\""], ["", "definition \"p2rel P \\<equiv> {(x,y). P x y}\""], ["", "lemma rel2pD: \"\\<lbrakk>rel2p R a b\\<rbrakk> \\<Longrightarrow> (a,b)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p R a b \\<Longrightarrow> (a, b) \\<in> R", "by (auto simp: rel2p_def)"], ["", "lemma p2relD: \"\\<lbrakk>(a,b) \\<in> p2rel R\\<rbrakk> \\<Longrightarrow> R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> p2rel R \\<Longrightarrow> R a b", "by (auto simp: p2rel_def)"], ["", "lemma rel2p_inv[simp]:\n  \"rel2p (p2rel P) = P\"\n  \"p2rel (rel2p R) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p (p2rel P) = P &&& p2rel (rel2p R) = R", "by (auto simp: rel2p_def[abs_def] p2rel_def)"], ["", "named_theorems rel2p"], ["", "named_theorems p2rel"], ["", "lemma rel2p_dflt[rel2p]:\n  \"rel2p Id = (=)\"\n  \"rel2p (A\\<rightarrow>B) = rel_fun (rel2p A) (rel2p B)\"\n  \"rel2p (A\\<times>\\<^sub>rB) = rel_prod (rel2p A) (rel2p B)\"\n  \"rel2p (\\<langle>A,B\\<rangle>sum_rel) = rel_sum (rel2p A) (rel2p B)\"\n  \"rel2p (\\<langle>A\\<rangle>option_rel) = rel_option (rel2p A)\"\n  \"rel2p (\\<langle>A\\<rangle>list_rel) = list_all2 (rel2p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel2p Id = (=) &&&\n     rel2p (A \\<rightarrow> B) = rel_fun (rel2p A) (rel2p B) &&&\n     rel2p (A \\<times>\\<^sub>r B) = rel_prod (rel2p A) (rel2p B)) &&&\n    rel2p (\\<langle>A, B\\<rangle>sum_rel) = rel_sum (rel2p A) (rel2p B) &&&\n    rel2p (\\<langle>A\\<rangle>option_rel) = rel_option (rel2p A) &&&\n    rel2p (\\<langle>A\\<rangle>list_rel) = list_all2 (rel2p A)", "by (auto \n    simp: rel2p_def[abs_def] \n    intro!: ext\n    simp: fun_rel_def rel_fun_def \n    simp: sum_rel_def elim: rel_sum.cases\n    simp: option_rel_def elim: option.rel_cases\n    simp: list_rel_def\n    simp: set_rel_def rel_set_def Image_def\n    )"], ["", "lemma p2rel_dflt[p2rel]: \n  \"p2rel (=) = Id\"\n  \"p2rel (rel_fun A B) = p2rel A \\<rightarrow> p2rel B\"\n  \"p2rel (rel_prod A B) = p2rel A \\<times>\\<^sub>r p2rel B\"\n  \"p2rel (rel_sum A B) = \\<langle>p2rel A, p2rel B\\<rangle>sum_rel\"\n  \"p2rel (rel_option A) = \\<langle>p2rel A\\<rangle>option_rel\"\n  \"p2rel (list_all2 A) = \\<langle>p2rel A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p2rel (=) = Id &&&\n     p2rel (rel_fun A B) = p2rel A \\<rightarrow> p2rel B &&&\n     p2rel (rel_prod A B) = p2rel A \\<times>\\<^sub>r p2rel B) &&&\n    p2rel (rel_sum A B) = \\<langle>p2rel A, p2rel B\\<rangle>sum_rel &&&\n    p2rel (rel_option A) = \\<langle>p2rel A\\<rangle>option_rel &&&\n    p2rel (list_all2 A) = \\<langle>p2rel A\\<rangle>list_rel", "by (auto \n    simp: p2rel_def[abs_def] \n    simp: fun_rel_def rel_fun_def \n    simp: sum_rel_def elim: rel_sum.cases\n    simp: option_rel_def elim: option.rel_cases\n    simp: list_rel_def\n    )"], ["", "lemma [rel2p]: \"rel2p (\\<langle>A\\<rangle>set_rel) = rel_set (rel2p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p (\\<langle>A\\<rangle>set_rel) = rel_set (rel2p A)", "unfolding set_rel_def rel_set_def rel2p_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y.\n        (x, y)\n        \\<in> {(Aa, B).\n               (\\<forall>x\\<in>Aa. \\<exists>y\\<in>B. (x, y) \\<in> A) \\<and>\n               (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. (x, y) \\<in> A)}) =\n    (\\<lambda>Aa B.\n        (\\<forall>x\\<in>Aa. \\<exists>y\\<in>B. (x, y) \\<in> A) \\<and>\n        (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. (x, y) \\<in> A))", "by blast"], ["", "lemma [p2rel]: \"left_unique A \\<Longrightarrow> p2rel (rel_set A) = (\\<langle>p2rel A\\<rangle>set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique A \\<Longrightarrow>\n    p2rel (rel_set A) = \\<langle>p2rel A\\<rangle>set_rel", "unfolding set_rel_def rel_set_def p2rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique A \\<Longrightarrow>\n    {(Aa, B).\n     (\\<forall>x\\<in>Aa. Bex B (A x)) \\<and>\n     (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. A x y)} =\n    {(Aa, B).\n     (\\<forall>x\\<in>Aa.\n         \\<exists>y\\<in>B. (x, y) \\<in> {(x, y). A x y}) \\<and>\n     (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. (x, y) \\<in> {(x, y). A x y})}", "by blast"], ["", "lemma rel2p_comp: \"rel2p A OO rel2p B = rel2p (A O B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p A OO rel2p B = rel2p (A O B)", "by (auto simp: rel2p_def[abs_def] intro!: ext)"], ["", "lemma rel2p_inj[simp]: \"rel2p A = rel2p B \\<longleftrightarrow> A=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel2p A = rel2p B) = (A = B)", "by (auto simp: rel2p_def[abs_def]; meson)"], ["", "subsection \\<open>More Properties\\<close>"], ["", "(* TODO: Do compp-lemmas for other standard relations *)"], ["", "lemma list_rel_compp: \"\\<langle>A O B\\<rangle>list_rel = \\<langle>A\\<rangle>list_rel O \\<langle>B\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>list_rel =\n    \\<langle>A\\<rangle>list_rel O \\<langle>B\\<rangle>list_rel", "using list.rel_compp[of \"rel2p A\" \"rel2p B\"]"], ["proof (prove)\nusing this:\n  list_all2 (rel2p A OO rel2p B) =\n  list_all2 (rel2p A) OO list_all2 (rel2p B)\n\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>list_rel =\n    \\<langle>A\\<rangle>list_rel O \\<langle>B\\<rangle>list_rel", "by (auto simp: rel2p(2-)[symmetric] rel2p_comp)"], ["", "(* TODO: Not very systematic proof *)"], ["", "lemma option_rel_compp: \"\\<langle>A O B\\<rangle>option_rel = \\<langle>A\\<rangle>option_rel O \\<langle>B\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>option_rel =\n    \\<langle>A\\<rangle>option_rel O \\<langle>B\\<rangle>option_rel", "using option.rel_compp[of \"rel2p A\" \"rel2p B\"]"], ["proof (prove)\nusing this:\n  rel_option (rel2p A OO rel2p B) =\n  rel_option (rel2p A) OO rel_option (rel2p B)\n\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>option_rel =\n    \\<langle>A\\<rangle>option_rel O \\<langle>B\\<rangle>option_rel", "by (auto simp: rel2p(2-)[symmetric] rel2p_comp)"], ["", "(* TODO: Not very systematic proof *)"], ["", "lemma prod_rel_compp: \"\\<langle>A O B, C O D\\<rangle>prod_rel = \\<langle>A,C\\<rangle>prod_rel O \\<langle>B,D\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A O B \\<times>\\<^sub>r C O D =\n    (A \\<times>\\<^sub>r C) O (B \\<times>\\<^sub>r D)", "using prod.rel_compp[of \"rel2p A\" \"rel2p B\" \"rel2p C\" \"rel2p D\"]"], ["proof (prove)\nusing this:\n  rel_prod (rel2p A OO rel2p B) (rel2p C OO rel2p D) =\n  rel_prod (rel2p A) (rel2p C) OO rel_prod (rel2p B) (rel2p D)\n\ngoal (1 subgoal):\n 1. A O B \\<times>\\<^sub>r C O D =\n    (A \\<times>\\<^sub>r C) O (B \\<times>\\<^sub>r D)", "by (auto simp: rel2p(2-)[symmetric] rel2p_comp)"], ["", "(* TODO: Not very systematic proof *)"], ["", "lemma sum_rel_compp: \"\\<langle>A O B, C O D\\<rangle>sum_rel = \\<langle>A,C\\<rangle>sum_rel O \\<langle>B,D\\<rangle>sum_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A O B, C O D\\<rangle>sum_rel =\n    \\<langle>A, C\\<rangle>sum_rel O \\<langle>B, D\\<rangle>sum_rel", "using sum.rel_compp[of \"rel2p A\" \"rel2p B\" \"rel2p C\" \"rel2p D\"]"], ["proof (prove)\nusing this:\n  rel_sum (rel2p A OO rel2p B) (rel2p C OO rel2p D) =\n  rel_sum (rel2p A) (rel2p C) OO rel_sum (rel2p B) (rel2p D)\n\ngoal (1 subgoal):\n 1. \\<langle>A O B, C O D\\<rangle>sum_rel =\n    \\<langle>A, C\\<rangle>sum_rel O \\<langle>B, D\\<rangle>sum_rel", "by (auto simp: rel2p(2-)[symmetric] rel2p_comp)"], ["", "(* TODO: Not very systematic proof *)"], ["", "lemma set_rel_compp: \"\\<langle>A O B\\<rangle>set_rel = \\<langle>A\\<rangle>set_rel O \\<langle>B\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>set_rel =\n    \\<langle>A\\<rangle>set_rel O \\<langle>B\\<rangle>set_rel", "using rel_set_OO[of \"rel2p A\" \"rel2p B\"]"], ["proof (prove)\nusing this:\n  rel_set (rel2p A) OO rel_set (rel2p B) = rel_set (rel2p A OO rel2p B)\n\ngoal (1 subgoal):\n 1. \\<langle>A O B\\<rangle>set_rel =\n    \\<langle>A\\<rangle>set_rel O \\<langle>B\\<rangle>set_rel", "by (auto simp: rel2p(2-)[symmetric] rel2p_comp)"], ["", "(* TODO: Not very systematic proof *)"], ["", "lemma map_in_list_rel_conv: \n  shows \"(l, map \\<alpha> l) \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<longleftrightarrow> (\\<forall>x\\<in>set l. I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, map \\<alpha> l) \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n    (\\<forall>x\\<in>set l. I x)", "by (induction l) (auto simp: in_br_conv)"], ["", "lemma br_set_rel_alt: \"(s',s)\\<in>\\<langle>br \\<alpha> I\\<rangle>set_rel \\<longleftrightarrow> (s=\\<alpha>`s' \\<and> (\\<forall>x\\<in>s'. I x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s', s) \\<in> \\<langle>br \\<alpha> I\\<rangle>set_rel) =\n    (s = \\<alpha> ` s' \\<and> (\\<forall>x\\<in>s'. I x))", "by (auto simp: set_rel_def br_def)"], ["", "(* TODO: Find proof that does not depend on br, and move to Misc *)"], ["", "lemma finite_Image_sv: \"single_valued R \\<Longrightarrow> finite s \\<Longrightarrow> finite (R``s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; finite s\\<rbrakk>\n    \\<Longrightarrow> finite (R `` s)", "by (erule single_valued_as_brE) simp"], ["", "lemma finite_set_rel_transfer: \"\\<lbrakk>(s,s')\\<in>\\<langle>R\\<rangle>set_rel; single_valued R; finite s\\<rbrakk> \\<Longrightarrow> finite s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> \\<langle>R\\<rangle>set_rel; single_valued R;\n     finite s\\<rbrakk>\n    \\<Longrightarrow> finite s'", "unfolding set_rel_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> {(A, B).\n                    A \\<subseteq> R\\<inverse> `` B \\<and>\n                    B \\<subseteq> R `` A};\n     single_valued R; finite s\\<rbrakk>\n    \\<Longrightarrow> finite s'", "by (blast intro: finite_subset[OF _ finite_Image_sv])"], ["", "lemma finite_set_rel_transfer_back: \"\\<lbrakk>(s,s')\\<in>\\<langle>R\\<rangle>set_rel; single_valued (R\\<inverse>); finite s'\\<rbrakk> \\<Longrightarrow> finite s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> \\<langle>R\\<rangle>set_rel;\n     single_valued (R\\<inverse>); finite s'\\<rbrakk>\n    \\<Longrightarrow> finite s", "unfolding set_rel_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> {(A, B).\n                    A \\<subseteq> R\\<inverse> `` B \\<and>\n                    B \\<subseteq> R `` A};\n     single_valued (R\\<inverse>); finite s'\\<rbrakk>\n    \\<Longrightarrow> finite s", "by (blast intro: finite_subset[OF _ finite_Image_sv])"], ["", "end"]]}