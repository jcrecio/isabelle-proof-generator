{"file_name": "/home/qj213/afp-2021-10-22/thys/ADS_Functor/Merkle_Interface.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ADS_Functor", "problem_names": ["lemma vimage2p_mono': \"R \\<le> S \\<Longrightarrow> vimage2p f g R \\<le> vimage2p f g S\"", "lemma vimage2p_map_rel_prod: \n  \"vimage2p (map_prod f g) (map_prod f' g') (rel_prod A B) = rel_prod (vimage2p f f' A) (vimage2p g g' B)\"", "lemma vimage2p_map_list_all2:\n  \"vimage2p (map f) (map g) (list_all2 A) = list_all2 (vimage2p f g A)\"", "lemma equivclp_least:\n  assumes le: \"r \\<le> s\" and s: \"equivp s\"\n  shows \"equivclp r \\<le> s\"", "lemma reflp_eq_onp: \"reflp R \\<longleftrightarrow> eq_onp (\\<lambda>x. True) \\<le> R\"", "lemma eq_onpE:\n  assumes \"eq_onp P x y\"\n  obtains \"x = y\" \"P y\"", "lemma case_unit_parametric [transfer_rule]: \"rel_fun A (rel_fun (=) A) case_unit case_unit\"", "lemma reflp: \"reflp bo\"", "lemma antisymp: \"antisymp bo\"", "lemma transp: \"transp bo\"", "lemma hash: \"bo \\<le> vimage2p h h (=)\"", "lemma join: \"m a b = Some ab \\<longleftrightarrow> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\"", "lemma equivclp_blinding_of: \"equivclp bo = vimage2p h h (=)\" (is \"?lhs = ?rhs\")", "lemma blinding_hash_eq: \"bo x y \\<Longrightarrow> h x = h y\"", "lemma refl_pointfree: \"eq_onp (\\<lambda>x. x \\<in> A) \\<le> bo\"", "lemma blinding_respects_hashes: \"blinding_respects_hashes h bo\"", "lemmas hash = hash", "lemma trans_pointfree: \"eq_onp (\\<lambda>x. x \\<in> A) OO bo OO bo \\<le> bo\"", "lemma antisym_pointfree: \"inf (eq_onp (\\<lambda>x. x \\<in> A) OO bo) bo\\<inverse>\\<inverse> \\<le> (=)\"", "lemma same: \"a \\<in> A \\<Longrightarrow> m a a = Some a\"", "lemma blinding_of_antisym_on: \"blinding_of_on UNIV h bo\"", "lemma transp: \"transp bo\"", "lemmas hash = hash\n  and refl = refl\n  and antisym = antisym[OF _ _ UNIV_I]", "lemma respects_hashes:\n  \"a \\<in> A \\<Longrightarrow> h a = h b \\<longleftrightarrow> (\\<exists>ab. m a b = Some ab)\"", "lemma join':\n  \"a \\<in> A \\<Longrightarrow> \\<forall>ab. m a b = Some ab \\<longleftrightarrow> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\"", "lemma merge_on_subset:\n  \"B \\<subseteq> A \\<Longrightarrow> merge_on B h bo m\"", "lemma merkle_interface_aux: \"merkle_interface h bo m = merge_on UNIV h bo m\" \n  (is \"?lhs = ?rhs\")", "lemma merkle_interfaceI [locale_witness]:\n  assumes \"merge_on UNIV h bo m\"\n  shows \"merkle_interface h bo m\"", "lemma (in merkle_interface) merkle_interfaceD: \"merge_on UNIV h bo m\"", "lemma blinding_respects_hashes_parametric [transfer_rule]:\n  \"((A1 ===> A2) ===> (A1 ===> A1 ===> (\\<longleftrightarrow>)) ===> (\\<longleftrightarrow>))\n   blinding_respects_hashes blinding_respects_hashes\"\n  if [transfer_rule]: \"bi_unique A2\" \"bi_total A1\""], "translations": [["", "lemma vimage2p_mono': \"R \\<le> S \\<Longrightarrow> vimage2p f g R \\<le> vimage2p f g S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> S \\<Longrightarrow> vimage2p f g R \\<le> vimage2p f g S", "by(auto simp add: vimage2p_def le_fun_def)"], ["", "lemma vimage2p_map_rel_prod: \n  \"vimage2p (map_prod f g) (map_prod f' g') (rel_prod A B) = rel_prod (vimage2p f f' A) (vimage2p g g' B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vimage2p (map_prod f g) (map_prod f' g') (rel_prod A B) =\n    rel_prod (vimage2p f f' A) (vimage2p g g' B)", "by(simp add: vimage2p_def prod.rel_map)"], ["", "lemma vimage2p_map_list_all2:\n  \"vimage2p (map f) (map g) (list_all2 A) = list_all2 (vimage2p f g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vimage2p (map f) (map g) (list_all2 A) = list_all2 (vimage2p f g A)", "by(simp add: vimage2p_def list.rel_map)"], ["", "lemma equivclp_least:\n  assumes le: \"r \\<le> s\" and s: \"equivp s\"\n  shows \"equivclp r \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivclp r \\<le> s", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. equivclp r x y \\<Longrightarrow> s x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivclp r x_ y_ \\<Longrightarrow> s x_ y_", "by(induction rule: equivclp_induct)(auto 4 3 intro: equivp_reflp[OF s] equivp_transp[OF s] equivp_symp[OF s] le[THEN predicate2D])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reflp_eq_onp: \"reflp R \\<longleftrightarrow> eq_onp (\\<lambda>x. True) \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp R = (eq_onp (\\<lambda>x. True) \\<le> R)", "by(auto simp add: reflp_def eq_onp_def)"], ["", "lemma eq_onpE:\n  assumes \"eq_onp P x y\"\n  obtains \"x = y\" \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x = y; P y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  eq_onp P x y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x = y; P y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: eq_onp_def)"], ["", "lemma case_unit_parametric [transfer_rule]: \"rel_fun A (rel_fun (=) A) case_unit case_unit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun A (rel_fun (=) A) case_unit case_unit", "by(simp add: rel_fun_def split: unit.split)"], ["", "(************************************************************)"], ["", "section \\<open>Authenticated Data Structures\\<close>"], ["", "(************************************************************)\n\n(************************************************************)"], ["", "subsection \\<open>Interface\\<close>"], ["", "(************************************************************)\n\n(************************************************************)"], ["", "subsubsection \\<open> Types \\<close>"], ["", "(************************************************************)"], ["", "type_synonym ('a\\<^sub>m, 'a\\<^sub>h) hash = \"'a\\<^sub>m \\<Rightarrow> 'a\\<^sub>h\" \\<comment> \\<open>Type of hash operation\\<close>"], ["", "type_synonym 'a\\<^sub>m blinding_of = \"'a\\<^sub>m \\<Rightarrow> 'a\\<^sub>m \\<Rightarrow> bool\""], ["", "type_synonym 'a\\<^sub>m merge = \"'a\\<^sub>m \\<Rightarrow> 'a\\<^sub>m \\<Rightarrow> 'a\\<^sub>m option\" \\<comment> \\<open> merging that can fail for values with different hashes\\<close>"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Properties \\<close>"], ["", "(************************************************************)"], ["", "locale merkle_interface =\n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and bo :: \"'a\\<^sub>m blinding_of\"\n    and m :: \"'a\\<^sub>m merge\"\n  assumes merge_respects_hashes: \"h a = h b \\<longleftrightarrow> (\\<exists>ab. m a b = Some ab)\"\n    and idem: \"m a a = Some a\"\n    and commute: \"m a b = m b a\"\n    and assoc: \"m a b \\<bind> m c = m b c \\<bind> m a\"\n    and bo_def: \"bo a b \\<longleftrightarrow> m a b = Some b\"\nbegin"], ["", "lemma reflp: \"reflp bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp bo", "unfolding bo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (\\<lambda>a b. m a b = Some b)", "by(rule reflpI)(simp add: idem)"], ["", "lemma antisymp: \"antisymp bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymp bo", "unfolding bo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymp (\\<lambda>a b. m a b = Some b)", "by(rule antisympI)(simp add: commute)"], ["", "lemma transp: \"transp bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp bo", "apply(rule transpI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>bo x y; bo y z\\<rbrakk> \\<Longrightarrow> bo x z", "subgoal for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bo x y; bo y z\\<rbrakk> \\<Longrightarrow> bo x z", "using assoc[of x y z]"], ["proof (prove)\nusing this:\n  m x y \\<bind> m z = m y z \\<bind> m x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bo x y; bo y z\\<rbrakk> \\<Longrightarrow> bo x z", "by(simp add: commute bo_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hash: \"bo \\<le> vimage2p h h (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo \\<le> vimage2p h h (=)", "unfolding bo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b. m a b = Some b) \\<le> vimage2p h h (=)", "by(auto simp add: vimage2p_def merge_respects_hashes)"], ["", "lemma join: \"m a b = Some ab \\<longleftrightarrow> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m a b = Some ab) =\n    (bo a ab \\<and>\n     bo b ab \\<and>\n     (\\<forall>u.\n         bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u))", "unfolding bo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m a b = Some ab) =\n    (m a ab = Some ab \\<and>\n     m b ab = Some ab \\<and>\n     (\\<forall>u.\n         m a u = Some u \\<longrightarrow>\n         m b u = Some u \\<longrightarrow> m ab u = Some u))", "by (smt Option.bind_cong bind.bind_lunit commute idem merkle_interface.assoc merkle_interface_axioms)"], ["", "text \\<open>The equivalence closure of the blinding relation are the equivalence classes of the hash function (the kernel).\\<close>"], ["", "lemma equivclp_blinding_of: \"equivclp bo = vimage2p h h (=)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivclp bo = vimage2p h h (=)", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. equivclp bo \\<le> vimage2p h h (=)\n 2. vimage2p h h (=) \\<le> equivclp bo", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivclp bo \\<le> vimage2p h h (=)", "by(rule equivclp_least[OF hash])(rule equivp_vimage2p[OF identity_equivp])"], ["proof (state)\nthis:\n  equivclp bo \\<le> vimage2p h h (=)\n\ngoal (1 subgoal):\n 1. vimage2p h h (=) \\<le> equivclp bo", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vimage2p h h (=) \\<le> equivclp bo", "unfolding vimage2p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. h x = h y) \\<le> equivclp bo", "proof(rule predicate2I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "assume \"h x = h y\""], ["proof (state)\nthis:\n  h x = h y\n\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "then"], ["proof (chain)\npicking this:\n  h x = h y", "obtain xy where \"m x y = Some xy\""], ["proof (prove)\nusing this:\n  h x = h y\n\ngoal (1 subgoal):\n 1. (\\<And>xy. m x y = Some xy \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_respects_hashes"], ["proof (prove)\nusing this:\n  \\<exists>ab. m x y = Some ab\n\ngoal (1 subgoal):\n 1. (\\<And>xy. m x y = Some xy \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m x y = Some xy\n\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "hence \"bo x xy\" \"bo y xy\""], ["proof (prove)\nusing this:\n  m x y = Some xy\n\ngoal (1 subgoal):\n 1. bo x xy &&& bo y xy", "unfolding join"], ["proof (prove)\nusing this:\n  bo x xy \\<and>\n  bo y xy \\<and>\n  (\\<forall>u. bo x u \\<longrightarrow> bo y u \\<longrightarrow> bo xy u)\n\ngoal (1 subgoal):\n 1. bo x xy &&& bo y xy", "by blast+"], ["proof (state)\nthis:\n  bo x xy\n  bo y xy\n\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "hence \"equivclp bo x xy\" \"equivclp bo xy y\""], ["proof (prove)\nusing this:\n  bo x xy\n  bo y xy\n\ngoal (1 subgoal):\n 1. equivclp bo x xy &&& equivclp bo xy y", "by(blast)+"], ["proof (state)\nthis:\n  equivclp bo x xy\n  equivclp bo xy y\n\ngoal (1 subgoal):\n 1. \\<And>x y. h x = h y \\<Longrightarrow> equivclp bo x y", "thus \"equivclp bo x y\""], ["proof (prove)\nusing this:\n  equivclp bo x xy\n  equivclp bo xy y\n\ngoal (1 subgoal):\n 1. equivclp bo x y", "by(rule equivclp_trans)"], ["proof (state)\nthis:\n  equivclp bo x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vimage2p h h (=) \\<le> equivclp bo\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(************************************************************)"], ["", "subsection \\<open> Auxiliary definitions \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> Directly proving that an interface satisfies the specification of a Merkle interface as given\nabove is difficult. Instead, we provide several layers of auxiliary definitions that can easily be\nproved layer-by-layer. \n\nIn particular, proving that an interface on recursive datatypes is a Merkle interface requires\ninduction. As the induction hypothesis only applies to a subset of values of a type, we add\nauxiliary definitions equipped with an explicit set @{term A} of values to which the definition\napplies. Once the induction proof is complete, we can typically instantiate @{term A} with @{term\nUNIV}. In particular, in the induction proof for a layer, we can assume that properties for the\nearlier layers hold for \\<^emph>\\<open>all\\<close> values, not just those in the induction hypothesis.\n\\<close>"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "locale blinding_respects_hashes =\n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and bo :: \"'a\\<^sub>m blinding_of\"\n  assumes hash: \"bo \\<le> vimage2p h h (=)\"\nbegin"], ["", "lemma blinding_hash_eq: \"bo x y \\<Longrightarrow> h x = h y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo x y \\<Longrightarrow> h x = h y", "by(drule hash[THEN predicate2D])(simp add: vimage2p_def)"], ["", "end"], ["", "locale blinding_of_on =\n  blinding_respects_hashes h bo\n    for A :: \"'a\\<^sub>m set\"\n    and h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and bo :: \"'a\\<^sub>m blinding_of\"\n  + assumes refl: \"x \\<in> A \\<Longrightarrow> bo x x\"\n    and trans: \"\\<lbrakk> bo x y; bo y z; x \\<in> A \\<rbrakk> \\<Longrightarrow> bo x z\"\n    and antisym: \"\\<lbrakk> bo x y; bo y x; x \\<in> A \\<rbrakk> \\<Longrightarrow> x = y\"\nbegin"], ["", "lemma refl_pointfree: \"eq_onp (\\<lambda>x. x \\<in> A) \\<le> bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_onp (\\<lambda>x. x \\<in> A) \\<le> bo", "by(auto elim!: eq_onpE intro: refl)"], ["", "lemma blinding_respects_hashes: \"blinding_respects_hashes h bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_respects_hashes h bo", ".."], ["", "lemmas hash = hash"], ["", "lemma trans_pointfree: \"eq_onp (\\<lambda>x. x \\<in> A) OO bo OO bo \\<le> bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_onp (\\<lambda>x. x \\<in> A) OO bo OO bo \\<le> bo", "by(auto elim!: eq_onpE intro: trans)"], ["", "lemma antisym_pointfree: \"inf (eq_onp (\\<lambda>x. x \\<in> A) OO bo) bo\\<inverse>\\<inverse> \\<le> (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (eq_onp (\\<lambda>x. x \\<in> A) OO bo) bo\\<inverse>\\<inverse>\n    \\<le> (=)", "by(auto elim!: eq_onpE dest: antisym)"], ["", "end"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> In general, we prove the properties of blinding before the properties of merging. Thus,\n  in the following definitions we assume that the blinding properties already hold on @{term UNIV}.\n  The @{term Ball} restricts the argument of the merge operation on which induction will be done. \\<close>"], ["", "locale merge_on =\n  blinding_of_on UNIV h bo\n    for A :: \"'a\\<^sub>m set\"\n    and h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and bo :: \"'a\\<^sub>m blinding_of\" \n    and m :: \"'a\\<^sub>m merge\" +\n  assumes join: \"\\<lbrakk> h a = h b; a \\<in> A \\<rbrakk> \n      \\<Longrightarrow> \\<exists>ab. m a b = Some ab \\<and> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\"\n    and undefined: \"\\<lbrakk> h a \\<noteq> h b; a \\<in> A \\<rbrakk> \\<Longrightarrow> m a b = None\"\nbegin"], ["", "lemma same: \"a \\<in> A \\<Longrightarrow> m a a = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> m a a = Some a", "using join[of a a] refl[of a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>h a = h a; a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       m a a = Some ab \\<and>\n                       bo a ab \\<and>\n                       bo a ab \\<and>\n                       (\\<forall>u.\n                           bo a u \\<longrightarrow>\n                           bo a u \\<longrightarrow> bo ab u)\n  a \\<in> UNIV \\<Longrightarrow> bo a a\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> m a a = Some a", "by(auto 4 3 intro: antisym)"], ["", "lemma blinding_of_antisym_on: \"blinding_of_on UNIV h bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV h bo", ".."], ["", "lemma transp: \"transp bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp bo", "by(auto intro: transpI trans)"], ["", "lemmas hash = hash\n  and refl = refl\n  and antisym = antisym[OF _ _ UNIV_I]"], ["", "lemma respects_hashes:\n  \"a \\<in> A \\<Longrightarrow> h a = h b \\<longleftrightarrow> (\\<exists>ab. m a b = Some ab)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> (h a = h b) = (\\<exists>ab. m a b = Some ab)", "using join undefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>h ?a = h ?b; ?a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       m ?a ?b = Some ab \\<and>\n                       bo ?a ab \\<and>\n                       bo ?b ab \\<and>\n                       (\\<forall>u.\n                           bo ?a u \\<longrightarrow>\n                           bo ?b u \\<longrightarrow> bo ab u)\n  \\<lbrakk>h ?a \\<noteq> h ?b; ?a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> m ?a ?b = None\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> (h a = h b) = (\\<exists>ab. m a b = Some ab)", "by fastforce"], ["", "lemma join':\n  \"a \\<in> A \\<Longrightarrow> \\<forall>ab. m a b = Some ab \\<longleftrightarrow> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow>\n    \\<forall>ab.\n       (m a b = Some ab) =\n       (bo a ab \\<and>\n        bo b ab \\<and>\n        (\\<forall>u.\n            bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u))", "using join undefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>h ?a = h ?b; ?a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       m ?a ?b = Some ab \\<and>\n                       bo ?a ab \\<and>\n                       bo ?b ab \\<and>\n                       (\\<forall>u.\n                           bo ?a u \\<longrightarrow>\n                           bo ?b u \\<longrightarrow> bo ab u)\n  \\<lbrakk>h ?a \\<noteq> h ?b; ?a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> m ?a ?b = None\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow>\n    \\<forall>ab.\n       (m a b = Some ab) =\n       (bo a ab \\<and>\n        bo b ab \\<and>\n        (\\<forall>u.\n            bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u))", "by (metis (full_types) hash local.antisym option.distinct(1) option.sel predicate2D vimage2p_def)"], ["", "lemma merge_on_subset:\n  \"B \\<subseteq> A \\<Longrightarrow> merge_on B h bo m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow> merge_on B h bo m", "by unfold_locales (auto dest: same join undefined)"], ["", "end"], ["", "subsection \\<open> Interface equality \\<close>"], ["", "text \\<open> Here, we prove that the auxiliary definitions specify the same interface as the original ones.\\<close>"], ["", "lemma merkle_interface_aux: \"merkle_interface h bo m = merge_on UNIV h bo m\" \n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface h bo m = merge_on UNIV h bo m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. merkle_interface h bo m \\<Longrightarrow> merge_on UNIV h bo m\n 2. merge_on UNIV h bo m \\<Longrightarrow> merkle_interface h bo m", "show ?rhs if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. bo \\<le> vimage2p h h (=)\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>bo x y; bo y z; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> bo x z\n 4. \\<And>x y.\n       \\<lbrakk>bo x y; bo y x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 6. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "interpret merkle_interface h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface h bo m", "by(fact that)"], ["proof (state)\ngoal (6 subgoals):\n 1. bo \\<le> vimage2p h h (=)\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>bo x y; bo y z; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> bo x z\n 4. \\<And>x y.\n       \\<lbrakk>bo x y; bo y x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 6. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"bo \\<le> vimage2p h h (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo \\<le> vimage2p h h (=)", "by(fact hash)"], ["proof (state)\nthis:\n  bo \\<le> vimage2p h h (=)\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>bo x y; bo y z; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> bo x z\n 3. \\<And>x y.\n       \\<lbrakk>bo x y; bo y x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 5. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"bo x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bo x x", "using reflp"], ["proof (prove)\nusing this:\n  reflp bo\n\ngoal (1 subgoal):\n 1. bo x x", "by(simp add: reflp_def)"], ["proof (state)\nthis:\n  bo ?x ?x\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>bo x y; bo y z; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> bo x z\n 2. \\<And>x y.\n       \\<lbrakk>bo x y; bo y x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 4. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"bo x z\" if \"bo x y\" \"bo y z\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. bo x z", "using transp that"], ["proof (prove)\nusing this:\n  transp bo\n  bo x y\n  bo y z\n\ngoal (1 subgoal):\n 1. bo x z", "by(rule transpD)"], ["proof (state)\nthis:\n  \\<lbrakk>bo ?x ?y; bo ?y ?z\\<rbrakk> \\<Longrightarrow> bo ?x ?z\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>bo x y; bo y x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 3. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"x = y\" if \"bo x y\" \"bo y x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using antisymp that"], ["proof (prove)\nusing this:\n  antisymp bo\n  bo x y\n  bo y x\n\ngoal (1 subgoal):\n 1. x = y", "by(rule antisympD)"], ["proof (state)\nthis:\n  \\<lbrakk>bo ?x ?y; bo ?y ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            m a b = Some ab \\<and>\n                            bo a ab \\<and>\n                            bo b ab \\<and>\n                            (\\<forall>u.\n                                bo a u \\<longrightarrow>\n                                bo b u \\<longrightarrow> bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"\\<exists>ab. m a b = Some ab \\<and> bo a ab \\<and> bo b ab \\<and> (\\<forall>u. bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)\" if \"h a = h b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       m a b = Some ab \\<and>\n       bo a ab \\<and>\n       bo b ab \\<and>\n       (\\<forall>u.\n           bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)", "using that"], ["proof (prove)\nusing this:\n  h a = h b\n\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       m a b = Some ab \\<and>\n       bo a ab \\<and>\n       bo b ab \\<and>\n       (\\<forall>u.\n           bo a u \\<longrightarrow> bo b u \\<longrightarrow> bo ab u)", "by(simp add: merge_respects_hashes join)"], ["proof (state)\nthis:\n  h ?a = h ?b \\<Longrightarrow>\n  \\<exists>ab.\n     m ?a ?b = Some ab \\<and>\n     bo ?a ab \\<and>\n     bo ?b ab \\<and>\n     (\\<forall>u.\n         bo ?a u \\<longrightarrow> bo ?b u \\<longrightarrow> bo ab u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>h a \\<noteq> h b; a \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> m a b = None", "show \"m a b = None\" if \"h a \\<noteq> h b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a b = None", "using that"], ["proof (prove)\nusing this:\n  h a \\<noteq> h b\n\ngoal (1 subgoal):\n 1. m a b = None", "by(simp add: merge_respects_hashes)"], ["proof (state)\nthis:\n  h ?a \\<noteq> h ?b \\<Longrightarrow> m ?a ?b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merkle_interface h bo m \\<Longrightarrow> merge_on UNIV h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m \\<Longrightarrow> merkle_interface h bo m", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface h bo m", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b. (h a = h b) = (\\<exists>ab. m a b = Some ab)\n 2. \\<And>a. m a a = Some a\n 3. \\<And>a b. m a b = m b a\n 4. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 5. \\<And>a b. bo a b = (m a b = Some b)", "interpret merge_on UNIV h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "by(fact that)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b. (h a = h b) = (\\<exists>ab. m a b = Some ab)\n 2. \\<And>a. m a a = Some a\n 3. \\<And>a b. m a b = m b a\n 4. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 5. \\<And>a b. bo a b = (m a b = Some b)", "show eq: \"h a = h b \\<longleftrightarrow> (\\<exists>ab. m a b = Some ab)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h a = h b) = (\\<exists>ab. m a b = Some ab)", "by(simp add: respects_hashes)"], ["proof (state)\nthis:\n  (h ?a = h ?b) = (\\<exists>ab. m ?a ?b = Some ab)\n\ngoal (4 subgoals):\n 1. \\<And>a. m a a = Some a\n 2. \\<And>a b. m a b = m b a\n 3. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 4. \\<And>a b. bo a b = (m a b = Some b)", "show idem: \"m a a = Some a\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a a = Some a", "by(simp add: same)"], ["proof (state)\nthis:\n  m ?a ?a = Some ?a\n\ngoal (3 subgoals):\n 1. \\<And>a b. m a b = m b a\n 2. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 3. \\<And>a b. bo a b = (m a b = Some b)", "show commute: \"m a b = m b a\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a b = m b a", "using join[of a b] join[of b a] undefined antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>h a = h b; a \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       m a b = Some ab \\<and>\n                       bo a ab \\<and>\n                       bo b ab \\<and>\n                       (\\<forall>u.\n                           bo a u \\<longrightarrow>\n                           bo b u \\<longrightarrow> bo ab u)\n  \\<lbrakk>h b = h a; b \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       m b a = Some ab \\<and>\n                       bo b ab \\<and>\n                       bo a ab \\<and>\n                       (\\<forall>u.\n                           bo b u \\<longrightarrow>\n                           bo a u \\<longrightarrow> bo ab u)\n  \\<lbrakk>h ?a \\<noteq> h ?b; ?a \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> m ?a ?b = None\n  \\<lbrakk>bo ?x ?y; bo ?y ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. m a b = m b a", "by(cases \"m a b\") force+"], ["proof (state)\nthis:\n  m ?a ?b = m ?b ?a\n\ngoal (2 subgoals):\n 1. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 2. \\<And>a b. bo a b = (m a b = Some b)", "have undefined_partitioned: \"m a c = None\" if \"m a b = None\" \"m b c = Some bc\" for a b c bc"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a c = None", "using that eq"], ["proof (prove)\nusing this:\n  m a b = None\n  m b c = Some bc\n  (h ?a = h ?b) = (\\<exists>ab. m ?a ?b = Some ab)\n\ngoal (1 subgoal):\n 1. m a c = None", "by (metis option.distinct(1) option.exhaust)"], ["proof (state)\nthis:\n  \\<lbrakk>m ?a ?b = None; m ?b ?c = Some ?bc\\<rbrakk>\n  \\<Longrightarrow> m ?a ?c = None\n\ngoal (2 subgoals):\n 1. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 2. \\<And>a b. bo a b = (m a b = Some b)", "have merge_twice: \"m a b = Some c \\<Longrightarrow> m a c = Some c\" for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a b = Some c \\<Longrightarrow> m a c = Some c", "by (simp add: join')"], ["proof (state)\nthis:\n  m ?a ?b = Some ?c \\<Longrightarrow> m ?a ?c = Some ?c\n\ngoal (2 subgoals):\n 1. \\<And>a b c. m a b \\<bind> m c = m b c \\<bind> m a\n 2. \\<And>a b. bo a b = (m a b = Some b)", "show \"m a b \\<bind> m c = m b c \\<bind> m a\" for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. m a b \\<bind> m c = m b c \\<bind> m a", "proof(simp split: Option.bind_split; safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>m a b = None; m b c = Some v\\<rbrakk>\n       \\<Longrightarrow> None = m a v\n 2. \\<And>v.\n       \\<lbrakk>m a b = Some v; m b c = None\\<rbrakk>\n       \\<Longrightarrow> m c v = None\n 3. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "show \"None = m a d\" if \"m a b = None\" \"m b c = Some d\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. None = m a d", "using that"], ["proof (prove)\nusing this:\n  m a b = None\n  m b c = Some d\n\ngoal (1 subgoal):\n 1. None = m a d", "by(metis undefined_partitioned merge_twice)"], ["proof (state)\nthis:\n  \\<lbrakk>m a b = None; m b c = Some ?d\\<rbrakk>\n  \\<Longrightarrow> None = m a ?d\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>m a b = Some v; m b c = None\\<rbrakk>\n       \\<Longrightarrow> m c v = None\n 2. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "show \"m c d = None\" if \"m a b = Some d\" \"m b c = None\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. m c d = None", "using that"], ["proof (prove)\nusing this:\n  m a b = Some d\n  m b c = None\n\ngoal (1 subgoal):\n 1. m c d = None", "by(metis commute merge_twice undefined_partitioned)"], ["proof (state)\nthis:\n  \\<lbrakk>m a b = Some ?d; m b c = None\\<rbrakk>\n  \\<Longrightarrow> m c ?d = None\n\ngoal (1 subgoal):\n 1. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "fix ab bc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "assume assms: \"m a b = Some ab\" \"m b c = Some bc\""], ["proof (state)\nthis:\n  m a b = Some ab\n  m b c = Some bc\n\ngoal (1 subgoal):\n 1. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "then"], ["proof (chain)\npicking this:\n  m a b = Some ab\n  m b c = Some bc", "obtain cab and abc where cab: \"m c ab = Some cab\" and abc: \"m a bc = Some abc\""], ["proof (prove)\nusing this:\n  m a b = Some ab\n  m b c = Some bc\n\ngoal (1 subgoal):\n 1. (\\<And>cab abc.\n        \\<lbrakk>m c ab = Some cab; m a bc = Some abc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eq[THEN iffD2, OF exI] eq[THEN iffD1]"], ["proof (prove)\nusing this:\n  m a b = Some ab\n  m b c = Some bc\n  m ?a1 ?b1 = Some ?ab2 \\<Longrightarrow> h ?a1 = h ?b1\n  h ?a1 = h ?b1 \\<Longrightarrow> \\<exists>ab. m ?a1 ?b1 = Some ab\n\ngoal (1 subgoal):\n 1. (\\<And>cab abc.\n        \\<lbrakk>m c ab = Some cab; m a bc = Some abc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis merge_twice)"], ["proof (state)\nthis:\n  m c ab = Some cab\n  m a bc = Some abc\n\ngoal (1 subgoal):\n 1. \\<And>v va.\n       \\<lbrakk>m a b = Some v; m b c = Some va\\<rbrakk>\n       \\<Longrightarrow> m c v = m a va", "thus \"m c ab = m a bc\""], ["proof (prove)\nusing this:\n  m c ab = Some cab\n  m a bc = Some abc\n\ngoal (1 subgoal):\n 1. m c ab = m a bc", "using assms"], ["proof (prove)\nusing this:\n  m c ab = Some cab\n  m a bc = Some abc\n  m a b = Some ab\n  m b c = Some bc\n\ngoal (1 subgoal):\n 1. m c ab = m a bc", "by(clarsimp simp add: join')(metis UNIV_I abc cab local.antisym local.trans)"], ["proof (state)\nthis:\n  m c ab = m a bc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m ?a ?b \\<bind> m ?c = m ?b ?c \\<bind> m ?a\n\ngoal (1 subgoal):\n 1. \\<And>a b. bo a b = (m a b = Some b)", "show \"bo a b \\<longleftrightarrow> m a b = Some b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. bo a b = (m a b = Some b)", "using idem join'"], ["proof (prove)\nusing this:\n  m ?a ?a = Some ?a\n  ?a \\<in> UNIV \\<Longrightarrow>\n  \\<forall>ab.\n     (m ?a ?b = Some ab) =\n     (bo ?a ab \\<and>\n      bo ?b ab \\<and>\n      (\\<forall>u.\n          bo ?a u \\<longrightarrow> bo ?b u \\<longrightarrow> bo ab u))\n\ngoal (1 subgoal):\n 1. bo a b = (m a b = Some b)", "by auto"], ["proof (state)\nthis:\n  bo ?a ?b = (m ?a ?b = Some ?b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on UNIV h bo m \\<Longrightarrow> merkle_interface h bo m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merkle_interfaceI [locale_witness]:\n  assumes \"merge_on UNIV h bo m\"\n  shows \"merkle_interface h bo m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface h bo m", "using assms"], ["proof (prove)\nusing this:\n  merge_on UNIV h bo m\n\ngoal (1 subgoal):\n 1. merkle_interface h bo m", "unfolding merkle_interface_aux"], ["proof (prove)\nusing this:\n  merge_on UNIV h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "by auto"], ["", "lemma (in merkle_interface) merkle_interfaceD: \"merge_on UNIV h bo m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "using merkle_interface_aux[of h bo m, symmetric]"], ["proof (prove)\nusing this:\n  merge_on UNIV h bo m = merkle_interface h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "by simp unfold_locales"], ["", "subsection \\<open> Parametricity rules \\<close>"], ["", "context includes lifting_syntax begin"], ["", "parametric_constant le_fun_parametric[transfer_rule]: le_fun_def"], ["", "parametric_constant vimage2p_parametric[transfer_rule]: vimage2p_def"], ["", "parametric_constant blinding_respects_hashes_parametric_aux: blinding_respects_hashes_def"], ["", "lemma blinding_respects_hashes_parametric [transfer_rule]:\n  \"((A1 ===> A2) ===> (A1 ===> A1 ===> (\\<longleftrightarrow>)) ===> (\\<longleftrightarrow>))\n   blinding_respects_hashes blinding_respects_hashes\"\n  if [transfer_rule]: \"bi_unique A2\" \"bi_total A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A1 ===> A2) ===> (A1 ===> A1 ===> (=)) ===> (=))\n     blinding_respects_hashes blinding_respects_hashes", "by(rule blinding_respects_hashes_parametric_aux that le_fun_parametric | simp add: rel_fun_eq)+"], ["", "parametric_constant blinding_of_on_axioms_parametric [transfer_rule]:\n  blinding_of_on_axioms_def[folded Ball_def, unfolded le_fun_def le_bool_def eq_onp_def relcompp.simps, simplified]"], ["", "parametric_constant blinding_of_on_parametric [transfer_rule]: blinding_of_on_def"], ["", "parametric_constant antisymp_parametric[transfer_rule]: antisymp_def"], ["", "parametric_constant transp_parametric[transfer_rule]: transp_def"], ["", "parametric_constant merge_on_axioms_parametric [transfer_rule]: merge_on_axioms_def"], ["", "parametric_constant merge_on_parametric[transfer_rule]: merge_on_def"], ["", "parametric_constant merkle_interface_parametric[transfer_rule]: merkle_interface_def"], ["", "end"], ["", "end"]]}