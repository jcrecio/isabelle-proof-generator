{"file_name": "/home/qj213/afp-2021-10-22/thys/ADS_Functor/Canton_Transaction_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ADS_Functor", "problem_names": ["lemma merkle_view_data:\n  \"merkle_interface hash_view_data blinding_of_view_data merge_view_data\"", "lemma merkle_view_metadata:\n  \"merkle_interface hash_view_metadata blinding_of_view_metadata merge_view_metadata\"", "lemma from_to_view\\<^sub>h [simp]: \"from_view\\<^sub>h (to_view\\<^sub>h x) = x\"", "lemma to_from_view\\<^sub>h [simp]: \"to_view\\<^sub>h (from_view\\<^sub>h x) = x\"", "lemma iso_view\\<^sub>h: \"type_definition from_view\\<^sub>h to_view\\<^sub>h UNIV\"", "lemma cr_view\\<^sub>h_Grp: \"cr_view\\<^sub>h = Grp UNIV to_view\\<^sub>h\"", "lemma View\\<^sub>h_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_blindable\\<^sub>h (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===> pcr_view\\<^sub>h) Tree\\<^sub>h View\\<^sub>h\"", "lemma from_to_view\\<^sub>m [simp]: \"from_view\\<^sub>m (to_view\\<^sub>m x) = x\"", "lemma to_from_view\\<^sub>m [simp]: \"to_view\\<^sub>m (from_view\\<^sub>m x) = x\"", "lemma iso_view\\<^sub>m: \"type_definition from_view\\<^sub>m to_view\\<^sub>m UNIV\"", "lemma cr_view\\<^sub>m_Grp: \"cr_view\\<^sub>m = Grp UNIV to_view\\<^sub>m\"", "lemma View\\<^sub>m_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_blindable\\<^sub>m (rel_prod (=) (list_all2 pcr_view\\<^sub>m)) (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===> pcr_view\\<^sub>m) Tree\\<^sub>m View\\<^sub>m\"", "lemma merkle_view [locale_witness]: \"merkle_interface hash_view blinding_of_view merge_view\"", "lemma hash_view_simps [simp]:\n  \"hash_view (View\\<^sub>m x) = \n   View\\<^sub>h (hash_blindable (hash_prod hash_view_content (hash_list hash_view)) x)\"", "lemma blinding_of_view_iff [simp]:\n  \"blinding_of_view (View\\<^sub>m x) (View\\<^sub>m y) \\<longleftrightarrow>\n   blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))\n     (blinding_of_prod blinding_of_view_content (blinding_of_list blinding_of_view)) x y\"", "lemma blinding_of_view_induct [consumes 1, induct pred: blinding_of_view]:\n  assumes \"blinding_of_view x y\"\n    and \"\\<And>x y. blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))\n             (blinding_of_prod blinding_of_view_content (blinding_of_list (\\<lambda>x y. blinding_of_view x y \\<and> P x y))) x y\n         \\<Longrightarrow> P (View\\<^sub>m x) (View\\<^sub>m y)\"\n  shows \"P x y\"", "lemma merge_view_simps [simp]:\n  \"merge_view (View\\<^sub>m x) (View\\<^sub>m y) =\n   map_option View\\<^sub>m (merge_rt_F\\<^sub>m hash_view_content merge_view_content hash_view merge_view x y)\"", "lemma iso_transaction\\<^sub>h: \"type_definition the_Transaction\\<^sub>h Transaction\\<^sub>h UNIV\"", "lemma Transaction\\<^sub>h_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction\\<^sub>h) id Transaction\\<^sub>h\"", "lemma iso_transaction\\<^sub>m: \"type_definition the_Transaction\\<^sub>m Transaction\\<^sub>m UNIV\"", "lemma Transaction\\<^sub>m_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction\\<^sub>m) id Transaction\\<^sub>m\"", "lemma merkle_transaction [locale_witness]:\n  \"merkle_interface hash_transaction blinding_of_transaction merge_transaction\"", "lemmas hash_transaction_simps [simp] = hash_transaction.abs_eq", "lemmas blinding_of_transaction_iff [simp] = blinding_of_transaction.abs_eq", "lemmas merge_transaction_simps [simp] = merge_transaction.abs_eq", "lemma from_to_view [simp]: \"from_view (to_view x) = x\"", "lemma to_from_view [simp]: \"to_view (from_view x) = x\"", "lemma iso_view: \"type_definition from_view to_view UNIV\"", "lemma View_View': \"View = (\\<lambda>vm vd vs. View' ((vm, vd), vs))\"", "lemma cr_view_Grp: \"cr_view = Grp UNIV to_view\"", "lemma View'_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod (=) (list_all2 pcr_view) ===> pcr_view) Tree View'\"", "lemma embed_view_simps [simp]:\n  \"embed_view (View vm vd vs) = View\\<^sub>m (Unblinded ((Unblinded vm, Unblinded vd), map embed_view vs))\"", "lemma Transaction_Transaction': \"Transaction = (\\<lambda>cm pm views. Transaction' ((cm, pm), views))\"", "lemma the_Transaction_inverse [simp]: \"Transaction' (the_Transaction x) = x\"", "lemma Transaction'_inverse [simp]: \"the_Transaction (Transaction' x) = x\"", "lemma iso_transaction: \"type_definition the_Transaction Transaction' UNIV\"", "lemma Transaction'_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction) id Transaction'\"", "lemma embed_transaction_simps [simp]:\n  \"embed_transaction (Transaction cm pm views) =\n   Transaction\\<^sub>m (Unblinded ((Unblinded cm, Unblinded pm), map embed_view views))\" \n  for views", "lemma blinding_of_mediator_view [simp]: \"blinding_of_view (mediator_view view) (embed_view view)\"", "lemma blinding_of_mediator_transaction_tree:\n  \"blinding_of_transaction (mediator_transaction_tree tt) (embed_transaction tt)\"", "lemma view_of_zipper\\<^sub>m_Nil [simp]: \"view_of_zipper\\<^sub>m ([], t) = t\"", "lemma embed_view_path_Nil [simp]: \"embed_view_path [] = []\"", "lemma zippers_view_same_hash:\n  assumes \"z \\<in> set (zippers_view (p, t))\"\n  shows \"hash_view (view_of_zipper\\<^sub>m z) = hash_view (view_of_zipper\\<^sub>m (embed_view_path p, embed_view t))\"", "lemma zippers_view_blinding_of:\n  assumes \"z \\<in> set (zippers_view (p, t))\"\n  shows \"blinding_of_view (view_of_zipper\\<^sub>m z) (view_of_zipper\\<^sub>m (blind_view_path p, embed_view t))\"", "lemma hash_blind_view: \"hash_view (blind_view view) = hash_view (embed_view view)\"", "lemma hash_blind_transaction:\n  \"hash_transaction (blind_transaction transaction) = hash_transaction (embed_transaction transaction)\"", "lemma view_trees_for_same_hash:\n  \"vt \\<in> set (view_trees_for view) \\<Longrightarrow> hash_view vt = hash_view (embed_view view)\"", "lemma transaction_views_for_same_hash:\n  \"t\\<^sub>m \\<in> set (transaction_views_for t) \\<Longrightarrow> hash_transaction t\\<^sub>m = hash_transaction (embed_transaction t)\"", "lemma transaction_projection_for_same_hash:\n  \"hash_transaction (transaction_projection_for t) = hash_transaction (embed_transaction t)\"", "lemma transaction_projection_for_upper:\n  assumes \"t\\<^sub>m \\<in> set (transaction_views_for t)\"\n  shows \"blinding_of_transaction t\\<^sub>m (transaction_projection_for t)\""], "translations": [["", "lemma merkle_view_data:\n  \"merkle_interface hash_view_data blinding_of_view_data merge_view_data\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable id) (blinding_of_blindable id (=))\n     (merge_blindable id merge_discrete)", "by unfold_locales"], ["", "abbreviation (input) hash_view_metadata :: \"(view_metadata\\<^sub>m, view_metadata\\<^sub>h) hash\" where\n  \"hash_view_metadata \\<equiv> hash_blindable id\""], ["", "abbreviation (input) blinding_of_view_metadata :: \"view_metadata\\<^sub>m blinding_of\" where\n  \"blinding_of_view_metadata \\<equiv> blinding_of_blindable id (=)\""], ["", "abbreviation (input) merge_view_metadata :: \"view_metadata\\<^sub>m merge\" where\n  \"merge_view_metadata \\<equiv> merge_blindable id merge_discrete\""], ["", "lemma merkle_view_metadata:\n  \"merkle_interface hash_view_metadata blinding_of_view_metadata merge_view_metadata\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable id) (blinding_of_blindable id (=))\n     (merge_blindable id merge_discrete)", "by unfold_locales"], ["", "type_synonym view_content = \"view_metadata \\<times> view_data\""], ["", "type_synonym view_content\\<^sub>h = \"view_metadata\\<^sub>h \\<times>\\<^sub>h view_data\\<^sub>h\""], ["", "type_synonym view_content\\<^sub>m = \"view_metadata\\<^sub>m \\<times>\\<^sub>m view_data\\<^sub>m\""], ["", "locale view_merkle begin"], ["", "type_synonym view\\<^sub>h' = \"view_content\\<^sub>h rose_tree\\<^sub>h\""], ["", "primrec from_view\\<^sub>h :: \"view\\<^sub>h \\<Rightarrow> view\\<^sub>h'\" where\n  \"from_view\\<^sub>h (View\\<^sub>h x) = Tree\\<^sub>h (map_blindable\\<^sub>h (map_prod id (map from_view\\<^sub>h)) x)\""], ["", "primrec to_view\\<^sub>h :: \"view\\<^sub>h' \\<Rightarrow> view\\<^sub>h\" where\n  \"to_view\\<^sub>h (Tree\\<^sub>h x) = View\\<^sub>h (map_blindable\\<^sub>h (map_prod id (map to_view\\<^sub>h)) x)\""], ["", "lemma from_to_view\\<^sub>h [simp]: \"from_view\\<^sub>h (to_view\\<^sub>h x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_view\\<^sub>h (to_view\\<^sub>h x) = x", "apply(induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set_blindable\\<^sub>h xa; xaaa \\<in> snds xaa;\n            xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> from_view\\<^sub>h (to_view\\<^sub>h xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       from_view\\<^sub>h (to_view\\<^sub>h (Tree\\<^sub>h xa)) =\n       Tree\\<^sub>h xa", "apply(simp add: blindable\\<^sub>h.map_comp o_def prod.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set_blindable\\<^sub>h xa; xaaa \\<in> snds xaa;\n            xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> from_view\\<^sub>h (to_view\\<^sub>h xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       map_blindable\\<^sub>h\n        (map_prod (\\<lambda>x. x)\n          (map (\\<lambda>x. from_view\\<^sub>h (to_view\\<^sub>h x))))\n        xa =\n       xa", "apply(simp cong: blindable\\<^sub>h.map_cong prod.map_cong list.map_cong add: blindable\\<^sub>h.map_id[unfolded id_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_from_view\\<^sub>h [simp]: \"to_view\\<^sub>h (from_view\\<^sub>h x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_view\\<^sub>h (from_view\\<^sub>h x) = x", "apply(induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set_blindable\\<^sub>h xa; xaaa \\<in> snds xaa;\n            xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> to_view\\<^sub>h (from_view\\<^sub>h xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       to_view\\<^sub>h (from_view\\<^sub>h (View\\<^sub>h xa)) =\n       View\\<^sub>h xa", "apply(simp add: blindable\\<^sub>h.map_comp o_def prod.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set_blindable\\<^sub>h xa; xaaa \\<in> snds xaa;\n            xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> to_view\\<^sub>h (from_view\\<^sub>h xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       map_blindable\\<^sub>h\n        (map_prod (\\<lambda>x. x)\n          (map (\\<lambda>x. to_view\\<^sub>h (from_view\\<^sub>h x))))\n        xa =\n       xa", "apply(simp cong: blindable\\<^sub>h.map_cong prod.map_cong list.map_cong add: blindable\\<^sub>h.map_id[unfolded id_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iso_view\\<^sub>h: \"type_definition from_view\\<^sub>h to_view\\<^sub>h UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition from_view\\<^sub>h to_view\\<^sub>h UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_view\\<^sub>h"], ["", "lemma cr_view\\<^sub>h_Grp: \"cr_view\\<^sub>h = Grp UNIV to_view\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_view\\<^sub>h = Grp UNIV to_view\\<^sub>h", "by(simp add: cr_view\\<^sub>h_def Grp_def fun_eq_iff)(transfer, auto)"], ["", "lemma View\\<^sub>h_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_blindable\\<^sub>h (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===> pcr_view\\<^sub>h) Tree\\<^sub>h View\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===>\n     pcr_view\\<^sub>h)\n     Tree\\<^sub>h View\\<^sub>h", "by(simp add: rel_fun_def view\\<^sub>h.pcr_cr_eq cr_view\\<^sub>h_Grp list.rel_Grp eq_alt prod.rel_Grp blindable\\<^sub>h.rel_Grp)\n    (simp add: Grp_def)"], ["", "type_synonym view\\<^sub>m' = \"(view_content\\<^sub>m, view_content\\<^sub>h) rose_tree\\<^sub>m\""], ["", "primrec from_view\\<^sub>m :: \"view\\<^sub>m \\<Rightarrow> view\\<^sub>m'\" where\n  \"from_view\\<^sub>m (View\\<^sub>m x) = Tree\\<^sub>m (map_blindable\\<^sub>m (map_prod id (map from_view\\<^sub>m)) (map_prod id (map from_view\\<^sub>h)) x)\""], ["", "primrec to_view\\<^sub>m :: \"view\\<^sub>m' \\<Rightarrow> view\\<^sub>m\" where\n  \"to_view\\<^sub>m (Tree\\<^sub>m x) = View\\<^sub>m (map_blindable\\<^sub>m (map_prod id (map to_view\\<^sub>m)) (map_prod id (map to_view\\<^sub>h)) x)\""], ["", "lemma from_to_view\\<^sub>m [simp]: \"from_view\\<^sub>m (to_view\\<^sub>m x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_view\\<^sub>m (to_view\\<^sub>m x) = x", "apply(induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n            xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> from_view\\<^sub>m (to_view\\<^sub>m xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       from_view\\<^sub>m (to_view\\<^sub>m (Tree\\<^sub>m xa)) =\n       Tree\\<^sub>m xa", "apply(simp add: blindable\\<^sub>m.map_comp o_def prod.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n            xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> from_view\\<^sub>m (to_view\\<^sub>m xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       map_blindable\\<^sub>m\n        (map_prod (\\<lambda>x. x)\n          (map (\\<lambda>x. from_view\\<^sub>m (to_view\\<^sub>m x))))\n        (\\<lambda>x. x) xa =\n       xa", "apply(simp cong: blindable\\<^sub>m.map_cong prod.map_cong list.map_cong add: blindable\\<^sub>m.map_id[unfolded id_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_from_view\\<^sub>m [simp]: \"to_view\\<^sub>m (from_view\\<^sub>m x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_view\\<^sub>m (from_view\\<^sub>m x) = x", "apply(induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n            xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> to_view\\<^sub>m (from_view\\<^sub>m xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       to_view\\<^sub>m (from_view\\<^sub>m (View\\<^sub>m xa)) =\n       View\\<^sub>m xa", "apply(simp add: blindable\\<^sub>m.map_comp o_def prod.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa xaaaa.\n           \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n            xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa\\<rbrakk>\n           \\<Longrightarrow> to_view\\<^sub>m (from_view\\<^sub>m xaaaa) =\n                             xaaaa) \\<Longrightarrow>\n       map_blindable\\<^sub>m\n        (map_prod (\\<lambda>x. x)\n          (map (\\<lambda>x. to_view\\<^sub>m (from_view\\<^sub>m x))))\n        (\\<lambda>x. x) xa =\n       xa", "apply(simp cong: blindable\\<^sub>m.map_cong prod.map_cong list.map_cong add: blindable\\<^sub>m.map_id[unfolded id_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iso_view\\<^sub>m: \"type_definition from_view\\<^sub>m to_view\\<^sub>m UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition from_view\\<^sub>m to_view\\<^sub>m UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_view\\<^sub>m"], ["", "lemma cr_view\\<^sub>m_Grp: \"cr_view\\<^sub>m = Grp UNIV to_view\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_view\\<^sub>m = Grp UNIV to_view\\<^sub>m", "by(simp add: cr_view\\<^sub>m_def Grp_def fun_eq_iff)(transfer, auto)"], ["", "lemma View\\<^sub>m_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_blindable\\<^sub>m (rel_prod (=) (list_all2 pcr_view\\<^sub>m)) (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===> pcr_view\\<^sub>m) Tree\\<^sub>m View\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_blindable\\<^sub>m (rel_prod (=) (list_all2 pcr_view\\<^sub>m))\n      (rel_prod (=) (list_all2 pcr_view\\<^sub>h)) ===>\n     pcr_view\\<^sub>m)\n     Tree\\<^sub>m View\\<^sub>m", "by(simp add: rel_fun_def view\\<^sub>h.pcr_cr_eq view\\<^sub>m.pcr_cr_eq cr_view\\<^sub>h_Grp cr_view\\<^sub>m_Grp list.rel_Grp eq_alt prod.rel_Grp blindable\\<^sub>m.rel_Grp)\n    (simp add: Grp_def)"], ["", "end"], ["", "code_datatype View\\<^sub>h"], ["", "code_datatype View\\<^sub>m"], ["", "context begin"], ["", "interpretation view_merkle"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation (input) hash_view_content :: \"(view_content\\<^sub>m, view_content\\<^sub>h) hash\" where\n  \"hash_view_content \\<equiv> hash_prod hash_view_metadata hash_view_data\""], ["", "abbreviation (input) blinding_of_view_content :: \"view_content\\<^sub>m blinding_of\" where\n  \"blinding_of_view_content \\<equiv> blinding_of_prod blinding_of_view_metadata blinding_of_view_data\""], ["", "abbreviation (input) merge_view_content :: \"view_content\\<^sub>m merge\" where\n  \"merge_view_content \\<equiv> merge_prod merge_view_metadata merge_view_data\""], ["", "lift_definition hash_view :: \"(view\\<^sub>m, view\\<^sub>h) hash\" is\n  \"hash_tree hash_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition blinding_of_view :: \"view\\<^sub>m blinding_of\" is\n  \"blinding_of_tree hash_view_content blinding_of_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition merge_view :: \"view\\<^sub>m merge\" is\n  \"merge_tree hash_view_content merge_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma merkle_view [locale_witness]: \"merkle_interface hash_view blinding_of_view merge_view\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface hash_view blinding_of_view merge_view", "by transfer unfold_locales"], ["", "lemma hash_view_simps [simp]:\n  \"hash_view (View\\<^sub>m x) = \n   View\\<^sub>h (hash_blindable (hash_prod hash_view_content (hash_list hash_view)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_view (View\\<^sub>m x) =\n    View\\<^sub>h\n     (hash_blindable\n       (map_prod (map_prod (hash_blindable id) (hash_blindable id))\n         (map hash_view))\n       x)", "by transfer(simp add: hash_rt_F\\<^sub>m_def prod.map_comp hash_blindable_def blindable\\<^sub>m.map_id)"], ["", "lemma blinding_of_view_iff [simp]:\n  \"blinding_of_view (View\\<^sub>m x) (View\\<^sub>m y) \\<longleftrightarrow>\n   blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))\n     (blinding_of_prod blinding_of_view_content (blinding_of_list blinding_of_view)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_view (View\\<^sub>m x) (View\\<^sub>m y) =\n    blinding_of_blindable\n     (map_prod (map_prod (hash_blindable id) (hash_blindable id))\n       (map hash_view))\n     (rel_prod\n       (rel_prod (blinding_of_blindable id (=))\n         (blinding_of_blindable id (=)))\n       (list_all2 blinding_of_view))\n     x y", "by transfer simp"], ["", "lemma blinding_of_view_induct [consumes 1, induct pred: blinding_of_view]:\n  assumes \"blinding_of_view x y\"\n    and \"\\<And>x y. blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))\n             (blinding_of_prod blinding_of_view_content (blinding_of_list (\\<lambda>x y. blinding_of_view x y \\<and> P x y))) x y\n         \\<Longrightarrow> P (View\\<^sub>m x) (View\\<^sub>m y)\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using assms"], ["proof (prove)\nusing this:\n  blinding_of_view x y\n  blinding_of_blindable\n   (map_prod (map_prod (hash_blindable id) (hash_blindable id))\n     (map hash_view))\n   (rel_prod\n     (rel_prod (blinding_of_blindable id (=))\n       (blinding_of_blindable id (=)))\n     (list_all2 (\\<lambda>x y. blinding_of_view x y \\<and> P x y)))\n   ?x ?y \\<Longrightarrow>\n  P (View\\<^sub>m ?x) (View\\<^sub>m ?y)\n\ngoal (1 subgoal):\n 1. P x y", "by transfer(rule blinding_of_tree.induct)"], ["", "lemma merge_view_simps [simp]:\n  \"merge_view (View\\<^sub>m x) (View\\<^sub>m y) =\n   map_option View\\<^sub>m (merge_rt_F\\<^sub>m hash_view_content merge_view_content hash_view merge_view x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_view (View\\<^sub>m x) (View\\<^sub>m y) =\n    map_option View\\<^sub>m\n     (merge_rt_F\\<^sub>m (map_prod (hash_blindable id) (hash_blindable id))\n       (merge_prod (merge_blindable id merge_discrete)\n         (merge_blindable id merge_discrete))\n       hash_view merge_view x y)", "by transfer simp"], ["", "end"], ["", "subsection \\<open>Transaction trees as authenticated data structures\\<close>"], ["", "type_synonym common_metadata\\<^sub>h = \"common_metadata blindable\\<^sub>h\""], ["", "type_synonym common_metadata\\<^sub>m = \"(common_metadata, common_metadata) blindable\\<^sub>m\""], ["", "type_synonym participant_metadata\\<^sub>h = \"participant_metadata blindable\\<^sub>h\""], ["", "type_synonym participant_metadata\\<^sub>m = \"(participant_metadata, participant_metadata) blindable\\<^sub>m\""], ["", "datatype transaction\\<^sub>h = Transaction\\<^sub>h \n  (the_Transaction\\<^sub>h: \"((common_metadata\\<^sub>h \\<times>\\<^sub>h participant_metadata\\<^sub>h) \\<times>\\<^sub>h view\\<^sub>h list\\<^sub>h) blindable\\<^sub>h\")"], ["", "datatype transaction\\<^sub>m = Transaction\\<^sub>m \n  (the_Transaction\\<^sub>m: \"((common_metadata\\<^sub>m \\<times>\\<^sub>m participant_metadata\\<^sub>m) \\<times>\\<^sub>m view\\<^sub>m list\\<^sub>m,\n    (common_metadata\\<^sub>h \\<times>\\<^sub>h participant_metadata\\<^sub>h) \\<times>\\<^sub>h view\\<^sub>h list\\<^sub>h) blindable\\<^sub>m\")"], ["", "abbreviation (input) hash_common_metadata :: \"(common_metadata\\<^sub>m, common_metadata\\<^sub>h) hash\" where\n  \"hash_common_metadata \\<equiv> hash_blindable id\""], ["", "abbreviation (input) blinding_of_common_metadata :: \"common_metadata\\<^sub>m blinding_of\" where\n  \"blinding_of_common_metadata \\<equiv> blinding_of_blindable id (=)\""], ["", "abbreviation (input) merge_common_metadata :: \"common_metadata\\<^sub>m merge\" where\n  \"merge_common_metadata \\<equiv> merge_blindable id merge_discrete\""], ["", "abbreviation (input) hash_participant_metadata :: \"(participant_metadata\\<^sub>m, participant_metadata\\<^sub>h) hash\" where\n  \"hash_participant_metadata \\<equiv> hash_blindable id\""], ["", "abbreviation (input) blinding_of_participant_metadata :: \"participant_metadata\\<^sub>m blinding_of\" where\n  \"blinding_of_participant_metadata \\<equiv> blinding_of_blindable id (=)\""], ["", "abbreviation (input) merge_participant_metadata :: \"participant_metadata\\<^sub>m merge\" where\n  \"merge_participant_metadata \\<equiv> merge_blindable id merge_discrete\""], ["", "locale transaction_merkle begin"], ["", "lemma iso_transaction\\<^sub>h: \"type_definition the_Transaction\\<^sub>h Transaction\\<^sub>h UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition the_Transaction\\<^sub>h Transaction\\<^sub>h UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_transaction\\<^sub>h"], ["", "lemma Transaction\\<^sub>h_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction\\<^sub>h) id Transaction\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_transaction\\<^sub>h) id Transaction\\<^sub>h", "by(simp add: transaction\\<^sub>h.pcr_cr_eq cr_transaction\\<^sub>h_def rel_fun_def)"], ["", "lemma iso_transaction\\<^sub>m: \"type_definition the_Transaction\\<^sub>m Transaction\\<^sub>m UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition the_Transaction\\<^sub>m Transaction\\<^sub>m UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_transaction\\<^sub>m"], ["", "lemma Transaction\\<^sub>m_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction\\<^sub>m) id Transaction\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_transaction\\<^sub>m) id Transaction\\<^sub>m", "by(simp add: transaction\\<^sub>m.pcr_cr_eq cr_transaction\\<^sub>m_def rel_fun_def)"], ["", "end"], ["", "code_datatype Transaction\\<^sub>h"], ["", "code_datatype Transaction\\<^sub>m"], ["", "context begin"], ["", "interpretation transaction_merkle"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition hash_transaction :: \"(transaction\\<^sub>m, transaction\\<^sub>h) hash\" is\n  \"hash_blindable (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition blinding_of_transaction :: \"transaction\\<^sub>m blinding_of\" is\n  \"blinding_of_blindable \n     (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))\n     (blinding_of_prod (blinding_of_prod blinding_of_common_metadata blinding_of_participant_metadata) (blinding_of_list blinding_of_view))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition merge_transaction :: \"transaction\\<^sub>m merge\" is\n  \"merge_blindable\n     (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))\n     (merge_prod (merge_prod merge_common_metadata merge_participant_metadata) (merge_list merge_view))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma merkle_transaction [locale_witness]:\n  \"merkle_interface hash_transaction blinding_of_transaction merge_transaction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface hash_transaction blinding_of_transaction\n     merge_transaction", "by transfer unfold_locales"], ["", "lemmas hash_transaction_simps [simp] = hash_transaction.abs_eq"], ["", "lemmas blinding_of_transaction_iff [simp] = blinding_of_transaction.abs_eq"], ["", "lemmas merge_transaction_simps [simp] = merge_transaction.abs_eq"], ["", "end"], ["", "interpretation transaction:\n  merkle_interface hash_transaction blinding_of_transaction merge_transaction"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface hash_transaction blinding_of_transaction\n     merge_transaction", "by(rule merkle_transaction)"], ["", "subsection \\<open>\nConstructing authenticated data structures for views\n\\<close>"], ["", "context view_merkle begin"], ["", "type_synonym view' = \"(view_metadata \\<times> view_data) rose_tree\""], ["", "primrec from_view :: \"view \\<Rightarrow> view'\" where\n  \"from_view (View vm vd vs) = Tree ((vm, vd), map from_view vs)\""], ["", "primrec to_view :: \"view' \\<Rightarrow> view\" where\n  \"to_view (Tree x) = View (fst (fst x)) (snd (fst x)) (snd (map_prod id (map to_view) x))\""], ["", "lemma from_to_view [simp]: \"from_view (to_view x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_view (to_view x) = x", "by(induction x)(clarsimp cong: map_cong)"], ["", "lemma to_from_view [simp]: \"to_view (from_view x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_view (from_view x) = x", "by(induction x)(clarsimp cong: map_cong)"], ["", "lemma iso_view: \"type_definition from_view to_view UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition from_view to_view UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_view"], ["", "definition View' :: \"(view_metadata \\<times> view_data) \\<times> view list \\<Rightarrow> view\" where\n  \"View' = (\\<lambda>((vm, vd), vs). View vm vd vs)\""], ["", "lemma View_View': \"View = (\\<lambda>vm vd vs. View' ((vm, vd), vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. View = (\\<lambda>vm vd vs. View' ((vm, vd), vs))", "by(simp add: View'_def)"], ["", "lemma cr_view_Grp: \"cr_view = Grp UNIV to_view\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_view = Grp UNIV to_view", "by(simp add: cr_view_def Grp_def fun_eq_iff)(transfer, auto)"], ["", "lemma View'_transfer [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod (=) (list_all2 pcr_view) ===> pcr_view) Tree View'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod (=) (list_all2 pcr_view) ===> pcr_view) Tree View'", "by(simp add: view.pcr_cr_eq cr_view_Grp eq_alt prod.rel_Grp rose_tree.rel_Grp list.rel_Grp)\n    (auto simp add: Grp_def View'_def)"], ["", "end"], ["", "code_datatype View"], ["", "context begin"], ["", "interpretation view_merkle"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation embed_view_content :: \"view_metadata \\<times> view_data \\<Rightarrow> view_metadata\\<^sub>m \\<times> view_data\\<^sub>m\" where\n  \"embed_view_content \\<equiv> map_prod Unblinded Unblinded\""], ["", "lift_definition embed_view :: \"view \\<Rightarrow> view\\<^sub>m\" is \"embed_source_tree embed_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma embed_view_simps [simp]:\n  \"embed_view (View vm vd vs) = View\\<^sub>m (Unblinded ((Unblinded vm, Unblinded vd), map embed_view vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_view (View vm vd vs) =\n    View\\<^sub>m\n     (Unblinded ((Unblinded vm, Unblinded vd), map embed_view vs))", "unfolding View_View'"], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_view (View' ((vm, vd), vs)) =\n    View\\<^sub>m\n     (Unblinded ((Unblinded vm, Unblinded vd), map embed_view vs))", "by transfer simp"], ["", "end"], ["", "context transaction_merkle begin"], ["", "primrec the_Transaction :: \"transaction \\<Rightarrow> (common_metadata \\<times> participant_metadata) \\<times> view list\" where\n  \"the_Transaction (Transaction cm pm views) = ((cm, pm), views)\" for views"], ["", "definition Transaction' :: \"(common_metadata \\<times> participant_metadata) \\<times> view list \\<Rightarrow> transaction\" where\n  \"Transaction' = (\\<lambda>((cm, pm), views). Transaction cm pm views)\""], ["", "lemma Transaction_Transaction': \"Transaction = (\\<lambda>cm pm views. Transaction' ((cm, pm), views))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transaction = (\\<lambda>cm pm views. Transaction' ((cm, pm), views))", "by(simp add: Transaction'_def)"], ["", "lemma the_Transaction_inverse [simp]: \"Transaction' (the_Transaction x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transaction' (the_Transaction x) = x", "by(cases x)(simp add: Transaction'_def)"], ["", "lemma Transaction'_inverse [simp]: \"the_Transaction (Transaction' x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_Transaction (Transaction' x) = x", "by(simp add: Transaction'_def split_def)"], ["", "lemma iso_transaction: \"type_definition the_Transaction Transaction' UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition the_Transaction Transaction' UNIV", "by unfold_locales simp_all"], ["", "setup_lifting iso_transaction"], ["", "lemma Transaction'_transfer [transfer_rule]: includes lifting_syntax shows\n  \"((=) ===> pcr_transaction) id Transaction'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_transaction) id Transaction'", "by(simp add: transaction.pcr_cr_eq cr_transaction_def rel_fun_def)"], ["", "end"], ["", "code_datatype Transaction"], ["", "context begin"], ["", "interpretation transaction_merkle"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition embed_transaction :: \"transaction \\<Rightarrow> transaction\\<^sub>m\" is\n  \"Unblinded \\<circ> map_prod (map_prod Unblinded Unblinded) (map embed_view)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma embed_transaction_simps [simp]:\n  \"embed_transaction (Transaction cm pm views) =\n   Transaction\\<^sub>m (Unblinded ((Unblinded cm, Unblinded pm), map embed_view views))\" \n  for views"], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_transaction (Transaction cm pm views) =\n    Transaction\\<^sub>m\n     (Unblinded ((Unblinded cm, Unblinded pm), map embed_view views))", "unfolding Transaction_Transaction'"], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_transaction (Transaction' ((cm, pm), views)) =\n    Transaction\\<^sub>m\n     (Unblinded ((Unblinded cm, Unblinded pm), map embed_view views))", "by transfer simp"], ["", "end"], ["", "subsubsection \\<open>Inclusion proof for the mediator\\<close>"], ["", "primrec mediator_view :: \"view \\<Rightarrow> view\\<^sub>m\" where\n  \"mediator_view (View vm vd vs) =\n   View\\<^sub>m (Unblinded ((Unblinded vm, Blinded (Content vd)), map mediator_view vs))\""], ["", "primrec mediator_transaction_tree :: \"transaction \\<Rightarrow> transaction\\<^sub>m\" where\n  \"mediator_transaction_tree (Transaction cm pm views) =\n   Transaction\\<^sub>m (Unblinded ((Unblinded cm, Blinded (Content pm)), map mediator_view views))\"\n  for views"], ["", "lemma blinding_of_mediator_view [simp]: \"blinding_of_view (mediator_view view) (embed_view view)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_view (mediator_view view) (embed_view view)", "by(induction view)(auto simp add: list.rel_map intro!: list.rel_refl_strong)"], ["", "lemma blinding_of_mediator_transaction_tree:\n  \"blinding_of_transaction (mediator_transaction_tree tt) (embed_transaction tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_transaction (mediator_transaction_tree tt)\n     (embed_transaction tt)", "by(cases tt)(auto simp add: list.rel_map intro: list.rel_refl_strong)"], ["", "subsubsection \\<open>Inclusion proofs for participants\\<close>"], ["", "text \\<open>Next, we define a function for producing all transaction views from a given view,\n  and prove its properties.\\<close>"], ["", "type_synonym view_path_elem = \"(view_metadata \\<times> view_data) blindable \\<times> view list \\<times> view list\""], ["", "type_synonym view_path = \"view_path_elem list\""], ["", "type_synonym view_zipper = \"view_path \\<times> view\""], ["", "type_synonym view_path_elem\\<^sub>m = \"(view_metadata\\<^sub>m \\<times>\\<^sub>m view_data\\<^sub>m) \\<times> view\\<^sub>m list\\<^sub>m \\<times> view\\<^sub>m list\\<^sub>m\""], ["", "type_synonym view_path\\<^sub>m = \"view_path_elem\\<^sub>m list\""], ["", "type_synonym view_zipper\\<^sub>m = \"view_path\\<^sub>m \\<times> view\\<^sub>m\""], ["", "context begin"], ["", "interpretation view_merkle"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zipper_of_view :: \"view \\<Rightarrow> view_zipper\" is zipper_of_tree"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition view_of_zipper :: \"view_zipper \\<Rightarrow> view\" is tree_of_zipper"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zipper_of_view\\<^sub>m :: \"view\\<^sub>m \\<Rightarrow> view_zipper\\<^sub>m\" is zipper_of_tree\\<^sub>m"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition view_of_zipper\\<^sub>m :: \"view_zipper\\<^sub>m \\<Rightarrow> view\\<^sub>m\" is tree_of_zipper\\<^sub>m"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma view_of_zipper\\<^sub>m_Nil [simp]: \"view_of_zipper\\<^sub>m ([], t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. view_of_zipper\\<^sub>m ([], t) = t", "by transfer simp"], ["", "lift_definition blind_view_path_elem :: \"view_path_elem \\<Rightarrow> view_path_elem\\<^sub>m\" is\n  \"blind_path_elem embed_view_content hash_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition blind_view_path :: \"view_path \\<Rightarrow> view_path\\<^sub>m\" is\n  \"blind_path embed_view_content hash_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition embed_view_path_elem :: \"view_path_elem \\<Rightarrow> view_path_elem\\<^sub>m\" is\n  \"embed_path_elem embed_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition embed_view_path :: \"view_path \\<Rightarrow> view_path\\<^sub>m\" is\n  \"embed_path embed_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition hash_view_path_elem :: \"view_path_elem\\<^sub>m \\<Rightarrow> (view_content\\<^sub>h \\<times> view\\<^sub>h list \\<times> view\\<^sub>h list)\" is\n  \"hash_path_elem hash_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zippers_view :: \"view_zipper \\<Rightarrow> view_zipper\\<^sub>m list\" is\n  \"zippers_rose_tree embed_view_content hash_view_content\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma embed_view_path_Nil [simp]: \"embed_view_path [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_view_path [] = []", "by transfer(simp add: embed_path_def)"], ["", "lemma zippers_view_same_hash:\n  assumes \"z \\<in> set (zippers_view (p, t))\"\n  shows \"hash_view (view_of_zipper\\<^sub>m z) = hash_view (view_of_zipper\\<^sub>m (embed_view_path p, embed_view t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_view (view_of_zipper\\<^sub>m z) =\n    hash_view (view_of_zipper\\<^sub>m (embed_view_path p, embed_view t))", "using assms"], ["proof (prove)\nusing this:\n  z \\<in> set (zippers_view (p, t))\n\ngoal (1 subgoal):\n 1. hash_view (view_of_zipper\\<^sub>m z) =\n    hash_view (view_of_zipper\\<^sub>m (embed_view_path p, embed_view t))", "by transfer(rule zippers_rose_tree_same_hash')"], ["", "lemma zippers_view_blinding_of:\n  assumes \"z \\<in> set (zippers_view (p, t))\"\n  shows \"blinding_of_view (view_of_zipper\\<^sub>m z) (view_of_zipper\\<^sub>m (blind_view_path p, embed_view t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_view (view_of_zipper\\<^sub>m z)\n     (view_of_zipper\\<^sub>m (blind_view_path p, embed_view t))", "using assms"], ["proof (prove)\nusing this:\n  z \\<in> set (zippers_view (p, t))\n\ngoal (1 subgoal):\n 1. blinding_of_view (view_of_zipper\\<^sub>m z)\n     (view_of_zipper\\<^sub>m (blind_view_path p, embed_view t))", "by transfer(rule zippers_rose_tree_blinding_of, unfold_locales)"], ["", "end"], ["", "primrec blind_view :: \"view \\<Rightarrow> view\\<^sub>m\" where\n  \"blind_view (View vm vd subviews) = \n   View\\<^sub>m (Blinded (Content ((Content vm, Content vd), map (hash_view \\<circ> embed_view) subviews)))\"\n  for subviews"], ["", "lemma hash_blind_view: \"hash_view (blind_view view) = hash_view (embed_view view)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_view (blind_view view) = hash_view (embed_view view)", "by(cases view) simp"], ["", "primrec blind_transaction :: \"transaction \\<Rightarrow> transaction\\<^sub>m\" where\n  \"blind_transaction (Transaction cm pm views) = \n   Transaction\\<^sub>m (Blinded (Content ((Content cm, Content pm), map (hash_view \\<circ> blind_view) views)))\"\n  for views"], ["", "lemma hash_blind_transaction:\n  \"hash_transaction (blind_transaction transaction) = hash_transaction (embed_transaction transaction)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_transaction (blind_transaction transaction) =\n    hash_transaction (embed_transaction transaction)", "by(cases transaction)(simp add: hash_blind_view)"], ["", "typedecl participant"], ["", "consts recipients :: \"view_metadata \\<Rightarrow> participant list\""], ["", "fun view_recipients :: \"view\\<^sub>m \\<Rightarrow> participant set\" where\n  \"view_recipients (View\\<^sub>m (Unblinded ((Unblinded vm, vd), subviews))) = set (recipients vm)\" for subviews\n| \"view_recipients _ = {}\" \\<comment> \\<open>Sane default case\\<close>"], ["", "context fixes participant :: participant begin"], ["", "definition view_trees_for :: \"view \\<Rightarrow> view\\<^sub>m list\" where\n  \"view_trees_for view =\n   map view_of_zipper\\<^sub>m\n     (filter (\\<lambda>(_, t). participant \\<in> view_recipients t) \n       (zippers_view ([], view)))\""], ["", "primrec transaction_views_for :: \"transaction \\<Rightarrow> transaction\\<^sub>m list\" where\n  \"transaction_views_for (Transaction cm pm views) =\n   map (\\<lambda>view\\<^sub>m. Transaction\\<^sub>m (Unblinded ((Unblinded cm, Unblinded pm), view\\<^sub>m)))\n  (concat (map (\\<lambda>(l, v, r). map (\\<lambda>v\\<^sub>m. map blind_view l @ [v\\<^sub>m] @ map blind_view r) (view_trees_for v)) (splits views)))\"\n  for views"], ["", "lemma view_trees_for_same_hash:\n  \"vt \\<in> set (view_trees_for view) \\<Longrightarrow> hash_view vt = hash_view (embed_view view)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vt \\<in> set (local.view_trees_for view) \\<Longrightarrow>\n    hash_view vt = hash_view (embed_view view)", "by(auto simp add: view_trees_for_def dest: zippers_view_same_hash)"], ["", "lemma transaction_views_for_same_hash:\n  \"t\\<^sub>m \\<in> set (transaction_views_for t) \\<Longrightarrow> hash_transaction t\\<^sub>m = hash_transaction (embed_transaction t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sub>m \\<in> set (local.transaction_views_for t) \\<Longrightarrow>\n    hash_transaction t\\<^sub>m = hash_transaction (embed_transaction t)", "by(cases t)(clarsimp simp add: splits_iff hash_blind_view view_trees_for_same_hash)"], ["", "definition transaction_projection_for :: \"transaction \\<Rightarrow> transaction\\<^sub>m\" where\n  \"transaction_projection_for t =\n   (let tvs = transaction_views_for t\n    in if tvs = [] then blind_transaction t else the (transaction.Merge (set tvs)))\""], ["", "lemma transaction_projection_for_same_hash:\n  \"hash_transaction (transaction_projection_for t) = hash_transaction (embed_transaction t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "proof(cases \"transaction_views_for t = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.transaction_views_for t = [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)\n 2. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "case True"], ["proof (state)\nthis:\n  local.transaction_views_for t = []\n\ngoal (2 subgoals):\n 1. local.transaction_views_for t = [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)\n 2. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.transaction_views_for t = []\n\ngoal (1 subgoal):\n 1. hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "by(simp add: transaction_projection_for_def Let_def hash_blind_transaction)"], ["proof (state)\nthis:\n  hash_transaction (local.transaction_projection_for t) =\n  hash_transaction (embed_transaction t)\n\ngoal (1 subgoal):\n 1. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "case False"], ["proof (state)\nthis:\n  local.transaction_views_for t \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "then"], ["proof (chain)\npicking this:\n  local.transaction_views_for t \\<noteq> []", "have \"transaction.Merge (set (transaction_views_for t)) \\<noteq> None\""], ["proof (prove)\nusing this:\n  local.transaction_views_for t \\<noteq> []\n\ngoal (1 subgoal):\n 1. transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None", "by(intro transaction.Merge_defined)(auto simp add: transaction_views_for_same_hash)"], ["proof (state)\nthis:\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. local.transaction_views_for t \\<noteq> [] \\<Longrightarrow>\n    hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "with False"], ["proof (chain)\npicking this:\n  local.transaction_views_for t \\<noteq> []\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  local.transaction_views_for t \\<noteq> []\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. hash_transaction (local.transaction_projection_for t) =\n    hash_transaction (embed_transaction t)", "apply(clarsimp simp add: transaction_projection_for_def neq_Nil_conv simp del: transaction.Merge_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya ys.\n       \\<lbrakk>transaction.Merge (insert y (set ys)) = Some ya;\n        local.transaction_views_for t = y # ys\\<rbrakk>\n       \\<Longrightarrow> hash_transaction ya =\n                         hash_transaction (embed_transaction t)", "apply(drule transaction.Merge_hash[symmetric], blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya ys.\n       \\<lbrakk>local.transaction_views_for t = y # ys;\n        hash_transaction ya = hash_transaction y\\<rbrakk>\n       \\<Longrightarrow> hash_transaction ya =\n                         hash_transaction (embed_transaction t)", "apply(auto intro: transaction_views_for_same_hash)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hash_transaction (local.transaction_projection_for t) =\n  hash_transaction (embed_transaction t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transaction_projection_for_upper:\n  assumes \"t\\<^sub>m \\<in> set (transaction_views_for t)\"\n  shows \"blinding_of_transaction t\\<^sub>m (transaction_projection_for t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_transaction t\\<^sub>m (local.transaction_projection_for t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_transaction t\\<^sub>m (local.transaction_projection_for t)", "from assms"], ["proof (chain)\npicking this:\n  t\\<^sub>m \\<in> set (local.transaction_views_for t)", "have \"transaction.Merge (set (transaction_views_for t)) \\<noteq> None\""], ["proof (prove)\nusing this:\n  t\\<^sub>m \\<in> set (local.transaction_views_for t)\n\ngoal (1 subgoal):\n 1. transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None", "by(intro transaction.Merge_defined)(auto simp add: transaction_views_for_same_hash)"], ["proof (state)\nthis:\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. blinding_of_transaction t\\<^sub>m (local.transaction_projection_for t)", "with assms"], ["proof (chain)\npicking this:\n  t\\<^sub>m \\<in> set (local.transaction_views_for t)\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>m \\<in> set (local.transaction_views_for t)\n  transaction.Merge (set (local.transaction_views_for t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. blinding_of_transaction t\\<^sub>m (local.transaction_projection_for t)", "by(auto simp add: transaction_projection_for_def Let_def dest: transaction.Merge_upper)"], ["proof (state)\nthis:\n  blinding_of_transaction t\\<^sub>m (local.transaction_projection_for t)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}