{"file_name": "/home/qj213/afp-2021-10-22/thys/ADS_Functor/Inclusion_Proof_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ADS_Functor", "problem_names": ["lemma hash_blind_blindable [simp]: \"hash_blindable h (blind_blindable h x) = hash_blindable h x\"", "lemma hash_blinded_simp: \"hash_tree h' (blind_source_tree h st) = hash_source_tree h st\"", "lemma hash_embedded_simp:\n  \"hash_tree h (embed_source_tree e st) = hash_source_tree (h \\<circ> e) st\"", "lemma blinded_embedded_same_hash:\n  \"hash_tree h'' (blind_source_tree (h o e) st) = hash_tree h (embed_source_tree e st)\"", "lemma blinding_blinds [simp]:\n  \"is_blinded (blind_source_tree h t)\"", "lemma blinded_blinds_embedded: \n  \"blinding_of_tree h bo (blind_source_tree (h o e) st) (embed_source_tree e st)\"", "lemma splits_iff: \"(l, a, r) \\<in> set (splits ll) = (ll = l @ a # r)\"", "lemma tree_of_zipper_id[iff]: \"tree_of_zipper (zipper_of_tree t) = t\"", "lemma zipper_children_same_tree:\n  assumes \"z' \\<in> set (zipper_children z)\"\n  shows \"tree_of_zipper z' = tree_of_zipper z\"", "lemma tree_of_zipper\\<^sub>m_append:\n  \"tree_of_zipper\\<^sub>m (p @ p', t) = tree_of_zipper\\<^sub>m (p', tree_of_zipper\\<^sub>m (p, t))\"", "lemma zipper_children_same_tree\\<^sub>m:\n  assumes \"z' \\<in> set (zipper_children\\<^sub>m z)\"\n  shows \"tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z\"", "lemma hash_tree_of_zipper_same_path: \n  \"hash_tree h (tree_of_zipper\\<^sub>m (p, v)) = hash_tree h (tree_of_zipper\\<^sub>m (p, v'))\n        \\<longleftrightarrow> hash_tree h v = hash_tree h v'\"", "lemma hash_view_zipper_eqI:\n  \"\\<lbrakk> hash_list (hash_path_elem h) p = hash_list (hash_path_elem h') p';\n    hash_tree h v = hash_tree h' v' \\<rbrakk> \\<Longrightarrow>\n    hash_tree h (tree_of_zipper\\<^sub>m (p, v)) = hash_tree h' (tree_of_zipper\\<^sub>m (p', v'))\"", "lemma blind_embed_path_same_hash:\n  \"hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) = hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))\"", "lemma tree_of_embed_commute:\n  \"tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t) = embed_source_tree e (tree_of_zipper (p, t))\"", "lemma childz_same_tree:\n  \"(l, t, r) \\<in> set (splits ts) \\<Longrightarrow>\n  tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e (Tree (d, ts))) \n  = tree_of_zipper\\<^sub>m (embed_path e ((d, l, r) # p), embed_source_tree e t)\"", "lemma blinding_of_same_path:\n  assumes bo: \"blinding_of_on UNIV h bo\"\n  shows\n  \"blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t)) (tree_of_zipper\\<^sub>m (p, t'))\n  \\<longleftrightarrow> blinding_of_tree h bo t t'\"", "lemma zipper_children_size_change [termination_simp]: \"(a, b) \\<in> set (zipper_children (p, v)) \\<Longrightarrow> size b < size v\"", "lemmas [simp del] = zippers_rose_tree.simps zipper_children.simps", "lemma zippers_rose_tree_same_hash':\n  assumes \"z \\<in> set (zippers_rose_tree e h (p, t))\"\n  shows \"hash_tree h (tree_of_zipper\\<^sub>m z) = \n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\"", "lemma zippers_rose_tree_blinding_of:\n  assumes \"blinding_of_on UNIV h bo\" \n    and z: \"z \\<in> set (zippers_rose_tree e h (p, t))\"\n  shows \"blinding_of_tree h bo (tree_of_zipper\\<^sub>m z) (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\"", "lemma zippers_rose_tree_neq_Nil: \"zippers_rose_tree e h (p, t) \\<noteq> []\"", "lemma (in comp_fun_idem) fold_set_union:\n  assumes \"finite A\" \"finite B\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\"", "lemma comp_fun_idem_merge: \"comp_fun_idem (\\<lambda>x yo. yo \\<bind> m x)\"", "lemma Merge_empty [simp]: \"Merge {} = None\"", "lemma Merge_infinite [simp]: \"infinite A \\<Longrightarrow> Merge A = None\"", "lemma Merge_cong_start:\n  \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A\" (is \"?lhs = ?rhs\")\n  if \"x \\<in> A\" \"y \\<in> A\" \"finite A\"", "lemma Merge_insert [simp]: \"Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\" (is \"?lhs = ?rhs\")", "lemma Merge_insert_alt:\n  \"Merge (insert x A) = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A\" (is \"?lhs = ?rhs\") if \"finite A\"", "lemma Merge_None [simp]: \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None\"", "lemma Merge_union: \n  \"Merge (A \\<union> B) = (if A = {} then Merge B else if B = {} then Merge A else (Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)))\"\n  (is \"?lhs = ?rhs\")", "lemma Merge_upper:\n  assumes m: \"Merge A = Some x\" and y: \"y \\<in> A\"\n  shows \"bo y x\"", "lemma Merge_least:\n  assumes m: \"Merge A = Some x\" and u[rule_format]: \"\\<forall>a\\<in>A. bo a u\"\n  shows \"bo x u\"", "lemma Merge_defined:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"\\<forall>a\\<in>A. \\<forall>b \\<in> A. h a = h b\"\n  shows \"Merge A \\<noteq> None\"", "lemma Merge_hash:\n  assumes \"Merge A = Some x\" \"a \\<in> A\"\n  shows \"h a = h x\""], "translations": [["", "lemma hash_blind_blindable [simp]: \"hash_blindable h (blind_blindable h x) = hash_blindable h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_blindable h (blind_blindable h x) = hash_blindable h x", "by(cases x) simp_all"], ["", "subsection \\<open>Inclusion proof construction for rose trees\\<close>"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashing, embedding and blinding source trees \\<close>"], ["", "(************************************************************)"], ["", "context fixes h :: \"'a \\<Rightarrow> 'a\\<^sub>h\" begin"], ["", "fun hash_source_tree :: \"'a rose_tree \\<Rightarrow> 'a\\<^sub>h rose_tree\\<^sub>h\" where\n  \"hash_source_tree (Tree (data, subtrees)) = Tree\\<^sub>h (Content (h data, map hash_source_tree subtrees))\""], ["", "end"], ["", "context fixes e :: \"'a \\<Rightarrow> 'a\\<^sub>m\" begin"], ["", "fun embed_source_tree :: \"'a rose_tree \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m\" where\n  \"embed_source_tree (Tree (data, subtrees)) =\n    Tree\\<^sub>m (Unblinded (e data, map embed_source_tree subtrees))\""], ["", "end"], ["", "context fixes h :: \"'a \\<Rightarrow> 'a\\<^sub>h\" begin"], ["", "fun blind_source_tree :: \"'a rose_tree \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m\" where\n  \"blind_source_tree (Tree (data, subtrees)) = Tree\\<^sub>m (Blinded (Content (h data, map (hash_source_tree h) subtrees)))\""], ["", "end"], ["", "case_of_simps blind_source_tree_cases: blind_source_tree.simps"], ["", "fun is_blinded :: \"('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m \\<Rightarrow> bool\" where\n  \"is_blinded (Tree\\<^sub>m (Blinded _)) = True\"\n| \"is_blinded _ = False\""], ["", "lemma hash_blinded_simp: \"hash_tree h' (blind_source_tree h st) = hash_source_tree h st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h' (blind_source_tree h st) = hash_source_tree h st", "by(cases st rule: blind_source_tree.cases)(simp_all add: hash_rt_F\\<^sub>m_def)"], ["", "lemma hash_embedded_simp:\n  \"hash_tree h (embed_source_tree e st) = hash_source_tree (h \\<circ> e) st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h (embed_source_tree e st) = hash_source_tree (h \\<circ> e) st", "by(induction st rule: embed_source_tree.induct)(simp add: hash_rt_F\\<^sub>m_def)"], ["", "lemma blinded_embedded_same_hash:\n  \"hash_tree h'' (blind_source_tree (h o e) st) = hash_tree h (embed_source_tree e st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h'' (blind_source_tree (h \\<circ> e) st) =\n    hash_tree h (embed_source_tree e st)", "by(simp add: hash_blinded_simp hash_embedded_simp)"], ["", "lemma blinding_blinds [simp]:\n  \"is_blinded (blind_source_tree h t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_blinded (blind_source_tree h t)", "by(simp add: blind_source_tree_cases split: rose_tree.split)"], ["", "lemma blinded_blinds_embedded: \n  \"blinding_of_tree h bo (blind_source_tree (h o e) st) (embed_source_tree e st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (blind_source_tree (h \\<circ> e) st)\n     (embed_source_tree e st)", "by(cases st rule: blind_source_tree.cases)(simp_all add: hash_embedded_simp)"], ["", "fun embed_hash_tree :: \"'ha rose_tree\\<^sub>h \\<Rightarrow> ('a, 'ha) rose_tree\\<^sub>m\" where\n  \"embed_hash_tree (Tree\\<^sub>h h) = Tree\\<^sub>m (Blinded h)\""], ["", "(************************************************************)"], ["", "subsubsection \\<open>Auxiliary definitions: selectors and list splits\\<close>"], ["", "(************************************************************)"], ["", "fun children :: \"'a rose_tree \\<Rightarrow> 'a rose_tree list\" where\n  \"children (Tree (data, subtrees)) = subtrees\""], ["", "fun children\\<^sub>m :: \"('a, 'a\\<^sub>h) rose_tree\\<^sub>m \\<Rightarrow> ('a, 'a\\<^sub>h) rose_tree\\<^sub>m list\" where\n  \"children\\<^sub>m (Tree\\<^sub>m (Unblinded (data, subtrees))) = subtrees\"\n| \"children\\<^sub>m _ = undefined\""], ["", "fun splits :: \"'a list \\<Rightarrow> ('a list \\<times> 'a \\<times> 'a list) list\" where\n  \"splits [] = []\"\n| \"splits (x#xs) = ([], x, xs) # map (\\<lambda>(l, y, r). (x # l, y, r)) (splits xs)\""], ["", "lemma splits_iff: \"(l, a, r) \\<in> set (splits ll) = (ll = l @ a # r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, a, r) \\<in> set (splits ll)) = (ll = l @ a # r)", "by(induction ll arbitrary: l a r)(auto simp add: Cons_eq_append_conv)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Zippers \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> Zippers provide a neat representation of tree-like ADSs when they have only a single \n  unblinded subtree. The zipper path provides the \"inclusion proof\" that the unblinded subtree is\n  included in a larger structure. \\<close>"], ["", "type_synonym 'a path_elem = \"'a \\<times> 'a rose_tree list \\<times> 'a rose_tree list\""], ["", "type_synonym 'a path = \"'a path_elem list\""], ["", "type_synonym 'a zipper = \"'a path \\<times> 'a rose_tree\""], ["", "definition zipper_of_tree :: \"'a rose_tree \\<Rightarrow> 'a zipper\" where\n  \"zipper_of_tree t \\<equiv> ([], t)\""], ["", "fun tree_of_zipper :: \"'a zipper \\<Rightarrow> 'a rose_tree\" where\n  \"tree_of_zipper ([], t) = t\"\n| \"tree_of_zipper ((a, l, r) # z, t) = tree_of_zipper (z, (Tree (a, (l @ t # r))))\""], ["", "case_of_simps tree_of_zipper_cases: tree_of_zipper.simps"], ["", "lemma tree_of_zipper_id[iff]: \"tree_of_zipper (zipper_of_tree t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_of_zipper (zipper_of_tree t) = t", "by(simp add: zipper_of_tree_def)"], ["", "fun zipper_children :: \"'a zipper \\<Rightarrow> 'a zipper list\" where\n  \"zipper_children (p, Tree (a, ts)) = map (\\<lambda>(l, t, r). ((a, l, r) # p, t)) (splits ts)\""], ["", "lemma zipper_children_same_tree:\n  assumes \"z' \\<in> set (zipper_children z)\"\n  shows \"tree_of_zipper z' = tree_of_zipper z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_of_zipper z' = tree_of_zipper z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_of_zipper z' = tree_of_zipper z", "obtain p a ts where z: \"z = (p, Tree (a, ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p a ts.\n        z = (p, Tree (a, ts)) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z' \\<in> set (zipper_children z)\n\ngoal (1 subgoal):\n 1. (\\<And>p a ts.\n        z = (p, Tree (a, ts)) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z rule: zipper_children.cases) (simp_all)"], ["proof (state)\nthis:\n  z = (p, Tree (a, ts))\n\ngoal (1 subgoal):\n 1. tree_of_zipper z' = tree_of_zipper z", "then"], ["proof (chain)\npicking this:\n  z = (p, Tree (a, ts))", "obtain l t r where ltr: \"z' = ((a, l, r) # p, t)\" and \"(l, t, r) \\<in> set (splits ts)\""], ["proof (prove)\nusing this:\n  z = (p, Tree (a, ts))\n\ngoal (1 subgoal):\n 1. (\\<And>l r t.\n        \\<lbrakk>z' = ((a, l, r) # p, t);\n         (l, t, r) \\<in> set (splits ts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z = (p, Tree (a, ts))\n  z' \\<in> set (zipper_children z)\n\ngoal (1 subgoal):\n 1. (\\<And>l r t.\n        \\<lbrakk>z' = ((a, l, r) # p, t);\n         (l, t, r) \\<in> set (splits ts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)\n\ngoal (1 subgoal):\n 1. tree_of_zipper z' = tree_of_zipper z", "with z"], ["proof (chain)\npicking this:\n  z = (p, Tree (a, ts))\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  z = (p, Tree (a, ts))\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)\n\ngoal (1 subgoal):\n 1. tree_of_zipper z' = tree_of_zipper z", "by(simp add: splits_iff)"], ["proof (state)\nthis:\n  tree_of_zipper z' = tree_of_zipper z\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym ('a\\<^sub>m, 'a\\<^sub>h) path_elem\\<^sub>m = \"'a\\<^sub>m \\<times> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m list \\<times> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m list\""], ["", "type_synonym ('a\\<^sub>m, 'a\\<^sub>h) path\\<^sub>m = \"('a\\<^sub>m, 'a\\<^sub>h) path_elem\\<^sub>m list\""], ["", "type_synonym ('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m = \"('a\\<^sub>m, 'a\\<^sub>h) path\\<^sub>m \\<times> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m\""], ["", "definition zipper_of_tree\\<^sub>m :: \"('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m\" where\n  \"zipper_of_tree\\<^sub>m t \\<equiv> ([], t)\""], ["", "fun tree_of_zipper\\<^sub>m :: \"('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m\" where\n  \"tree_of_zipper\\<^sub>m ([], t) = t\"\n| \"tree_of_zipper\\<^sub>m ((m, l, r) # z, t) = tree_of_zipper\\<^sub>m (z, Tree\\<^sub>m (Unblinded (m, l @ t # r)))\""], ["", "lemma tree_of_zipper\\<^sub>m_append:\n  \"tree_of_zipper\\<^sub>m (p @ p', t) = tree_of_zipper\\<^sub>m (p', tree_of_zipper\\<^sub>m (p, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m (p @ p', t) =\n    tree_of_zipper\\<^sub>m (p', tree_of_zipper\\<^sub>m (p, t))", "by(induction p arbitrary: p' t) auto"], ["", "fun zipper_children\\<^sub>m :: \"('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m list\" where\n  \"zipper_children\\<^sub>m (p, Tree\\<^sub>m (Unblinded (a, ts))) = map (\\<lambda>(l, t, r). ((a, l, r) # p, t)) (splits ts) \"\n| \"zipper_children\\<^sub>m _ = []\""], ["", "lemma zipper_children_same_tree\\<^sub>m:\n  assumes \"z' \\<in> set (zipper_children\\<^sub>m z)\"\n  shows \"tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z", "obtain p a ts where z: \"z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p a ts.\n        z = (p, Tree\\<^sub>m (Unblinded (a, ts))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z' \\<in> set (zipper_children\\<^sub>m z)\n\ngoal (1 subgoal):\n 1. (\\<And>p a ts.\n        z = (p, Tree\\<^sub>m (Unblinded (a, ts))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases z rule: zipper_children\\<^sub>m.cases) (simp_all)"], ["proof (state)\nthis:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\n\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z", "then"], ["proof (chain)\npicking this:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))", "obtain l t r where ltr: \"z' = ((a, l, r) # p, t)\" and \"(l, t, r) \\<in> set (splits ts)\""], ["proof (prove)\nusing this:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\n\ngoal (1 subgoal):\n 1. (\\<And>l r t.\n        \\<lbrakk>z' = ((a, l, r) # p, t);\n         (l, t, r) \\<in> set (splits ts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\n  z' \\<in> set (zipper_children\\<^sub>m z)\n\ngoal (1 subgoal):\n 1. (\\<And>l r t.\n        \\<lbrakk>z' = ((a, l, r) # p, t);\n         (l, t, r) \\<in> set (splits ts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)\n\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z", "with z"], ["proof (chain)\npicking this:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  z = (p, Tree\\<^sub>m (Unblinded (a, ts)))\n  z' = ((a, l, r) # p, t)\n  (l, t, r) \\<in> set (splits ts)\n\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z", "by(simp add: splits_iff)"], ["proof (state)\nthis:\n  tree_of_zipper\\<^sub>m z' = tree_of_zipper\\<^sub>m z\n\ngoal:\nNo subgoals!", "qed"], ["", "fun blind_path_elem :: \"('a \\<Rightarrow> 'a\\<^sub>m) \\<Rightarrow> ('a\\<^sub>m \\<Rightarrow> 'a\\<^sub>h) \\<Rightarrow> 'a path_elem \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) path_elem\\<^sub>m\"  where\n  \"blind_path_elem e h (x, l, r) = (e x, map (blind_source_tree (h \\<circ> e)) l, map (blind_source_tree (h \\<circ> e)) r)\""], ["", "case_of_simps blind_path_elem_cases: blind_path_elem.simps"], ["", "definition blind_path :: \"('a \\<Rightarrow> 'a\\<^sub>m) \\<Rightarrow> ('a\\<^sub>m \\<Rightarrow> 'a\\<^sub>h) \\<Rightarrow> 'a path \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) path\\<^sub>m\" where\n  \"blind_path e h \\<equiv> map (blind_path_elem e h)\""], ["", "fun embed_path_elem :: \"('a \\<Rightarrow> 'a\\<^sub>m) \\<Rightarrow> 'a path_elem \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) path_elem\\<^sub>m\" where\n  \"embed_path_elem e (d, l, r) = (e d, map (embed_source_tree e) l, map (embed_source_tree e) r)\""], ["", "definition embed_path :: \"('a \\<Rightarrow> 'a\\<^sub>m) \\<Rightarrow> 'a path \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) path\\<^sub>m\" where\n  \"embed_path embed_elem \\<equiv> map (embed_path_elem embed_elem)\""], ["", "lemma hash_tree_of_zipper_same_path: \n  \"hash_tree h (tree_of_zipper\\<^sub>m (p, v)) = hash_tree h (tree_of_zipper\\<^sub>m (p, v'))\n        \\<longleftrightarrow> hash_tree h v = hash_tree h v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hash_tree h (tree_of_zipper\\<^sub>m (p, v)) =\n     hash_tree h (tree_of_zipper\\<^sub>m (p, v'))) =\n    (hash_tree h v = hash_tree h v')", "by(induction p arbitrary: v v')(auto simp add: hash_rt_F\\<^sub>m_def)"], ["", "fun hash_path_elem :: \"('a\\<^sub>m \\<Rightarrow> 'a\\<^sub>h) \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) path_elem\\<^sub>m \\<Rightarrow> ('a\\<^sub>h \\<times> 'a\\<^sub>h rose_tree\\<^sub>h list \\<times> 'a\\<^sub>h rose_tree\\<^sub>h list)\" where\n  \"hash_path_elem h (e, l, r) = (h e, map (hash_tree h) l, map (hash_tree h) r)\""], ["", "lemma hash_view_zipper_eqI:\n  \"\\<lbrakk> hash_list (hash_path_elem h) p = hash_list (hash_path_elem h') p';\n    hash_tree h v = hash_tree h' v' \\<rbrakk> \\<Longrightarrow>\n    hash_tree h (tree_of_zipper\\<^sub>m (p, v)) = hash_tree h' (tree_of_zipper\\<^sub>m (p', v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (hash_path_elem h) p = map (hash_path_elem h') p';\n     hash_tree h v = hash_tree h' v'\\<rbrakk>\n    \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m (p, v)) =\n                      hash_tree h' (tree_of_zipper\\<^sub>m (p', v'))", "by(induction p arbitrary: p' v v')(auto simp add: hash_rt_F\\<^sub>m_def)"], ["", "lemma blind_embed_path_same_hash:\n  \"hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) = hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) =\n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) =\n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))", "have \"hash_path_elem h \\<circ> blind_path_elem e h = hash_path_elem h \\<circ> embed_path_elem e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_path_elem h \\<circ> blind_path_elem e h =\n    hash_path_elem h \\<circ> embed_path_elem e", "by(clarsimp simp add: hash_blinded_simp hash_embedded_simp fun_eq_iff intro!: arg_cong2[where f=hash_source_tree, OF _ refl])"], ["proof (state)\nthis:\n  hash_path_elem h \\<circ> blind_path_elem e h =\n  hash_path_elem h \\<circ> embed_path_elem e\n\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) =\n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))", "then"], ["proof (chain)\npicking this:\n  hash_path_elem h \\<circ> blind_path_elem e h =\n  hash_path_elem h \\<circ> embed_path_elem e", "show ?thesis"], ["proof (prove)\nusing this:\n  hash_path_elem h \\<circ> blind_path_elem e h =\n  hash_path_elem h \\<circ> embed_path_elem e\n\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) =\n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))", "by(intro hash_view_zipper_eqI)(simp_all add: embed_path_def blind_path_def list.map_comp)"], ["proof (state)\nthis:\n  hash_tree h (tree_of_zipper\\<^sub>m (blind_path e h p, t)) =\n  hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_of_embed_commute:\n  \"tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t) = embed_source_tree e (tree_of_zipper (p, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t) =\n    embed_source_tree e (tree_of_zipper (p, t))", "by(induction \"(p, t)\" arbitrary: p t rule: tree_of_zipper.induct)(simp_all add: embed_path_def)"], ["", "lemma childz_same_tree:\n  \"(l, t, r) \\<in> set (splits ts) \\<Longrightarrow>\n  tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e (Tree (d, ts))) \n  = tree_of_zipper\\<^sub>m (embed_path e ((d, l, r) # p), embed_source_tree e t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, t, r) \\<in> set (splits ts) \\<Longrightarrow>\n    tree_of_zipper\\<^sub>m\n     (embed_path e p, embed_source_tree e (Tree (d, ts))) =\n    tree_of_zipper\\<^sub>m\n     (embed_path e ((d, l, r) # p), embed_source_tree e t)", "by(simp add: tree_of_embed_commute splits_iff del: embed_source_tree.simps)"], ["", "lemma blinding_of_same_path:\n  assumes bo: \"blinding_of_on UNIV h bo\"\n  shows\n  \"blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t)) (tree_of_zipper\\<^sub>m (p, t'))\n  \\<longleftrightarrow> blinding_of_tree h bo t t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n     (tree_of_zipper\\<^sub>m (p, t')) =\n    blinding_of_tree h bo t t'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n     (tree_of_zipper\\<^sub>m (p, t')) =\n    blinding_of_tree h bo t t'", "interpret a: blinding_of_on UNIV h bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV h bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n     (tree_of_zipper\\<^sub>m (p, t')) =\n    blinding_of_tree h bo t t'", "interpret tree: blinding_of_on UNIV \"hash_tree h\" \"blinding_of_tree h bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV (hash_tree h) (blinding_of_tree h bo)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n     (tree_of_zipper\\<^sub>m (p, t')) =\n    blinding_of_tree h bo t t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n     (tree_of_zipper\\<^sub>m (p, t')) =\n    blinding_of_tree h bo t t'", "by(induction p arbitrary: t t')(auto simp add: list_all2_append list.rel_refl a.refl tree.refl)"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m (p, t))\n   (tree_of_zipper\\<^sub>m (p, t')) =\n  blinding_of_tree h bo t t'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zipper_children_size_change [termination_simp]: \"(a, b) \\<in> set (zipper_children (p, v)) \\<Longrightarrow> size b < size v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (zipper_children (p, v)) \\<Longrightarrow>\n    size b < size v", "by(cases v)(clarsimp simp add: splits_iff Set.image_iff)"], ["", "subsection \\<open>All zippers of a rose tree\\<close>"], ["", "context fixes e :: \"'a \\<Rightarrow> 'a\\<^sub>m\" and h :: \"'a\\<^sub>m \\<Rightarrow> 'a\\<^sub>h\" begin"], ["", "fun zippers_rose_tree :: \"'a zipper \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h) zipper\\<^sub>m list\" where\n  \"zippers_rose_tree (p, t) = (blind_path e h p, embed_source_tree e t) # \n    concat (map zippers_rose_tree (zipper_children (p, t)))\""], ["", "end"], ["", "lemmas [simp del] = zippers_rose_tree.simps zipper_children.simps"], ["", "lemma zippers_rose_tree_same_hash':\n  assumes \"z \\<in> set (zippers_rose_tree e h (p, t))\"\n  shows \"hash_tree h (tree_of_zipper\\<^sub>m z) = \n    hash_tree h (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))", "using assms(1)"], ["proof (prove)\nusing this:\n  z \\<in> set (zippers_rose_tree e h (p, t))\n\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))", "proof(induction \"(p, t)\" arbitrary: p t rule: zippers_rose_tree.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> hash_tree h\n(tree_of_zipper\\<^sub>m z) =\n                                     hash_tree h\n(tree_of_zipper\\<^sub>m (embed_path e pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                         hash_tree h\n                          (tree_of_zipper\\<^sub>m\n                            (embed_path e p, embed_source_tree e t))", "case (1 p t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?p, ?t) \\<in> set (zipper_children (p, t));\n   z \\<in> set (zippers_rose_tree e h (?p, ?t))\\<rbrakk>\n  \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                    hash_tree h\n                     (tree_of_zipper\\<^sub>m\n                       (embed_path e ?p, embed_source_tree e ?t))\n  z \\<in> set (zippers_rose_tree e h (p, t))\n\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> hash_tree h\n(tree_of_zipper\\<^sub>m z) =\n                                     hash_tree h\n(tree_of_zipper\\<^sub>m (embed_path e pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                         hash_tree h\n                          (tree_of_zipper\\<^sub>m\n                            (embed_path e p, embed_source_tree e t))", "from \"1.prems\"[unfolded zippers_rose_tree.simps]"], ["proof (chain)\npicking this:\n  z \\<in> set ((blind_path e h p, embed_source_tree e t) #\n               concat\n                (map (zippers_rose_tree e h) (zipper_children (p, t))))", "consider (find) \"z = (blind_path e h p, embed_source_tree e t)\"\n    | (rec) x ts l t' r where \"t = Tree (x, ts)\" \"(l, t', r) \\<in> set (splits ts)\" \"z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\""], ["proof (prove)\nusing this:\n  z \\<in> set ((blind_path e h p, embed_source_tree e t) #\n               concat\n                (map (zippers_rose_tree e h) (zipper_children (p, t))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n             thesis;\n     \\<And>x ts l t' r.\n        \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n         z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases t)(auto simp add: zipper_children.simps)"], ["proof (state)\nthis:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> hash_tree h\n(tree_of_zipper\\<^sub>m z) =\n                                     hash_tree h\n(tree_of_zipper\\<^sub>m (embed_path e pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                         hash_tree h\n                          (tree_of_zipper\\<^sub>m\n                            (embed_path e p, embed_source_tree e t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n    hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\n 2. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                         hash_tree h\n                          (tree_of_zipper\\<^sub>m\n                            (embed_path e p, embed_source_tree e t))", "case rec"], ["proof (state)\nthis:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (2 subgoals):\n 1. z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n    hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\n 2. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> hash_tree h (tree_of_zipper\\<^sub>m z) =\n                         hash_tree h\n                          (tree_of_zipper\\<^sub>m\n                            (embed_path e p, embed_source_tree e t))", "then"], ["proof (chain)\npicking this:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (1 subgoal):\n 1. hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))", "apply(subst \"1.hyps\"[of \"(x, l, r) # p\" \"t'\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n     z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n    \\<Longrightarrow> ((x, l, r) # p, t') \\<in> set (zipper_children (p, t))\n 2. \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n     z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n    \\<Longrightarrow> z \\<in> set (zippers_rose_tree e h\n                                    ((x, l, r) # p, t'))\n 3. \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n     z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n    \\<Longrightarrow> hash_tree h\n                       (tree_of_zipper\\<^sub>m\n                         (embed_path e ((x, l, r) # p),\n                          embed_source_tree e t')) =\n                      hash_tree h\n                       (tree_of_zipper\\<^sub>m\n                         (embed_path e p, embed_source_tree e t))", "apply(simp_all add: rev_image_eqI zipper_children.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n     z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n    \\<Longrightarrow> hash_tree h\n                       (tree_of_zipper\\<^sub>m\n                         (embed_path e ((x, l, r) # p),\n                          embed_source_tree e t')) =\n                      hash_tree h\n                       (tree_of_zipper\\<^sub>m\n                         (embed_path e p,\n                          Tree\\<^sub>m\n                           (Unblinded (e x, map (embed_source_tree e) ts))))", "by (metis (no_types) childz_same_tree comp_apply embed_source_tree.simps rec(2))"], ["proof (state)\nthis:\n  hash_tree h (tree_of_zipper\\<^sub>m z) =\n  hash_tree h\n   (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\n\ngoal (1 subgoal):\n 1. z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n    hash_tree h (tree_of_zipper\\<^sub>m z) =\n    hash_tree h\n     (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))", "qed(simp add: blind_embed_path_same_hash)"], ["proof (state)\nthis:\n  hash_tree h (tree_of_zipper\\<^sub>m z) =\n  hash_tree h\n   (tree_of_zipper\\<^sub>m (embed_path e p, embed_source_tree e t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zippers_rose_tree_blinding_of:\n  assumes \"blinding_of_on UNIV h bo\" \n    and z: \"z \\<in> set (zippers_rose_tree e h (p, t))\"\n  shows \"blinding_of_tree h bo (tree_of_zipper\\<^sub>m z) (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "using z"], ["proof (prove)\nusing this:\n  z \\<in> set (zippers_rose_tree e h (p, t))\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "proof(induction \"(p, t)\" arbitrary: p t rule: zippers_rose_tree.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo\n(tree_of_zipper\\<^sub>m z)\n(tree_of_zipper\\<^sub>m (blind_path e h pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "case (1 p t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?p, ?t) \\<in> set (zipper_children (p, t));\n   z \\<in> set (zippers_rose_tree e h (?p, ?t))\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                     (tree_of_zipper\\<^sub>m\n                       (blind_path e h ?p, embed_source_tree e ?t))\n  z \\<in> set (zippers_rose_tree e h (p, t))\n\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo\n(tree_of_zipper\\<^sub>m z)\n(tree_of_zipper\\<^sub>m (blind_path e h pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "interpret a: blinding_of_on UNIV h bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV h bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo\n(tree_of_zipper\\<^sub>m z)\n(tree_of_zipper\\<^sub>m (blind_path e h pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "interpret rt: blinding_of_on UNIV \"hash_tree h\" \"blinding_of_tree h bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV (hash_tree h) (blinding_of_tree h bo)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo\n(tree_of_zipper\\<^sub>m z)\n(tree_of_zipper\\<^sub>m (blind_path e h pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "from \"1.prems\"[unfolded zippers_rose_tree.simps]"], ["proof (chain)\npicking this:\n  z \\<in> set ((blind_path e h p, embed_source_tree e t) #\n               concat\n                (map (zippers_rose_tree e h) (zipper_children (p, t))))", "consider (find) \"z = (blind_path e h p, embed_source_tree e t)\"\n    | (rec) x ts l t' r where \"t = Tree (x, ts)\" \"(l, t', r) \\<in> set (splits ts)\" \"z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\""], ["proof (prove)\nusing this:\n  z \\<in> set ((blind_path e h p, embed_source_tree e t) #\n               concat\n                (map (zippers_rose_tree e h) (zipper_children (p, t))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n             thesis;\n     \\<And>x ts l t' r.\n        \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n         z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases t)(auto simp add: zipper_children.simps)"], ["proof (state)\nthis:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p t.\n       \\<lbrakk>\\<And>pa ta.\n                   \\<lbrakk>(pa, ta) \\<in> set (zipper_children (p, t));\n                    z \\<in> set (zippers_rose_tree e h (pa, ta))\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo\n(tree_of_zipper\\<^sub>m z)\n(tree_of_zipper\\<^sub>m (blind_path e h pa, embed_source_tree e ta));\n        z \\<in> set (zippers_rose_tree e h (p, t))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n           ?thesis;\n   \\<And>x ts l t' r.\n      \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n       z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n    blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\n 2. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "case find"], ["proof (state)\nthis:\n  z = (blind_path e h p, embed_source_tree e t)\n\ngoal (2 subgoals):\n 1. z = (blind_path e h p, embed_source_tree e t) \\<Longrightarrow>\n    blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\n 2. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "then"], ["proof (chain)\npicking this:\n  z = (blind_path e h p, embed_source_tree e t)", "show ?thesis"], ["proof (prove)\nusing this:\n  z = (blind_path e h p, embed_source_tree e t)\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "by(simp add: rt.refl)"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\n\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "case rec"], ["proof (state)\nthis:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "then"], ["proof (chain)\npicking this:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))", "have \"blinding_of_tree h bo \n      (tree_of_zipper\\<^sub>m z) \n      (tree_of_zipper\\<^sub>m (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\""], ["proof (prove)\nusing this:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m\n       (blind_path e h ((x, l, r) # p), embed_source_tree e t'))", "by(intro 1)(simp add: rev_image_eqI zipper_children.simps)"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "also"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "have \"blinding_of_tree h bo \n      (tree_of_zipper\\<^sub>m (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n      (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e (Tree (x, ts))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo\n     (tree_of_zipper\\<^sub>m\n       (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n     (tree_of_zipper\\<^sub>m\n       (blind_path e h p, embed_source_tree e (Tree (x, ts))))", "using rec"], ["proof (prove)\nusing this:\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo\n     (tree_of_zipper\\<^sub>m\n       (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n     (tree_of_zipper\\<^sub>m\n       (blind_path e h p, embed_source_tree e (Tree (x, ts))))", "by(simp add: blind_path_def splits_iff blinding_of_same_path[OF assms(1)] a.refl list_all2_append list_all2_same list.rel_map blinded_blinds_embedded rt.refl)"], ["proof (state)\nthis:\n  blinding_of_tree h bo\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h ((x, l, r) # p), embed_source_tree e t'))\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h p, embed_source_tree e (Tree (x, ts))))\n\ngoal (1 subgoal):\n 1. \\<And>x ts l t' r.\n       \\<lbrakk>t = Tree (x, ts); (l, t', r) \\<in> set (splits ts);\n        z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n                          (tree_of_zipper\\<^sub>m\n                            (blind_path e h p, embed_source_tree e t))", "finally (rt.trans)"], ["proof (chain)\npicking this:\n  tree_of_zipper\\<^sub>m z \\<in> UNIV \\<Longrightarrow>\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h p, embed_source_tree e (Tree (x, ts))))", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_of_zipper\\<^sub>m z \\<in> UNIV \\<Longrightarrow>\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h p, embed_source_tree e (Tree (x, ts))))\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "using rec"], ["proof (prove)\nusing this:\n  tree_of_zipper\\<^sub>m z \\<in> UNIV \\<Longrightarrow>\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m\n     (blind_path e h p, embed_source_tree e (Tree (x, ts))))\n  t = Tree (x, ts)\n  (l, t', r) \\<in> set (splits ts)\n  z \\<in> set (zippers_rose_tree e h ((x, l, r) # p, t'))\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n     (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))", "by simp"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  blinding_of_tree h bo (tree_of_zipper\\<^sub>m z)\n   (tree_of_zipper\\<^sub>m (blind_path e h p, embed_source_tree e t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zippers_rose_tree_neq_Nil: \"zippers_rose_tree e h (p, t) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zippers_rose_tree e h (p, t) \\<noteq> []", "by(simp add: zippers_rose_tree.simps)"], ["", "lemma (in comp_fun_idem) fold_set_union:\n  assumes \"finite A\" \"finite B\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "using assms(2,1)"], ["proof (prove)\nusing this:\n  finite B\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "by induct simp_all"], ["", "context merkle_interface begin"], ["", "lemma comp_fun_idem_merge: \"comp_fun_idem (\\<lambda>x yo. yo \\<bind> m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>x yo. yo \\<bind> m x)", "apply(unfold_locales; clarsimp simp add: fun_eq_iff split: bind_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x v.\n       (m x v = None \\<longrightarrow>\n        (\\<forall>va.\n            m y v = Some va \\<longrightarrow> None = m x va)) \\<and>\n       (\\<forall>va.\n           m x v = Some va \\<longrightarrow>\n           (m y v = None \\<longrightarrow> m y va = None) \\<and>\n           (\\<forall>vb. m y v = Some vb \\<longrightarrow> m y va = m x vb))\n 2. \\<And>x v va. m x v = Some va \\<Longrightarrow> m x va = Some va", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m x_ v_ = None \\<longrightarrow>\n     (\\<forall>va.\n         m y_ v_ = Some va \\<longrightarrow> None = m x_ va)) \\<and>\n    (\\<forall>va.\n        m x_ v_ = Some va \\<longrightarrow>\n        (m y_ v_ = None \\<longrightarrow> m y_ va = None) \\<and>\n        (\\<forall>vb.\n            m y_ v_ = Some vb \\<longrightarrow> m y_ va = m x_ vb))", "by (metis assoc bind.bind_lunit bind.bind_lzero idem option.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v va. m x v = Some va \\<Longrightarrow> m x va = Some va", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. m x_ v_ = Some va_ \\<Longrightarrow> m x_ va_ = Some va_", "by (simp add: join)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation merge: comp_fun_idem \"\\<lambda>x yo. yo \\<bind> m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>x yo. yo \\<bind> m x)", "by(rule comp_fun_idem_merge)"], ["", "definition Merge :: \"'a\\<^sub>m set \\<Rightarrow> 'a\\<^sub>m option\" where\n  \"Merge A = (if A = {} \\<or> infinite A then None else Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> A)) A)\""], ["", "lemma Merge_empty [simp]: \"Merge {} = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge {} = None", "by(simp add: Merge_def)"], ["", "lemma Merge_infinite [simp]: \"infinite A \\<Longrightarrow> Merge A = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> Merge A = None", "by(simp add: Merge_def)"], ["", "lemma Merge_cong_start:\n  \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A\" (is \"?lhs = ?rhs\")\n  if \"x \\<in> A\" \"y \\<in> A\" \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "have \"?lhs = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A)", "by(simp add: insert_absorb)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "also"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "have \"\\<dots> = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A", "by(simp only: merge.fold_insert_idem2)(simp add: commute)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "also"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert y A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "have \"\\<dots> = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A)", "by(simp only: merge.fold_insert_idem2)(simp)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "also"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (m x y) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "by(simp add: insert_absorb)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "finally"], ["proof (chain)\npicking this:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A", "."], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some y) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Merge_insert [simp]: \"Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "proof(cases \"finite A \\<and> A \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<and> A \\<noteq> {} \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n 2. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "case True"], ["proof (state)\nthis:\n  finite A \\<and> A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. finite A \\<and> A \\<noteq> {} \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n 2. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "then"], ["proof (chain)\npicking this:\n  finite A \\<and> A \\<noteq> {}", "have \"?lhs = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> A)) (insert x A)\""], ["proof (prove)\nusing this:\n  finite A \\<and> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> A)) (insert x A)", "unfolding Merge_def"], ["proof (prove)\nusing this:\n  finite A \\<and> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if insert x A = {} \\<or> infinite (insert x A) then None\n     else Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n           (Some (SOME xa. xa \\<in> insert x A)) (insert x A)) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> A)) (insert x A)", "by(subst Merge_cong_start[where y=\"SOME x. x \\<in> A\", OF someI])(auto intro: someI)"], ["proof (state)\nthis:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> A))\n   (insert x A)\n\ngoal (2 subgoals):\n 1. finite A \\<and> A \\<noteq> {} \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n 2. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "also"], ["proof (state)\nthis:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> A))\n   (insert x A)\n\ngoal (2 subgoals):\n 1. finite A \\<and> A \\<noteq> {} \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n 2. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> A)) (insert x A) =\n    (if A = {} then Some x else Merge A \\<bind> m x)", "using True"], ["proof (prove)\nusing this:\n  finite A \\<and> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> A)) (insert x A) =\n    (if A = {} then Some x else Merge A \\<bind> m x)", "by(simp add: Merge_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> A))\n   (insert x A) =\n  (if A = {} then Some x else Merge A \\<bind> m x)\n\ngoal (2 subgoals):\n 1. finite A \\<and> A \\<noteq> {} \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n 2. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "finally"], ["proof (chain)\npicking this:\n  Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n\ngoal (1 subgoal):\n 1. Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "."], ["proof (state)\nthis:\n  Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)\n\ngoal (1 subgoal):\n 1. \\<not> (finite A \\<and> A \\<noteq> {}) \\<Longrightarrow>\n    Merge (insert x A) = (if A = {} then Some x else Merge A \\<bind> m x)", "qed(auto simp add: Merge_def idem)"], ["", "lemma Merge_insert_alt:\n  \"Merge (insert x A) = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A\" (is \"?lhs = ?rhs\") if \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "have \"?lhs = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)", "using that"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)", "unfolding Merge_def"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (if insert x A = {} \\<or> infinite (insert x A) then None\n     else Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n           (Some (SOME xa. xa \\<in> insert x A)) (insert x A)) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)", "by(subst Merge_cong_start[where y=x, OF someI]) auto"], ["proof (state)\nthis:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "also"], ["proof (state)\nthis:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A)\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "using that"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "by(simp only: merge.fold_insert_idem2)(simp add: idem)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "finally"], ["proof (chain)\npicking this:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "show ?thesis"], ["proof (prove)\nusing this:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A\n\ngoal (1 subgoal):\n 1. Merge (insert x A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A", "."], ["proof (state)\nthis:\n  Merge (insert x A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some x) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Merge_None [simp]: \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None", "proof(cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None\n 2. infinite A \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None\n 2. infinite A \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None", "then"], ["proof (chain)\npicking this:\n  finite A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None", "by(induction) auto"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) None A = None", "qed simp"], ["", "lemma Merge_union: \n  \"Merge (A \\<union> B) = (if A = {} then Merge B else if B = {} then Merge A else (Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "proof(cases \"finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "case True"], ["proof (state)\nthis:\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "then"], ["proof (chain)\npicking this:\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}", "have \"?lhs = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> B)) (B \\<union> A)\""], ["proof (prove)\nusing this:\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Merge (A \\<union> B) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> B)) (B \\<union> A)", "unfolding Merge_def"], ["proof (prove)\nusing this:\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if A \\<union> B = {} \\<or> infinite (A \\<union> B) then None\n     else Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n           (Some (SOME x. x \\<in> A \\<union> B)) (A \\<union> B)) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> B)) (B \\<union> A)", "by(subst Merge_cong_start[where y=\"SOME x. x \\<in> B\", OF someI])(auto intro: someI simp add: Un_commute)"], ["proof (state)\nthis:\n  Merge (A \\<union> B) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> B))\n   (B \\<union> A)\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "also"], ["proof (state)\nthis:\n  Merge (A \\<union> B) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> B))\n   (B \\<union> A)\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "have \"\\<dots> = Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> B)) (B \\<union> A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A", "using True"], ["proof (prove)\nusing this:\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x)\n     (Some (SOME x. x \\<in> B)) (B \\<union> A) =\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A", "by(simp add: Merge_def merge.fold_set_union)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> B))\n   (B \\<union> A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "also"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some (SOME x. x \\<in> B))\n   (B \\<union> A) =\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "have \"\\<dots> = Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "proof(cases \"Merge B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Merge B = None \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n 2. \\<And>a.\n       Merge B = Some a \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n       Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "case (Some b)"], ["proof (state)\nthis:\n  Merge B = Some b\n\ngoal (2 subgoals):\n 1. Merge B = None \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n 2. \\<And>a.\n       Merge B = Some a \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n       Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Merge B = Some b\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "using True"], ["proof (prove)\nusing this:\n  Merge B = Some b\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "by simp(subst Merge_insert_alt[symmetric]; simp add: commute; metis commute)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n  Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n\ngoal (1 subgoal):\n 1. Merge B = None \\<Longrightarrow>\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n    Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "qed simp"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Merge B) A =\n  Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n\ngoal (2 subgoals):\n 1. finite (A \\<union> B) \\<and>\n    A \\<noteq> {} \\<and> B \\<noteq> {} \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n 2. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "finally"], ["proof (chain)\npicking this:\n  Merge (A \\<union> B) = Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Merge (A \\<union> B) = Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n\ngoal (1 subgoal):\n 1. Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "using True"], ["proof (prove)\nusing this:\n  Merge (A \\<union> B) = Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a)\n  finite (A \\<union> B) \\<and> A \\<noteq> {} \\<and> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "by simp"], ["proof (state)\nthis:\n  Merge (A \\<union> B) =\n  (if A = {} then Merge B\n   else if B = {} then Merge A\n        else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))\n\ngoal (1 subgoal):\n 1. \\<not> (finite (A \\<union> B) \\<and>\n            A \\<noteq> {} \\<and> B \\<noteq> {}) \\<Longrightarrow>\n    Merge (A \\<union> B) =\n    (if A = {} then Merge B\n     else if B = {} then Merge A\n          else Merge A \\<bind> (\\<lambda>a. Merge B \\<bind> m a))", "qed auto"], ["", "lemma Merge_upper:\n  assumes m: \"Merge A = Some x\" and y: \"y \\<in> A\"\n  shows \"bo y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bo y x", "have \"Merge A = Merge (insert y A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge A = Merge (insert y A)", "using y"], ["proof (prove)\nusing this:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. Merge A = Merge (insert y A)", "by(simp add: insert_absorb)"], ["proof (state)\nthis:\n  Merge A = Merge (insert y A)\n\ngoal (1 subgoal):\n 1. bo y x", "also"], ["proof (state)\nthis:\n  Merge A = Merge (insert y A)\n\ngoal (1 subgoal):\n 1. bo y x", "have \"\\<dots> = Merge A \\<bind> m y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge (insert y A) = Merge A \\<bind> m y", "using y"], ["proof (prove)\nusing this:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. Merge (insert y A) = Merge A \\<bind> m y", "by auto"], ["proof (state)\nthis:\n  Merge (insert y A) = Merge A \\<bind> m y\n\ngoal (1 subgoal):\n 1. bo y x", "finally"], ["proof (chain)\npicking this:\n  Merge A = Merge A \\<bind> m y", "have \"m y x = Some x\""], ["proof (prove)\nusing this:\n  Merge A = Merge A \\<bind> m y\n\ngoal (1 subgoal):\n 1. m y x = Some x", "using m"], ["proof (prove)\nusing this:\n  Merge A = Merge A \\<bind> m y\n  Merge A = Some x\n\ngoal (1 subgoal):\n 1. m y x = Some x", "by simp"], ["proof (state)\nthis:\n  m y x = Some x\n\ngoal (1 subgoal):\n 1. bo y x", "thus ?thesis"], ["proof (prove)\nusing this:\n  m y x = Some x\n\ngoal (1 subgoal):\n 1. bo y x", "by(simp add: bo_def)"], ["proof (state)\nthis:\n  bo y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Merge_least:\n  assumes m: \"Merge A = Some x\" and u[rule_format]: \"\\<forall>a\\<in>A. bo a u\"\n  shows \"bo x u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo x u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bo x u", "define a where \"a \\<equiv> SOME x. x \\<in> A\""], ["proof (state)\nthis:\n  a \\<equiv> SOME x. x \\<in> A\n\ngoal (1 subgoal):\n 1. bo x u", "from m"], ["proof (chain)\npicking this:\n  Merge A = Some x", "have A: \"finite A\" \"A \\<noteq> {}\" \n    and *: \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = Some x\""], ["proof (prove)\nusing this:\n  Merge A = Some x\n\ngoal (1 subgoal):\n 1. (finite A &&& A \\<noteq> {}) &&&\n    Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = Some x", "by(auto simp add: Merge_def a_def split: if_splits)"], ["proof (state)\nthis:\n  finite A\n  A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = Some x\n\ngoal (1 subgoal):\n 1. bo x u", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"bo a u\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. bo a u", "by(auto intro: someI u simp add: a_def)"], ["proof (state)\nthis:\n  bo a u\n\ngoal (1 subgoal):\n 1. bo x u", "with A * u"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = Some x\n  ?a \\<in> A \\<Longrightarrow> bo ?a u\n  bo a u", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = Some x\n  ?a \\<in> A \\<Longrightarrow> bo ?a u\n  bo a u\n\ngoal (1 subgoal):\n 1. bo x u", "proof(induction A arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>{} \\<noteq> {};\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) {} =\n        Some x;\n        \\<And>a. a \\<in> {} \\<Longrightarrow> bo a u; bo a u\\<rbrakk>\n       \\<Longrightarrow> bo x u\n 2. \\<And>xa F a.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<And>a.\n           \\<lbrakk>F \\<noteq> {};\n            Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) F =\n            Some x;\n            \\<And>a. a \\<in> F \\<Longrightarrow> bo a u; bo a u\\<rbrakk>\n           \\<Longrightarrow> bo x u;\n        insert xa F \\<noteq> {};\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n         (insert xa F) =\n        Some x;\n        \\<And>a. a \\<in> insert xa F \\<Longrightarrow> bo a u;\n        bo a u\\<rbrakk>\n       \\<Longrightarrow> bo x u", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<noteq> {};\n   Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some ?a) A = Some x;\n   \\<And>a. a \\<in> A \\<Longrightarrow> bo a u; bo ?a u\\<rbrakk>\n  \\<Longrightarrow> bo x u\n  insert x A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) (insert x A) =\n  Some x\n  ?a \\<in> insert x A \\<Longrightarrow> bo ?a u\n  bo a u\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>{} \\<noteq> {};\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) {} =\n        Some x;\n        \\<And>a. a \\<in> {} \\<Longrightarrow> bo a u; bo a u\\<rbrakk>\n       \\<Longrightarrow> bo x u\n 2. \\<And>xa F a.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<And>a.\n           \\<lbrakk>F \\<noteq> {};\n            Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) F =\n            Some x;\n            \\<And>a. a \\<in> F \\<Longrightarrow> bo a u; bo a u\\<rbrakk>\n           \\<Longrightarrow> bo x u;\n        insert xa F \\<noteq> {};\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n         (insert xa F) =\n        Some x;\n        \\<And>a. a \\<in> insert xa F \\<Longrightarrow> bo a u;\n        bo a u\\<rbrakk>\n       \\<Longrightarrow> bo x u", "then"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<noteq> {};\n   Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some ?a) A = Some x;\n   \\<And>a. a \\<in> A \\<Longrightarrow> bo a u; bo ?a u\\<rbrakk>\n  \\<Longrightarrow> bo x u\n  insert x A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) (insert x A) =\n  Some x\n  ?a \\<in> insert x A \\<Longrightarrow> bo ?a u\n  bo a u", "show ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<noteq> {};\n   Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some ?a) A = Some x;\n   \\<And>a. a \\<in> A \\<Longrightarrow> bo a u; bo ?a u\\<rbrakk>\n  \\<Longrightarrow> bo x u\n  insert x A \\<noteq> {}\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) (insert x A) =\n  Some x\n  ?a \\<in> insert x A \\<Longrightarrow> bo ?a u\n  bo a u\n\ngoal (1 subgoal):\n 1. bo x u", "by(cases \"m x a\"; cases \"A = {}\"; simp only: merge.fold_insert_idem2; simp)(auto simp add: join)"], ["proof (state)\nthis:\n  bo x u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>{} \\<noteq> {};\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) {} =\n        Some x;\n        \\<And>a. a \\<in> {} \\<Longrightarrow> bo a u; bo a u\\<rbrakk>\n       \\<Longrightarrow> bo x u", "qed simp"], ["proof (state)\nthis:\n  bo x u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Merge_defined:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"\\<forall>a\\<in>A. \\<forall>b \\<in> A. h a = h b\"\n  shows \"Merge A \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Merge A \\<noteq> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "define a where \"a \\<equiv> SOME a. a \\<in> A\""], ["proof (state)\nthis:\n  a \\<equiv> SOME a. a \\<in> A\n\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "have a: \"a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> A) \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  \\<forall>a\\<in>A. \\<forall>b\\<in>A. h a = h b\n\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> A) \\<in> A", "by(auto intro: someI)"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "hence ha: \"\\<forall>b \\<in> A. h b = h a\""], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>A. h b = h a", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> A\n  finite A\n  A \\<noteq> {}\n  \\<forall>a\\<in>A. \\<forall>b\\<in>A. h a = h b\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>A. h b = h a", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>A. h b = h a\n\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "assume m: \"Merge A = None\""], ["proof (state)\nthis:\n  Merge A = None\n\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "hence \"Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None\""], ["proof (prove)\nusing this:\n  Merge A = None\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None", "using assms"], ["proof (prove)\nusing this:\n  Merge A = None\n  finite A\n  A \\<noteq> {}\n  \\<forall>a\\<in>A. \\<forall>b\\<in>A. h a = h b\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None", "by(simp add: Merge_def a_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None\n\ngoal (1 subgoal):\n 1. Merge A = None \\<Longrightarrow> False", "with assms(1)"], ["proof (chain)\npicking this:\n  finite A\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None", "show False"], ["proof (prove)\nusing this:\n  finite A\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None\n\ngoal (1 subgoal):\n 1. False", "using ha"], ["proof (prove)\nusing this:\n  finite A\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) A = None\n  \\<forall>b\\<in>A. h b = h a\n\ngoal (1 subgoal):\n 1. False", "proof(induction arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                 {} =\n                None;\n        \\<forall>b\\<in>{}. h b = h a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x F a.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a.\n           \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                     F =\n                    None;\n            \\<forall>b\\<in>F. h b = h a\\<rbrakk>\n           \\<Longrightarrow> False;\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n         (insert x F) =\n        None;\n        \\<forall>b\\<in>insert x F. h b = h a\\<rbrakk>\n       \\<Longrightarrow> False", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some ?a) A =\n           None;\n   \\<forall>b\\<in>A. h b = h ?a\\<rbrakk>\n  \\<Longrightarrow> False\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) (insert x A) =\n  None\n  \\<forall>b\\<in>insert x A. h b = h a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                 {} =\n                None;\n        \\<forall>b\\<in>{}. h b = h a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x F a.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a.\n           \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                     F =\n                    None;\n            \\<forall>b\\<in>F. h b = h a\\<rbrakk>\n           \\<Longrightarrow> False;\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n         (insert x F) =\n        None;\n        \\<forall>b\\<in>insert x F. h b = h a\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some ?a) A =\n           None;\n   \\<forall>b\\<in>A. h b = h ?a\\<rbrakk>\n  \\<Longrightarrow> False\n  Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a) (insert x A) =\n  None\n  \\<forall>b\\<in>insert x A. h b = h a\n\ngoal (1 subgoal):\n 1. False", "apply(cases \"m x a\"; use nothing in \\<open>simp only: merge.fold_insert_idem2\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A;\n     \\<And>a.\n        \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                  A =\n                 None;\n         \\<forall>b\\<in>A. h b = h a\\<rbrakk>\n        \\<Longrightarrow> False;\n     Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a \\<bind> m x)\n      A =\n     None;\n     \\<forall>b\\<in>insert x A. h b = h a; m x a = None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a.\n       \\<lbrakk>finite A; x \\<notin> A;\n        \\<And>a.\n           \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                     A =\n                    None;\n            \\<forall>b\\<in>A. h b = h a\\<rbrakk>\n           \\<Longrightarrow> False;\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a \\<bind> m x)\n         A =\n        None;\n        \\<forall>b\\<in>insert x A. h b = h a; m x a = Some a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: merge_respects_hashes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>finite A; x \\<notin> A;\n        \\<And>a.\n           \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                     A =\n                    None;\n            \\<forall>b\\<in>A. h b = h a\\<rbrakk>\n           \\<Longrightarrow> False;\n        Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a \\<bind> m x)\n         A =\n        None;\n        \\<forall>b\\<in>insert x A. h b = h a; m x a = Some a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce simp add: join vimage2p_def dest: hash[THEN predicate2D])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Finite_Set.fold (\\<lambda>x yo. yo \\<bind> m x) (Some a)\n                 {} =\n                None;\n        \\<forall>b\\<in>{}. h b = h a\\<rbrakk>\n       \\<Longrightarrow> False", "qed simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Merge_hash:\n  assumes \"Merge A = Some x\" \"a \\<in> A\"\n  shows \"h a = h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = h x", "using Merge_upper[OF assms] hash"], ["proof (prove)\nusing this:\n  bo a x\n  bo \\<le> vimage2p h h (=)\n\ngoal (1 subgoal):\n 1. h a = h x", "by(auto simp add: vimage2p_def)"], ["", "end"], ["", "end"]]}